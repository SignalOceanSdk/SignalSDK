{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Signal SDK","text":"<p>The Signal Ocean SDK combines the power of Python and Signal Ocean's APIs to give you access to a variety of shipping data available in The Signal Ocean Platform.</p> <p> </p> <p>The Signal Ocean SDK GitHub repository: </p> <p>The Signal Ocean PyPi: </p>"},{"location":"#installation","title":"Installation","text":"<p>Install the SDK with pip: <pre><code>pip install signal-ocean\n</code></pre></p> <p>The Signal Ocean SDK depends on the pandas library for some of its data analysis features. Optional pandas dependencies are also optional in this SDK. If you plan to use data frame features like plotting or exporting to Excel, you need to install additional dependencies, for example: <pre><code>pip install matplotlib openpyxl\n</code></pre> For more information refer to pandas documentation.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To use the SDK, you need to create an account in our API Portal and subscribe to an API. Once you have a subscription key, put it inside an environment variable called <code>SIGNAL_OCEAN_API_KEY</code>.</p> <p>Now you're ready to fetch some data: <pre><code>from signal_ocean.tonnage_list  import TonnageListAPI\n\ntonnage_list_api = TonnageListAPI()\nports = tonnage_list_api.get_ports()\n\nprint(ports)\n</code></pre></p> <p>If you don't want to use environment variables, want to use different keys for different APIs, or if you want to override the environment variables, you can configure your <code>Connection</code> when creating the API class: <pre><code>from signal_ocean import Connection \nfrom signal_ocean.tonnage_list  import TonnageListAPI\n\ntonnage_list_api = TonnageListAPI(Connection(api_key='YOUR KEY GOES HERE'))\nvessel_classes = tonnage_list_api.get_vessel_classes()\n\nprint(vessel_classes)\n</code></pre></p> <p>All API classes follow this pattern of configuration.</p> <p>Check the docs for examples covering usage of our other APIs.</p>"},{"location":"companies/","title":"Package Documentation","text":"<p>Companies API Package.</p> <p>Classes:</p> Name Description <code>CompaniesAPI</code> <p>Represents Signal's Companies API.</p> <code>Company</code> <p>Represents a Company.</p>"},{"location":"companies/#signal_ocean.companies.CompaniesAPI","title":"<code>CompaniesAPI</code>","text":"<p>Represents Signal's Companies API.</p> Source code in <code>signal_ocean/companies/companies_api.py</code> <pre><code>class CompaniesAPI:\n    \"\"\"Represents Signal's Companies API.\"\"\"\n\n    relative_url = \"companies-api/v1/\"\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes CompaniesAPI.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_company(self, company_id: int) -&gt; Optional[Company]:\n        \"\"\"Retrieves a company by its id.\n\n        Args:\n            company_id: Unique id of the company to retrieve.\n\n        Returns:\n            A company or None if no company with the specified id has\n            been found.\n        \"\"\"\n        url = urljoin(CompaniesAPI.relative_url, f\"companies/{company_id}\")\n        return get_single(self.__connection, url, Company)\n\n    def get_companies(self, name: Optional[str] = None) -&gt; Tuple[Company, ...]:\n        \"\"\"Retrieves all available companies.\n\n        Args:\n            name: String to filter and return only companies the name\n                of which contains the provided string. If None, all\n                companies are returned.\n\n        Returns:\n            A tuple of all available companies.\n        \"\"\"\n        endpoint = (\n            \"companies/all\"\n            if name is None\n            else f\"companies/searchByName/{name}\"\n        )\n        url = urljoin(CompaniesAPI.relative_url, endpoint)\n        return get_multiple(self.__connection, url, Company)\n</code></pre>"},{"location":"companies/#signal_ocean.companies.CompaniesAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes CompaniesAPI.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/companies/companies_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes CompaniesAPI.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"companies/#signal_ocean.companies.CompaniesAPI.get_companies","title":"<code>get_companies(name=None)</code>","text":"<p>Retrieves all available companies.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>String to filter and return only companies the name of which contains the provided string. If None, all companies are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Company, ...]</code> <p>A tuple of all available companies.</p> Source code in <code>signal_ocean/companies/companies_api.py</code> <pre><code>def get_companies(self, name: Optional[str] = None) -&gt; Tuple[Company, ...]:\n    \"\"\"Retrieves all available companies.\n\n    Args:\n        name: String to filter and return only companies the name\n            of which contains the provided string. If None, all\n            companies are returned.\n\n    Returns:\n        A tuple of all available companies.\n    \"\"\"\n    endpoint = (\n        \"companies/all\"\n        if name is None\n        else f\"companies/searchByName/{name}\"\n    )\n    url = urljoin(CompaniesAPI.relative_url, endpoint)\n    return get_multiple(self.__connection, url, Company)\n</code></pre>"},{"location":"companies/#signal_ocean.companies.CompaniesAPI.get_company","title":"<code>get_company(company_id)</code>","text":"<p>Retrieves a company by its id.</p> <p>Parameters:</p> Name Type Description Default <code>company_id</code> <code>int</code> <p>Unique id of the company to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Company]</code> <p>A company or None if no company with the specified id has</p> <code>Optional[Company]</code> <p>been found.</p> Source code in <code>signal_ocean/companies/companies_api.py</code> <pre><code>def get_company(self, company_id: int) -&gt; Optional[Company]:\n    \"\"\"Retrieves a company by its id.\n\n    Args:\n        company_id: Unique id of the company to retrieve.\n\n    Returns:\n        A company or None if no company with the specified id has\n        been found.\n    \"\"\"\n    url = urljoin(CompaniesAPI.relative_url, f\"companies/{company_id}\")\n    return get_single(self.__connection, url, Company)\n</code></pre>"},{"location":"companies/#signal_ocean.companies.Company","title":"<code>Company</code>  <code>dataclass</code>","text":"<p>Contains all details of a company.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Numeric unique ID identifying a maritime company.</p> <code>updated_date</code> <code>datetime</code> <p>Date, format YYYY-MM-DD HH:MM:SS, corresponding to the latest update.</p> <code>company_name</code> <code>Optional[str]</code> <p>String, official name of the maritime company.</p> <code>website</code> <code>Optional[str]</code> <p>String, website of the company.</p> <code>fleet_list</code> <code>Optional[str]</code> <p>String, link to the fleet list of the company if it has vessels under commercial management.</p> <code>synonyms</code> <code>Optional[Tuple[str, ...]]</code> <p>Strings representing synonyms, acronyms or other names the company goes by in the shipping market.</p> <code>charterer_vessel_types</code> <code>Optional[Tuple[str, ...]]</code> <p>String, indicates in which market segments the company operates as charterer. Possible VesselTypes are \"Tanker, Dry, Containers, LNG, LPG\".</p> <code>commercial_operator_vessel_types</code> <code>Optional[Tuple[str, ...]]</code> <p>String, indicates in which market segments the company operates as commercial operator, therefore commercially manages vessel. Possible VesselTypes are \"Tanker, Dry, Containers, LNG, LPG\".</p> <code>geo_asset_owner_vessel_types</code> <code>Optional[Tuple[str, ...]]</code> <p>String, indicates if the company owns specific facilities such as shipyards or refineries relative to a particular vessel type. Possible VesselTypes are \"Tanker, Dry, Containers, LNG, LPG\".</p> <code>broker_vessel_types</code> <code>Optional[Tuple[str, ...]]</code> <p>String, indicates for which market segments the company operates as broker. Possible VesselTypes are \"Tanker, Dry, Containers, LNG, LPG\".</p> <code>port_agent_vessel_types</code> <code>Optional[Tuple[str, ...]]</code> <p>String, indicates for which market segments the company operates as port agent. Possible VesselTypes are \"Tanker, Dry, Containers, LNG, LPG\".</p> <code>seller_vessel_types</code> <code>Optional[Tuple[str, ...]]</code> <p>String, indicates for which market segments the company operates as a seller. Possible VesselTypes are \"Tanker, Dry, Containers, LNG, LPG\".</p> <code>buyer_vessel_types</code> <code>Optional[Tuple[str, ...]]</code> <p>String, indicates for which market segments the company operates as a buyer. Possible VesselTypes are \"Tanker, Dry, Containers, LNG, LPG\".</p> <code>parent_company_id</code> <code>Optional[int]</code> <p>Companies can have parent-child relationships, that is being legally related and having common interests. This numeric ID corresponds to the parent company or umbrella under which the company is.</p> <code>children_companies_ids</code> <code>Optional[Tuple[int, ...]]</code> <p>ID(s) of all companies acting as children of the initial company. Please note that a company can either have parent or children. We do not support two degrees relationships.</p> Source code in <code>signal_ocean/companies/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Company:\n    \"\"\"Contains all details of a company.\n\n    Attributes:\n        id: Numeric unique ID identifying a maritime company.\n        updated_date: Date, format YYYY-MM-DD HH:MM:SS, corresponding to the\n            latest update.\n        company_name: String, official name of the maritime company.\n        website: String, website of the company.\n        fleet_list: String, link to the fleet list of the company if it has\n            vessels under commercial management.\n        synonyms: Strings representing synonyms, acronyms or other names the\n            company goes by in the shipping market.\n        charterer_vessel_types: String, indicates in which market segments the\n            company operates as charterer. Possible VesselTypes are \"Tanker,\n            Dry, Containers, LNG, LPG\".\n        commercial_operator_vessel_types: String, indicates in which market\n            segments the company operates as commercial operator, therefore\n            commercially manages vessel. Possible VesselTypes are \"Tanker, Dry,\n            Containers, LNG, LPG\".\n        geo_asset_owner_vessel_types: String, indicates if the company owns\n            specific facilities such as shipyards or refineries relative to a\n            particular vessel type. Possible VesselTypes are \"Tanker, Dry,\n            Containers, LNG, LPG\".\n        broker_vessel_types: String, indicates for which market segments the\n            company operates as broker. Possible VesselTypes are \"Tanker, Dry,\n            Containers, LNG, LPG\".\n        port_agent_vessel_types: String, indicates for which market segments\n            the company operates as port agent. Possible VesselTypes are\n            \"Tanker, Dry, Containers, LNG, LPG\".\n        seller_vessel_types: String, indicates for which market segments the\n            company operates as a seller. Possible VesselTypes are \"Tanker,\n            Dry, Containers, LNG, LPG\".\n        buyer_vessel_types: String, indicates for which market segments the\n            company operates as a buyer. Possible VesselTypes are \"Tanker,\n            Dry, Containers, LNG, LPG\".\n        parent_company_id: Companies can have parent-child relationships, that\n            is being legally related and having common interests. This numeric\n            ID corresponds to the parent company or umbrella under which the\n            company is.\n        children_companies_ids: ID(s) of all companies acting as children of\n            the initial company. Please note that a company can either have\n            parent or children. We do not support two degrees relationships.\n    \"\"\"\n\n    id: int\n    updated_date: datetime\n    company_name: Optional[str] = None\n    website: Optional[str] = None\n    fleet_list: Optional[str] = None\n    synonyms: Optional[Tuple[str, ...]] = None\n    charterer_vessel_types: Optional[Tuple[str, ...]] = None\n    commercial_operator_vessel_types: Optional[Tuple[str, ...]] = None\n    geo_asset_owner_vessel_types: Optional[Tuple[str, ...]] = None\n    broker_vessel_types: Optional[Tuple[str, ...]] = None\n    port_agent_vessel_types: Optional[Tuple[str, ...]] = None\n    seller_vessel_types: Optional[Tuple[str, ...]] = None\n    buyer_vessel_types: Optional[Tuple[str, ...]] = None\n    parent_company_id: Optional[int] = None\n    children_companies_ids: Optional[Tuple[int, ...]] = None\n</code></pre>"},{"location":"distances/","title":"Package Documentation","text":"<p>Distances API Package.</p> <p>Classes:</p> Name Description <code>DistancesAPI</code> <p>Represents Signal's Distances API.</p> <code>VesselClass</code> <p>A group of vessels of similar characteristics.</p> <code>VesselClassFilter</code> <p>A filter used to find specific vessel classes.</p> <code>Port</code> <p>A maritime facility where vessels can dock.</p> <code>PortFilter</code> <p>A filter used to find specific ports.</p> <code>LoadingCondition</code> <p>The states of a vessel carrying cargo.</p> <code>RouteResponse</code> <p>A route between two points</p> <code>AlternativePath</code> <p>An alternative path for the route</p> <code>PointsOnRoute</code> <p>A point and extra properties needed for a route</p> <code>Point</code> <p>A point in latitude and longitude.</p>"},{"location":"distances/#signal_ocean.distances.AlternativePath","title":"<code>AlternativePath</code>  <code>dataclass</code>","text":"<p>An alternative path for the route.</p> <p>Attributes:</p> Name Type Description <code>calculated_route</code> <code>Tuple[Point, ...]</code> <p>List of coordinates between start and end point.</p> <code>distance</code> <code>Decimal</code> <p>The distance between the two points.</p> <code>routing_points_on_route</code> <code>Tuple[PointsOnRoute, ...]</code> <code>piracy_distance</code> <code>Decimal</code> <p>The distance between the two points when piracy is considered.</p> <code>seca_distance</code> <code>Decimal</code> <p>The distance between the two points when SECA is considered.</p> Source code in <code>signal_ocean/distances/models.py</code> <pre><code>@dataclass(frozen=True)\nclass AlternativePath:\n    \"\"\"An alternative path for the route.\n\n    Attributes:\n        calculated_route: List of coordinates between start and end point.\n        distance: The distance between the two points.\n        routing_points_on_route:\n        piracy_distance: The distance between the two points when piracy\n            is considered.\n        seca_distance: The distance between the two points when SECA is\n            considered.\n    \"\"\"\n\n    calculated_route: Tuple[Point, ...]\n    distance: Decimal\n    routing_points_on_route: Tuple[PointsOnRoute, ...]\n    piracy_distance: Decimal\n    seca_distance: Decimal\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI","title":"<code>DistancesAPI</code>","text":"<p>Represents Signal's Distances API.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>class DistancesAPI:\n    \"\"\"Represents Signal's Distances API.\"\"\"\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes DistancesAPI.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_vessel_classes(\n        self, class_filter: Optional[VesselClassFilter] = None\n    ) -&gt; Tuple[VesselClass, ...]:\n        \"\"\"Retrieves available vessel classes.\n\n        Args:\n            class_filter: A filter used to find specific vessel classes. If not\n                specified, returns all available vessel classes.\n\n        Returns:\n            A tuple of available vessel classes that match the filter.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/VesselClasses\"\n        )\n        response.raise_for_status()\n\n        classes = (VesselClass(**c) for c in response.json())\n        class_filter = class_filter or VesselClassFilter()\n\n        return tuple(class_filter._apply(classes))\n\n    def get_ports(\n        self, port_filter: Optional[PortFilter] = None\n    ) -&gt; Tuple[Port, ...]:\n        \"\"\"Retrieves available ports.\n\n        Args:\n            port_filter: A filter used to find specific ports. If not\n                specified, returns all available ports.\n\n        Returns:\n            A tuple of available ports that match the filter.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/ports\"\n        )\n        response.raise_for_status()\n\n        ports = (Port(**p) for p in response.json())\n        port_filter = port_filter or PortFilter()\n\n        return tuple(port_filter._apply(ports))\n\n    def get_point_to_point_distance(\n        self,\n        vessel_class: VesselClass,\n        loading_condition_id: int,\n        start_point: Point,\n        end_point: Point,\n    ) -&gt; Optional[Decimal]:\n        \"\"\"Retrieves the distance from one point to another.\n\n        Args:\n            vessel_class: Vessel class for which the distance will be\n                calculated.\n            loading_condition_id: Loading condition of the vessels\n                for which the distance will be calculated.\n                Options available: Laden and Ballast.\n            start_point: The starting point latitude and longitude.\n            end_point: The ending point latitude and longitude.\n\n        Returns:\n            A Decimal representing the distance in NM between two points.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/Distance/PointToPoint\",\n            {\n                \"vesselclass\": vessel_class.id,\n                \"loadingcondition\": loading_condition_id,\n                \"latitudefrom\": str(start_point.lat),\n                \"latitudeto\": str(end_point.lat),\n                \"longitudefrom\": str(start_point.lon),\n                \"longitudeto\": str(end_point.lon),\n            },\n        )\n\n        response.raise_for_status()\n\n        return as_decimal(response.json())\n\n    def get_point_to_port_distance(\n        self,\n        vessel_class: VesselClass,\n        loading_condition_id: int,\n        point: Point,\n        port: Port,\n    ) -&gt; Optional[Decimal]:\n        \"\"\"Retrieves the distance from one point to another.\n\n        Args:\n            vessel_class: Vessel class for which the distance will be\n                calculated.\n            loading_condition_id: Loading condition of the vessels\n                for which the distance will be calculated.\n                Options available: Laden and Ballast.\n            point: The starting point latitude and longitude.\n            port: The target port.\n\n        Returns:\n            A Decimal representing the distance in NM between a point\n                and a port.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/Distance/PointToPort\",\n            {\n                \"vesselclass\": vessel_class.id,\n                \"loadingcondition\": loading_condition_id,\n                \"latitude\": str(point.lat),\n                \"longitude\": str(point.lon),\n                \"portid\": port.id,\n            },\n        )\n\n        response.raise_for_status()\n\n        return as_decimal(response.json())\n\n    def get_port_to_port_distance(\n        self,\n        vessel_class: VesselClass,\n        loading_condition_id: int,\n        port_from: Port,\n        port_to: Port,\n    ) -&gt; Optional[Decimal]:\n        \"\"\"Retrieves the distance from one point to another.\n\n        Args:\n            vessel_class: Vessel class for which the distance will be\n                calculated.\n            loading_condition_id: Loading condition of the vessels\n                for which the distance will be calculated.\n                Options available: Laden and Ballast.\n            port_from: The starting port for the distance\n                route calculation.\n            port_to: The ending port for the distance\n                route calculation.\n\n        Returns:\n            A Decimal representing the distance in NM between two ports.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/Distance/PortToPort\",\n            {\n                \"vesselclass\": vessel_class.id,\n                \"loadingcondition\": loading_condition_id,\n                \"portIdFrom\": port_from.id,\n                \"portIdTo\": port_to.id,\n            },\n        )\n\n        response.raise_for_status()\n\n        return as_decimal(response.json())\n\n    def get_point_to_point_route(\n        self,\n        vessel_class: VesselClass,\n        loading_condition_id: int,\n        start_point: Point,\n        end_point: Point,\n    ) -&gt; RouteResponse:\n        \"\"\"Retrieves the route from one point to another.\n\n        Args:\n            vessel_class: Vessel class for which the distance will be\n                calculated.\n            loading_condition_id: Loading condition of the vessels\n                for which the distance will be calculated.\n                Options available: Laden and Ballast.\n            start_point: The starting point latitude and longitude.\n            end_point: The ending point latitude and longitude.\n\n        Returns:\n            A Route between two points with distance in NM.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/Distance/PointToPoint/Route\",\n            {\n                \"vesselclass\": vessel_class.id,\n                \"loadingcondition\": loading_condition_id,\n                \"latitudefrom\": str(start_point.lat),\n                \"latitudeto\": str(end_point.lat),\n                \"longitudefrom\": str(start_point.lon),\n                \"longitudeto\": str(end_point.lon),\n            },\n        )\n\n        response.raise_for_status()\n\n        return _distances_json.parse_route_response(response.json())\n\n    def get_point_to_port_route(\n        self,\n        vessel_class: VesselClass,\n        loading_condition_id: int,\n        point: Point,\n        port: Port,\n    ) -&gt; RouteResponse:\n        \"\"\"Retrieves the route from one point to another.\n\n        Args:\n            vessel_class: Vessel class for which the distance will be\n                calculated.\n            loading_condition_id: Loading condition of the vessels\n                for which the distance will be calculated.\n                Options available: Laden and Ballast.\n            point: The starting point latitude and longitude.\n            port: The ending port for the distance\n                route calculation.\n\n        Returns:\n            A Route between a point and a port with distance in NM.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/Distance/PointToPort/Route\",\n            {\n                \"vesselclass\": vessel_class.id,\n                \"loadingcondition\": loading_condition_id,\n                \"latitude\": str(point.lat),\n                \"longitude\": str(point.lon),\n                \"portid\": port.id,\n            },\n        )\n\n        response.raise_for_status()\n\n        return _distances_json.parse_route_response(response.json())\n\n    def get_port_to_port_route(\n        self,\n        vessel_class: VesselClass,\n        loading_condition_id: int,\n        port_from: Port,\n        port_to: Port,\n    ) -&gt; RouteResponse:\n        \"\"\"Retrieves the route from one point to another.\n\n        Args:\n            vessel_class: Vessel class for which the distance will be\n                calculated.\n            loading_condition_id: Loading condition of the vessels\n                for which the distance will be calculated.\n                Options available: Laden and Ballast.\n            port_from: The starting port for the distance\n                route calculation.\n            port_to: The ending port for the distance\n                route calculation.\n\n        Returns:\n            A Route between two ports with distance in NM.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/Distance/PortToPort/Route\",\n            {\n                \"vesselclass\": vessel_class.id,\n                \"loadingcondition\": loading_condition_id,\n                \"portIdFrom\": port_from.id,\n                \"portIdTo\": port_to.id,\n            },\n        )\n\n        response.raise_for_status()\n\n        return _distances_json.parse_route_response(response.json())\n\n    def get_generic_point_to_point_route(\n        self,\n        start_point: Point,\n        end_point: Point,\n        route_restrictions: Optional[RouteRestrictions] = None,\n        delays_valid_at: Optional[date] = None,\n        get_alternatives: Optional[bool] = None,\n    ) -&gt; RouteResponse:\n        \"\"\"Retrieves a generic route between two points.\n\n        The method takes into consideration the provided restrictions and can\n        also return alternative routes.\n\n        Args:\n            start_point: The starting point latitude and longitude.\n            end_point: The ending point latitude and longitude.\n            route_restrictions: Restrictions to obey while calculating the\n                route.\n            delays_valid_at: Date at which the route delays are valid.\n            get_alternatives: Whether or not to include alternative routes.\n\n        Returns:\n            A Route between two points with distance in NM.\n        \"\"\"\n        route_restrictions = route_restrictions or RouteRestrictions()\n        response = self.__connection._make_get_request(\n            \"/distances-api/api/v1/Distance/Generic\",\n            {\n                \"StartPointLatitude\": str(start_point.lat),\n                \"StartPointLongitude\": str(start_point.lon),\n                \"EndPointLatitude\": str(end_point.lat),\n                \"EndPointLongitude\": str(end_point.lon),\n                \"DelaysValidAt\": format_iso_date(delays_valid_at)\n                if delays_valid_at\n                else None,\n                \"GetAlternatives\": get_alternatives,\n                **route_restrictions._to_query_string(),\n            },\n        )\n\n        response.raise_for_status()\n        return _distances_json.parse_route_response(response.json())\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes DistancesAPI.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes DistancesAPI.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_generic_point_to_point_route","title":"<code>get_generic_point_to_point_route(start_point, end_point, route_restrictions=None, delays_valid_at=None, get_alternatives=None)</code>","text":"<p>Retrieves a generic route between two points.</p> <p>The method takes into consideration the provided restrictions and can also return alternative routes.</p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>Point</code> <p>The starting point latitude and longitude.</p> required <code>end_point</code> <code>Point</code> <p>The ending point latitude and longitude.</p> required <code>route_restrictions</code> <code>Optional[RouteRestrictions]</code> <p>Restrictions to obey while calculating the route.</p> <code>None</code> <code>delays_valid_at</code> <code>Optional[date]</code> <p>Date at which the route delays are valid.</p> <code>None</code> <code>get_alternatives</code> <code>Optional[bool]</code> <p>Whether or not to include alternative routes.</p> <code>None</code> <p>Returns:</p> Type Description <code>RouteResponse</code> <p>A Route between two points with distance in NM.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_generic_point_to_point_route(\n    self,\n    start_point: Point,\n    end_point: Point,\n    route_restrictions: Optional[RouteRestrictions] = None,\n    delays_valid_at: Optional[date] = None,\n    get_alternatives: Optional[bool] = None,\n) -&gt; RouteResponse:\n    \"\"\"Retrieves a generic route between two points.\n\n    The method takes into consideration the provided restrictions and can\n    also return alternative routes.\n\n    Args:\n        start_point: The starting point latitude and longitude.\n        end_point: The ending point latitude and longitude.\n        route_restrictions: Restrictions to obey while calculating the\n            route.\n        delays_valid_at: Date at which the route delays are valid.\n        get_alternatives: Whether or not to include alternative routes.\n\n    Returns:\n        A Route between two points with distance in NM.\n    \"\"\"\n    route_restrictions = route_restrictions or RouteRestrictions()\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/Distance/Generic\",\n        {\n            \"StartPointLatitude\": str(start_point.lat),\n            \"StartPointLongitude\": str(start_point.lon),\n            \"EndPointLatitude\": str(end_point.lat),\n            \"EndPointLongitude\": str(end_point.lon),\n            \"DelaysValidAt\": format_iso_date(delays_valid_at)\n            if delays_valid_at\n            else None,\n            \"GetAlternatives\": get_alternatives,\n            **route_restrictions._to_query_string(),\n        },\n    )\n\n    response.raise_for_status()\n    return _distances_json.parse_route_response(response.json())\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_point_to_point_distance","title":"<code>get_point_to_point_distance(vessel_class, loading_condition_id, start_point, end_point)</code>","text":"<p>Retrieves the distance from one point to another.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class</code> <code>VesselClass</code> <p>Vessel class for which the distance will be calculated.</p> required <code>loading_condition_id</code> <code>int</code> <p>Loading condition of the vessels for which the distance will be calculated. Options available: Laden and Ballast.</p> required <code>start_point</code> <code>Point</code> <p>The starting point latitude and longitude.</p> required <code>end_point</code> <code>Point</code> <p>The ending point latitude and longitude.</p> required <p>Returns:</p> Type Description <code>Optional[Decimal]</code> <p>A Decimal representing the distance in NM between two points.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_point_to_point_distance(\n    self,\n    vessel_class: VesselClass,\n    loading_condition_id: int,\n    start_point: Point,\n    end_point: Point,\n) -&gt; Optional[Decimal]:\n    \"\"\"Retrieves the distance from one point to another.\n\n    Args:\n        vessel_class: Vessel class for which the distance will be\n            calculated.\n        loading_condition_id: Loading condition of the vessels\n            for which the distance will be calculated.\n            Options available: Laden and Ballast.\n        start_point: The starting point latitude and longitude.\n        end_point: The ending point latitude and longitude.\n\n    Returns:\n        A Decimal representing the distance in NM between two points.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/Distance/PointToPoint\",\n        {\n            \"vesselclass\": vessel_class.id,\n            \"loadingcondition\": loading_condition_id,\n            \"latitudefrom\": str(start_point.lat),\n            \"latitudeto\": str(end_point.lat),\n            \"longitudefrom\": str(start_point.lon),\n            \"longitudeto\": str(end_point.lon),\n        },\n    )\n\n    response.raise_for_status()\n\n    return as_decimal(response.json())\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_point_to_point_route","title":"<code>get_point_to_point_route(vessel_class, loading_condition_id, start_point, end_point)</code>","text":"<p>Retrieves the route from one point to another.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class</code> <code>VesselClass</code> <p>Vessel class for which the distance will be calculated.</p> required <code>loading_condition_id</code> <code>int</code> <p>Loading condition of the vessels for which the distance will be calculated. Options available: Laden and Ballast.</p> required <code>start_point</code> <code>Point</code> <p>The starting point latitude and longitude.</p> required <code>end_point</code> <code>Point</code> <p>The ending point latitude and longitude.</p> required <p>Returns:</p> Type Description <code>RouteResponse</code> <p>A Route between two points with distance in NM.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_point_to_point_route(\n    self,\n    vessel_class: VesselClass,\n    loading_condition_id: int,\n    start_point: Point,\n    end_point: Point,\n) -&gt; RouteResponse:\n    \"\"\"Retrieves the route from one point to another.\n\n    Args:\n        vessel_class: Vessel class for which the distance will be\n            calculated.\n        loading_condition_id: Loading condition of the vessels\n            for which the distance will be calculated.\n            Options available: Laden and Ballast.\n        start_point: The starting point latitude and longitude.\n        end_point: The ending point latitude and longitude.\n\n    Returns:\n        A Route between two points with distance in NM.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/Distance/PointToPoint/Route\",\n        {\n            \"vesselclass\": vessel_class.id,\n            \"loadingcondition\": loading_condition_id,\n            \"latitudefrom\": str(start_point.lat),\n            \"latitudeto\": str(end_point.lat),\n            \"longitudefrom\": str(start_point.lon),\n            \"longitudeto\": str(end_point.lon),\n        },\n    )\n\n    response.raise_for_status()\n\n    return _distances_json.parse_route_response(response.json())\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_point_to_port_distance","title":"<code>get_point_to_port_distance(vessel_class, loading_condition_id, point, port)</code>","text":"<p>Retrieves the distance from one point to another.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class</code> <code>VesselClass</code> <p>Vessel class for which the distance will be calculated.</p> required <code>loading_condition_id</code> <code>int</code> <p>Loading condition of the vessels for which the distance will be calculated. Options available: Laden and Ballast.</p> required <code>point</code> <code>Point</code> <p>The starting point latitude and longitude.</p> required <code>port</code> <code>Port</code> <p>The target port.</p> required <p>Returns:</p> Type Description <code>Optional[Decimal]</code> <p>A Decimal representing the distance in NM between a point and a port.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_point_to_port_distance(\n    self,\n    vessel_class: VesselClass,\n    loading_condition_id: int,\n    point: Point,\n    port: Port,\n) -&gt; Optional[Decimal]:\n    \"\"\"Retrieves the distance from one point to another.\n\n    Args:\n        vessel_class: Vessel class for which the distance will be\n            calculated.\n        loading_condition_id: Loading condition of the vessels\n            for which the distance will be calculated.\n            Options available: Laden and Ballast.\n        point: The starting point latitude and longitude.\n        port: The target port.\n\n    Returns:\n        A Decimal representing the distance in NM between a point\n            and a port.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/Distance/PointToPort\",\n        {\n            \"vesselclass\": vessel_class.id,\n            \"loadingcondition\": loading_condition_id,\n            \"latitude\": str(point.lat),\n            \"longitude\": str(point.lon),\n            \"portid\": port.id,\n        },\n    )\n\n    response.raise_for_status()\n\n    return as_decimal(response.json())\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_point_to_port_route","title":"<code>get_point_to_port_route(vessel_class, loading_condition_id, point, port)</code>","text":"<p>Retrieves the route from one point to another.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class</code> <code>VesselClass</code> <p>Vessel class for which the distance will be calculated.</p> required <code>loading_condition_id</code> <code>int</code> <p>Loading condition of the vessels for which the distance will be calculated. Options available: Laden and Ballast.</p> required <code>point</code> <code>Point</code> <p>The starting point latitude and longitude.</p> required <code>port</code> <code>Port</code> <p>The ending port for the distance route calculation.</p> required <p>Returns:</p> Type Description <code>RouteResponse</code> <p>A Route between a point and a port with distance in NM.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_point_to_port_route(\n    self,\n    vessel_class: VesselClass,\n    loading_condition_id: int,\n    point: Point,\n    port: Port,\n) -&gt; RouteResponse:\n    \"\"\"Retrieves the route from one point to another.\n\n    Args:\n        vessel_class: Vessel class for which the distance will be\n            calculated.\n        loading_condition_id: Loading condition of the vessels\n            for which the distance will be calculated.\n            Options available: Laden and Ballast.\n        point: The starting point latitude and longitude.\n        port: The ending port for the distance\n            route calculation.\n\n    Returns:\n        A Route between a point and a port with distance in NM.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/Distance/PointToPort/Route\",\n        {\n            \"vesselclass\": vessel_class.id,\n            \"loadingcondition\": loading_condition_id,\n            \"latitude\": str(point.lat),\n            \"longitude\": str(point.lon),\n            \"portid\": port.id,\n        },\n    )\n\n    response.raise_for_status()\n\n    return _distances_json.parse_route_response(response.json())\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_port_to_port_distance","title":"<code>get_port_to_port_distance(vessel_class, loading_condition_id, port_from, port_to)</code>","text":"<p>Retrieves the distance from one point to another.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class</code> <code>VesselClass</code> <p>Vessel class for which the distance will be calculated.</p> required <code>loading_condition_id</code> <code>int</code> <p>Loading condition of the vessels for which the distance will be calculated. Options available: Laden and Ballast.</p> required <code>port_from</code> <code>Port</code> <p>The starting port for the distance route calculation.</p> required <code>port_to</code> <code>Port</code> <p>The ending port for the distance route calculation.</p> required <p>Returns:</p> Type Description <code>Optional[Decimal]</code> <p>A Decimal representing the distance in NM between two ports.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_port_to_port_distance(\n    self,\n    vessel_class: VesselClass,\n    loading_condition_id: int,\n    port_from: Port,\n    port_to: Port,\n) -&gt; Optional[Decimal]:\n    \"\"\"Retrieves the distance from one point to another.\n\n    Args:\n        vessel_class: Vessel class for which the distance will be\n            calculated.\n        loading_condition_id: Loading condition of the vessels\n            for which the distance will be calculated.\n            Options available: Laden and Ballast.\n        port_from: The starting port for the distance\n            route calculation.\n        port_to: The ending port for the distance\n            route calculation.\n\n    Returns:\n        A Decimal representing the distance in NM between two ports.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/Distance/PortToPort\",\n        {\n            \"vesselclass\": vessel_class.id,\n            \"loadingcondition\": loading_condition_id,\n            \"portIdFrom\": port_from.id,\n            \"portIdTo\": port_to.id,\n        },\n    )\n\n    response.raise_for_status()\n\n    return as_decimal(response.json())\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_port_to_port_route","title":"<code>get_port_to_port_route(vessel_class, loading_condition_id, port_from, port_to)</code>","text":"<p>Retrieves the route from one point to another.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class</code> <code>VesselClass</code> <p>Vessel class for which the distance will be calculated.</p> required <code>loading_condition_id</code> <code>int</code> <p>Loading condition of the vessels for which the distance will be calculated. Options available: Laden and Ballast.</p> required <code>port_from</code> <code>Port</code> <p>The starting port for the distance route calculation.</p> required <code>port_to</code> <code>Port</code> <p>The ending port for the distance route calculation.</p> required <p>Returns:</p> Type Description <code>RouteResponse</code> <p>A Route between two ports with distance in NM.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_port_to_port_route(\n    self,\n    vessel_class: VesselClass,\n    loading_condition_id: int,\n    port_from: Port,\n    port_to: Port,\n) -&gt; RouteResponse:\n    \"\"\"Retrieves the route from one point to another.\n\n    Args:\n        vessel_class: Vessel class for which the distance will be\n            calculated.\n        loading_condition_id: Loading condition of the vessels\n            for which the distance will be calculated.\n            Options available: Laden and Ballast.\n        port_from: The starting port for the distance\n            route calculation.\n        port_to: The ending port for the distance\n            route calculation.\n\n    Returns:\n        A Route between two ports with distance in NM.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/Distance/PortToPort/Route\",\n        {\n            \"vesselclass\": vessel_class.id,\n            \"loadingcondition\": loading_condition_id,\n            \"portIdFrom\": port_from.id,\n            \"portIdTo\": port_to.id,\n        },\n    )\n\n    response.raise_for_status()\n\n    return _distances_json.parse_route_response(response.json())\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_ports","title":"<code>get_ports(port_filter=None)</code>","text":"<p>Retrieves available ports.</p> <p>Parameters:</p> Name Type Description Default <code>port_filter</code> <code>Optional[PortFilter]</code> <p>A filter used to find specific ports. If not specified, returns all available ports.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Port, ...]</code> <p>A tuple of available ports that match the filter.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_ports(\n    self, port_filter: Optional[PortFilter] = None\n) -&gt; Tuple[Port, ...]:\n    \"\"\"Retrieves available ports.\n\n    Args:\n        port_filter: A filter used to find specific ports. If not\n            specified, returns all available ports.\n\n    Returns:\n        A tuple of available ports that match the filter.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/ports\"\n    )\n    response.raise_for_status()\n\n    ports = (Port(**p) for p in response.json())\n    port_filter = port_filter or PortFilter()\n\n    return tuple(port_filter._apply(ports))\n</code></pre>"},{"location":"distances/#signal_ocean.distances.DistancesAPI.get_vessel_classes","title":"<code>get_vessel_classes(class_filter=None)</code>","text":"<p>Retrieves available vessel classes.</p> <p>Parameters:</p> Name Type Description Default <code>class_filter</code> <code>Optional[VesselClassFilter]</code> <p>A filter used to find specific vessel classes. If not specified, returns all available vessel classes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VesselClass, ...]</code> <p>A tuple of available vessel classes that match the filter.</p> Source code in <code>signal_ocean/distances/distances_api.py</code> <pre><code>def get_vessel_classes(\n    self, class_filter: Optional[VesselClassFilter] = None\n) -&gt; Tuple[VesselClass, ...]:\n    \"\"\"Retrieves available vessel classes.\n\n    Args:\n        class_filter: A filter used to find specific vessel classes. If not\n            specified, returns all available vessel classes.\n\n    Returns:\n        A tuple of available vessel classes that match the filter.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"/distances-api/api/v1/VesselClasses\"\n    )\n    response.raise_for_status()\n\n    classes = (VesselClass(**c) for c in response.json())\n    class_filter = class_filter or VesselClassFilter()\n\n    return tuple(class_filter._apply(classes))\n</code></pre>"},{"location":"distances/#signal_ocean.distances.LoadingCondition","title":"<code>LoadingCondition</code>","text":"<p>Contains constants for available loading conditions.</p> Source code in <code>signal_ocean/distances/loading_condition.py</code> <pre><code>class LoadingCondition(metaclass=IterableConstants):\n    \"\"\"Contains constants for available loading conditions.\"\"\"\n    LADEN = 1\n    '''\n    Vessel is loaded.\n    '''\n    BALLAST = 2\n    '''\n    Vessel is free of cargo\n    '''\n</code></pre>"},{"location":"distances/#signal_ocean.distances.LoadingCondition.BALLAST","title":"<code>BALLAST = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is free of cargo</p>"},{"location":"distances/#signal_ocean.distances.LoadingCondition.LADEN","title":"<code>LADEN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is loaded.</p>"},{"location":"distances/#signal_ocean.distances.Point","title":"<code>Point</code>  <code>dataclass</code>","text":"<p>A point on the surface of Earth.</p> <p>Attributes:</p> Name Type Description <code>lat</code> <code>Decimal</code> <p>The latitude of the point.</p> <code>lon</code> <code>Decimal</code> <p>The longitude of the point.</p> Source code in <code>signal_ocean/distances/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Point:\n    \"\"\"A point on the surface of Earth.\n\n    Attributes:\n        lat: The latitude of the point.\n        lon: The longitude of the point.\n    \"\"\"\n\n    lat: Decimal\n    lon: Decimal\n</code></pre>"},{"location":"distances/#signal_ocean.distances.PointsOnRoute","title":"<code>PointsOnRoute</code>  <code>dataclass</code>","text":"<p>A point and extra properties needed for a route.</p> <p>Attributes:</p> Name Type Description <code>is_hra</code> <code>bool</code> <p>Is the point in a high-risk area.</p> <code>is_seca</code> <code>bool</code> <p>Is the point in a Sulfur Emission Control Area.</p> <code>distance</code> <code>Decimal</code> <p>The distance between the two points.</p> <code>distance_to_enter</code> <code>Decimal</code> <code>heading</code> <code>int</code> <p>The point on route heading.</p> <code>editable</code> <code>bool</code> <p>If the point on route is editable.</p> <code>name</code> <code>str</code> <p>The point on route name.</p> <code>is_shown</code> <code>bool</code> <p>If the point on route is shown.</p> <code>delay_mins</code> <code>int</code> <p>The delay in minutes.</p> <code>center_point</code> <code>Point</code> <p>The center point of route.</p> Source code in <code>signal_ocean/distances/models.py</code> <pre><code>@dataclass(frozen=True)\nclass PointsOnRoute:\n    \"\"\"A point and extra properties needed for a route.\n\n    Attributes:\n        is_hra: Is the point in a high-risk area.\n        is_seca: Is the point in a Sulfur Emission Control Area.\n        distance: The distance between the two points.\n        distance_to_enter:\n        heading: The point on route heading.\n        editable: If the point on route is editable.\n        name: The point on route name.\n        is_shown: If the point on route is shown.\n        delay_mins: The delay in minutes.\n        center_point: The center point of route.\n    \"\"\"\n\n    is_hra: bool\n    is_seca: bool\n    distance: Decimal\n    distance_to_enter: Decimal\n    heading: int\n    editable: bool\n    name: str\n    is_shown: bool\n    delay_mins: int\n    center_point: Point\n</code></pre>"},{"location":"distances/#signal_ocean.distances.Port","title":"<code>Port</code>  <code>dataclass</code>","text":"<p>A maritime facility where vessels can dock.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the port.</p> <code>name</code> <code>str</code> <p>The name of the port.</p> Source code in <code>signal_ocean/distances/port.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass Port:\n    \"\"\"A maritime facility where vessels can dock.\n\n    Attributes:\n        id: The ID of the port.\n        name: The name of the port.\n    \"\"\"\n    id: int\n    name: str\n</code></pre>"},{"location":"distances/#signal_ocean.distances.PortFilter","title":"<code>PortFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific ports.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find ports by name. When specified, ports whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/distances/port_filter.py</code> <pre><code>@dataclass(eq=False)\nclass PortFilter:\n    \"\"\"A filter used to find specific ports.\n\n    Attributes:\n        name_like: Used to find ports by name. When specified, ports whose\n            names partially match (contain) the attribute's value will be\n            returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(self, ports: Iterable[Port]) -&gt; Iterable[Port]:\n        return filter(self.__does_port_match, ports)\n\n    def __does_port_match(self, port: Port) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, port.name\n        )\n</code></pre>"},{"location":"distances/#signal_ocean.distances.RouteResponse","title":"<code>RouteResponse</code>  <code>dataclass</code>","text":"<p>A route between two points.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The id of the route response.</p> <code>start_point</code> <code>Point</code> <p>Start point coordinates.</p> <code>end_point</code> <code>Point</code> <p>End point coordinates.</p> <code>calculated_route</code> <code>Tuple[Point, ...]</code> <p>List of coordinates between start and end point.</p> <code>routing_points_on_route</code> <code>Tuple[PointsOnRoute, ...]</code> <p>List of points on a route.</p> <code>distance</code> <code>Decimal</code> <p>The distance between the two points.</p> <code>piracy_distance</code> <code>Decimal</code> <p>The distance between the two points when piracy is considered.</p> <code>seca_distance</code> <code>Decimal</code> <p>The distance between the two points when seca is considered.</p> <code>alternative_paths</code> <code>Tuple[AlternativePath, ...]</code> <p>List of alternative paths between the two points.</p> <code>is_empty</code> <code>bool</code> <p>If the response is empty.</p> <code>bbox</code> <code>Optional[Tuple[Decimal, ...]]</code> <p>The bounding box of the route.</p> Source code in <code>signal_ocean/distances/models.py</code> <pre><code>@dataclass(frozen=True)\nclass RouteResponse:\n    \"\"\"A route between two points.\n\n    Attributes:\n        id: The id of the route response.\n        start_point: Start point coordinates.\n        end_point: End point coordinates.\n        calculated_route: List of coordinates between start and end point.\n        routing_points_on_route: List of points on a route.\n        distance: The distance between the two points.\n        piracy_distance: The distance between the two points when piracy is\n            considered.\n        seca_distance: The distance between the two points when seca is\n            considered.\n        alternative_paths: List of alternative paths between the two points.\n        is_empty: If the response is empty.\n        bbox: The bounding box of the route.\n    \"\"\"\n\n    id: int\n    start_point: Point\n    end_point: Point\n    calculated_route: Tuple[Point, ...]\n    routing_points_on_route: Tuple[PointsOnRoute, ...]\n    distance: Decimal\n    piracy_distance: Decimal\n    seca_distance: Decimal\n    alternative_paths: Tuple[AlternativePath, ...]\n    is_empty: bool\n    bbox: Optional[Tuple[Decimal, ...]]\n</code></pre>"},{"location":"distances/#signal_ocean.distances.RouteRestrictions","title":"<code>RouteRestrictions</code>  <code>dataclass</code>","text":"<p>Restrictions that can be placed upon a route.</p> <p>Attributes:</p> Name Type Description <code>is_suez_open</code> <code>Optional[bool]</code> <p>Determines whether or not to route through the Suez Canal.</p> <code>is_panama_open</code> <code>Optional[bool]</code> <p>Determines whether or not to route through the Panama Canal.</p> <code>is_messina_open</code> <code>Optional[bool]</code> <p>Determines whether or not to route through the Strait of Messina.</p> <code>is_oresund_open</code> <code>Optional[bool]</code> <p>Determines whether or not to route through the \u00d8resund Strait.</p> <code>is_suez_open_only_northbound</code> <code>Optional[bool]</code> <p>Determines whether or not to route through the Suez Canal only when northbound.</p> <code>is_piracy_considered</code> <code>Optional[bool]</code> <p>Determines whether or not to route through areas where a piracy threat exists.</p> <code>minimize_seca</code> <code>Optional[bool]</code> <p>Determines whether or not to minimize distance travelled through SECA areas.</p> Source code in <code>signal_ocean/distances/models.py</code> <pre><code>@dataclass(frozen=True)\nclass RouteRestrictions:\n    \"\"\"Restrictions that can be placed upon a route.\n\n    Attributes:\n        is_suez_open: Determines whether or not to route through the Suez\n            Canal.\n        is_panama_open: Determines whether or not to route through the Panama\n            Canal.\n        is_messina_open: Determines whether or not to route through the Strait\n            of Messina.\n        is_oresund_open: Determines whether or not to route through the \u00d8resund\n            Strait.\n        is_suez_open_only_northbound: Determines whether or not to route\n            through the Suez Canal only when northbound.\n        is_piracy_considered: Determines whether or not to route through areas\n            where a piracy threat exists.\n        minimize_seca: Determines whether or not to minimize distance travelled\n            through SECA areas.\n    \"\"\"\n\n    is_suez_open: Optional[bool] = None\n    is_panama_open: Optional[bool] = None\n    is_messina_open: Optional[bool] = None\n    is_oresund_open: Optional[bool] = None\n    is_suez_open_only_northbound: Optional[bool] = None\n    is_piracy_considered: Optional[bool] = None\n    minimize_seca: Optional[bool] = None\n\n    def _to_query_string(self) -&gt; Dict[str, Optional[bool]]:\n        return {\n            \"IsSuezOpen\": self.is_suez_open,\n            \"IsPanamaOpen\": self.is_panama_open,\n            \"IsPiracyConsidered\": self.is_piracy_considered,\n            \"IsMessinaOpen\": self.is_messina_open,\n            \"IsOresundOpen\": self.is_oresund_open,\n            \"IsSuezOpenOnlyNorthbound\": self.is_suez_open_only_northbound,\n            \"MinimizeSeca\": self.minimize_seca,\n        }\n</code></pre>"},{"location":"distances/#signal_ocean.distances.VesselClass","title":"<code>VesselClass</code>  <code>dataclass</code>","text":"<p>A group of vessels of similar characteristics, i.e. Aframax, Panamax, etc.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The vessel class ID.</p> <code>name</code> <code>str</code> <p>The vessel class name.</p> Source code in <code>signal_ocean/distances/vessel_class.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass VesselClass:\n    \"\"\"A group of vessels of similar characteristics, i.e. Aframax, Panamax, etc.\n\n    Attributes:\n        id: The vessel class ID.\n        name: The vessel class name.\n    \"\"\"\n    id: int\n    name: str\n</code></pre>"},{"location":"distances/#signal_ocean.distances.VesselClassFilter","title":"<code>VesselClassFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific vessel classes.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find vessel classes by name. When specified, vessel classes whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/distances/vessel_class_filter.py</code> <pre><code>@dataclass(eq=False)\nclass VesselClassFilter:\n    \"\"\"A filter used to find specific vessel classes.\n\n    Attributes:\n        name_like: Used to find vessel classes by name. When specified, vessel\n            classes whose names partially match (contain) the attribute's value\n            will be returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(\n        self, vessel_classes: Iterable[VesselClass]\n    ) -&gt; Iterable[VesselClass]:\n        return filter(self.__does_class_match, vessel_classes)\n\n    def __does_class_match(self, vessel_class: VesselClass) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, vessel_class.name\n        )\n</code></pre>"},{"location":"freight_rates/","title":"Freight Rates","text":"<p>Freight Rates API Package.</p> <p>Classes:</p> Name Description <code>FreightRatesAPI</code> <p>Represents Signal's Freight Rates API.</p> <code>FreightPricing</code> <p>The freight pricing given a load and discharge port.</p> <code>VesselClass</code> <p>A vessel class.</p> <code>Port</code> <p>A maritime facility where vessels can dock.</p> <code>PortFilter</code> <p>A filter used to find specific ports.</p>"},{"location":"freight_rates/#signal_ocean.freight_rates.Cost","title":"<code>Cost</code>  <code>dataclass</code>","text":"<p>The freight costs breakdown.</p> <p>Attributes:</p> Name Type Description <code>canal</code> <code>float</code> <p>Canal costs.</p> <code>freight_cost</code> <code>float</code> <p>Freight cost.</p> <code>other_port_expenses</code> <code>float</code> <p>Other port expenses.</p> Source code in <code>signal_ocean/freight_rates/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Cost:\n    \"\"\"The freight costs breakdown.\n\n    Attributes:\n        canal: Canal costs.\n        freight_cost: Freight cost.\n        other_port_expenses: Other port expenses.\n    \"\"\"\n\n    canal: float\n    freight_cost: float\n    other_port_expenses: float\n</code></pre>"},{"location":"freight_rates/#signal_ocean.freight_rates.FreightPricing","title":"<code>FreightPricing</code>  <code>dataclass</code>","text":"<p>The freight pricing given a load and discharge port.</p> <p>Attributes:</p> Name Type Description <code>vessel_class</code> <code>str</code> <p>The vessel class.</p> <code>rate</code> <code>float</code> <p>Value of the rate.</p> <code>rate_type</code> <code>str</code> <p>Type of the rate.</p> <code>estimated_flat_rate</code> <code>float</code> <p>Estimated flat rate.</p> <code>costs</code> <code>Cost</code> <p>Costs breakdown.</p> <code>total_freight_cost</code> <code>float</code> <p>Total freight cost.</p> <code>total_freight_rate</code> <code>float</code> <p>Total freight rate.</p> <code>route_type</code> <code>str</code> <p>Route type.</p> <code>load_ports</code> <code>List[Port]</code> <p>Load ports.</p> <code>discharge_ports</code> <code>List[Port]</code> <p>Discharge ports.</p> <code>quantity</code> <code>float</code> <p>Quantity.</p> <code>min_flat_augusta_used</code> <code>bool</code> <p>True if minimum flat Augusta was used.</p> <code>routing_choices</code> <code>Optional[List[str]]</code> <p>Routing choices (e.g. Suez, Panama etc).</p> Source code in <code>signal_ocean/freight_rates/models.py</code> <pre><code>@dataclass(frozen=True)\nclass FreightPricing:\n    \"\"\"The freight pricing given a load and discharge port.\n\n    Attributes:\n        vessel_class: The vessel class.\n        rate: Value of the rate.\n        rate_type: Type of the rate.\n        estimated_flat_rate: Estimated flat rate.\n        costs: Costs breakdown.\n        total_freight_cost: Total freight cost.\n        total_freight_rate: Total freight rate.\n        route_type: Route type.\n        load_ports: Load ports.\n        discharge_ports: Discharge ports.\n        quantity: Quantity.\n        min_flat_augusta_used: True if minimum flat Augusta was used.\n        routing_choices: Routing choices (e.g. Suez, Panama etc).\n    \"\"\"\n\n    vessel_class: str\n    rate: float\n    rate_type: str\n    estimated_flat_rate: float\n    costs: Cost\n    total_freight_cost: float\n    total_freight_rate: float\n    route_type: str\n    load_ports: List[Port]\n    discharge_ports: List[Port]\n    quantity: float\n    min_flat_augusta_used: bool\n    routing_choices: Optional[List[str]]\n</code></pre>"},{"location":"freight_rates/#signal_ocean.freight_rates.FreightRatesAPI","title":"<code>FreightRatesAPI</code>","text":"<p>Represents Signal's Freight Rates API.</p> Source code in <code>signal_ocean/freight_rates/freight_rates_api.py</code> <pre><code>class FreightRatesAPI:\n    \"\"\"Represents Signal's Freight Rates API.\"\"\"\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes the Freight Rates API.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_freight_pricing(\n            self, load_ports: List[int], discharge_ports: List[int],\n            vessel_classes: List[str], is_clean: bool,\n            date: date = date.today()\n    ) -&gt; Tuple[FreightPricing, ...]:\n        \"\"\"Provides freight pricing for given load/discharge ports.\n\n        Args:\n            load_ports: Load ports.\n            discharge_ports: Discharge ports.\n            vessel_classes: Vessel classes for which to return the freight e.g.\n            VLCC, Aframax etc.\n            is_clean: True if it is clean cargo.\n            date: Date of pricing.\n\n\n        Returns:\n            The freight pricing or None if there are is no freight matching the\n            given criteria.\n        \"\"\"\n        query_dict = {\n            \"LoadPorts\": '&amp;LoadPorts='.join([str(lp) for lp in load_ports]),\n            \"DischargePorts\": '&amp;DischargePorts='.join([str(dp) for dp in\n                                                       discharge_ports]),\n            \"IsClean\": '{}'.format(is_clean),\n            \"Date\": date.isoformat()\n        }\n\n        vessel_classes_param = '&amp;VesselClasses='.join(vessel_classes)\n        query_dict['VesselClasses'] = vessel_classes_param\n\n        query_string: QueryString = query_dict\n        response = self.__connection._make_get_request(\n            \"freight/api/Freight/v3/pricing\", query_string\n        )\n        response.raise_for_status()\n        response_json = response.json()\n        return_object = parse_freight_pricing(response_json)\n\n        return return_object\n\n    @staticmethod\n    def get_vessel_classes() -&gt; Tuple[str, ...]:\n        \"\"\"Retrieves all available vessel classes.\n\n        Returns:\n            A tuple of all available vessel classes.\n        \"\"\"\n        vessel_classes = tuple(vessel_class.name\n                               for vessel_class in VesselClass)\n        return vessel_classes\n\n    def get_ports(\n        self, port_filter: Optional[PortFilter] = None\n    ) -&gt; Tuple[Port, ...]:\n        \"\"\"Retrieves available ports.\n\n        Args:\n            port_filter: A filter used to find specific ports. If not\n                specified, returns all available ports.\n\n        Returns:\n            A tuple of available ports that match the filter.\n        \"\"\"\n        query_dict = {\n            \"date\": date.today().isoformat()\n        }\n\n        query_string: QueryString = query_dict\n\n        available_ports: List[Port] = []\n        for vessel_class in VesselClass:\n            response = self.__connection._make_get_request(\n                f\"freight/api/Freight/v2/pricing/\"\n                f\"availablePorts/{vessel_class.name}\",\n                query_string\n            )\n            response.raise_for_status()\n            response_json = response.json()\n            available_ports += parse_ports(response_json)\n\n        port_filter = port_filter or PortFilter()\n\n        return tuple(port_filter._apply(available_ports))\n</code></pre>"},{"location":"freight_rates/#signal_ocean.freight_rates.FreightRatesAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes the Freight Rates API.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/freight_rates/freight_rates_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes the Freight Rates API.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"freight_rates/#signal_ocean.freight_rates.FreightRatesAPI.get_freight_pricing","title":"<code>get_freight_pricing(load_ports, discharge_ports, vessel_classes, is_clean, date=date.today())</code>","text":"<p>Provides freight pricing for given load/discharge ports.</p> <p>Parameters:</p> Name Type Description Default <code>load_ports</code> <code>List[int]</code> <p>Load ports.</p> required <code>discharge_ports</code> <code>List[int]</code> <p>Discharge ports.</p> required <code>vessel_classes</code> <code>List[str]</code> <p>Vessel classes for which to return the freight e.g.</p> required <code>is_clean</code> <code>bool</code> <p>True if it is clean cargo.</p> required <code>date</code> <code>date</code> <p>Date of pricing.</p> <code>today()</code> <p>Returns:</p> Type Description <code>FreightPricing</code> <p>The freight pricing or None if there are is no freight matching the</p> <code>...</code> <p>given criteria.</p> Source code in <code>signal_ocean/freight_rates/freight_rates_api.py</code> <pre><code>def get_freight_pricing(\n        self, load_ports: List[int], discharge_ports: List[int],\n        vessel_classes: List[str], is_clean: bool,\n        date: date = date.today()\n) -&gt; Tuple[FreightPricing, ...]:\n    \"\"\"Provides freight pricing for given load/discharge ports.\n\n    Args:\n        load_ports: Load ports.\n        discharge_ports: Discharge ports.\n        vessel_classes: Vessel classes for which to return the freight e.g.\n        VLCC, Aframax etc.\n        is_clean: True if it is clean cargo.\n        date: Date of pricing.\n\n\n    Returns:\n        The freight pricing or None if there are is no freight matching the\n        given criteria.\n    \"\"\"\n    query_dict = {\n        \"LoadPorts\": '&amp;LoadPorts='.join([str(lp) for lp in load_ports]),\n        \"DischargePorts\": '&amp;DischargePorts='.join([str(dp) for dp in\n                                                   discharge_ports]),\n        \"IsClean\": '{}'.format(is_clean),\n        \"Date\": date.isoformat()\n    }\n\n    vessel_classes_param = '&amp;VesselClasses='.join(vessel_classes)\n    query_dict['VesselClasses'] = vessel_classes_param\n\n    query_string: QueryString = query_dict\n    response = self.__connection._make_get_request(\n        \"freight/api/Freight/v3/pricing\", query_string\n    )\n    response.raise_for_status()\n    response_json = response.json()\n    return_object = parse_freight_pricing(response_json)\n\n    return return_object\n</code></pre>"},{"location":"freight_rates/#signal_ocean.freight_rates.FreightRatesAPI.get_ports","title":"<code>get_ports(port_filter=None)</code>","text":"<p>Retrieves available ports.</p> <p>Parameters:</p> Name Type Description Default <code>port_filter</code> <code>Optional[PortFilter]</code> <p>A filter used to find specific ports. If not specified, returns all available ports.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Port, ...]</code> <p>A tuple of available ports that match the filter.</p> Source code in <code>signal_ocean/freight_rates/freight_rates_api.py</code> <pre><code>def get_ports(\n    self, port_filter: Optional[PortFilter] = None\n) -&gt; Tuple[Port, ...]:\n    \"\"\"Retrieves available ports.\n\n    Args:\n        port_filter: A filter used to find specific ports. If not\n            specified, returns all available ports.\n\n    Returns:\n        A tuple of available ports that match the filter.\n    \"\"\"\n    query_dict = {\n        \"date\": date.today().isoformat()\n    }\n\n    query_string: QueryString = query_dict\n\n    available_ports: List[Port] = []\n    for vessel_class in VesselClass:\n        response = self.__connection._make_get_request(\n            f\"freight/api/Freight/v2/pricing/\"\n            f\"availablePorts/{vessel_class.name}\",\n            query_string\n        )\n        response.raise_for_status()\n        response_json = response.json()\n        available_ports += parse_ports(response_json)\n\n    port_filter = port_filter or PortFilter()\n\n    return tuple(port_filter._apply(available_ports))\n</code></pre>"},{"location":"freight_rates/#signal_ocean.freight_rates.FreightRatesAPI.get_vessel_classes","title":"<code>get_vessel_classes()</code>  <code>staticmethod</code>","text":"<p>Retrieves all available vessel classes.</p> <p>Returns:</p> Type Description <code>Tuple[str, ...]</code> <p>A tuple of all available vessel classes.</p> Source code in <code>signal_ocean/freight_rates/freight_rates_api.py</code> <pre><code>@staticmethod\ndef get_vessel_classes() -&gt; Tuple[str, ...]:\n    \"\"\"Retrieves all available vessel classes.\n\n    Returns:\n        A tuple of all available vessel classes.\n    \"\"\"\n    vessel_classes = tuple(vessel_class.name\n                           for vessel_class in VesselClass)\n    return vessel_classes\n</code></pre>"},{"location":"freight_rates/#signal_ocean.freight_rates.Port","title":"<code>Port</code>  <code>dataclass</code>","text":"<p>A maritime facility where vessels can dock.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[int]</code> <p>ID of the port.</p> <code>name</code> <code>str</code> <p>Name of the port.</p> <code>country</code> <code>Optional[str]</code> <p>Country of the port.</p> <code>area</code> <code>Optional[str]</code> <p>Area of the port.</p> Source code in <code>signal_ocean/freight_rates/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Port:\n    \"\"\"A maritime facility where vessels can dock.\n\n    Attributes:\n        id: ID of the port.\n        name: Name of the port.\n        country: Country of the port.\n        area: Area of the port.\n    \"\"\"\n\n    name: str\n    id: Optional[int] = None\n    country: Optional[str] = None\n    area: Optional[str] = None\n</code></pre>"},{"location":"freight_rates/#signal_ocean.freight_rates.PortFilter","title":"<code>PortFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific ports.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find ports by name. When specified, ports whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/freight_rates/port_filter.py</code> <pre><code>@dataclass(eq=False)\nclass PortFilter:\n    \"\"\"A filter used to find specific ports.\n\n    Attributes:\n        name_like: Used to find ports by name. When specified, ports whose\n            names partially match (contain) the attribute's value will be\n            returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(self, ports: Iterable[Port]) -&gt; \\\n            Iterable[Port]:\n        return filter(self.__does_port_match, ports)\n\n    def __does_port_match(self, port: Port) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, port.name\n        )\n</code></pre>"},{"location":"geos/","title":"Package Documentation","text":"<p>Geos API Package.</p> <p>Classes:</p> Name Description <code>GeosAPI</code> <p>Represents Signal's Geos API.</p>"},{"location":"geos/#signal_ocean.geos.GeosAPI","title":"<code>GeosAPI</code>","text":"<p>Represents Signal's Geos API.</p> Source code in <code>signal_ocean/geos/geos_api.py</code> <pre><code>class GeosAPI:\n    \"\"\"Represents Signal's Geos API.\"\"\"\n\n    relative_url = \"geos-api/v2/\"\n    default_pit = str(date.today())\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes GeosAPI.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_areas(self, areaId: Optional[int] = None) -&gt; Tuple[Area, ...]:\n        \"\"\"Retrieves all available areas.\n\n        Args:\n            areaId: area identifier to filter and return only a\n                specific area.\n\n        Returns:\n            A tuple of all available areas.\n        \"\"\"\n        endpoint = (\n            \"areas/all\" if areaId is None else f\"areas/{areaId}\"\n        )\n\n        url = urljoin(GeosAPI.relative_url, endpoint)\n        response = get_single(self.__connection, url, AreasPagedResponse)\n\n        if response is not None and response.data is not None:\n            return response.data\n        else:\n            return tuple([])\n\n    def get_geoAssets(\n        self,\n        geoAssetId: Optional[int] = None\n    ) -&gt; Tuple[GeoAsset, ...]:\n        \"\"\"Retrieves all available geo assets.\n\n        Args:\n            geoAssetId: geo asset identifier to filter and return only a\n                specific geo asset.\n\n        Returns:\n            A tuple of all available geo asset.\n        \"\"\"\n        endpoint = (\n            \"geoAssets/all\" if geoAssetId is None\n            else f\"geoAssets/{geoAssetId}\"\n        )\n        rename_keys = {\n            \"AreaIDLevel0\": \"area_id_level0\",\n            \"AreaIDLevel1\": \"area_id_level1\",\n            \"AreaIDLevel2\": \"area_id_level2\",\n            \"AreaIDLevel3\": \"area_id_level3\",\n            \"CountryCodeISO3\": \"country_code_iso3\"}\n        url = urljoin(GeosAPI.relative_url, endpoint)\n        response = get_single(\n            self.__connection,\n            url,\n            GeoAssetsPagedResponse,\n            rename_keys=rename_keys)\n        if response is not None and response.data is not None:\n            return response.data\n        else:\n            return tuple([])\n\n    def get_countries(\n        self,\n        countryId: Optional[int] = None\n    ) -&gt; Tuple[Country, ...]:\n        \"\"\"Retrieves all available countries.\n\n        Args:\n            countryId: country identifier to filter and return only a\n                specific country.\n\n        Returns:\n            A tuple of all available countries.\n        \"\"\"\n        endpoint = (\n            \"countries/all\" if countryId is None else f\"countries/{countryId}\"\n        )\n        url = urljoin(GeosAPI.relative_url, endpoint)\n        response = get_single(self.__connection, url, CountriesPagedResponse)\n        if response is not None and response.data is not None:\n            return response.data\n        else:\n            return tuple([])\n\n    def get_ports(self, portId: Optional[int] = None) -&gt; Tuple[Port, ...]:\n        \"\"\"Retrieves all available ports.\n\n        Args:\n            portId: port identifier to filter and return only a\n                specific port.\n\n        Returns:\n            A tuple of all available ports.\n        \"\"\"\n        endpoint = (\n            \"ports/all\" if portId is None else f\"ports/{portId}\"\n        )\n        rename_keys = {\n            \"AreaIDLevel0\": \"area_id_level0\",\n            \"AreaIDLevel1\": \"area_id_level1\",\n            \"AreaIDLevel2\": \"area_id_level2\",\n            \"AreaIDLevel3\": \"area_id_level3\"}\n        url = urljoin(GeosAPI.relative_url, endpoint)\n        response = get_single(\n            self.__connection,\n            url,\n            PortsPagedResponse,\n            rename_keys=rename_keys)\n        if response is not None and response.data is not None:\n            return response.data\n        else:\n            return tuple([])\n</code></pre>"},{"location":"geos/#signal_ocean.geos.GeosAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes GeosAPI.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/geos/geos_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes GeosAPI.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"geos/#signal_ocean.geos.GeosAPI.get_areas","title":"<code>get_areas(areaId=None)</code>","text":"<p>Retrieves all available areas.</p> <p>Parameters:</p> Name Type Description Default <code>areaId</code> <code>Optional[int]</code> <p>area identifier to filter and return only a specific area.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Area, ...]</code> <p>A tuple of all available areas.</p> Source code in <code>signal_ocean/geos/geos_api.py</code> <pre><code>def get_areas(self, areaId: Optional[int] = None) -&gt; Tuple[Area, ...]:\n    \"\"\"Retrieves all available areas.\n\n    Args:\n        areaId: area identifier to filter and return only a\n            specific area.\n\n    Returns:\n        A tuple of all available areas.\n    \"\"\"\n    endpoint = (\n        \"areas/all\" if areaId is None else f\"areas/{areaId}\"\n    )\n\n    url = urljoin(GeosAPI.relative_url, endpoint)\n    response = get_single(self.__connection, url, AreasPagedResponse)\n\n    if response is not None and response.data is not None:\n        return response.data\n    else:\n        return tuple([])\n</code></pre>"},{"location":"geos/#signal_ocean.geos.GeosAPI.get_countries","title":"<code>get_countries(countryId=None)</code>","text":"<p>Retrieves all available countries.</p> <p>Parameters:</p> Name Type Description Default <code>countryId</code> <code>Optional[int]</code> <p>country identifier to filter and return only a specific country.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Country, ...]</code> <p>A tuple of all available countries.</p> Source code in <code>signal_ocean/geos/geos_api.py</code> <pre><code>def get_countries(\n    self,\n    countryId: Optional[int] = None\n) -&gt; Tuple[Country, ...]:\n    \"\"\"Retrieves all available countries.\n\n    Args:\n        countryId: country identifier to filter and return only a\n            specific country.\n\n    Returns:\n        A tuple of all available countries.\n    \"\"\"\n    endpoint = (\n        \"countries/all\" if countryId is None else f\"countries/{countryId}\"\n    )\n    url = urljoin(GeosAPI.relative_url, endpoint)\n    response = get_single(self.__connection, url, CountriesPagedResponse)\n    if response is not None and response.data is not None:\n        return response.data\n    else:\n        return tuple([])\n</code></pre>"},{"location":"geos/#signal_ocean.geos.GeosAPI.get_geoAssets","title":"<code>get_geoAssets(geoAssetId=None)</code>","text":"<p>Retrieves all available geo assets.</p> <p>Parameters:</p> Name Type Description Default <code>geoAssetId</code> <code>Optional[int]</code> <p>geo asset identifier to filter and return only a specific geo asset.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[GeoAsset, ...]</code> <p>A tuple of all available geo asset.</p> Source code in <code>signal_ocean/geos/geos_api.py</code> <pre><code>def get_geoAssets(\n    self,\n    geoAssetId: Optional[int] = None\n) -&gt; Tuple[GeoAsset, ...]:\n    \"\"\"Retrieves all available geo assets.\n\n    Args:\n        geoAssetId: geo asset identifier to filter and return only a\n            specific geo asset.\n\n    Returns:\n        A tuple of all available geo asset.\n    \"\"\"\n    endpoint = (\n        \"geoAssets/all\" if geoAssetId is None\n        else f\"geoAssets/{geoAssetId}\"\n    )\n    rename_keys = {\n        \"AreaIDLevel0\": \"area_id_level0\",\n        \"AreaIDLevel1\": \"area_id_level1\",\n        \"AreaIDLevel2\": \"area_id_level2\",\n        \"AreaIDLevel3\": \"area_id_level3\",\n        \"CountryCodeISO3\": \"country_code_iso3\"}\n    url = urljoin(GeosAPI.relative_url, endpoint)\n    response = get_single(\n        self.__connection,\n        url,\n        GeoAssetsPagedResponse,\n        rename_keys=rename_keys)\n    if response is not None and response.data is not None:\n        return response.data\n    else:\n        return tuple([])\n</code></pre>"},{"location":"geos/#signal_ocean.geos.GeosAPI.get_ports","title":"<code>get_ports(portId=None)</code>","text":"<p>Retrieves all available ports.</p> <p>Parameters:</p> Name Type Description Default <code>portId</code> <code>Optional[int]</code> <p>port identifier to filter and return only a specific port.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Port, ...]</code> <p>A tuple of all available ports.</p> Source code in <code>signal_ocean/geos/geos_api.py</code> <pre><code>def get_ports(self, portId: Optional[int] = None) -&gt; Tuple[Port, ...]:\n    \"\"\"Retrieves all available ports.\n\n    Args:\n        portId: port identifier to filter and return only a\n            specific port.\n\n    Returns:\n        A tuple of all available ports.\n    \"\"\"\n    endpoint = (\n        \"ports/all\" if portId is None else f\"ports/{portId}\"\n    )\n    rename_keys = {\n        \"AreaIDLevel0\": \"area_id_level0\",\n        \"AreaIDLevel1\": \"area_id_level1\",\n        \"AreaIDLevel2\": \"area_id_level2\",\n        \"AreaIDLevel3\": \"area_id_level3\"}\n    url = urljoin(GeosAPI.relative_url, endpoint)\n    response = get_single(\n        self.__connection,\n        url,\n        PortsPagedResponse,\n        rename_keys=rename_keys)\n    if response is not None and response.data is not None:\n        return response.data\n    else:\n        return tuple([])\n</code></pre>"},{"location":"historical_tonnage_list/","title":"Package Documentation","text":"<p>\u26a0 Deprecation Warning</p> <p>This package is deprecated and will be removed in a future version of the SDK. Please use the tonnage_list package instead.</p> <p>Historical Tonnage List API Package.</p> <p>Classes:</p> Name Description <code>HistoricalTonnageListAPI</code> <p>Represents Signal's Historical Tonnage List API.</p> <code>HistoricalTonnageList</code> <p>Result of a Historical Tonnage List query.</p> <code>TonnageList</code> <p>A singular tonnage list in HistoricalTonnageList.</p> <code>Vessel</code> <p>A vessel contained in a TonnageList.</p> <code>VesselFilter</code> <p>Used for filtering vessels in queries.</p> <code>PushType</code> <p>Contains constants for available push types.</p> <code>MarketDeployment</code> <p>Contains constants for available market deployments.</p> <code>CommercialStatus</code> <p>Contains constants for available commercial statuses.</p> <code>VesseSubclass</code> <p>Contains constants for available vessel subclasses.</p> <code>LocationTaxonomy</code> <p>Contains constants for available location taxonomies.</p> <code>Area</code> <p>A geographical area.</p> <code>Column</code> <p>Contains constants for available data frame column names.</p> <code>IndexLevel</code> <p>Contains constants for available data frame index levels.</p> <code>OperationalStatus</code> <p>Contains constants for available operational statuses.</p> <code>FixtureType</code> <p>Contains constants for available fixture types.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.Area","title":"<code>Area</code>  <code>dataclass</code>","text":"<p>A geographical area.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The area name.</p> <code>location_taxonomy</code> <code>str</code> <p>The area's location taxonomy. See the LocationTaxonomy class for available values.</p> Source code in <code>signal_ocean/historical_tonnage_list/area.py</code> <pre><code>@dataclass(frozen=True)\nclass Area:\n    \"\"\"A geographical area.\n\n    Attributes:\n        name: The area name.\n        location_taxonomy: The area's location taxonomy. See the\n            LocationTaxonomy class for available values.\n    \"\"\"\n    name: str\n    location_taxonomy: str\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.Column","title":"<code>Column</code>","text":"<p>Contains constants for data frame column names.</p> Source code in <code>signal_ocean/historical_tonnage_list/column.py</code> <pre><code>class Column(metaclass=IterableConstants):\n    \"\"\"Contains constants for data frame column names.\"\"\"\n\n    NAME = \"name\"\n    VESSEL_CLASS = _category(\"vessel_class\")\n    ICE_CLASS = _category(\"ice_class\")\n    YEAR_BUILT = \"year_built\"\n    DEADWEIGHT = \"deadweight\"\n    LENGTH_OVERALL = \"length_overall\"\n    BREADTH_EXTREME = \"breadth_extreme\"\n    SUBCLASS = _category(\"subclass\")\n    MARKET_DEPLOYMENT = _category(_pit_col(\"market_deployment\"))\n    PUSH_TYPE = _category(_pit_col(\"push_type\"))\n    OPEN_PORT = _category(_pit_col(\"open_port\"))\n    OPEN_DATE = _pit_col(\"open_date\")\n    OPERATIONAL_STATUS = _category(_pit_col(\"operational_status\"))\n    COMMERCIAL_OPERATOR = _category(_pit_col(\"commercial_operator\"))\n    COMMERCIAL_STATUS = _category(_pit_col(\"commercial_status\"))\n    ETA = _pit_col(\"eta\")\n    LATEST_AIS = _pit_col(\"latest_ais\")\n    OPEN_PREDICTION_ACCURACY = _category(_pit_col(\"open_prediction_accuracy\"))\n    OPEN_COUNTRY = _category(_pit_col(\"open_country\"))\n    OPEN_NARROW_AREA = _category(_pit_col(\"open_narrow_area\"))\n    OPEN_WIDE_AREA = _category(_pit_col(\"open_wide_area\"))\n    AVAILABILITY_PORT_TYPE = _category(_pit_col(\"availability_port_type\"))\n    AVAILABILITY_DATE_TYPE = _category(_pit_col(\"availability_date_type\"))\n\n    @staticmethod\n    def _create_row(vessel: Vessel) -&gt; List[Any]:\n        return [\n            vessel.name,\n            vessel.vessel_class,\n            vessel.ice_class,\n            vessel.year_built,\n            vessel.deadweight,\n            vessel.length_overall,\n            vessel.breadth_extreme,\n            vessel.subclass,\n            vessel.market_deployment,\n            vessel.push_type,\n            vessel.open_port,\n            vessel.open_date,\n            vessel.operational_status,\n            vessel.commercial_operator,\n            vessel.commercial_status,\n            vessel.eta,\n            vessel.latest_ais,\n            vessel.open_prediction_accuracy,\n            vessel.open_country,\n            vessel.open_narrow_area,\n            vessel.open_wide_area,\n            vessel.availability_port_type,\n            vessel.availability_date_type\n        ]\n\n    @staticmethod\n    def _get_data_types() -&gt; Dict[str, str]:\n        return _data_types\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.CommercialStatus","title":"<code>CommercialStatus</code>","text":"<p>Contains constants for available commercial statuses.</p> Source code in <code>signal_ocean/historical_tonnage_list/commercial_status.py</code> <pre><code>class CommercialStatus(metaclass=IterableConstants):\n    \"\"\"Contains constants for available commercial statuses.\"\"\"\n    ON_SUBS = 'On Subs'\n    \"\"\"\n    Vessel is On Subs for a new Fixture.\n    \"\"\"\n    FAILED = 'Failed'\n    \"\"\"\n    Last fixture failed for this Vessel.\n    \"\"\"\n    CANCELLED = 'Cancelled'\n    \"\"\"\n    Last fixture cancelled for this Vessel.\n    \"\"\"\n    AVAILABLE = 'Available'\n    \"\"\"\n    Vessel is available for a new voyage after her open date.\n    \"\"\"\n    POTENTIALLY_FIXED = 'Poss Fixed'\n    \"\"\"\n    Systems assumes the vessel is fixed for her new voyage based\n        on AIS information\n    \"\"\"\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.CommercialStatus.AVAILABLE","title":"<code>AVAILABLE = 'Available'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is available for a new voyage after her open date.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.CommercialStatus.CANCELLED","title":"<code>CANCELLED = 'Cancelled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Last fixture cancelled for this Vessel.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.CommercialStatus.FAILED","title":"<code>FAILED = 'Failed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Last fixture failed for this Vessel.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.CommercialStatus.ON_SUBS","title":"<code>ON_SUBS = 'On Subs'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is On Subs for a new Fixture.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.CommercialStatus.POTENTIALLY_FIXED","title":"<code>POTENTIALLY_FIXED = 'Poss Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Systems assumes the vessel is fixed for her new voyage based     on AIS information</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.FixtureType","title":"<code>FixtureType</code>","text":"<p>Contains constants for available fixture types.</p> Source code in <code>signal_ocean/historical_tonnage_list/fixture_type.py</code> <pre><code>class FixtureType(metaclass=IterableConstants):\n    \"\"\"Contains constants for available fixture types.\"\"\"\n    SCRAPED = 'Scraped'\n    MANUAL = 'Manual'\n    IMPLIED = 'Implied'\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.HistoricalTonnageList","title":"<code>HistoricalTonnageList</code>","text":"<p>               Bases: <code>Sequence[TonnageList]</code></p> <p>The class that represents a Historical Tonnage List.</p> <p>A Historical Tonnage List consists from an collection of Tonnage Lists one for every day between the start and end date specified when querying the Historica Tonnage List API.</p> Source code in <code>signal_ocean/historical_tonnage_list/historical_tonnage_list.py</code> <pre><code>class HistoricalTonnageList(Sequence[TonnageList]):\n    \"\"\"The class that represents a Historical Tonnage List.\n\n    A Historical Tonnage List consists from an collection of Tonnage Lists\n    one for every day between the start and end date specified\n    when querying the Historica Tonnage List API.\n    \"\"\"\n\n    def __init__(self, tonnage_lists: Iterable[TonnageList]):\n        \"\"\"Initializes the Historical Tonnage List.\n\n        Args:\n            tonnage_lists: Tonnage Lists contained within the Historical\n                Tonnage List.\n        \"\"\"\n        self.__tonnage_lists = tuple(tonnage_lists)\n\n    @overload\n    def __getitem__(self, index: int) -&gt; TonnageList:  # noqa: D105\n        ...\n\n    @overload\n    def __getitem__(self, slice: slice) -&gt; Sequence[TonnageList]:  # noqa: D105\n        ...\n\n    def __getitem__(\n        self, i: Union[int, slice]\n    ) -&gt; Union[TonnageList, Sequence[TonnageList]]:  # noqa: D105\n        return self.__tonnage_lists.__getitem__(i)\n\n    def __len__(self) -&gt; int:  # noqa: D105\n        return self.__tonnage_lists.__len__()\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        class_name = self.__class__.__name__\n        return f\"{class_name}(tonnage_lists={self.__tonnage_lists!r})\"\n\n    def to_data_frame(self) -&gt; pd.DataFrame:\n        \"\"\"Converts the Historical Tonnage List to a pandas data frame.\"\"\"\n        index_tuples = []\n        data = []\n        for tonnage_list in self.__tonnage_lists:\n            for vessel in tonnage_list.vessels:\n                index_tuples.append((tonnage_list.date, vessel.imo))\n                data.append(Column._create_row(vessel))\n\n        data_frame = pd.DataFrame(\n            data,\n            index=pd.MultiIndex.from_tuples(\n                index_tuples, names=[IndexLevel.DATE, IndexLevel.IMO]\n            ),\n            columns=list(Column),\n        )\n\n        return data_frame.astype(Column._get_data_types())  # type: ignore\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.HistoricalTonnageList.__init__","title":"<code>__init__(tonnage_lists)</code>","text":"<p>Initializes the Historical Tonnage List.</p> <p>Parameters:</p> Name Type Description Default <code>tonnage_lists</code> <code>Iterable[TonnageList]</code> <p>Tonnage Lists contained within the Historical Tonnage List.</p> required Source code in <code>signal_ocean/historical_tonnage_list/historical_tonnage_list.py</code> <pre><code>def __init__(self, tonnage_lists: Iterable[TonnageList]):\n    \"\"\"Initializes the Historical Tonnage List.\n\n    Args:\n        tonnage_lists: Tonnage Lists contained within the Historical\n            Tonnage List.\n    \"\"\"\n    self.__tonnage_lists = tuple(tonnage_lists)\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.HistoricalTonnageList.to_data_frame","title":"<code>to_data_frame()</code>","text":"<p>Converts the Historical Tonnage List to a pandas data frame.</p> Source code in <code>signal_ocean/historical_tonnage_list/historical_tonnage_list.py</code> <pre><code>def to_data_frame(self) -&gt; pd.DataFrame:\n    \"\"\"Converts the Historical Tonnage List to a pandas data frame.\"\"\"\n    index_tuples = []\n    data = []\n    for tonnage_list in self.__tonnage_lists:\n        for vessel in tonnage_list.vessels:\n            index_tuples.append((tonnage_list.date, vessel.imo))\n            data.append(Column._create_row(vessel))\n\n    data_frame = pd.DataFrame(\n        data,\n        index=pd.MultiIndex.from_tuples(\n            index_tuples, names=[IndexLevel.DATE, IndexLevel.IMO]\n        ),\n        columns=list(Column),\n    )\n\n    return data_frame.astype(Column._get_data_types())  # type: ignore\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.HistoricalTonnageListAPI","title":"<code>HistoricalTonnageListAPI</code>","text":"<p>Handles communications with  Signal's Historical Tonnage List API.</p> Source code in <code>signal_ocean/historical_tonnage_list/historical_tonnage_list_api.py</code> <pre><code>class HistoricalTonnageListAPI:\n    \"\"\"Handles communications with  Signal's Historical Tonnage List API.\"\"\"\n\n    __MAX_DATE_RANGE_DAYS = 365\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes HistoricalTonnageListAPI.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_historical_tonnage_list(\n        self,\n        loading_port: Port,\n        vessel_class: VesselClass,\n        laycan_end_in_days: Optional[int] = None,\n        start_date: Optional[date] = None,\n        end_date: Optional[date] = None,\n        time: Optional[time] = None,\n        vessel_filter: Optional[VesselFilter] = None,\n    ) -&gt; HistoricalTonnageList:\n        \"\"\"Retrieves a Historical Tonnage List.\n\n        If no input dates are provided, the last 10 days will be fetched\n        (including today).\n\n        To get a tonnage list for a specific day, set both date parameters to\n        the desired date.\n\n        Args:\n            loading_port: The loading port from which ETA will be calculated.\n            vessel_class: The vessel class to calculate the tonnage lists.\n            laycan_end_in_days: The maximum ETA expressed as a number of days\n                after the end date.\n            start_date: The date of the earliest tonnage list in the response.\n            end_date: The date of the latest tonnage list in the response.\n            time: Specifies the UTC time of day for which the state of\n                the tonnage lists will be retrieved.\n                It can get the values 00, 06, 12, 18.\n            vessel_filter: A filter defining which vessels should be included\n                in the response see Vessel Filter class for more details.\n\n        Returns:\n            Given a time-range, returns a Historical Tonnage List containing a\n            Tonnage List for every day between the start and end dates, at the\n            requested time of day.\n        \"\"\"\n        all_tonnage_lists: List[TonnageList] = []\n        date_ranges = _DateRange(start_date, end_date).split(\n            HistoricalTonnageListAPI.__MAX_DATE_RANGE_DAYS\n        )\n\n        for date_range in date_ranges:\n            tonnage_lists = self._get_htl_chunk(\n                loading_port,\n                vessel_class,\n                date_range,\n                laycan_end_in_days,\n                time,\n                vessel_filter,\n            )\n            all_tonnage_lists.extend(tonnage_lists)\n\n        return HistoricalTonnageList(all_tonnage_lists)\n\n    def _get_htl_chunk(\n        self,\n        loading_port: Port,\n        vessel_class: VesselClass,\n        date_range: _DateRange,\n        laycan_end_in_days: Optional[int] = None,\n        time: Optional[time] = None,\n        vessel_filter: Optional[VesselFilter] = None,\n    ) -&gt; Iterable[TonnageList]:\n        query_string: QueryString = {\n            \"loadingPort\": loading_port.id,\n            \"vesselClass\": vessel_class.id,\n            \"laycanEndInDays\": laycan_end_in_days,\n            \"startDate\": format_iso_date(date_range.start),\n            \"endDate\": format_iso_date(date_range.end),\n            \"time\": time.strftime(\"%H:%M\") if time else None,\n            **(vessel_filter._to_query_string() if vessel_filter else {}),\n        }\n\n        response = self.__connection._make_get_request(\n            \"htl-api/historical-tonnage-list/\", query_string\n        )\n\n        response.raise_for_status()\n        return _historical_tonnage_list_json.parse_tonnage_lists(\n            response.json()\n        )\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.HistoricalTonnageListAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes HistoricalTonnageListAPI.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/historical_tonnage_list/historical_tonnage_list_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes HistoricalTonnageListAPI.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.HistoricalTonnageListAPI.get_historical_tonnage_list","title":"<code>get_historical_tonnage_list(loading_port, vessel_class, laycan_end_in_days=None, start_date=None, end_date=None, time=None, vessel_filter=None)</code>","text":"<p>Retrieves a Historical Tonnage List.</p> <p>If no input dates are provided, the last 10 days will be fetched (including today).</p> <p>To get a tonnage list for a specific day, set both date parameters to the desired date.</p> <p>Parameters:</p> Name Type Description Default <code>loading_port</code> <code>Port</code> <p>The loading port from which ETA will be calculated.</p> required <code>vessel_class</code> <code>VesselClass</code> <p>The vessel class to calculate the tonnage lists.</p> required <code>laycan_end_in_days</code> <code>Optional[int]</code> <p>The maximum ETA expressed as a number of days after the end date.</p> <code>None</code> <code>start_date</code> <code>Optional[date]</code> <p>The date of the earliest tonnage list in the response.</p> <code>None</code> <code>end_date</code> <code>Optional[date]</code> <p>The date of the latest tonnage list in the response.</p> <code>None</code> <code>time</code> <code>Optional[time]</code> <p>Specifies the UTC time of day for which the state of the tonnage lists will be retrieved. It can get the values 00, 06, 12, 18.</p> <code>None</code> <code>vessel_filter</code> <code>Optional[VesselFilter]</code> <p>A filter defining which vessels should be included in the response see Vessel Filter class for more details.</p> <code>None</code> <p>Returns:</p> Type Description <code>HistoricalTonnageList</code> <p>Given a time-range, returns a Historical Tonnage List containing a</p> <code>HistoricalTonnageList</code> <p>Tonnage List for every day between the start and end dates, at the</p> <code>HistoricalTonnageList</code> <p>requested time of day.</p> Source code in <code>signal_ocean/historical_tonnage_list/historical_tonnage_list_api.py</code> <pre><code>def get_historical_tonnage_list(\n    self,\n    loading_port: Port,\n    vessel_class: VesselClass,\n    laycan_end_in_days: Optional[int] = None,\n    start_date: Optional[date] = None,\n    end_date: Optional[date] = None,\n    time: Optional[time] = None,\n    vessel_filter: Optional[VesselFilter] = None,\n) -&gt; HistoricalTonnageList:\n    \"\"\"Retrieves a Historical Tonnage List.\n\n    If no input dates are provided, the last 10 days will be fetched\n    (including today).\n\n    To get a tonnage list for a specific day, set both date parameters to\n    the desired date.\n\n    Args:\n        loading_port: The loading port from which ETA will be calculated.\n        vessel_class: The vessel class to calculate the tonnage lists.\n        laycan_end_in_days: The maximum ETA expressed as a number of days\n            after the end date.\n        start_date: The date of the earliest tonnage list in the response.\n        end_date: The date of the latest tonnage list in the response.\n        time: Specifies the UTC time of day for which the state of\n            the tonnage lists will be retrieved.\n            It can get the values 00, 06, 12, 18.\n        vessel_filter: A filter defining which vessels should be included\n            in the response see Vessel Filter class for more details.\n\n    Returns:\n        Given a time-range, returns a Historical Tonnage List containing a\n        Tonnage List for every day between the start and end dates, at the\n        requested time of day.\n    \"\"\"\n    all_tonnage_lists: List[TonnageList] = []\n    date_ranges = _DateRange(start_date, end_date).split(\n        HistoricalTonnageListAPI.__MAX_DATE_RANGE_DAYS\n    )\n\n    for date_range in date_ranges:\n        tonnage_lists = self._get_htl_chunk(\n            loading_port,\n            vessel_class,\n            date_range,\n            laycan_end_in_days,\n            time,\n            vessel_filter,\n        )\n        all_tonnage_lists.extend(tonnage_lists)\n\n    return HistoricalTonnageList(all_tonnage_lists)\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.IndexLevel","title":"<code>IndexLevel</code>","text":"<p>Contains constants for available data frame index levels.</p> Source code in <code>signal_ocean/historical_tonnage_list/index_level.py</code> <pre><code>class IndexLevel(metaclass=IterableConstants):\n    \"\"\"Contains constants for available data frame index levels.\"\"\"\n    DATE = 'date'\n    IMO = 'imo'\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.LocationTaxonomy","title":"<code>LocationTaxonomy</code>","text":"<p>Contains constants for available location taxonomies.</p> Source code in <code>signal_ocean/historical_tonnage_list/location_taxonomy.py</code> <pre><code>class LocationTaxonomy(metaclass=IterableConstants):\n    \"\"\"Contains constants for available location taxonomies.\"\"\"\n    PORT = 'Port'\n    \"\"\"\n    Location Taxonomy Port.\n    \"\"\"\n    COUNTRY = 'Country'\n    \"\"\"\n    Location Taxonomy Country.\n    \"\"\"\n    NARROW_AREA = 'Narrow Area'\n    \"\"\"\n    Location Taxonomy Narrow Area.\n    \"\"\"\n    WIDE_AREA = 'Wide Area'\n    \"\"\"\n    Location Taxonomy Wide Area.\n    \"\"\"\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.LocationTaxonomy.COUNTRY","title":"<code>COUNTRY = 'Country'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Location Taxonomy Country.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.LocationTaxonomy.NARROW_AREA","title":"<code>NARROW_AREA = 'Narrow Area'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Location Taxonomy Narrow Area.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.LocationTaxonomy.PORT","title":"<code>PORT = 'Port'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Location Taxonomy Port.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.LocationTaxonomy.WIDE_AREA","title":"<code>WIDE_AREA = 'Wide Area'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Location Taxonomy Wide Area.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.MarketDeployment","title":"<code>MarketDeployment</code>","text":"<p>Contains constants for available market deployments.</p> Source code in <code>signal_ocean/historical_tonnage_list/market_deployment.py</code> <pre><code>class MarketDeployment(metaclass=IterableConstants):\n    \"\"\"Contains constants for available market deployments.\"\"\"\n    SPOT = 'Spot'\n    '''\n    Vessels controlled by commercial operators that participate in the\n    spot market and are advertised through Tonnage lists and\n    get reported fixtures\n    '''\n    PROGRAM = 'Program'\n    '''\n    Vessels controlled by charterers like\n    that do not participate in the spot market and\n    are either not advertised through Tonnage lists or\n    Tonnage lists report the fact that they are program\n    '''\n    RELET = 'Relet'\n    '''\n    Vessels controlled by charterers that participate in the spot market\n    and are advertised through Tonnage lists and get reported fixtures\n    '''\n    CONTRACT = 'Contract'\n    '''\n    Vessels controlled by commercial operators that do not participate\n    in the spot market and are typically\n    doing system cargoes with repetitive trading patterns.\n    '''\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.MarketDeployment.CONTRACT","title":"<code>CONTRACT = 'Contract'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels controlled by commercial operators that do not participate in the spot market and are typically doing system cargoes with repetitive trading patterns.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.MarketDeployment.PROGRAM","title":"<code>PROGRAM = 'Program'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels controlled by charterers like that do not participate in the spot market and are either not advertised through Tonnage lists or Tonnage lists report the fact that they are program</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.MarketDeployment.RELET","title":"<code>RELET = 'Relet'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels controlled by charterers that participate in the spot market and are advertised through Tonnage lists and get reported fixtures</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.MarketDeployment.SPOT","title":"<code>SPOT = 'Spot'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels controlled by commercial operators that participate in the spot market and are advertised through Tonnage lists and get reported fixtures</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus","title":"<code>OperationalStatus</code>","text":"<p>Contains constants for available operational statuses.</p> Source code in <code>signal_ocean/historical_tonnage_list/operational_status.py</code> <pre><code>class OperationalStatus(metaclass=IterableConstants):\n    \"\"\"Contains constants for available operational statuses.\"\"\"\n    BALLAST_FIXED = \"Ballast Fixed\"\n    '''\n    Vessel is currently empty of cargo but fixed forward\n    '''\n    REPAIRS = \"Repairs\"\n    '''\n    Vessel is undergoing repairs or Drydock.\n    '''\n    WAITING_TO_LOAD = \"Waiting to Load\"\n    '''\n    Vessel is waiting to load\n    '''\n    LOADING = \"Loading\"\n    '''\n    Vessel is loading, i.e. it has entered a Jetty or is performing STS\n    '''\n    LADEN = \"Laden\"\n    '''\n    Vesel has loaded\n    '''\n    WAITING_TO_DISCHARGE = \"Waiting to Discharge\"\n    '''\n    Vessel is waiting to Discharge\n    '''\n    DISCHARGING = \"Discharging\"\n    '''\n    Vessel is discharging, i.e. it has entered a Jetty or is performing STS\n    '''\n    ACTIVE_STORAGE = \"Active Storage\"\n    '''\n    Vessel is in active storage.\n    This means it acts as storage for a\n    short term (compared to storage vessels).\n    '''\n    BALLAST_UNFIXED = \"Ballast Unfixed\"\n    '''\n    Vessel is currently free of cargo and not fixed (prompt)\n    '''\n    BALLAST_FIXED_IMPLIED = \"Ballast Fixed (implied)\"\n    '''\n    Vessel is currently free of cargo and her AIS destination implies a fixture\n    '''\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.ACTIVE_STORAGE","title":"<code>ACTIVE_STORAGE = 'Active Storage'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is in active storage. This means it acts as storage for a short term (compared to storage vessels).</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.BALLAST_FIXED","title":"<code>BALLAST_FIXED = 'Ballast Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is currently empty of cargo but fixed forward</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.BALLAST_FIXED_IMPLIED","title":"<code>BALLAST_FIXED_IMPLIED = 'Ballast Fixed (implied)'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is currently free of cargo and her AIS destination implies a fixture</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.BALLAST_UNFIXED","title":"<code>BALLAST_UNFIXED = 'Ballast Unfixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is currently free of cargo and not fixed (prompt)</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.DISCHARGING","title":"<code>DISCHARGING = 'Discharging'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is discharging, i.e. it has entered a Jetty or is performing STS</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.LADEN","title":"<code>LADEN = 'Laden'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vesel has loaded</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.LOADING","title":"<code>LOADING = 'Loading'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is loading, i.e. it has entered a Jetty or is performing STS</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.REPAIRS","title":"<code>REPAIRS = 'Repairs'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is undergoing repairs or Drydock.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.WAITING_TO_DISCHARGE","title":"<code>WAITING_TO_DISCHARGE = 'Waiting to Discharge'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is waiting to Discharge</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.OperationalStatus.WAITING_TO_LOAD","title":"<code>WAITING_TO_LOAD = 'Waiting to Load'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessel is waiting to load</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.PushType","title":"<code>PushType</code>","text":"<p>Contains constants for available push types.</p> Source code in <code>signal_ocean/historical_tonnage_list/push_type.py</code> <pre><code>class PushType(metaclass=IterableConstants):\n    \"\"\"Contains constants for available push types.\"\"\"\n    NOT_PUSHED = 'Not Pushed'\n    '''\n    vessels not pushed anymore\n    '''\n    PUSHED_POSS = 'Pushed POSS'\n    '''\n    Actively pushed in the market with notification Poss (Possibly)\n    meaning that this is a broker projection\n    '''\n    PUSHED = 'Pushed'\n    '''\n    Actively pushed in the market through Tonnage lists or Positions lists\n    '''\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.PushType.NOT_PUSHED","title":"<code>NOT_PUSHED = 'Not Pushed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>vessels not pushed anymore</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.PushType.PUSHED","title":"<code>PUSHED = 'Pushed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Actively pushed in the market through Tonnage lists or Positions lists</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.PushType.PUSHED_POSS","title":"<code>PUSHED_POSS = 'Pushed POSS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Actively pushed in the market with notification Poss (Possibly) meaning that this is a broker projection</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.TonnageList","title":"<code>TonnageList</code>  <code>dataclass</code>","text":"<p>A tonnage list as it occurred at a certain point in time.</p> <p>Attributes:</p> Name Type Description <code>date</code> <code>datetime</code> <p>The date and time at which the tonnage list was captured.</p> <code>vessels</code> <code>Tuple[Vessel, ...]</code> <p>Vessels present in the tonnage list at the point in time</p> Source code in <code>signal_ocean/historical_tonnage_list/tonnage_list.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass TonnageList:\n    \"\"\"A tonnage list as it occurred at a certain point in time.\n\n    Attributes:\n        date: The date and time at which the tonnage list was captured.\n        vessels: Vessels present in the tonnage list at the point in time\n        and their availability information. for more details see Vessel class.\n    \"\"\"\n    date: datetime\n    vessels: Tuple[Vessel, ...]\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.Vessel","title":"<code>Vessel</code>  <code>dataclass</code>","text":"<p>Holds information for a vessel that participates in a tonnage list.</p> <p>Contains both static vessel and point-in-time vessel data. All point in time data are annotated with the name _point_in_time when converted to data_frame, see column class for details</p> <p>Attributes:</p> Name Type Description <code>imo</code> <code>int</code> <p>The vessel's IMO number.</p> <code>name</code> <code>str</code> <p>The vessel's name.</p> <code>vessel_class</code> <code>str</code> <p>The vessel's class name.</p> <code>ice_class</code> <code>Optional[str]</code> <p>The vessel's ice class.</p> <code>year_built</code> <code>int</code> <p>The year the vessel has been built.</p> <code>deadweight</code> <code>int</code> <p>The vessel's deadweight.</p> <code>length_overall</code> <code>float</code> <p>The vessel's length overall.</p> <code>breadth_extreme</code> <code>int</code> <p>The vessel's breadth extreme.</p> <code>market_deployment</code> <code>str</code> <p>Market deployment of the vessel.  Point in time property.  See the MarketDeployment class for available values.</p> <code>push_type</code> <code>str</code> <p>Push type of the vessel. Point in time property. See the PushType class for available values.</p> <code>open_port</code> <code>str</code> <p>The vessel's open port name. Point in time property.</p> <code>open_date</code> <code>Optional[datetime]</code> <p>The vessel's open date. Point in time property.</p> <code>operational_status</code> <code>str</code> <p>Operational status of the vessel. Point in time property. See the OperationalStatus class for available values.</p> <code>commercial_operator</code> <code>str</code> <p>The vessel's commercial operator. Point in time property.</p> <code>commercial_status</code> <code>str</code> <p>Commercial status of the vessel. Point in time property. See the CommercialStatus class for available values.</p> <code>eta</code> <code>Optional[datetime]</code> <p>Estimated time of arrival. Point in time property.</p> <code>latest_ais</code> <code>Optional[datetime]</code> <p>Timestamp of the vessel's latest AIS information. Point in time property.</p> <code>subclass</code> <code>str</code> <p>The vessel's subclass. See the VesselSubclass class for available values.</p> <code>willing_to_switch_subclass</code> <code>bool</code> <p>Is the vessel willing to switch its subclass.</p> <code>open_prediction_accuracy</code> <code>str</code> <p>How accurate is the open prediction. Point in time property. i.e: if a source is specifying the port then prediction is given at port level. See the LocationTaxonomy class for available values.</p> <code>open_areas</code> <code>Tuple[Area, ...]</code> <p>A hierarchical collection of areas the vessel opens at used to filtering. Point in time property. i.e: if a vessel opens in Rotterdam you get as open areas \"openAreas\":[{\"id\":24758,\"label\":\"Continent\",\"taxonomy\":4}, {\"id\":25016,\"label\":\"UK Continent\",\"taxonomy\":5}, {\"id\":25025,\"label\":\"Mediterranean / UK Continent\",\"taxonomy\":6}, {\"id\":25028,\"label\":\"West\",\"taxonomy\":7}, {\"id\":173,\"label\":\"Netherlands\",\"taxonomy\":3}]</p> <code>availability_port_type</code> <code>str</code> <p>If it says source it means that there is hard evidence for the specific prediction of Port, if it says prediction it means the system is predicting based on the algorithm. Point in time property.</p> <code>availability_date_type</code> <code>str</code> <p>If it says source it means that there is hard evidence for the specific prediction of the Open date, if it says prediction it means the system is predicting based on the algorithm. Point in time property.</p> Source code in <code>signal_ocean/historical_tonnage_list/vessel.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass Vessel:\n    \"\"\"Holds information for a vessel that participates in a tonnage list.\n\n    Contains both static vessel and point-in-time vessel data.\n    All point in time data are annotated with the name _point_in_time\n    when converted to data_frame, see column class for details\n\n    Attributes:\n        imo: The vessel's IMO number.\n        name: The vessel's name.\n        vessel_class: The vessel's class name.\n        ice_class: The vessel's ice class.\n        year_built: The year the vessel has been built.\n        deadweight: The vessel's deadweight.\n        length_overall: The vessel's length overall.\n        breadth_extreme: The vessel's breadth extreme.\n        market_deployment: Market deployment of the vessel.\n             Point in time property.\n             See the MarketDeployment class for available values.\n        push_type: Push type of the vessel.\n            Point in time property.\n            See the PushType class for available values.\n        open_port: The vessel's open port name.\n            Point in time property.\n        open_date: The vessel's open date.\n            Point in time property.\n        operational_status: Operational status of the vessel.\n            Point in time property.\n            See the OperationalStatus class for available values.\n        commercial_operator: The vessel's commercial operator.\n            Point in time property.\n        commercial_status: Commercial status of the vessel.\n            Point in time property.\n            See the CommercialStatus class for available values.\n        eta: Estimated time of arrival.\n            Point in time property.\n        latest_ais: Timestamp of the vessel's latest AIS information.\n            Point in time property.\n        subclass: The vessel's subclass.\n            See the VesselSubclass class for available values.\n        willing_to_switch_subclass: Is the vessel willing\n            to switch its subclass.\n        open_prediction_accuracy: How accurate is the open prediction.\n            Point in time property. i.e: if a source is specifying the port\n            then prediction is given at port level.\n            See the LocationTaxonomy class for available values.\n        open_areas: A hierarchical collection of areas the vessel opens\n            at used to filtering.\n            Point in time property.\n            i.e: if a vessel opens in Rotterdam you get as open areas\n            \"openAreas\":[{\"id\":24758,\"label\":\"Continent\",\"taxonomy\":4},\n            {\"id\":25016,\"label\":\"UK Continent\",\"taxonomy\":5},\n            {\"id\":25025,\"label\":\"Mediterranean / UK Continent\",\"taxonomy\":6},\n            {\"id\":25028,\"label\":\"West\",\"taxonomy\":7},\n            {\"id\":173,\"label\":\"Netherlands\",\"taxonomy\":3}]\n        availability_port_type: If it says source it means that there is\n            hard evidence for the specific prediction of Port,\n            if it says prediction it means the system is predicting\n            based on the algorithm.\n            Point in time property.\n        availability_date_type: If it says source it means that there is\n            hard evidence for\n            the specific prediction of the Open date,\n            if it says prediction it means the system is\n            predicting based on the algorithm.\n            Point in time property.\n    \"\"\"\n\n    imo: int\n    name: str\n    vessel_class: str\n    ice_class: Optional[str]\n    year_built: int\n    deadweight: int\n    length_overall: float\n    breadth_extreme: int\n    market_deployment: str\n    push_type: str\n    open_port: str\n    open_date: Optional[datetime]\n    operational_status: str\n    commercial_operator: str\n    commercial_status: str\n    eta: Optional[datetime]\n    latest_ais: Optional[datetime]\n    subclass: str\n    willing_to_switch_subclass: bool\n    open_prediction_accuracy: str\n    open_areas: Tuple[Area, ...]\n    availability_port_type: str\n    availability_date_type: str\n\n    def __post_init__(self) -&gt; None:  # noqa: D105\n        if self.open_areas is None:\n            object.__setattr__(self, \"open_areas\", tuple())\n\n    @property\n    def open_country(self) -&gt; Optional[str]:\n        \"\"\"Returns the vessel's open country name.\n\n        Returns:\n            The name of the open country or None if an area with\n            LocationTaxonomy.COUNTRY was not present.\n        \"\"\"\n        return self.__area_name_by_taxonomy(LocationTaxonomy.COUNTRY)\n\n    @property\n    def open_narrow_area(self) -&gt; Optional[str]:\n        \"\"\"Returns the vessel's open narrow area name.\n\n        Returns:\n            The name of the open narrow area or None if an area with\n            LocationTaxonomy.NARROW_AREA was not present.\n        \"\"\"\n        return self.__area_name_by_taxonomy(LocationTaxonomy.NARROW_AREA)\n\n    @property\n    def open_wide_area(self) -&gt; Optional[str]:\n        \"\"\"Returns the vessel's open wide area name.\n\n        Returns:\n            The name of the open wide area or None if an area with\n            LocationTaxonomy.WIDE_AREA was not present.\n        \"\"\"\n        return self.__area_name_by_taxonomy(LocationTaxonomy.WIDE_AREA)\n\n    def __area_name_by_taxonomy(self, taxonomy: str) -&gt; Optional[str]:\n        for a in self.open_areas:\n            if a.location_taxonomy == taxonomy:\n                return a.name\n        return None\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.Vessel.open_country","title":"<code>open_country</code>  <code>property</code>","text":"<p>Returns the vessel's open country name.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The name of the open country or None if an area with</p> <code>Optional[str]</code> <p>LocationTaxonomy.COUNTRY was not present.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.Vessel.open_narrow_area","title":"<code>open_narrow_area</code>  <code>property</code>","text":"<p>Returns the vessel's open narrow area name.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The name of the open narrow area or None if an area with</p> <code>Optional[str]</code> <p>LocationTaxonomy.NARROW_AREA was not present.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.Vessel.open_wide_area","title":"<code>open_wide_area</code>  <code>property</code>","text":"<p>Returns the vessel's open wide area name.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The name of the open wide area or None if an area with</p> <code>Optional[str]</code> <p>LocationTaxonomy.WIDE_AREA was not present.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.VesselFilter","title":"<code>VesselFilter</code>  <code>dataclass</code>","text":"<p>Enables vessel filtering in a Historical Tonnage List query.</p> <p>All attributes in this class are optional, i.e. no filtering will be performed on attributes whose value is None.</p> <p>Attributes that accept a list of values are used to perform an OR comparison. In other words, when a non-empty list of values is used, the Historical Tonnage List will contain vessels that match on any of the specified values. Using an empty list will result in no filtering at all.</p> <p>VesselFilter is mutable in order to allow making adjustments to existing instances if query results are unsatisfactory.</p> <p>Attributes:</p> Name Type Description <code>push_types</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified push types. Use constants defined in the PushType class for the values of this attribute.</p> <code>market_deployments</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified market deployment types. Use constants defined in the MarketDeployment class for the values of this attribute.</p> <code>commercial_statuses</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified commercial statuses. Use constants defined in the CommercialStatus class for the values of this attribute.</p> <code>vessel_subclass</code> <code>Optional[str]</code> <p>Return vessels of the specified subclass. Use constants defined in the VesselSubclass class for the values of this attribute.</p> <code>add_willing_to_switch_subclass</code> <code>Optional[bool]</code> <p>When True, returns vessels that do not match the subclass but are willing to switch to it.</p> <code>latest_ais_since</code> <code>Optional[int]</code> <p>The maximum age, in days, of the vessel's AIS information at the time the tonnage list was captured.</p> <code>operational_statuses</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified operational statuses. Use constants defined in the OperationalStatus class for the values of this attribute.</p> <code>min_liquid_capacity</code> <code>Optional[int]</code> <p>The minimum liquid capacity, in cubic meters, the vessel should be able to hold.</p> <code>max_liquid_capacity</code> <code>Optional[int]</code> <p>The maximum liquid capacity, in cubic meters, the vessel should be able to hold.</p> <code>fixture_types</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified fixture types. Use constants defined in the FixtureType class for the values of this attribute.</p> <code>last_cargo_types</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified last cargo type IDs.</p> <code>past_port_visits</code> <code>Optional[List[int]]</code> <p>Return vessels with the specified past port visits.</p> <code>open_port_ids</code> <code>Optional[List[int]]</code> <p>Return vessels with the specified open port ids.</p> <code>canakkale_cancelling</code> <code>Optional[date]</code> <p>Return vessels with the specified Canakkale cancelling date.</p> <code>open_date</code> <code>Optional[date]</code> <p>Return vessels with the specified open date.</p> <code>ice_classes</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified ice classes.</p> <code>min_cranes_ton_capacity</code> <code>Optional[int]</code> <p>Return vessels with the specified minimum cranes ton capacity.</p> <code>max_cranes_ton_capacity</code> <code>Optional[int]</code> <p>Return vessels with the specified maximum cranes ton capacity.</p> <code>min_length_overall</code> <code>Optional[int]</code> <p>Return vessels with the specified minimum length overall.</p> <code>max_length_overall</code> <code>Optional[int]</code> <p>Return vessels with the specified maximum length overall.</p> <code>min_breadth_extreme</code> <code>Optional[int]</code> <p>Return vessels with the specified minimum breadth extreme.</p> <code>max_breadth_extreme</code> <code>Optional[int]</code> <p>Return vessels with the specified maximum breadth extreme.</p> <code>openAreas</code> <code>Optional[int]</code> <p>Return vessels with the specified open area ids.</p> <code>openCountries</code> <code>Optional[int]</code> <p>Return vessels with the specified open country ids.</p> Source code in <code>signal_ocean/historical_tonnage_list/vessel_filter.py</code> <pre><code>@dataclass(eq=False)\nclass VesselFilter:\n    \"\"\"Enables vessel filtering in a Historical Tonnage List query.\n\n    All attributes in this class are optional, i.e. no filtering will be\n    performed on attributes whose value is None.\n\n    Attributes that accept a list of values are used to perform an *OR*\n    comparison. In other words, when a non-empty list of values is used,\n    the Historical Tonnage List will contain vessels that match on **any**\n    of the specified values. Using an empty list will result in no filtering\n    at all.\n\n    VesselFilter is mutable in order to allow making adjustments to\n    existing instances if query results are unsatisfactory.\n\n    Attributes:\n        push_types: Return vessels with the specified push types.\n            Use constants defined in the PushType class for the values of\n            this attribute.\n        market_deployments: Return vessels with the specified market\n            deployment types. Use constants defined in the MarketDeployment\n            class for the values of this attribute.\n        commercial_statuses: Return vessels with the specified\n            commercial statuses. Use constants defined in the CommercialStatus\n            class for the values of this attribute.\n        vessel_subclass: Return vessels of the specified subclass.\n            Use constants defined in the VesselSubclass class for the values\n            of this attribute.\n        add_willing_to_switch_subclass: When True, returns vessels\n            that do not match the subclass but are willing to switch to it.\n        latest_ais_since: The maximum age, in days, of the vessel's\n            AIS information at the time the tonnage list was captured.\n        operational_statuses: Return vessels with the specified\n            operational statuses. Use constants defined in the\n            OperationalStatus class for the values of this attribute.\n        min_liquid_capacity: The minimum liquid capacity, in cubic\n            meters, the vessel should be able to hold.\n        max_liquid_capacity: The maximum liquid capacity, in cubic\n            meters, the vessel should be able to hold.\n        fixture_types: Return vessels with the specified\n            fixture types. Use constants defined in the FixtureType class for\n            the values of this attribute.\n        last_cargo_types: Return vessels with the specified last\n            cargo type IDs.\n        past_port_visits: Return vessels with the specified past\n            port visits.\n        open_port_ids: Return vessels with the specified open\n            port ids.\n        canakkale_cancelling: Return vessels with the specified\n            Canakkale cancelling date.\n        open_date: Return vessels with the specified open date.\n        ice_classes: Return vessels with the specified ice classes.\n        min_cranes_ton_capacity: Return vessels with the specified\n            minimum cranes ton capacity.\n        max_cranes_ton_capacity: Return vessels with the specified\n            maximum cranes ton capacity.\n        min_length_overall: Return vessels with the specified\n            minimum length overall.\n        max_length_overall: Return vessels with the specified\n            maximum length overall.\n        min_breadth_extreme: Return vessels with the specified\n            minimum breadth extreme.\n        max_breadth_extreme: Return vessels with the specified\n            maximum breadth extreme.\n        openAreas: Return vessels with the specified open area ids.\n        openCountries: Return vessels with the specified open\n            country ids.\n    \"\"\"\n\n    push_types: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    market_deployments: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    commercial_statuses: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    vessel_subclass: Optional[str] = VesselSubclass.ALL\n    add_willing_to_switch_subclass: Optional[bool] = False\n    latest_ais_since: Optional[int] = None\n    operational_statuses: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    min_liquid_capacity: Optional[int] = None\n    max_liquid_capacity: Optional[int] = None\n    fixture_types: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    past_port_visits: Optional[List[int]] = cast(\n        List[int], field(default_factory=list)\n    )\n    open_port_ids: Optional[List[int]] = cast(\n        List[int], field(default_factory=list)\n    )\n    canakkale_cancelling: Optional[date] = None\n    open_date: Optional[date] = None\n    ice_classes: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    min_cranes_ton_capacity: Optional[int] = None\n    max_cranes_ton_capacity: Optional[int] = None\n    min_length_overall: Optional[int] = None\n    max_length_overall: Optional[int] = None\n    min_breadth_extreme: Optional[int] = None\n    max_breadth_extreme: Optional[int] = None\n    open_area_ids: Optional[List[int]] = cast(\n        List[int], field(default_factory=list)\n    )\n    open_country_ids: Optional[List[int]] = cast(\n        List[int], field(default_factory=list)\n    )\n\n    def _to_query_string(self) -&gt; QueryString:\n        return {\n            \"pushType\": self.push_types,\n            \"commercialStatus\": self.commercial_statuses,\n            \"latestAisSince\": self.latest_ais_since,\n            \"vesselSubclass\": self.vessel_subclass,\n            \"addWillingToSwitchSubclass\": self.add_willing_to_switch_subclass,\n            \"marketDeployment\": self.market_deployments,\n            \"operationalStatus\": self.operational_statuses,\n            \"minLiquidCapacity\": self.min_liquid_capacity,\n            \"maxLiquidCapacity\": self.max_liquid_capacity,\n            \"fixtureType\": self.fixture_types,\n            \"pastPortVisit\": self.past_port_visits,\n            \"openPortId\": self.open_port_ids,\n            \"canakkaleCancelling\": format_iso_date(self.canakkale_cancelling),\n            \"openDate\": format_iso_date(self.open_date),\n            \"iceClass\": self.ice_classes,\n            \"cranesTonCapacityMin\": self.min_cranes_ton_capacity,\n            \"cranesTonCapacityMax\": self.max_cranes_ton_capacity,\n            \"lengthOverallMin\": self.min_length_overall,\n            \"lengthOverallMax\": self.max_length_overall,\n            \"breadthExtremeMin\": self.min_breadth_extreme,\n            \"breadthExtremeMax\": self.max_breadth_extreme,\n            \"openArea\": self.open_area_ids,\n            \"openCountry\": self.open_country_ids\n        }\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.VesselSubclass","title":"<code>VesselSubclass</code>","text":"<p>Contains constants for available vessel subclasses.</p> Source code in <code>signal_ocean/historical_tonnage_list/vessel_subclass.py</code> <pre><code>class VesselSubclass(metaclass=IterableConstants):\n    \"\"\"Contains constants for available vessel subclasses.\"\"\"\n\n    ALL = None\n    '''\n    Refers to all the vessels without any classification regarding\n    the cargo type that they are carrying.\n    '''\n    DIRTY = 'Dirty'\n    '''\n    Refers to all the vessels that they classify\n        to the dirty types of oil cargo.\n    Applicable only for Tankers.\n    '''\n    CLEAN = 'Clean'\n    '''\n    Refers to all the vessels that they classify\n        to the clean types of oil cargo.\n    Applicable only for Tankers.\n    '''\n</code></pre>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.VesselSubclass.ALL","title":"<code>ALL = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Refers to all the vessels without any classification regarding the cargo type that they are carrying.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.VesselSubclass.CLEAN","title":"<code>CLEAN = 'Clean'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Refers to all the vessels that they classify     to the clean types of oil cargo. Applicable only for Tankers.</p>"},{"location":"historical_tonnage_list/#signal_ocean.historical_tonnage_list.VesselSubclass.DIRTY","title":"<code>DIRTY = 'Dirty'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Refers to all the vessels that they classify     to the dirty types of oil cargo. Applicable only for Tankers.</p>"},{"location":"market_rates/","title":"Market Rates","text":"<p>Market Rates API Package.</p> <p>Classes:</p> Name Description <code>MarketRatesAPI</code> <p>Represents Signal's Market Rates API.</p> <code>MarketRate</code> <p>The market rate of a certain route or vessel class.</p> <code>Route</code> <p>A route with available market rate.</p> <code>VesselClass</code> <p>A vessel class.</p> <code>CargoId</code> <p>The cargo ID, Dirty (0), Clean(1) or IMO (2).</p>"},{"location":"market_rates/#signal_ocean.market_rates.CargoId","title":"<code>CargoId</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration of all possible cargo ids.</p> Source code in <code>signal_ocean/market_rates/enums.py</code> <pre><code>@unique\nclass CargoId(Enum):\n    \"\"\"An enumeration of all possible cargo ids.\"\"\"\n    DIRTY = 0\n    CLEAN = 1\n    IMO = 2\n</code></pre>"},{"location":"market_rates/#signal_ocean.market_rates.MarketRate","title":"<code>MarketRate</code>  <code>dataclass</code>","text":"<p>The market rate of a certain route or vessel class.</p> <p>Attributes:</p> Name Type Description <code>route_id</code> <code>str</code> <p>ID of the route.</p> <code>rate_date</code> <code>datetime</code> <p>Date of the rate.</p> <code>rate_value</code> <code>float</code> <p>Value of the rate.</p> <code>unit</code> <code>str</code> <p>Unit of the rate.</p> <code>vessel_class_id</code> <code>int</code> <p>ID of the vessel class.</p> <code>deprecated_to</code> <code>Optional[str]</code> <p>Route ID if route is deprecated.</p> Source code in <code>signal_ocean/market_rates/models.py</code> <pre><code>@dataclass(frozen=True)\nclass MarketRate:\n    \"\"\"The market rate of a certain route or vessel class.\n\n    Attributes:\n        route_id: ID of the route.\n        rate_date: Date of the rate.\n        rate_value: Value of the rate.\n        unit: Unit of the rate.\n        vessel_class_id: ID of the vessel class.\n        deprecated_to: Route ID if route is deprecated.\n    \"\"\"\n\n    route_id: str\n    rate_date: datetime\n    rate_value: float\n    unit: str\n    vessel_class_id: int\n    deprecated_to: Optional[str] = None\n</code></pre>"},{"location":"market_rates/#signal_ocean.market_rates.MarketRatesAPI","title":"<code>MarketRatesAPI</code>","text":"<p>Represents Signal's Market Rates API.</p> Source code in <code>signal_ocean/market_rates/market_rates_api.py</code> <pre><code>class MarketRatesAPI:\n    \"\"\"Represents Signal's Market Rates API.\"\"\"\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes the Market Rates API.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_market_rates(\n        self, start_date: date, route_id: Optional[str] = None,\n            vessel_class_id: Optional[int] = None,\n            end_date: Optional[date] = None,\n            cargo_id: Optional[CargoId] = None\n    ) -&gt; Tuple[MarketRate, ...]:\n        \"\"\"Provides market rates for given day/period and route/vessel class.\n\n        Args:\n            start_date: Start date of market rates. If end date is not\n            specified, it returns market rate for the given day only.\n            route_id: Route ID.\n            vessel_class_id: Vessel class ID.\n            end_date: Combined with start_date will produce result market rates\n            for all consecutive days from start to end date.\n            cargo_id: Dirty (0), Clean(1) or IMO (2).\n\n        Returns:\n            The market rates or None if there are no market rates matching the\n            given criteria.\n        \"\"\"\n        query_dict = {\n            \"start_date\": start_date.isoformat(),\n            \"requested-by\": \"SignalSDK\"\n        }\n\n        if route_id is not None:\n            query_dict[\"route_id\"] = '{}'.format(route_id)\n        if vessel_class_id is not None:\n            query_dict[\"vessel_class_id\"] = '{}'.format(vessel_class_id)\n        if end_date is not None:\n            query_dict[\"end_date\"] = end_date.isoformat()\n        if cargo_id is not None:\n            query_dict[\"cargo_id\"] = cargo_id.value\n\n        query_string: QueryString = query_dict\n        response = self.__connection._make_get_request(\n            \"market-rates/api/v2/market_rates\", query_string\n        )\n        response.raise_for_status()\n        response_json = response.json()\n        return_object = parse_market_rates(response_json)\n\n        return return_object\n\n    def get_routes(\n        self, vessel_class_id: Optional[int] = None\n    ) -&gt; Tuple[Route, ...]:\n        \"\"\"Fetches all routes or the ones matching the vessel class ID.\n\n        Args:\n            vessel_class_id: Vessel class ID.\n\n        Returns:\n            The result routes.\n        \"\"\"\n        if vessel_class_id is not None:\n            uri = f\"market-rates/api/v2/routes/{vessel_class_id}\"\n        else:\n            uri = \"market-rates/api/v2/routes\"\n\n        response = self.__connection._make_get_request(uri)\n        response.raise_for_status()\n        response_json = response.json()\n        return_object = parse_routes(response_json)\n\n        return return_object\n\n    @staticmethod\n    def get_vessel_classes() -&gt; Tuple[VesselClass, ...]:\n        \"\"\"Retrieves all available vessel classes.\n\n        Returns:\n            A tuple of all available vessel classes.\n        \"\"\"\n        vessel_types = tuple(VesselClass(\n            cast(int, vessel_class[\"id\"]),\n            cast(int, vessel_class[\"vessel_type_id\"]),\n            cast(int, vessel_class[\"from_size\"]),\n            cast(int, vessel_class[\"to_size\"]),\n            cast(str, vessel_class[\"name\"]),\n            cast(str, vessel_class[\"vessel_type\"]),\n            cast(str, vessel_class[\"defining_size\"]),\n            cast(str, vessel_class[\"size\"]))\n                             for vessel_class in VESSEL_CLASSES)\n        return vessel_types\n</code></pre>"},{"location":"market_rates/#signal_ocean.market_rates.MarketRatesAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes the Market Rates API.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/market_rates/market_rates_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes the Market Rates API.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"market_rates/#signal_ocean.market_rates.MarketRatesAPI.get_market_rates","title":"<code>get_market_rates(start_date, route_id=None, vessel_class_id=None, end_date=None, cargo_id=None)</code>","text":"<p>Provides market rates for given day/period and route/vessel class.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>date</code> <p>Start date of market rates. If end date is not</p> required <code>route_id</code> <code>Optional[str]</code> <p>Route ID.</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Vessel class ID.</p> <code>None</code> <code>end_date</code> <code>Optional[date]</code> <p>Combined with start_date will produce result market rates</p> <code>None</code> <code>cargo_id</code> <code>Optional[CargoId]</code> <p>Dirty (0), Clean(1) or IMO (2).</p> <code>None</code> <p>Returns:</p> Type Description <code>MarketRate</code> <p>The market rates or None if there are no market rates matching the</p> <code>...</code> <p>given criteria.</p> Source code in <code>signal_ocean/market_rates/market_rates_api.py</code> <pre><code>def get_market_rates(\n    self, start_date: date, route_id: Optional[str] = None,\n        vessel_class_id: Optional[int] = None,\n        end_date: Optional[date] = None,\n        cargo_id: Optional[CargoId] = None\n) -&gt; Tuple[MarketRate, ...]:\n    \"\"\"Provides market rates for given day/period and route/vessel class.\n\n    Args:\n        start_date: Start date of market rates. If end date is not\n        specified, it returns market rate for the given day only.\n        route_id: Route ID.\n        vessel_class_id: Vessel class ID.\n        end_date: Combined with start_date will produce result market rates\n        for all consecutive days from start to end date.\n        cargo_id: Dirty (0), Clean(1) or IMO (2).\n\n    Returns:\n        The market rates or None if there are no market rates matching the\n        given criteria.\n    \"\"\"\n    query_dict = {\n        \"start_date\": start_date.isoformat(),\n        \"requested-by\": \"SignalSDK\"\n    }\n\n    if route_id is not None:\n        query_dict[\"route_id\"] = '{}'.format(route_id)\n    if vessel_class_id is not None:\n        query_dict[\"vessel_class_id\"] = '{}'.format(vessel_class_id)\n    if end_date is not None:\n        query_dict[\"end_date\"] = end_date.isoformat()\n    if cargo_id is not None:\n        query_dict[\"cargo_id\"] = cargo_id.value\n\n    query_string: QueryString = query_dict\n    response = self.__connection._make_get_request(\n        \"market-rates/api/v2/market_rates\", query_string\n    )\n    response.raise_for_status()\n    response_json = response.json()\n    return_object = parse_market_rates(response_json)\n\n    return return_object\n</code></pre>"},{"location":"market_rates/#signal_ocean.market_rates.MarketRatesAPI.get_routes","title":"<code>get_routes(vessel_class_id=None)</code>","text":"<p>Fetches all routes or the ones matching the vessel class ID.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class_id</code> <code>Optional[int]</code> <p>Vessel class ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Route, ...]</code> <p>The result routes.</p> Source code in <code>signal_ocean/market_rates/market_rates_api.py</code> <pre><code>def get_routes(\n    self, vessel_class_id: Optional[int] = None\n) -&gt; Tuple[Route, ...]:\n    \"\"\"Fetches all routes or the ones matching the vessel class ID.\n\n    Args:\n        vessel_class_id: Vessel class ID.\n\n    Returns:\n        The result routes.\n    \"\"\"\n    if vessel_class_id is not None:\n        uri = f\"market-rates/api/v2/routes/{vessel_class_id}\"\n    else:\n        uri = \"market-rates/api/v2/routes\"\n\n    response = self.__connection._make_get_request(uri)\n    response.raise_for_status()\n    response_json = response.json()\n    return_object = parse_routes(response_json)\n\n    return return_object\n</code></pre>"},{"location":"market_rates/#signal_ocean.market_rates.MarketRatesAPI.get_vessel_classes","title":"<code>get_vessel_classes()</code>  <code>staticmethod</code>","text":"<p>Retrieves all available vessel classes.</p> <p>Returns:</p> Type Description <code>Tuple[VesselClass, ...]</code> <p>A tuple of all available vessel classes.</p> Source code in <code>signal_ocean/market_rates/market_rates_api.py</code> <pre><code>@staticmethod\ndef get_vessel_classes() -&gt; Tuple[VesselClass, ...]:\n    \"\"\"Retrieves all available vessel classes.\n\n    Returns:\n        A tuple of all available vessel classes.\n    \"\"\"\n    vessel_types = tuple(VesselClass(\n        cast(int, vessel_class[\"id\"]),\n        cast(int, vessel_class[\"vessel_type_id\"]),\n        cast(int, vessel_class[\"from_size\"]),\n        cast(int, vessel_class[\"to_size\"]),\n        cast(str, vessel_class[\"name\"]),\n        cast(str, vessel_class[\"vessel_type\"]),\n        cast(str, vessel_class[\"defining_size\"]),\n        cast(str, vessel_class[\"size\"]))\n                         for vessel_class in VESSEL_CLASSES)\n    return vessel_types\n</code></pre>"},{"location":"market_rates/#signal_ocean.market_rates.Route","title":"<code>Route</code>  <code>dataclass</code>","text":"<p>A route with available market rate.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>ID of the route.</p> <code>description</code> <code>str</code> <p>Description of the route.</p> <code>unit</code> <code>str</code> <p>Unit in which rate is provided.</p> <code>vessel_class_id</code> <code>int</code> <p>ID of the vessel class.</p> <code>cargo_id</code> <code>int</code> <p>Cargo ID.</p> <code>load_port_id</code> <code>int</code> <p>Load port ID.</p> <code>discharge_port_id</code> <code>int</code> <p>Discharge port ID.</p> <code>load_area_id</code> <code>int</code> <p>Load area ID.</p> <code>discharge_area_id</code> <code>int</code> <p>Discharge area ID.</p> <code>load_port_2_id</code> <code>Optional[int]</code> <p>Second load port ID.</p> <code>discharge_port_2_id</code> <code>Optional[int]</code> <p>Second discharge port ID.</p> <code>load_area_2_id</code> <code>Optional[int]</code> <p>Second load area ID.</p> <code>discharge_area_2_id</code> <code>Optional[int]</code> <p>Second discharge area ID.</p> <code>deprecated_to</code> <code>Optional[str]</code> <p>Route ID if route is deprecated.</p> <code>deprecated_since</code> <code>Optional[datetime]</code> <p>Deprecation effective date.</p> Source code in <code>signal_ocean/market_rates/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Route:\n    \"\"\"A route with available market rate.\n\n    Attributes:\n        id: ID of the route.\n        description: Description of the route.\n        unit: Unit in which rate is provided.\n        vessel_class_id: ID of the vessel class.\n        cargo_id: Cargo ID.\n        load_port_id: Load port ID.\n        discharge_port_id: Discharge port ID.\n        load_area_id: Load area ID.\n        discharge_area_id: Discharge area ID.\n        load_port_2_id: Second load port ID.\n        discharge_port_2_id: Second discharge port ID.\n        load_area_2_id: Second load area ID.\n        discharge_area_2_id: Second discharge area ID.\n        deprecated_to: Route ID if route is deprecated.\n        deprecated_since: Deprecation effective date.\n    \"\"\"\n\n    id: str\n    description: str\n    unit: str\n    vessel_class_id: int\n    cargo_id: int\n    load_port_id: int\n    discharge_port_id: int\n    load_area_id: int\n    discharge_area_id: int\n    load_port_2_id: Optional[int] = None\n    discharge_port_2_id: Optional[int] = None\n    load_area_2_id: Optional[int] = None\n    discharge_area_2_id: Optional[int] = None\n    deprecated_to: Optional[str] = None\n    deprecated_since: Optional[datetime] = None\n</code></pre>"},{"location":"market_rates/#signal_ocean.market_rates.VesselClass","title":"<code>VesselClass</code>  <code>dataclass</code>","text":"<p>A vessel class.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The vessel class id, e.g. 60 -&gt; VLGC, 61 -&gt; Midsize/LGC etc.</p> <code>vessel_type_id</code> <code>int</code> <p>The vessel type id, e.g. 6</p> <code>from_size</code> <code>int</code> <p>Minimum size</p> <code>to_size</code> <code>int</code> <p>Maximum size</p> <code>name</code> <code>str</code> <p>The vessel class name</p> <code>vessel_type</code> <code>str</code> <p>The vessel type name, e.g. LPG</p> <code>defining_size</code> <code>str</code> <p>Size type, e.g. CubicSize</p> <code>size</code> <code>str</code> <p>The vessel size, e.g. cbm</p> Source code in <code>signal_ocean/market_rates/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VesselClass:\n    \"\"\"A vessel class.\n\n    Attributes:\n        id: The vessel class id, e.g. 60 -&gt; VLGC, 61 -&gt; Midsize/LGC etc.\n        vessel_type_id: The vessel type id, e.g. 6\n        from_size: Minimum size\n        to_size: Maximum size\n        name: The vessel class name\n        vessel_type: The vessel type name, e.g. LPG\n        defining_size: Size type, e.g. CubicSize\n        size: The vessel size, e.g. cbm\n    \"\"\"\n\n    id: int\n    vessel_type_id: int\n    from_size: int\n    to_size: int\n    name: str\n    vessel_type: str\n    defining_size: str\n    size: str\n</code></pre>"},{"location":"port_expenses/","title":"Package Documentation","text":"<p>Port Expenses API Package.</p> <p>Classes:</p> Name Description <code>PortExpensesAPI</code> <p>Represents Signal's Port Expenses API.</p> <code>Operation</code> <p>Enumeration of all possible operations.</p> <code>OperationStatus</code> <p>Enumeration of all possible operations statuses.</p> <code>EstimationStatus</code> <p>Enumeration of all possible estimation statuses.</p> <code>ItalianAnchorageDues</code> <p>Enumeration of all possible italian anchorage dues.</p> <code>PortExpenses</code> <p>The fees to be payed to port authorities.</p> <code>Port</code> <p>A maritime facility where vessels can dock.</p> <code>VesselType</code> <p>A vessel type.</p> <code>PortFilter</code> <p>A filter used to find specific ports.</p>"},{"location":"port_expenses/#signal_ocean.port_expenses.EstimationStatus","title":"<code>EstimationStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration of all possible estimation statuses.</p> Source code in <code>signal_ocean/port_expenses/enums.py</code> <pre><code>@unique\nclass EstimationStatus(Enum):\n    \"\"\"An enumeration of all possible estimation statuses.\"\"\"\n    PRIORITY_TO_FORMULAS = 0\n    PRIORITY_TO_ESTIMATES = 1\n    NO_ESTIMATES = 2\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.ItalianAnchorageDues","title":"<code>ItalianAnchorageDues</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration of all possible italian anchorage dues.</p> Source code in <code>signal_ocean/port_expenses/enums.py</code> <pre><code>@unique\nclass ItalianAnchorageDues(Enum):\n    \"\"\"An enumeration of all possible italian anchorage dues.\"\"\"\n    NONE = 0\n    MONTHLY = 1\n    YEARLY = 2\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.Operation","title":"<code>Operation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration of all possible operations.</p> Source code in <code>signal_ocean/port_expenses/enums.py</code> <pre><code>@unique\nclass Operation(Enum):\n    \"\"\"An enumeration of all possible operations.\"\"\"\n    LOAD = 0\n    DISCHARGE = 1\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.OperationStatus","title":"<code>OperationStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration of all possible operations statuses.</p> Source code in <code>signal_ocean/port_expenses/enums.py</code> <pre><code>@unique\nclass OperationStatus(Enum):\n    \"\"\"An enumeration of all possible operations statuses.\"\"\"\n    BALLAST = 0\n    LADEN = 1\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.Port","title":"<code>Port</code>  <code>dataclass</code>","text":"<p>A maritime facility where vessels can dock.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>ID of the port.</p> <code>name</code> <code>str</code> <p>Name of the port.</p> Source code in <code>signal_ocean/port_expenses/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Port:\n    \"\"\"A maritime facility where vessels can dock.\n\n    Attributes:\n        id: ID of the port.\n        name: Name of the port.\n    \"\"\"\n\n    id: int\n    name: str\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortExpenses","title":"<code>PortExpenses</code>  <code>dataclass</code>","text":"<p>The fees for port's facilities and services.</p> <p>Attributes:</p> Name Type Description <code>port_id</code> <code>int</code> <p>Port ID</p> <code>towage</code> <code>int</code> <p>Towage</p> <code>port_dues</code> <code>int</code> <p>Port dues</p> <code>pilotage</code> <code>int</code> <p>Pilotage</p> <code>agency_fees</code> <code>int</code> <p>Agency fees</p> <code>other</code> <code>int</code> <p>Other</p> <code>suez_dues</code> <code>int</code> <p>Suez dues</p> <code>total_cost</code> <code>int</code> <p>Total cost</p> <code>miscellaneous_dues</code> <code>int</code> <p>Mischellaneous dues</p> <code>is_estimated</code> <code>bool</code> <p>Flag for estimation</p> <code>canal_dues</code> <code>int</code> <p>Canal dues</p> <code>berth_dues</code> <code>int</code> <p>Berth dues</p> <code>lighthouse_dues</code> <code>int</code> <p>Lighthouse dues</p> <code>mooring_unmooring</code> <code>int</code> <p>Mooring-unmooring</p> <code>quay_dues</code> <code>int</code> <p>Quay dues</p> <code>anchorage_dues</code> <code>int</code> <p>Anchorage dues</p> Source code in <code>signal_ocean/port_expenses/models.py</code> <pre><code>@dataclass(frozen=True)\nclass PortExpenses:\n    \"\"\"The fees for port's facilities and services.\n\n    Attributes:\n        port_id: Port ID\n        towage: Towage\n        port_dues: Port dues\n        pilotage: Pilotage\n        agency_fees: Agency fees\n        other: Other\n        suez_dues: Suez dues\n        total_cost: Total cost\n        miscellaneous_dues: Mischellaneous dues\n        is_estimated: Flag for estimation\n        canal_dues: Canal dues\n        berth_dues: Berth dues\n        lighthouse_dues: Lighthouse dues\n        mooring_unmooring: Mooring-unmooring\n        quay_dues: Quay dues\n        anchorage_dues: Anchorage dues\n    \"\"\"\n\n    port_id: int\n    towage: int\n    port_dues: int\n    pilotage: int\n    agency_fees: int\n    other: int\n    suez_dues: int\n    total_cost: int\n    miscellaneous_dues: int\n    is_estimated: bool\n    canal_dues: int\n    berth_dues: int\n    lighthouse_dues: int\n    mooring_unmooring: int\n    quay_dues: int\n    anchorage_dues: int\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortExpensesAPI","title":"<code>PortExpensesAPI</code>","text":"<p>Represents Signal's Port Expenses API.</p> Source code in <code>signal_ocean/port_expenses/port_expenses_api.py</code> <pre><code>class PortExpensesAPI:\n    \"\"\"Represents Signal's Port Expenses API.\"\"\"\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes the Port Expenses API.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_port_expenses(\n        self, imo: int, port_id: int,\n            vessel_type_id: Optional[int] = None,\n            estimated_time_of_berth: Optional[datetime] = None,\n            estimated_time_of_sail: Optional[datetime] = None,\n            operation: Optional[Operation] = None,\n            italian_anchorage_dues: Optional[ItalianAnchorageDues] = None,\n            cargo_type: Optional[str] = None,\n            operation_status: Optional[OperationStatus] = None,\n            utc_date: Optional[datetime] = None,\n            historical_tce: Optional[bool] = None,\n            estimation_status: Optional[EstimationStatus] = None\n    ) -&gt; Optional[PortExpenses]:\n        \"\"\"Retrieves port expenses.\n\n        Args:\n            imo: The vessel's IMO number.\n            port_id: ID of the port to retrieve the expenses for.\n            vessel_type_id: Vessel type ID.\n            estimated_time_of_berth: Estimated time of berth.\n            estimated_time_of_sail: Estimated time of sail.\n            operation: Operation type.\n            italian_anchorage_dues: Italian anchorage dues.\n            cargo_type: Cargo type.\n            operation_status: Operation status.\n            utc_date: UTC date.\n            historical_tce: Flag for Historical TCE.\n            estimation_status: Estimation status.\n\n        Returns:\n            The port expenses or None if a port with given ID does not exist or\n            a vessel with the given IMO number does not exist.\n        \"\"\"\n        query_dict = {\n            \"imo\": '{}'.format(imo),\n            \"portId\": '{}'.format(port_id)\n        }\n\n        if vessel_type_id is not None:\n            query_dict[\"vesselTypeId\"] = '{}'.format(vessel_type_id)\n        if estimated_time_of_berth is not None:\n            query_dict[\"estimatedTimeOfBerth\"] = \\\n                estimated_time_of_berth.isoformat()\n        if estimated_time_of_sail is not None:\n            query_dict[\"estimatedTimeOfSail\"] = \\\n                estimated_time_of_sail.isoformat()\n        if operation is not None:\n            query_dict[\"operation\"] = '{}'.format(operation.value)\n        if italian_anchorage_dues is not None:\n            query_dict[\"italianAnchorageDues\"] = \\\n                '{}'.format(italian_anchorage_dues.value)\n        if cargo_type is not None:\n            query_dict[\"cargoType\"] = '{}'.format(cargo_type)\n        if operation_status is not None:\n            query_dict[\"operationStatus\"] = '{}'.format(operation_status.value)\n        if utc_date is not None:\n            query_dict[\"utcDate\"] = utc_date.isoformat()\n        if historical_tce is not None:\n            query_dict[\"historicalTce\"] = '{}'.format(historical_tce)\n        if estimation_status is not None:\n            query_dict[\"estimationStatus\"] = \\\n                '{}'.format(estimation_status.value)\n\n        query_string: QueryString = query_dict\n        response = self.__connection._make_post_request(\n            \"port-expenses/api/v1/Port\", query_string\n        )\n        response.raise_for_status()\n        response_json = response.json()\n        return_object = parse_port_expenses(response_json) \\\n            if response_json else None\n\n        return return_object\n\n    def get_port_model_vessel_expenses(\n        self, port_id: int, vessel_type_id: int,\n            formula_calculation_date: datetime, vessel_class_id: int = 0,\n            operation_status: OperationStatus = OperationStatus.BALLAST,\n            historical_tce: bool = False,\n            estimation_status: EstimationStatus =\n            EstimationStatus.PRIORITY_TO_FORMULAS) -&gt; Optional[PortExpenses]:\n        \"\"\"Retrieves model vessel port expenses.\n\n        Args:\n            port_id: ID of the port to retrieve the expenses for.\n            vessel_type_id: Vessel type ID.\n            formula_calculation_date: Formula calculation date.\n            vessel_class_id: Vessel class ID.\n            operation_status: Operation status.\n            historical_tce: Flag for historical TCE.\n            estimation_status: Estimation status.\n\n        Returns:\n            The port expenses for model vessel or None if a port with given ID\n            does not exist or a vessel type with the given ID number does not\n            exist.\n        \"\"\"\n        query_string: QueryString = {\n            \"portId\": '{}'.format(port_id),\n            \"vesselTypeId\": '{}'.format(vessel_type_id),\n            \"formulaCalculationDate\": formula_calculation_date.isoformat(),\n            \"vesselClassId\": '{}'.format(vessel_class_id),\n            \"operationStatus\": '{}'.format(operation_status.value),\n            \"historicalTce\": '{}'.format(historical_tce),\n            \"estimationStatus\": '{}'.format(estimation_status.value)\n        }\n\n        response = self.__connection._make_post_request(\n            \"port-expenses/api/v1/PortModelVessel\", query_string\n        )\n        response.raise_for_status()\n        response_json = response.json()\n        return_object = parse_port_expenses(response_json) \\\n            if response_json else None\n\n        return return_object\n\n    def get_required_formula_parameters(\n        self, port_id: int, vessel_type_id: int,\n            calculation_date: Optional[datetime] = None\n    ) -&gt; List[str]:\n        \"\"\"Retrieves required formula parameters.\n\n        Args:\n            port_id: ID of the port to retrieve the expenses for.\n            vessel_type_id: Vessel type ID.\n            calculation_date: Calculation date.\n\n        Returns:\n            List of required port expenses formula calculation parameters.\n        \"\"\"\n        query_dict = {\n            \"portId\": '{}'.format(port_id),\n            \"vesselTypeId\": '{}'.format(vessel_type_id),\n        }\n\n        if calculation_date is not None:\n            query_dict[\"calculationDate\"] = calculation_date.isoformat()\n\n        query_string: QueryString = query_dict\n        response = self.__connection._make_post_request(\n            \"port-expenses/api/v1/RequiredFormulaParameters\", query_string\n        )\n        response.raise_for_status()\n        response_json = response.json()\n\n        return cast(List[str], response_json)\n\n    def get_vessel_types(self) -&gt; Tuple[VesselType, ...]:\n        \"\"\"Retrieves all available vessel types.\n\n        Returns:\n            A tuple of all available vessel types.\n        \"\"\"\n        vessel_types = tuple(VesselType(vessel_type.value, vessel_type.name)\n                             for vessel_type in VesselTypeEnum)\n        return vessel_types\n\n    def get_ports(\n        self, port_filter: Optional[PortFilter] = None\n    ) -&gt; Tuple[Port, ...]:\n        \"\"\"Retrieves available ports.\n\n        Args:\n            port_filter: A filter used to find specific ports. If not\n                specified, returns all available ports.\n\n        Returns:\n            A tuple of available ports that match the filter.\n        \"\"\"\n        query_dict = {\n            \"date\": datetime.now().isoformat()\n        }\n\n        query_string: QueryString = query_dict\n\n        available_ports: List[Port] = []\n        for vessel_type in VesselTypeEnum:\n            response = self.__connection._make_get_request(\n                f\"port-expenses/api/v1/AvailablePorts/{vessel_type.value}\",\n                query_string\n            )\n            response.raise_for_status()\n            response_json = response.json()\n            available_ports += parse_ports(response_json)\n\n        port_filter = port_filter or PortFilter()\n\n        return tuple(port_filter._apply(available_ports))\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortExpensesAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes the Port Expenses API.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/port_expenses/port_expenses_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes the Port Expenses API.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortExpensesAPI.get_port_expenses","title":"<code>get_port_expenses(imo, port_id, vessel_type_id=None, estimated_time_of_berth=None, estimated_time_of_sail=None, operation=None, italian_anchorage_dues=None, cargo_type=None, operation_status=None, utc_date=None, historical_tce=None, estimation_status=None)</code>","text":"<p>Retrieves port expenses.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>int</code> <p>The vessel's IMO number.</p> required <code>port_id</code> <code>int</code> <p>ID of the port to retrieve the expenses for.</p> required <code>vessel_type_id</code> <code>Optional[int]</code> <p>Vessel type ID.</p> <code>None</code> <code>estimated_time_of_berth</code> <code>Optional[datetime]</code> <p>Estimated time of berth.</p> <code>None</code> <code>estimated_time_of_sail</code> <code>Optional[datetime]</code> <p>Estimated time of sail.</p> <code>None</code> <code>operation</code> <code>Optional[Operation]</code> <p>Operation type.</p> <code>None</code> <code>italian_anchorage_dues</code> <code>Optional[ItalianAnchorageDues]</code> <p>Italian anchorage dues.</p> <code>None</code> <code>cargo_type</code> <code>Optional[str]</code> <p>Cargo type.</p> <code>None</code> <code>operation_status</code> <code>Optional[OperationStatus]</code> <p>Operation status.</p> <code>None</code> <code>utc_date</code> <code>Optional[datetime]</code> <p>UTC date.</p> <code>None</code> <code>historical_tce</code> <code>Optional[bool]</code> <p>Flag for Historical TCE.</p> <code>None</code> <code>estimation_status</code> <code>Optional[EstimationStatus]</code> <p>Estimation status.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[PortExpenses]</code> <p>The port expenses or None if a port with given ID does not exist or</p> <code>Optional[PortExpenses]</code> <p>a vessel with the given IMO number does not exist.</p> Source code in <code>signal_ocean/port_expenses/port_expenses_api.py</code> <pre><code>def get_port_expenses(\n    self, imo: int, port_id: int,\n        vessel_type_id: Optional[int] = None,\n        estimated_time_of_berth: Optional[datetime] = None,\n        estimated_time_of_sail: Optional[datetime] = None,\n        operation: Optional[Operation] = None,\n        italian_anchorage_dues: Optional[ItalianAnchorageDues] = None,\n        cargo_type: Optional[str] = None,\n        operation_status: Optional[OperationStatus] = None,\n        utc_date: Optional[datetime] = None,\n        historical_tce: Optional[bool] = None,\n        estimation_status: Optional[EstimationStatus] = None\n) -&gt; Optional[PortExpenses]:\n    \"\"\"Retrieves port expenses.\n\n    Args:\n        imo: The vessel's IMO number.\n        port_id: ID of the port to retrieve the expenses for.\n        vessel_type_id: Vessel type ID.\n        estimated_time_of_berth: Estimated time of berth.\n        estimated_time_of_sail: Estimated time of sail.\n        operation: Operation type.\n        italian_anchorage_dues: Italian anchorage dues.\n        cargo_type: Cargo type.\n        operation_status: Operation status.\n        utc_date: UTC date.\n        historical_tce: Flag for Historical TCE.\n        estimation_status: Estimation status.\n\n    Returns:\n        The port expenses or None if a port with given ID does not exist or\n        a vessel with the given IMO number does not exist.\n    \"\"\"\n    query_dict = {\n        \"imo\": '{}'.format(imo),\n        \"portId\": '{}'.format(port_id)\n    }\n\n    if vessel_type_id is not None:\n        query_dict[\"vesselTypeId\"] = '{}'.format(vessel_type_id)\n    if estimated_time_of_berth is not None:\n        query_dict[\"estimatedTimeOfBerth\"] = \\\n            estimated_time_of_berth.isoformat()\n    if estimated_time_of_sail is not None:\n        query_dict[\"estimatedTimeOfSail\"] = \\\n            estimated_time_of_sail.isoformat()\n    if operation is not None:\n        query_dict[\"operation\"] = '{}'.format(operation.value)\n    if italian_anchorage_dues is not None:\n        query_dict[\"italianAnchorageDues\"] = \\\n            '{}'.format(italian_anchorage_dues.value)\n    if cargo_type is not None:\n        query_dict[\"cargoType\"] = '{}'.format(cargo_type)\n    if operation_status is not None:\n        query_dict[\"operationStatus\"] = '{}'.format(operation_status.value)\n    if utc_date is not None:\n        query_dict[\"utcDate\"] = utc_date.isoformat()\n    if historical_tce is not None:\n        query_dict[\"historicalTce\"] = '{}'.format(historical_tce)\n    if estimation_status is not None:\n        query_dict[\"estimationStatus\"] = \\\n            '{}'.format(estimation_status.value)\n\n    query_string: QueryString = query_dict\n    response = self.__connection._make_post_request(\n        \"port-expenses/api/v1/Port\", query_string\n    )\n    response.raise_for_status()\n    response_json = response.json()\n    return_object = parse_port_expenses(response_json) \\\n        if response_json else None\n\n    return return_object\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortExpensesAPI.get_port_model_vessel_expenses","title":"<code>get_port_model_vessel_expenses(port_id, vessel_type_id, formula_calculation_date, vessel_class_id=0, operation_status=OperationStatus.BALLAST, historical_tce=False, estimation_status=EstimationStatus.PRIORITY_TO_FORMULAS)</code>","text":"<p>Retrieves model vessel port expenses.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>ID of the port to retrieve the expenses for.</p> required <code>vessel_type_id</code> <code>int</code> <p>Vessel type ID.</p> required <code>formula_calculation_date</code> <code>datetime</code> <p>Formula calculation date.</p> required <code>vessel_class_id</code> <code>int</code> <p>Vessel class ID.</p> <code>0</code> <code>operation_status</code> <code>OperationStatus</code> <p>Operation status.</p> <code>BALLAST</code> <code>historical_tce</code> <code>bool</code> <p>Flag for historical TCE.</p> <code>False</code> <code>estimation_status</code> <code>EstimationStatus</code> <p>Estimation status.</p> <code>PRIORITY_TO_FORMULAS</code> <p>Returns:</p> Type Description <code>Optional[PortExpenses]</code> <p>The port expenses for model vessel or None if a port with given ID</p> <code>Optional[PortExpenses]</code> <p>does not exist or a vessel type with the given ID number does not</p> <code>Optional[PortExpenses]</code> <p>exist.</p> Source code in <code>signal_ocean/port_expenses/port_expenses_api.py</code> <pre><code>def get_port_model_vessel_expenses(\n    self, port_id: int, vessel_type_id: int,\n        formula_calculation_date: datetime, vessel_class_id: int = 0,\n        operation_status: OperationStatus = OperationStatus.BALLAST,\n        historical_tce: bool = False,\n        estimation_status: EstimationStatus =\n        EstimationStatus.PRIORITY_TO_FORMULAS) -&gt; Optional[PortExpenses]:\n    \"\"\"Retrieves model vessel port expenses.\n\n    Args:\n        port_id: ID of the port to retrieve the expenses for.\n        vessel_type_id: Vessel type ID.\n        formula_calculation_date: Formula calculation date.\n        vessel_class_id: Vessel class ID.\n        operation_status: Operation status.\n        historical_tce: Flag for historical TCE.\n        estimation_status: Estimation status.\n\n    Returns:\n        The port expenses for model vessel or None if a port with given ID\n        does not exist or a vessel type with the given ID number does not\n        exist.\n    \"\"\"\n    query_string: QueryString = {\n        \"portId\": '{}'.format(port_id),\n        \"vesselTypeId\": '{}'.format(vessel_type_id),\n        \"formulaCalculationDate\": formula_calculation_date.isoformat(),\n        \"vesselClassId\": '{}'.format(vessel_class_id),\n        \"operationStatus\": '{}'.format(operation_status.value),\n        \"historicalTce\": '{}'.format(historical_tce),\n        \"estimationStatus\": '{}'.format(estimation_status.value)\n    }\n\n    response = self.__connection._make_post_request(\n        \"port-expenses/api/v1/PortModelVessel\", query_string\n    )\n    response.raise_for_status()\n    response_json = response.json()\n    return_object = parse_port_expenses(response_json) \\\n        if response_json else None\n\n    return return_object\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortExpensesAPI.get_ports","title":"<code>get_ports(port_filter=None)</code>","text":"<p>Retrieves available ports.</p> <p>Parameters:</p> Name Type Description Default <code>port_filter</code> <code>Optional[PortFilter]</code> <p>A filter used to find specific ports. If not specified, returns all available ports.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Port, ...]</code> <p>A tuple of available ports that match the filter.</p> Source code in <code>signal_ocean/port_expenses/port_expenses_api.py</code> <pre><code>def get_ports(\n    self, port_filter: Optional[PortFilter] = None\n) -&gt; Tuple[Port, ...]:\n    \"\"\"Retrieves available ports.\n\n    Args:\n        port_filter: A filter used to find specific ports. If not\n            specified, returns all available ports.\n\n    Returns:\n        A tuple of available ports that match the filter.\n    \"\"\"\n    query_dict = {\n        \"date\": datetime.now().isoformat()\n    }\n\n    query_string: QueryString = query_dict\n\n    available_ports: List[Port] = []\n    for vessel_type in VesselTypeEnum:\n        response = self.__connection._make_get_request(\n            f\"port-expenses/api/v1/AvailablePorts/{vessel_type.value}\",\n            query_string\n        )\n        response.raise_for_status()\n        response_json = response.json()\n        available_ports += parse_ports(response_json)\n\n    port_filter = port_filter or PortFilter()\n\n    return tuple(port_filter._apply(available_ports))\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortExpensesAPI.get_required_formula_parameters","title":"<code>get_required_formula_parameters(port_id, vessel_type_id, calculation_date=None)</code>","text":"<p>Retrieves required formula parameters.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>ID of the port to retrieve the expenses for.</p> required <code>vessel_type_id</code> <code>int</code> <p>Vessel type ID.</p> required <code>calculation_date</code> <code>Optional[datetime]</code> <p>Calculation date.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of required port expenses formula calculation parameters.</p> Source code in <code>signal_ocean/port_expenses/port_expenses_api.py</code> <pre><code>def get_required_formula_parameters(\n    self, port_id: int, vessel_type_id: int,\n        calculation_date: Optional[datetime] = None\n) -&gt; List[str]:\n    \"\"\"Retrieves required formula parameters.\n\n    Args:\n        port_id: ID of the port to retrieve the expenses for.\n        vessel_type_id: Vessel type ID.\n        calculation_date: Calculation date.\n\n    Returns:\n        List of required port expenses formula calculation parameters.\n    \"\"\"\n    query_dict = {\n        \"portId\": '{}'.format(port_id),\n        \"vesselTypeId\": '{}'.format(vessel_type_id),\n    }\n\n    if calculation_date is not None:\n        query_dict[\"calculationDate\"] = calculation_date.isoformat()\n\n    query_string: QueryString = query_dict\n    response = self.__connection._make_post_request(\n        \"port-expenses/api/v1/RequiredFormulaParameters\", query_string\n    )\n    response.raise_for_status()\n    response_json = response.json()\n\n    return cast(List[str], response_json)\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortExpensesAPI.get_vessel_types","title":"<code>get_vessel_types()</code>","text":"<p>Retrieves all available vessel types.</p> <p>Returns:</p> Type Description <code>Tuple[VesselType, ...]</code> <p>A tuple of all available vessel types.</p> Source code in <code>signal_ocean/port_expenses/port_expenses_api.py</code> <pre><code>def get_vessel_types(self) -&gt; Tuple[VesselType, ...]:\n    \"\"\"Retrieves all available vessel types.\n\n    Returns:\n        A tuple of all available vessel types.\n    \"\"\"\n    vessel_types = tuple(VesselType(vessel_type.value, vessel_type.name)\n                         for vessel_type in VesselTypeEnum)\n    return vessel_types\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.PortFilter","title":"<code>PortFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific ports.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find ports by name. When specified, ports whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/port_expenses/port_filter.py</code> <pre><code>@dataclass(eq=False)\nclass PortFilter:\n    \"\"\"A filter used to find specific ports.\n\n    Attributes:\n        name_like: Used to find ports by name. When specified, ports whose\n            names partially match (contain) the attribute's value will be\n            returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(self, ports: Iterable[Port]) -&gt; Iterable[Port]:\n        return filter(self.__does_port_match, ports)\n\n    def __does_port_match(self, port: Port) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, port.name\n        )\n</code></pre>"},{"location":"port_expenses/#signal_ocean.port_expenses.VesselType","title":"<code>VesselType</code>  <code>dataclass</code>","text":"<p>A vessel type.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The vessel type id, e.g. 1 -&gt; Tanker, 3 -&gt; Dry, 4 -&gt; Containers, 5 -&gt; LNG (Liquified Natural gas), 6-&gt; LPG (Liquified Petroleum Gas).</p> <code>name</code> <code>str</code> <p>The vessel type name, e.g. Tanker, Dry, Containers, LNG (Liquified Natural gas), LPG (Liquified Petroleum Gas).</p> Source code in <code>signal_ocean/port_expenses/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VesselType:\n    \"\"\"A vessel type.\n\n    Attributes:\n        id: The vessel type id, e.g. 1 -&gt; Tanker, 3 -&gt; Dry, 4 -&gt; Containers,\n            5 -&gt; LNG (Liquified Natural gas),\n            6-&gt; LPG (Liquified Petroleum Gas).\n        name: The vessel type name, e.g. Tanker, Dry, Containers,\n            LNG (Liquified Natural gas), LPG (Liquified Petroleum Gas).\n    \"\"\"\n\n    id: int\n    name: str\n</code></pre>"},{"location":"release_notes/","title":"Latest version","text":""},{"location":"scraped_cargoes/","title":"Package Documentation","text":"<p>Scraped Cargoes API Package.</p> <p>Classes:</p> Name Description <code>ScrapedCargoesAPI</code> <p>Represents Signal's Scraped Cargoes API.</p> <code>ScrapedCargo</code> <p>Scraped Cargo.</p>"},{"location":"scraped_cargoes/#signal_ocean.scraped_cargoes.ScrapedCargo","title":"<code>ScrapedCargo</code>  <code>dataclass</code>","text":"<p>Detailed information about a scraped cargo.</p> <p>Attributes:</p> Name Type Description <code>cargo_id</code> <code>int</code> <p>Integer. A unique identifier of the cargo line.</p> <code>message_id</code> <code>Optional[int]</code> <p>Integer. A unique identifier of the message containing the specific cargo. A message can contain more than one cargo.</p> <code>external_message_id</code> <code>Optional[str]</code> <p>String. It serves as a unique identifier for a message, supplied by any company that has integrated with Signal.</p> <code>parsed_part_id</code> <code>Optional[int]</code> <p>Integer. A unique identifier for each email part. The email body and each attachment are considered different parsed parts. For an example the email body and its pdf attachment have same MessageID and different ParsedPartID.</p> <code>line_from</code> <code>Optional[int]</code> <p>Nullable integer. The starting line from which the cargo is extracted. The email subject counts as line 0 and the body content starts from line 1.</p> <code>line_to</code> <code>Optional[int]</code> <p>Nullable integer. The final line from which the cargo is extracted. For single line cargoes LineFrom is equal to LineTo. For descriptive cargoes that span across multiple lines we have LineTo&gt;LineFrom. These two numbers help the user identify which part of the text has been used to extract the cargo data.</p> <code>in_line_order</code> <code>Optional[int]</code> <p>Nullable integer. This integer is used to list different cargoes extracted from the same line. It is the case for cargoes with different discharge options. A cargo with a discharge and an option like 'med-ukc' is interpreted in our system as 2 cargoes with same MessageID, same ParsedPartID, same LineNumber,  different CargoID and an incremental InLineOrder number.</p> <code>source</code> <code>Optional[str]</code> <p>String. It describes the source of the information. Our system allows the user to inject data in many different ways, namely through email (Source='Email'), through Slack channels (Source='Slack') or through manual contributions directly from our frontend platform TSOP (Source='User').</p> <code>updated_date</code> <code>Optional[datetime]</code> <p>String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on which the cargo has been reevaluated for the last time. In case of an email received by a broker one month ago and reprocessed through our engine today, this date will be today's.</p> <code>received_date</code> <code>Optional[datetime]</code> <p>String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on which the cargo has been injected into our system and processed.</p> <code>is_deleted</code> <code>Optional[bool]</code> <p>Boolean. This value is true if the cargo is marked as Deleted.</p> <code>low_confidence</code> <code>Optional[bool]</code> <p>Boolean. This value is true when the data extraction process does not return as output some fields that we believe to be more important than others in business terms. These fields are called critical fields. The value is true if at least one of the critical fields is missing.For example missing charterer or laycan.</p> <code>scraped_laycan</code> <code>Optional[str]</code> <p>String. The laycan (latest day of cancellation) of the cargo as reported in the original text. It if often reported as a date range, e.g. '25-jan 27-jan', '31-1 feb', '11-12 apr'. The string 'dnr' (date not reported) can also be found.</p> <code>laycan_from</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the beginning of the laycan date range.</p> <code>laycan_to</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the end of the laycan date range.</p> <code>scraped_load</code> <code>Optional[str]</code> <p>String. The loading location reported in the original text of the cargo. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. Examples: 'singgi' for Singgi, 'rt' for Ras Tanura, 'waf' for West Africa.</p> <code>load_geo_id</code> <code>Optional[int]</code> <p>Integer. It is the internal ID of the mapped loading location reported in the cargo. Our models convert and map a scraped string containing geo information to a specific entity of the Signal's proprietary geofencing structure. Each geo entity is identified by a taxonomy, an ID and a name. Examples: the string 'bonny' is mapped to a geo asset with name 'Bonny', ID 3679 and taxonomy Port (TaxonomyID=2); the string 'nigeria' is mapped to a geoasset with name 'Nigeria', ID 171 and taxonomy Country (TaxonomyID=3); the string 'wafr' is mapped to a geoasset with name 'Africa Atlantic Coast', ID 24772 and taxonomy Level0 (TaxonomyID=4).</p> <code>load_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the reported loading location of the cargo. Examples: 'Bonny', 'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf', 'Singapore', 'East Coast Mexico'.</p> <code>load_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to each taxonomy, the level of geo details, from 1 to 7. A terminal (geoasset) has the lowest taxonomy (TaxonomyID=1), a port has TaxonomyID=2, while countries and wider areas have higher taxonomy (TaxonomyID&gt;=3). Examples of Level 0 areas (TaxonomyID=4) include 'Arabian Gulf', 'US Gulf' and 'East Mediterranean'. Level 1 areas (TaxonomyID=5) consist of multiple level 0 areas (TaxonomyID=4). For example, level 1 area 'Mediterranean' groups together the level 0 areas 'West Mediterranean', 'Central Mediterranean' and 'East Mediterranean'. Level 2 areas (TaxonomyID=6) consist of multiple level 1 areas (TaxonomyID=4). For example, level 2 area 'Mediterranean/UK Continent' groups together the 'Mediterranean' and 'UK Continent' level 1 areas. Level 3 areas (TaxonomyID=7) are the highest area grouping in our taxonomy and consist of multiple level 2 areas (TaxonomyID=6). Examples of such areas are 'Pacific America' or 'Africa'. These group together level 2 areas. For instance, 'Pacific America' groups together the level 2 areas 'West Coast North America', 'West Coast Mexico', 'West Coast Central America' and 'West Coast South America'.</p> <code>load_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_load2</code> <code>Optional[str]</code> <p>String. The second loading location reported in the original text of the cargo. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. Examples: 'singgi' for Singgi, 'rt' for Ras Tanura, 'waf' for West Africa.</p> <code>load_geo_id2</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped second loading location of the cargo. See LoadGeoID for more details.</p> <code>load_name2</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the reported second loading location of the cargo. Examples: 'Bonny', 'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf', 'Singapore', 'East Coast Mexico'.</p> <code>load_taxonomy_id2</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped discharging location. See LoadTaxonomyID for more details.</p> <code>load_taxonomy2</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_discharge</code> <code>Optional[str]</code> <p>String. The discharging port reported in the original text of the cargo. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. For cargoes reporting multiple discharge options, this field contains only the first string. For example in the cargo 'mercuria 75 ulsd n. mangalore ukc-wafr-jpn 14/jan 2.425m-2.375m-ws125' the field ScrapedDischarge contains 'ukc' only.</p> <code>scraped_discharge_options</code> <code>Optional[str]</code> <p>String. All the discharging options reported in the original text of the cargo. For example in the cargo 'minerva aries subs mercuria 75 ulsd n. mangalore ukc-wafr-jpn 14/jan 2.425m-2.375m-ws125' the field ScrapedDischargeOptions contains 'wafr-jpn'.</p> <code>discharge_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped discharging location of the cargo. See LoadGeoID for more details.</p> <code>discharge_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the discharging location of the cargo. Examples: 'Indonesia', 'Japan', 'Argentina'.</p> <code>discharge_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped discharging location. See LoadTaxonomyID for more details.</p> <code>discharge_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped discharging location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_discharge2</code> <code>Optional[str]</code> <p>String. The second discharging port reported in the original text of the cargo. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. For example in the cargo 'al agaila 130 gabon+algeria/ feast 14/01 rnr lord energy' the field ScrapedDischarge2 contains 'algeria'.</p> <code>discharge_geo_id2</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped second discharging location of the cargo. See LoadGeoID for more details.</p> <code>discharge_name2</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the second discharging location of the cargo. Examples: 'Algeria', 'Greece', 'France'.</p> <code>discharge_taxonomy_id2</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped second discharging location. See LoadTaxonomyID for more details.</p> <code>discharge_taxonomy2</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_charterer</code> <code>Optional[str]</code> <p>String. The cargo charterer as reported in the original text. Examples: 'atc', 'unipec', 'enoc', 'ioc', 'pbras'</p> <code>charterer_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the chartering company that it is reported in the line. We use an internal mapper to find the correspondence between the reported string and our database.</p> <code>charterer</code> <code>Optional[str]</code> <p>String. The company name corresponding to the ChartererID field. Provided to better specify the company involved in the business. Source: our internal Company Database.</p> <code>scraped_cargo_type</code> <code>Optional[str]</code> <p>String. The cargo type of the cargo as reported in the original text, often shortened. Examples: 'nhc', 'ulsd', 'ums', 'nap', 'go'.</p> <code>cargo_type_id</code> <code>Optional[int]</code> <p>Integer. It is an internal ID corresponding to the mapped cargo type of the cargo. A proprietary model is responsible to match the reported cargo string to a specific cargo type in our hierarchy. Examples: 19-&gt; Crude Oil, 16-&gt;Fueloil, 9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil, 60-&gt; 'Ultra Low Sulphur Diesel (ULSD 10ppm)'.</p> <code>cargo_type</code> <code>Optional[str]</code> <p>String. The extended name corresponding to the CargoTypeID field. Source: our internal CargoTypes database.</p> <code>cargo_type_group_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the high-level cargo type of the reported cargo type. It is provided to group cargoes and facilitate analytics. Examples: 130000-&gt;Dirty, 120000-&gt; Clean, 110000-&gt;IMO.</p> <code>cargo_type_group</code> <code>Optional[str]</code> <p>String. The extended name corresponding to the CargoGroupID field. Source: our internal CargoTypes database.</p> <code>scraped_quantity</code> <code>Optional[str]</code> <p>String. The cargo quantity as reported in the original text, including ranges and buffer. Also, it's common to report the required vessel class which indicates the size of suitable vessels. Examples: '80', '75000/10', '270', '180/10', 'VLCC', 'Kmx/Ppmx'.</p> <code>quantity</code> <code>Optional[float]</code> <p>Numeric. The mapped quantity measured in tonnes [t]. Quantity would be equal to '180000', both for ScrapedQuantity '180/10' and '180000/5'.</p> <code>quantity_buffer</code> <code>Optional[float]</code> <p>Numeric. The quantity buffer if reported in the cargo line, expressed as a fraction of 1. Examples: for ScrapedQuantity='75/10', QuantityBuffer=0.1. For ScrapedQuantity='180000/5', QuantityBuffer=0.05.</p> <code>quantity_from</code> <code>Optional[float]</code> <p>Numeric. The lower limit of the quantity range measured in tonnes [t], computed as QuantityFrom=(1-QuantityBuffer)*Quantity. Examples: for ScrapedQuantity='170/10', QuantityFrom=153000. For ScrapedQuantity='150000/10', QuantityFrom=135000. If QuantityBuffer=-0, we have Quantity=QuantityFrom=QuantityTo.</p> <code>quantity_to</code> <code>Optional[float]</code> <p>Numeric. The upper limit of the quantity range measured in tonnes [t], computed as QuantityFrom=(1+QuantityBuffer)*Quantity. Examples: for ScrapedQuantity='170/10', QuantityFrom=187000. For ScrapedQuantity='150000/10', QuantityFrom=165000. If QuantityBuffer=-0, we have Quantity=QuantityFrom=QuantityTo.</p> <code>size_from</code> <code>Optional[float]</code> <p>Numeric. The lower limit of the size range measured in tonnes [t]. Examples: for ScrapedQuantity='VLCC', SizeFrom=200000. For ScrapedQuantity='Kmx/Ppmx', SizeFrom=80000.</p> <code>size_to</code> <code>Optional[float]</code> <p>Numeric. The upper limit of the size range measured in tonnes [t]. Examples: for ScrapedQuantity='VLCC', SizeTo=350000. For ScrapedQuantity='Kmx/Ppmx', SizeTo=110000.</p> <code>scraped_delivery_date</code> <code>Optional[str]</code> <p>String. The delivery date of the time charter cargo as reported in the original text. It if often reported as a date range, e.g. '16/18 Nov', '17/19'.</p> <code>delivery_date_from</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the beginning of the delivery date range.</p> <code>delivery_date_to</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the end of the delivery date range.</p> <code>scraped_delivery_from</code> <code>Optional[str]</code> <p>String. The delivery location reported in the original text of the cargo. Very common in the case of time charter cargoes. If the delivery is reported as a geographical range, this field contains the first string. Otherwise the only delivery location reported. Example: In a dry cargo like ''Acct IVS Supramax/ultramax Del South Africa/West Africa 1 tct to Cont 10 March onw 3.75 adcom pus' we have ScrapedRedeliveryFrom = 'South Africa' and ScrapedRedeliveryTo = 'West Africa'. For the cargo ''Nova Marine Carriers SA 25/32k dwt Dely W Med 29/31 March  Redely UK  3,75 adc pus' we have ScrapedRedeliveryFrom = 'W Med'.</p> <code>delivery_from_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped delivery location of the cargo. See LoadGeoID for more details.</p> <code>delivery_from_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the delivery location of the cargo. Examples: 'E.Med' matches to 'East Mediterranean' (DeliveryFromGeoID=24737, DeliveryFromTaxonomyID=4, DeliveryFromTaxonomy='Level0'); 'PDM' matches to 'Ponta Da Madeira' (DeliveryFromGeoID=13013, DeliveryFromTaxonomyID=2, DeliveryFromTaxonomy='Port').</p> <code>delivery_from_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped delivery to location. See LoadTaxonomyID for more details.</p> <code>delivery_from_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped delivery location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_delivery_to</code> <code>Optional[str]</code> <p>String. If the delivery is reported as a geographical range, this field contains the end of the range as reported in the original text of the cargo. Example: In a dry cargo like ''Acct IVS Supramax/ultramax Del South Africa/West Africa 1 tct to Cont 10 March onw 3.75 adcom pus' we have ScrapedDeliveryTo = 'West Africa'.</p> <code>delivery_to_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped delivery location of the cargo. See LoadGeoID for more details.</p> <code>delivery_to_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the delivery location of the cargo. Example: 'West Africa' matches to 'West Africa' (DeliveryToGeoID=37, DeliveryToTaxonomyID=5, DeliveryToTaxonomy='Level1')</p> <code>delivery_to_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped delivery to location. See LoadTaxonomyID for more details.</p> <code>delivery_to_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped delivery location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_redelivery_from</code> <code>Optional[str]</code> <p>String. The redelivery location reported in the original text of the cargo. Very common in the case of time charter cargoes. If the redelivery is reported as a geographical range, this field contains the first string. Otherwise the only delivery location reported. Example: In a dry cargo like ''dely Corpus Christi 6/10 Oct trip via US Gulf redel Skaw-Gibraltar $35,000 + $800,000 bb - XO Shipping' we have ScrapedRedeliveryFrom = 'Skaw' and ScrapedRedeliveryTo = 'Gibraltar'. For the cargo ''dely Belawan 20/21 Sep trip via Indonesia redel N China $39,000 - cnr' we have ScrapedRedeliveryFrom = 'N China'.\"</p> <code>redelivery_from_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped redelivery location of the cargo. See LoadGeoID for more details.</p> <code>redelivery_from_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the redelivery location of the cargo. Example: 'N China' matches to 'North China' (RedeliveryFromGeoID=24666, DeliveryTaxonomyID=4, DeliveryTaxonomy='Level0').</p> <code>redelivery_from_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped redelivery location. Values from 1 to 7. See LoadTaxonomyID for more details.</p> <code>redelivery_from_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped redelivery location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_redelivery_to</code> <code>Optional[str]</code> <p>String. If the redelivery is reported as a geographical range, this field contains the end of the range as reported in the original text of the cargo. Example: In a dry cargo like ''dely Corpus Christi 6/10 Oct trip via US Gulf redel Skaw-Gibraltar $35,000 + $800,000 bb - XO Shipping' we have ScrapedRedeliveryTo = 'Gibraltar'.</p> <code>redelivery_to_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped redelivery location of the cargo. See LoadGeoID for more details.</p> <code>redelivery_to_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the redelivery location of the cargo. Example: 'Gibraltar' matches to 'Gibraltar' (RedeliveryToGeoID=7345, DeliveryTaxonomyID=2, DeliveryTaxonomy='Port').</p> <code>redelivery_to_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped redelivery location. Values from 1 to 7. See LoadTaxonomyID for more details.</p> <code>redelivery_to_taxonomy</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the redelivery location of the cargo. Example: 'Gibraltar' matches to 'Gibraltar' (RedeliveryToGeoID=7345, DeliveryTaxonomyID=2, DeliveryTaxonomy='Port').</p> <code>charter_type_id</code> <code>Optional[int]</code> <p>Integer. An internal ID to distinguish cargoes reporting voyage charter and time charter agreements. Possible values are 0 and 1.</p> <code>charter_type</code> <code>Optional[str]</code> <p>String. The extended name of the type of shipping contract reported in the cargo. Values currently supported are 'Voyage'-&gt;0, 'Time charter'-&gt;1.</p> <code>cargo_status_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the different values of the CargoStatus field. 0-&gt; OnSubs, 1-&gt; FullyFixed, 2 -&gt; Failed, 3 -&gt;Cancelled , 4-&gt; Available, -2 -&gt; NotSet, -1 -&gt; Unknown.</p> <code>cargo_status</code> <code>Optional[str]</code> <p>String denoting the commercial status of a cargo if explicitly mentioned, like 'ffxd' for fully fixed or 'subs'/'-s-' for on subs.</p> <code>content</code> <code>Optional[str]</code> <p>String. The full content of the cargo. For a single line cargo it is the line content. For multi line cargoes it is the collection of all the relevant parts of the text.</p> <code>subject</code> <code>Optional[str]</code> <p>String. The email subject of the cargo. This field has content when Source=\"Email\".</p> <code>sender</code> <code>Optional[str]</code> <p>String. Our own mapping of the shipping company sending out the market report through email. This string helps grouping emails sent by the same organization, but from different domains. It is often the case for big organizations operating worldwide. For example Sender= 'SSY' for both domains 'ssysin.com' and 'ssy.co'.</p> <code>is_private</code> <code>Optional[bool]</code> <p>Boolean. A cargo is private if injected by a user into his own private account within TSOP. A user can provide private information through email forwarding, through manual contributions or through Slack. Private cargo information stay in the account, are accessible by the account users only (people within the same company) and are the most valuable ones.</p> Source code in <code>signal_ocean/scraped_cargoes/models.py</code> <pre><code>@dataclass(frozen=True)\nclass ScrapedCargo:\n    \"\"\"Detailed information about a scraped cargo.\n\n    Attributes:\n        cargo_id: Integer. A unique identifier of the cargo line.\n        message_id: Integer. A unique identifier of the message containing the\n            specific cargo. A message can contain more than one cargo.\n        external_message_id: String. It serves as a unique identifier for a\n            message, supplied by any company that has integrated with Signal.\n        parsed_part_id: Integer. A unique identifier for each email part. The\n            email body and each attachment are considered different parsed\n            parts. For an example the email body and its pdf attachment have\n            same MessageID and different ParsedPartID.\n        line_from: Nullable integer. The starting line from which the cargo is\n            extracted. The email subject counts as line 0 and the body content\n            starts from line 1.\n        line_to: Nullable integer. The final line from which the cargo is\n            extracted. For single line cargoes LineFrom is equal to LineTo.\n            For descriptive cargoes that span across multiple lines we have\n            LineTo&gt;LineFrom. These two numbers help the user identify which\n            part of the text has been used to extract the cargo data.\n        in_line_order: Nullable integer. This integer is used to list different\n            cargoes extracted from the same line. It is the case for cargoes\n            with different discharge options. A cargo with a discharge and\n            an option like 'med-ukc' is interpreted in our system as 2 cargoes\n            with same MessageID, same ParsedPartID, same LineNumber,  different\n            CargoID and an incremental InLineOrder number.\n        source: String. It describes the source of the information. Our system\n            allows the user to inject data in many different ways, namely\n            through email (Source='Email'), through Slack channels\n            (Source='Slack') or through manual contributions directly from our\n            frontend platform TSOP (Source='User').\n        updated_date: String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on\n            which the cargo has been reevaluated for the last time. In case of\n            an email received by a broker one month ago and reprocessed through\n            our engine today, this date will be today's.\n        received_date: String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date\n            on which the cargo has been injected into our system and processed.\n        is_deleted: Boolean. This value is true if the cargo is marked as\n            Deleted.\n        low_confidence: Boolean. This value is true when the data extraction\n            process does not return as output some fields that we believe to\n            be more important than others in business terms. These fields are\n            called critical fields. The value is true if at least one of the\n            critical fields is missing.For example missing charterer or laycan.\n        scraped_laycan: String. The laycan (latest day of cancellation) of the\n            cargo as reported in the original text. It if often reported as a\n            date range, e.g. '25-jan 27-jan', '31-1 feb', '11-12 apr'. The\n            string 'dnr' (date not reported) can also be found.\n        laycan_from: Date, format YYYY-MM-DD. The mapped date corresponding to\n            the beginning of the laycan date range.\n        laycan_to: Date, format YYYY-MM-DD. The mapped date corresponding to\n            the end of the laycan date range.\n        scraped_load: String. The loading location reported in the original\n            text of the cargo. It is very often shortened, very compact and can\n            refer to terminals, ports, countries or wider areas. Examples:\n            'singgi' for Singgi, 'rt' for Ras Tanura, 'waf' for West Africa.\n        load_geo_id: Integer. It is the internal ID of the mapped loading\n            location reported in the cargo. Our models convert and map a\n            scraped string containing geo information to a specific entity of\n            the Signal's proprietary geofencing structure. Each geo entity is\n            identified by a taxonomy, an ID and a name. Examples: the string\n            'bonny' is mapped to a geo asset with name 'Bonny', ID 3679 and\n            taxonomy Port (TaxonomyID=2); the string 'nigeria' is mapped to a\n            geoasset with name 'Nigeria', ID 171 and taxonomy Country\n            (TaxonomyID=3); the string 'wafr' is mapped to a geoasset with name\n            'Africa Atlantic Coast', ID 24772 and taxonomy Level0\n            (TaxonomyID=4).\n        load_name: String. The name of the Signal geo entity related to the\n            reported loading location of the cargo. Examples: 'Bonny',\n            'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf', 'Singapore',\n            'East Coast Mexico'.\n        load_taxonomy_id: Integer. An internal ID corresponding to each\n            taxonomy, the level of geo details, from 1 to 7. A terminal\n            (geoasset) has the lowest taxonomy (TaxonomyID=1), a port has\n            TaxonomyID=2, while countries and wider areas have higher taxonomy\n            (TaxonomyID&gt;=3). Examples of Level 0 areas (TaxonomyID=4) include\n            'Arabian Gulf', 'US Gulf' and 'East Mediterranean'. Level 1 areas\n            (TaxonomyID=5) consist of multiple level 0 areas (TaxonomyID=4).\n            For example, level 1 area 'Mediterranean' groups together the\n            level 0 areas 'West Mediterranean', 'Central Mediterranean' and\n            'East Mediterranean'. Level 2 areas (TaxonomyID=6) consist of\n            multiple level 1 areas (TaxonomyID=4). For example, level 2 area\n            'Mediterranean/UK Continent' groups together the 'Mediterranean'\n            and 'UK Continent' level 1 areas. Level 3 areas (TaxonomyID=7) are\n            the highest area grouping in our taxonomy and consist of multiple\n            level 2 areas (TaxonomyID=6). Examples of such areas are\n            'Pacific America' or 'Africa'. These group together level 2 areas.\n            For instance, 'Pacific America' groups together the level 2 areas\n            'West Coast North America', 'West Coast Mexico',\n            'West Coast Central America' and 'West Coast South America'.\n        load_taxonomy: String. The extended name identifying the TaxonomyID.\n            Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3,\n            Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_load2: String. The second loading location reported in the\n            original text of the cargo. It is very often shortened, very\n            compact and can refer to terminals, ports, countries or wider\n            areas. Examples: 'singgi' for Singgi, 'rt' for Ras Tanura, 'waf'\n            for West Africa.\n        load_geo_id2: Integer. An internal ID corresponding to the mapped\n            second loading location of the cargo. See LoadGeoID for more\n            details.\n        load_name2: String. The name of the Signal geo entity related to\n            the reported second loading location of the cargo. Examples:\n            'Bonny', 'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf',\n            'Singapore', 'East Coast Mexico'.\n        load_taxonomy_id2: Integer. An internal ID corresponding to the\n            taxonomy of the mapped discharging location. See LoadTaxonomyID for\n            more details.\n        load_taxonomy2: String. The extended name identifying the TaxonomyID.\n            Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3,\n            Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_discharge: String. The discharging port reported in the\n            original text of the cargo. It is very often shortened, very\n            compact and can refer to terminals, ports, countries or wider\n            areas. For cargoes reporting multiple discharge options, this field\n            contains only the first string. For example in the cargo\n            'mercuria 75 ulsd n. mangalore ukc-wafr-jpn 14/jan\n            2.425m-2.375m-ws125' the field ScrapedDischarge contains 'ukc'\n            only.\n        scraped_discharge_options: String. All the discharging options reported\n            in the original text of the cargo. For example in the cargo\n            'minerva aries subs mercuria 75 ulsd n. mangalore ukc-wafr-jpn\n            14/jan 2.425m-2.375m-ws125' the field ScrapedDischargeOptions\n            contains 'wafr-jpn'.\n        discharge_geo_id: Integer. An internal ID corresponding to the mapped\n            discharging location of the cargo. See LoadGeoID for more details.\n        discharge_name: String. The name of the Signal geo entity related to\n            the discharging location of the cargo. Examples: 'Indonesia',\n            'Japan', 'Argentina'.\n        discharge_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped discharging location. See LoadTaxonomyID for\n            more details.\n        discharge_taxonomy: String. The extended name identifying the taxonomy\n            of the mapped discharging location. Possible values are:\n            GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5,\n            Level2-&gt;6, Level3-&gt;7.\n        scraped_discharge2: String. The second discharging port reported in the\n            original text of the cargo. It is very often shortened, very\n            compact and can refer to terminals, ports, countries or wider\n            areas. For example in the cargo 'al agaila 130 gabon+algeria/\n            feast 14/01 rnr lord energy' the field ScrapedDischarge2 contains\n            'algeria'.\n        discharge_geo_id2: Integer. An internal ID corresponding to the mapped\n            second discharging location of the cargo. See LoadGeoID for more\n            details.\n        discharge_name2: String. The name of the Signal geo entity related to\n            the second discharging location of the cargo. Examples:\n            'Algeria', 'Greece', 'France'.\n        discharge_taxonomy_id2: Integer. An internal ID corresponding to the\n            taxonomy of the mapped second discharging location. See\n            LoadTaxonomyID for more details.\n        discharge_taxonomy2: String. The extended name identifying the\n            TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2,\n            Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_charterer: String. The cargo charterer as reported in the\n            original text. Examples: 'atc', 'unipec', 'enoc', 'ioc', 'pbras'\n        charterer_id: Integer. Numeric ID corresponding to the chartering\n            company that it is reported in the line. We use an internal mapper\n            to find the correspondence between the reported string and our\n            database.\n        charterer: String. The company name corresponding to the ChartererID\n            field. Provided to better specify the company involved in the\n            business. Source: our internal Company Database.\n        scraped_cargo_type: String. The cargo type of the cargo as reported in\n            the original text, often shortened. Examples: 'nhc', 'ulsd', 'ums',\n            'nap', 'go'.\n        cargo_type_id: Integer. It is an internal ID corresponding to the\n            mapped cargo type of the cargo. A proprietary model is responsible\n            to match the reported cargo string to a specific cargo type in our\n            hierarchy. Examples: 19-&gt; Crude Oil, 16-&gt;Fueloil, 9-&gt; Naphtha,\n            135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil,\n            60-&gt; 'Ultra Low Sulphur Diesel (ULSD 10ppm)'.\n        cargo_type: String. The extended name corresponding to the CargoTypeID\n            field. Source: our internal CargoTypes database.\n        cargo_type_group_id: Integer. Numeric ID corresponding to the\n            high-level cargo type of the reported cargo type. It is provided to\n            group cargoes and facilitate analytics. Examples: 130000-&gt;Dirty,\n            120000-&gt; Clean, 110000-&gt;IMO.\n        cargo_type_group: String. The extended name corresponding to the\n            CargoGroupID field. Source: our internal CargoTypes database.\n        scraped_quantity: String. The cargo quantity as reported in the\n            original text, including ranges and buffer. Also, it's common to\n            report the required vessel class which indicates the size of\n            suitable vessels. Examples: '80', '75000/10', '270', '180/10',\n            'VLCC', 'Kmx/Ppmx'.\n        quantity: Numeric. The mapped quantity measured in tonnes [t].\n            Quantity would be equal to '180000', both for ScrapedQuantity\n            '180/10' and '180000/5'.\n        quantity_buffer: Numeric. The quantity buffer if reported in the cargo\n            line, expressed as a fraction of 1. Examples: for\n            ScrapedQuantity='75/10', QuantityBuffer=0.1.\n            For ScrapedQuantity='180000/5', QuantityBuffer=0.05.\n        quantity_from: Numeric. The lower limit of the quantity range measured\n            in tonnes [t], computed as\n            QuantityFrom=(1-QuantityBuffer)*Quantity.\n            Examples: for ScrapedQuantity='170/10', QuantityFrom=153000.\n            For ScrapedQuantity='150000/10', QuantityFrom=135000.\n            If QuantityBuffer=-0, we have Quantity=QuantityFrom=QuantityTo.\n        quantity_to: Numeric. The upper limit of the quantity range measured in\n            tonnes [t], computed as QuantityFrom=(1+QuantityBuffer)*Quantity.\n            Examples: for ScrapedQuantity='170/10', QuantityFrom=187000.\n            For ScrapedQuantity='150000/10', QuantityFrom=165000.\n            If QuantityBuffer=-0, we have Quantity=QuantityFrom=QuantityTo.\n        size_from: Numeric. The lower limit of the size range measured in\n            tonnes [t]. Examples: for ScrapedQuantity='VLCC', SizeFrom=200000.\n            For ScrapedQuantity='Kmx/Ppmx', SizeFrom=80000.\n        size_to: Numeric. The upper limit of the size range measured in\n            tonnes [t]. Examples: for ScrapedQuantity='VLCC', SizeTo=350000.\n            For ScrapedQuantity='Kmx/Ppmx', SizeTo=110000.\n        scraped_delivery_date: String. The delivery date of the time charter\n            cargo as reported in the original text. It if often reported as a\n            date range, e.g. '16/18 Nov', '17/19'.\n        delivery_date_from: Date, format YYYY-MM-DD. The mapped date\n            corresponding to the beginning of the delivery date range.\n        delivery_date_to: Date, format YYYY-MM-DD. The mapped date\n            corresponding to the end of the delivery date range.\n        scraped_delivery_from: String. The delivery location reported in the\n            original text of the cargo. Very common in the case of time charter\n            cargoes. If the delivery is reported as a geographical range,\n            this field contains the first string. Otherwise the only delivery\n            location reported. Example: In a dry cargo like\n            ''Acct IVS Supramax/ultramax Del South Africa/West Africa 1 tct to\n            Cont 10 March onw 3.75 adcom pus' we have\n            ScrapedRedeliveryFrom = 'South Africa' and\n            ScrapedRedeliveryTo = 'West Africa'. For the cargo\n            ''Nova Marine Carriers SA 25/32k dwt Dely\n            W Med 29/31 March  Redely UK  3,75 adc pus' we have\n            ScrapedRedeliveryFrom = 'W Med'.\n        delivery_from_geo_id: Integer. An internal ID corresponding to the\n            mapped delivery location of the cargo. See LoadGeoID for more\n            details.\n        delivery_from_name: String. The name of the Signal geo entity related\n            to the delivery location of the cargo. Examples: 'E.Med' matches\n            to 'East Mediterranean' (DeliveryFromGeoID=24737,\n            DeliveryFromTaxonomyID=4, DeliveryFromTaxonomy='Level0'); 'PDM'\n            matches to 'Ponta Da Madeira' (DeliveryFromGeoID=13013,\n            DeliveryFromTaxonomyID=2, DeliveryFromTaxonomy='Port').\n        delivery_from_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped delivery to location. See LoadTaxonomyID for\n            more details.\n        delivery_from_taxonomy: String. The extended name identifying the\n            taxonomy of the mapped delivery location. Possible values are:\n            GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5,\n            Level2-&gt;6, Level3-&gt;7.\n        scraped_delivery_to: String. If the delivery is reported as a\n            geographical range, this field contains the end of the range as\n            reported in the original text of the cargo. Example: In a dry cargo\n            like ''Acct IVS Supramax/ultramax Del South Africa/West Africa 1\n            tct to Cont 10 March onw 3.75 adcom pus' we have\n            ScrapedDeliveryTo = 'West Africa'.\n        delivery_to_geo_id: Integer. An internal ID corresponding to the mapped\n            delivery location of the cargo. See LoadGeoID for more details.\n        delivery_to_name: String. The name of the Signal geo entity related to\n            the delivery location of the cargo. Example: 'West Africa'\n            matches to 'West Africa' (DeliveryToGeoID=37,\n            DeliveryToTaxonomyID=5, DeliveryToTaxonomy='Level1')\n        delivery_to_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped delivery to location. See LoadTaxonomyID for\n            more details.\n        delivery_to_taxonomy: String. The extended name identifying the\n            taxonomy of the mapped delivery location. Possible values are:\n            GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5,\n            Level2-&gt;6, Level3-&gt;7.\n        scraped_redelivery_from: String. The redelivery location reported in\n            the original text of the cargo. Very common in the case of time\n            charter cargoes. If the redelivery is reported as a geographical\n            range, this field contains the first string. Otherwise the only\n            delivery location reported. Example: In a dry cargo like\n            ''dely Corpus Christi 6/10 Oct trip via US Gulf redel\n            Skaw-Gibraltar $35,000 + $800,000 bb - XO Shipping' we have\n            ScrapedRedeliveryFrom = 'Skaw' and\n            ScrapedRedeliveryTo = 'Gibraltar'. For the cargo ''dely Belawan\n            20/21 Sep trip via Indonesia redel N China $39,000 - cnr'\n            we have ScrapedRedeliveryFrom = 'N China'.\"\n        redelivery_from_geo_id: Integer. An internal ID corresponding to the\n            mapped redelivery location of the cargo. See LoadGeoID for more\n            details.\n        redelivery_from_name: String. The name of the Signal geo entity related\n            to the redelivery location of the cargo.\n            Example: 'N China' matches to 'North China'\n            (RedeliveryFromGeoID=24666, DeliveryTaxonomyID=4,\n            DeliveryTaxonomy='Level0').\n        redelivery_from_taxonomy_id: Integer. An internal ID corresponding to\n            the taxonomy of the mapped redelivery location. Values from 1 to 7.\n            See LoadTaxonomyID for more details.\n        redelivery_from_taxonomy: String. The extended name identifying the\n            taxonomy of the mapped redelivery location. Possible values are:\n            GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5,\n            Level2-&gt;6, Level3-&gt;7.\n        scraped_redelivery_to: String. If the redelivery is reported as a\n            geographical range, this field contains the end of the range as\n            reported in the original text of the cargo. Example: In a dry cargo\n            like ''dely Corpus Christi 6/10 Oct trip via US Gulf redel\n            Skaw-Gibraltar $35,000 + $800,000 bb - XO Shipping' we have\n            ScrapedRedeliveryTo = 'Gibraltar'.\n        redelivery_to_geo_id: Integer. An internal ID corresponding to the\n            mapped redelivery location of the cargo. See LoadGeoID for more\n            details.\n        redelivery_to_name: String. The name of the Signal geo entity related\n            to the redelivery location of the cargo. Example: 'Gibraltar'\n            matches to 'Gibraltar' (RedeliveryToGeoID=7345,\n            DeliveryTaxonomyID=2, DeliveryTaxonomy='Port').\n        redelivery_to_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped redelivery location. Values from 1 to 7.\n            See LoadTaxonomyID for more details.\n        redelivery_to_taxonomy: String. The name of the Signal geo entity\n            related to the redelivery location of the cargo. Example:\n            'Gibraltar' matches to 'Gibraltar' (RedeliveryToGeoID=7345,\n            DeliveryTaxonomyID=2, DeliveryTaxonomy='Port').\n        charter_type_id: Integer. An internal ID to distinguish cargoes\n            reporting voyage charter and time charter agreements. Possible\n            values are 0 and 1.\n        charter_type: String. The extended name of the type of shipping\n            contract reported in the cargo. Values currently supported are\n            'Voyage'-&gt;0, 'Time charter'-&gt;1.\n        cargo_status_id: Numeric ID corresponding to the different values of\n            the CargoStatus field. 0-&gt; OnSubs, 1-&gt; FullyFixed, 2 -&gt; Failed,\n            3 -&gt;Cancelled , 4-&gt; Available, -2 -&gt; NotSet, -1 -&gt; Unknown.\n        cargo_status: String denoting the commercial status of a cargo if\n            explicitly mentioned, like 'ffxd' for fully fixed or 'subs'/'-s-'\n            for on subs.\n        content: String. The full content of the cargo. For a single line cargo\n            it is the line content. For multi line cargoes it is the collection\n            of all the relevant parts of the text.\n        subject: String. The email subject of the cargo. This field has content\n            when Source=\"Email\".\n        sender: String. Our own mapping of the shipping company sending out the\n            market report through email. This string helps grouping emails sent\n            by the same organization, but from different domains. It is often\n            the case for big organizations operating worldwide. For example\n            Sender= 'SSY' for both domains 'ssysin.com' and 'ssy.co'.\n        is_private: Boolean. A cargo is private if injected by a user into his\n            own private account within TSOP. A user can provide private\n            information through email forwarding, through manual contributions\n            or through Slack. Private cargo information stay in the account,\n            are accessible by the account users only (people within the same\n            company) and are the most valuable ones.\n    \"\"\"\n\n    # entity details\n    cargo_id: int\n    message_id: Optional[int] = None\n    external_message_id: Optional[str] = None\n    parsed_part_id: Optional[int] = None\n    line_from: Optional[int] = None\n    line_to: Optional[int] = None\n    in_line_order: Optional[int] = None\n    source: Optional[str] = None\n    updated_date: Optional[datetime] = None\n    received_date: Optional[datetime] = None\n    is_deleted: Optional[bool] = False\n    low_confidence: Optional[bool] = False\n\n    # laycan\n    scraped_laycan: Optional[str] = None\n    laycan_from: Optional[datetime] = None\n    laycan_to: Optional[datetime] = None\n\n    # load\n    scraped_load: Optional[str] = None\n    load_geo_id: Optional[int] = None\n    load_name: Optional[str] = None\n    load_taxonomy_id: Optional[int] = None\n    load_taxonomy: Optional[str] = None\n\n    # load 2\n    scraped_load2: Optional[str] = None\n    load_geo_id2: Optional[int] = None\n    load_name2: Optional[str] = None\n    load_taxonomy_id2: Optional[int] = None\n    load_taxonomy2: Optional[str] = None\n\n    # discharge\n    scraped_discharge: Optional[str] = None\n    scraped_discharge_options: Optional[str] = None\n    discharge_geo_id: Optional[int] = None\n    discharge_name: Optional[str] = None\n    discharge_taxonomy_id: Optional[int] = None\n    discharge_taxonomy: Optional[str] = None\n\n    # discharge 2\n    scraped_discharge2: Optional[str] = None\n    discharge_geo_id2: Optional[int] = None\n    discharge_name2: Optional[str] = None\n    discharge_taxonomy_id2: Optional[int] = None\n    discharge_taxonomy2: Optional[str] = None\n\n    # charterer\n    scraped_charterer: Optional[str] = None\n    charterer_id: Optional[int] = None\n    charterer: Optional[str] = None\n\n    # cargo type\n    scraped_cargo_type: Optional[str] = None\n    cargo_type_id: Optional[int] = None\n    cargo_type: Optional[str] = None\n    cargo_type_group_id: Optional[int] = None\n    cargo_type_group: Optional[str] = None\n\n    # quantity\n    scraped_quantity: Optional[str] = None\n    quantity: Optional[float] = None\n    quantity_buffer: Optional[float] = None\n    quantity_from: Optional[float] = None\n    quantity_to: Optional[float] = None\n    size_from: Optional[float] = None\n    size_to: Optional[float] = None\n\n    # delivery date\n    scraped_delivery_date: Optional[str] = None\n    delivery_date_from: Optional[datetime] = None\n    delivery_date_to: Optional[datetime] = None\n\n    # delivery from\n    scraped_delivery_from: Optional[str] = None\n    delivery_from_geo_id: Optional[int] = None\n    delivery_from_name: Optional[str] = None\n    delivery_from_taxonomy_id: Optional[int] = None\n    delivery_from_taxonomy: Optional[str] = None\n\n    # delivery to\n    scraped_delivery_to: Optional[str] = None\n    delivery_to_geo_id: Optional[int] = None\n    delivery_to_name: Optional[str] = None\n    delivery_to_taxonomy_id: Optional[int] = None\n    delivery_to_taxonomy: Optional[str] = None\n\n    # redelivery from\n    scraped_redelivery_from: Optional[str] = None\n    redelivery_from_geo_id: Optional[int] = None\n    redelivery_from_name: Optional[str] = None\n    redelivery_from_taxonomy_id: Optional[int] = None\n    redelivery_from_taxonomy: Optional[str] = None\n\n    # redelivery to\n    scraped_redelivery_to: Optional[str] = None\n    redelivery_to_geo_id: Optional[int] = None\n    redelivery_to_name: Optional[str] = None\n    redelivery_to_taxonomy_id: Optional[int] = None\n    redelivery_to_taxonomy: Optional[str] = None\n\n    # charter type\n    charter_type_id: Optional[int] = None\n    charter_type: Optional[str] = None\n\n    # cargo status\n    cargo_status_id: Optional[int] = None\n    cargo_status: Optional[str] = None\n\n    # content\n    content: Optional[str] = None\n    subject: Optional[str] = None\n\n    # sender\n    sender: Optional[str] = None\n\n    # debug info\n    is_private: Optional[bool] = False\n</code></pre>"},{"location":"scraped_cargoes/#signal_ocean.scraped_cargoes.ScrapedCargoesAPI","title":"<code>ScrapedCargoesAPI</code>","text":"<p>               Bases: <code>ScrapedDataAPI[ScrapedCargoesResponse, ScrapedCargo]</code></p> <p>Represents Signal's Scraped Cargoes API.</p> Source code in <code>signal_ocean/scraped_cargoes/scraped_cargoes_api.py</code> <pre><code>class ScrapedCargoesAPI(ScrapedDataAPI[ScrapedCargoesResponse, ScrapedCargo]):\n    \"\"\"Represents Signal's Scraped Cargoes API.\"\"\"\n\n    relative_url = \"scraped-cargoes-api/v6.0/cargoes\"\n    response_class = ScrapedCargoesResponse\n\n    def get_cargoes(\n        self,\n        vessel_type: int,\n        cargo_ids: Optional[List[int]] = None,\n        message_ids: Optional[List[int]] = None,\n        external_message_ids: Optional[List[str]] = None,\n        received_date_from: Optional[datetime] = None,\n        received_date_to: Optional[datetime] = None,\n        updated_date_from: Optional[datetime] = None,\n        updated_date_to: Optional[datetime] = None,\n        include_details: Optional[bool] = True,\n        include_scraped_fields: Optional[bool] = True,\n        include_labels: Optional[bool] = True,\n        include_content: Optional[bool] = True,\n        include_sender: Optional[bool] = True,\n        include_debug_info: Optional[bool] = True,\n    ) -&gt; Tuple[ScrapedCargo, ...]:\n        \"\"\"This function collects and returns the cargoes by the given filters.\n\n        Args:\n            vessel_type: Format - int32. Available values\n                Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n            cargo_ids: List - Comma separated list of CargoIDs\n            message_ids: List - Comma separated list of MessageIDs\n            external_message_ids: List - Comma separated list of\n                ExternalMessageIDs\n            received_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the cargo received.\n                Cannot be combined with 'Updated' dates\n            received_date_to: Format - date-time (as date-time in RFC3339).\n                Latest date the cargo received.\n                Cannot be combined with 'Updated' dates\n            updated_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the cargo updated.\n                Cannot be combined with 'Received' dates\n            updated_date_to: Format - date-time (as date-time in RFC3339).\n                Latest date the cargo updated.\n                Cannot be combined with 'Received' dates\n            include_details: Boolean - Whether to include\n                additional cargo details in the response.\n            include_scraped_fields: Boolean - Whether to include the relative\n                scraped fields in the response.\n            include_labels: Boolean - Whether to include the relative labels in\n                the response.\n            include_content: Boolean - Whether to include the original message\n                line (untouched) in the response.\n            include_sender: Boolean - Whether to include some of the message\n                sender details in the response.\n            include_debug_info: Boolean - Whether to include some information\n                about the distribution of the cargo in the response.\n\n        Returns:\n            An Iterable of ScrapedCargo objects, as we have defined in\n            models.py Python file.\n        \"\"\"\n        return self.get_data(\n            vessel_type=vessel_type,\n            cargo_ids=cargo_ids,\n            message_ids=message_ids,\n            external_message_ids=external_message_ids,\n            received_date_from=received_date_from,\n            received_date_to=received_date_to,\n            updated_date_from=updated_date_from,\n            updated_date_to=updated_date_to,\n            include_details=include_details,\n            include_scraped_fields=include_scraped_fields,\n            include_labels=include_labels,\n            include_content=include_content,\n            include_sender=include_sender,\n            include_debug_info=include_debug_info,\n        )\n\n    def get_cargoes_incremental(\n            self,\n            vessel_type: int,\n            page_token: Optional[str] = None,\n            include_details: Optional[bool] = True,\n            include_scraped_fields: Optional[bool] = True,\n            include_labels: Optional[bool] = True,\n            include_content: Optional[bool] = True,\n            include_sender: Optional[bool] = True,\n            include_debug_info: Optional[bool] = True,\n    ) -&gt; IncrementalDataResponse[ScrapedCargo]:\n        \"\"\"This function collects and returns cargoes.\n\n           Specifically, all the cargoes updated after the given page token.\n           If page token is nullable, function will return all cargoes.\n\n        Args:\n            vessel_type: Format - int32. Available values\n                Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n            page_token: String. The key that should be used as a parameter of\n                the token to retrieve the relevant page.\n            include_details: Boolean - Whether to include\n                additional cargo details in the response.\n            include_scraped_fields: Boolean - Whether to include the relative\n                scraped fields in the response.\n            include_labels: Boolean - Whether to include the relative labels in\n                the response.\n            include_content: Boolean - Whether to include the original message\n                line (untouched) in the response.\n            include_sender: Boolean - Whether to include some of the message\n                sender details in the response.\n            include_debug_info: Boolean - Whether to include some information\n                about the distribution of the cargo in the response.\n\n        Returns:\n            A dictionary containing a tuple of ScrapedCargo objects and\n            NextRequestToken.\n            ScrapedCargo object is defined in models.py Python file.\n            Next Request Token is used as page_token.\n        \"\"\"\n        return self.get_data_incremental(\n            vessel_type=vessel_type,\n            page_token=page_token,\n            include_details=include_details,\n            include_scraped_fields=include_scraped_fields,\n            include_labels=include_labels,\n            include_content=include_content,\n            include_sender=include_sender,\n            include_debug_info=include_debug_info,\n        )\n\n    def get_cargoes_incremental_token(\n            self,\n            updated_date_from: datetime,\n    ) -&gt; Optional[str]:\n        \"\"\"This function returns a token to use in the incremental cargoes endpoint.\n\n        Args:\n            updated_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the cargo updated.\n                Cannot be combined with 'Received' dates\n\n        Returns:\n            A string containing the corresponding page token to\n            the provided datetime input.\n        \"\"\"\n        return self.get_data_incremental_token(\n            updated_date_from=updated_date_from,\n        )\n</code></pre>"},{"location":"scraped_cargoes/#signal_ocean.scraped_cargoes.ScrapedCargoesAPI.get_cargoes","title":"<code>get_cargoes(vessel_type, cargo_ids=None, message_ids=None, external_message_ids=None, received_date_from=None, received_date_to=None, updated_date_from=None, updated_date_to=None, include_details=True, include_scraped_fields=True, include_labels=True, include_content=True, include_sender=True, include_debug_info=True)</code>","text":"<p>This function collects and returns the cargoes by the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_type</code> <code>int</code> <p>Format - int32. Available values Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6</p> required <code>cargo_ids</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of CargoIDs</p> <code>None</code> <code>message_ids</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of MessageIDs</p> <code>None</code> <code>external_message_ids</code> <code>Optional[List[str]]</code> <p>List - Comma separated list of ExternalMessageIDs</p> <code>None</code> <code>received_date_from</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the cargo received. Cannot be combined with 'Updated' dates</p> <code>None</code> <code>received_date_to</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Latest date the cargo received. Cannot be combined with 'Updated' dates</p> <code>None</code> <code>updated_date_from</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the cargo updated. Cannot be combined with 'Received' dates</p> <code>None</code> <code>updated_date_to</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Latest date the cargo updated. Cannot be combined with 'Received' dates</p> <code>None</code> <code>include_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include additional cargo details in the response.</p> <code>True</code> <code>include_scraped_fields</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative scraped fields in the response.</p> <code>True</code> <code>include_labels</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative labels in the response.</p> <code>True</code> <code>include_content</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the original message line (untouched) in the response.</p> <code>True</code> <code>include_sender</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some of the message sender details in the response.</p> <code>True</code> <code>include_debug_info</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some information about the distribution of the cargo in the response.</p> <code>True</code> <p>Returns:</p> Type Description <code>ScrapedCargo</code> <p>An Iterable of ScrapedCargo objects, as we have defined in</p> <code>...</code> <p>models.py Python file.</p> Source code in <code>signal_ocean/scraped_cargoes/scraped_cargoes_api.py</code> <pre><code>def get_cargoes(\n    self,\n    vessel_type: int,\n    cargo_ids: Optional[List[int]] = None,\n    message_ids: Optional[List[int]] = None,\n    external_message_ids: Optional[List[str]] = None,\n    received_date_from: Optional[datetime] = None,\n    received_date_to: Optional[datetime] = None,\n    updated_date_from: Optional[datetime] = None,\n    updated_date_to: Optional[datetime] = None,\n    include_details: Optional[bool] = True,\n    include_scraped_fields: Optional[bool] = True,\n    include_labels: Optional[bool] = True,\n    include_content: Optional[bool] = True,\n    include_sender: Optional[bool] = True,\n    include_debug_info: Optional[bool] = True,\n) -&gt; Tuple[ScrapedCargo, ...]:\n    \"\"\"This function collects and returns the cargoes by the given filters.\n\n    Args:\n        vessel_type: Format - int32. Available values\n            Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n        cargo_ids: List - Comma separated list of CargoIDs\n        message_ids: List - Comma separated list of MessageIDs\n        external_message_ids: List - Comma separated list of\n            ExternalMessageIDs\n        received_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the cargo received.\n            Cannot be combined with 'Updated' dates\n        received_date_to: Format - date-time (as date-time in RFC3339).\n            Latest date the cargo received.\n            Cannot be combined with 'Updated' dates\n        updated_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the cargo updated.\n            Cannot be combined with 'Received' dates\n        updated_date_to: Format - date-time (as date-time in RFC3339).\n            Latest date the cargo updated.\n            Cannot be combined with 'Received' dates\n        include_details: Boolean - Whether to include\n            additional cargo details in the response.\n        include_scraped_fields: Boolean - Whether to include the relative\n            scraped fields in the response.\n        include_labels: Boolean - Whether to include the relative labels in\n            the response.\n        include_content: Boolean - Whether to include the original message\n            line (untouched) in the response.\n        include_sender: Boolean - Whether to include some of the message\n            sender details in the response.\n        include_debug_info: Boolean - Whether to include some information\n            about the distribution of the cargo in the response.\n\n    Returns:\n        An Iterable of ScrapedCargo objects, as we have defined in\n        models.py Python file.\n    \"\"\"\n    return self.get_data(\n        vessel_type=vessel_type,\n        cargo_ids=cargo_ids,\n        message_ids=message_ids,\n        external_message_ids=external_message_ids,\n        received_date_from=received_date_from,\n        received_date_to=received_date_to,\n        updated_date_from=updated_date_from,\n        updated_date_to=updated_date_to,\n        include_details=include_details,\n        include_scraped_fields=include_scraped_fields,\n        include_labels=include_labels,\n        include_content=include_content,\n        include_sender=include_sender,\n        include_debug_info=include_debug_info,\n    )\n</code></pre>"},{"location":"scraped_cargoes/#signal_ocean.scraped_cargoes.ScrapedCargoesAPI.get_cargoes_incremental","title":"<code>get_cargoes_incremental(vessel_type, page_token=None, include_details=True, include_scraped_fields=True, include_labels=True, include_content=True, include_sender=True, include_debug_info=True)</code>","text":"<p>This function collects and returns cargoes.</p> <p>Specifically, all the cargoes updated after the given page token.    If page token is nullable, function will return all cargoes.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_type</code> <code>int</code> <p>Format - int32. Available values Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6</p> required <code>page_token</code> <code>Optional[str]</code> <p>String. The key that should be used as a parameter of the token to retrieve the relevant page.</p> <code>None</code> <code>include_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include additional cargo details in the response.</p> <code>True</code> <code>include_scraped_fields</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative scraped fields in the response.</p> <code>True</code> <code>include_labels</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative labels in the response.</p> <code>True</code> <code>include_content</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the original message line (untouched) in the response.</p> <code>True</code> <code>include_sender</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some of the message sender details in the response.</p> <code>True</code> <code>include_debug_info</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some information about the distribution of the cargo in the response.</p> <code>True</code> <p>Returns:</p> Type Description <code>IncrementalDataResponse[ScrapedCargo]</code> <p>A dictionary containing a tuple of ScrapedCargo objects and</p> <code>IncrementalDataResponse[ScrapedCargo]</code> <p>NextRequestToken.</p> <code>IncrementalDataResponse[ScrapedCargo]</code> <p>ScrapedCargo object is defined in models.py Python file.</p> <code>IncrementalDataResponse[ScrapedCargo]</code> <p>Next Request Token is used as page_token.</p> Source code in <code>signal_ocean/scraped_cargoes/scraped_cargoes_api.py</code> <pre><code>def get_cargoes_incremental(\n        self,\n        vessel_type: int,\n        page_token: Optional[str] = None,\n        include_details: Optional[bool] = True,\n        include_scraped_fields: Optional[bool] = True,\n        include_labels: Optional[bool] = True,\n        include_content: Optional[bool] = True,\n        include_sender: Optional[bool] = True,\n        include_debug_info: Optional[bool] = True,\n) -&gt; IncrementalDataResponse[ScrapedCargo]:\n    \"\"\"This function collects and returns cargoes.\n\n       Specifically, all the cargoes updated after the given page token.\n       If page token is nullable, function will return all cargoes.\n\n    Args:\n        vessel_type: Format - int32. Available values\n            Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n        page_token: String. The key that should be used as a parameter of\n            the token to retrieve the relevant page.\n        include_details: Boolean - Whether to include\n            additional cargo details in the response.\n        include_scraped_fields: Boolean - Whether to include the relative\n            scraped fields in the response.\n        include_labels: Boolean - Whether to include the relative labels in\n            the response.\n        include_content: Boolean - Whether to include the original message\n            line (untouched) in the response.\n        include_sender: Boolean - Whether to include some of the message\n            sender details in the response.\n        include_debug_info: Boolean - Whether to include some information\n            about the distribution of the cargo in the response.\n\n    Returns:\n        A dictionary containing a tuple of ScrapedCargo objects and\n        NextRequestToken.\n        ScrapedCargo object is defined in models.py Python file.\n        Next Request Token is used as page_token.\n    \"\"\"\n    return self.get_data_incremental(\n        vessel_type=vessel_type,\n        page_token=page_token,\n        include_details=include_details,\n        include_scraped_fields=include_scraped_fields,\n        include_labels=include_labels,\n        include_content=include_content,\n        include_sender=include_sender,\n        include_debug_info=include_debug_info,\n    )\n</code></pre>"},{"location":"scraped_cargoes/#signal_ocean.scraped_cargoes.ScrapedCargoesAPI.get_cargoes_incremental_token","title":"<code>get_cargoes_incremental_token(updated_date_from)</code>","text":"<p>This function returns a token to use in the incremental cargoes endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>updated_date_from</code> <code>datetime</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the cargo updated. Cannot be combined with 'Received' dates</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>A string containing the corresponding page token to</p> <code>Optional[str]</code> <p>the provided datetime input.</p> Source code in <code>signal_ocean/scraped_cargoes/scraped_cargoes_api.py</code> <pre><code>def get_cargoes_incremental_token(\n        self,\n        updated_date_from: datetime,\n) -&gt; Optional[str]:\n    \"\"\"This function returns a token to use in the incremental cargoes endpoint.\n\n    Args:\n        updated_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the cargo updated.\n            Cannot be combined with 'Received' dates\n\n    Returns:\n        A string containing the corresponding page token to\n        the provided datetime input.\n    \"\"\"\n    return self.get_data_incremental_token(\n        updated_date_from=updated_date_from,\n    )\n</code></pre>"},{"location":"scraped_fixtures/","title":"Package Documentation","text":"<p>Scraped Fixtures API Package.</p> <p>Classes:</p> Name Description <code>ScrapedFixturesAPI</code> <p>Represents Signal's Scraped Fixtures API.</p> <code>ScrapedFixture</code> <p>Scraped Fixture.</p>"},{"location":"scraped_fixtures/#signal_ocean.scraped_fixtures.ScrapedFixture","title":"<code>ScrapedFixture</code>  <code>dataclass</code>","text":"<p>Detailed information about a scraped fixture.</p> <p>Attributes:</p> Name Type Description <code>fixture_id</code> <code>int</code> <p>Integer. A unique identifier of the fixture line.</p> <code>message_id</code> <code>Optional[int]</code> <p>Integer. A unique identifier of the message containing the specific fixture. A message can contain more than one fixture.</p> <code>external_message_id</code> <code>Optional[str]</code> <p>String. It serves as a unique identifier for a message, supplied by any company that has integrated with Signal.</p> <code>parsed_part_id</code> <code>Optional[int]</code> <p>Integer. A unique identifier for each email part. The email body and each attachment are considered different parsed parts. For an example the email body and its pdf attachment have same MessageID and different ParsedPartID.</p> <code>line_from</code> <code>Optional[int]</code> <p>Nullable integer. The starting line from which the fixture is extracted. The email subject counts as  line 0 and the body content starts from line 1.</p> <code>line_to</code> <code>Optional[int]</code> <p>Nullable integer. The final line from which the fixture is extracted. For single line fixtures LineFrom is equal to LineTo. For descriptive fixtures that span across multiple lines we have LineTo&gt;LineFrom. These two numbers help the user identify which part of the text has been used to extract the fixture data.</p> <code>in_line_order</code> <code>Optional[int]</code> <p>Nullable integer. This integer is used to list different fixtures extracted from the same line. It is the case for fixtures with different discharge options. A fixture with a discharge and an option like 'med-ukc' is interpreted in our system as 2 fixtures with same MessageID, same ParsedPartID, same LineNumber, same IMO, different FixtureID and an incremental InLineOrder number.</p> <code>source</code> <code>Optional[str]</code> <p>String. It describes the source of the information. Our system allows the user to inject data in many different ways, namely through email (Source='Email'), through Slack channels (Source='Slack') or through manual contributions directly from our frontend platform TSOP (Source='User').</p> <code>updated_date</code> <code>Optional[datetime]</code> <p>String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on which the fixture has been reevaluated for the last time. In case of an email received by a broker one month ago and reprocessed through our engine today, this date will be today's.</p> <code>received_date</code> <code>Optional[datetime]</code> <p>String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on which the fixture has been injected into our system and processed.</p> <code>is_deleted</code> <code>Optional[bool]</code> <p>Boolean. This value is true if the fixture is marked as Deleted.</p> <code>low_confidence</code> <code>Optional[bool]</code> <p>Boolean. This value is true when the data extraction process does not return as output some fields that we believe to be more important than others in business terms. These fields are called critical fields. The value is true if at least one of the critical fields is missing.For example missing charterer or laycan.</p> <code>scraped_vessel_name</code> <code>Optional[str]</code> <p>String. The vessel name as reported in the fixture line, i.e. 'Signal Alpha', 'Cpt A Stellatos', 'Genco Tiberius'. 'TBN' can also be found.</p> <code>scraped_deadweight</code> <code>Optional[str]</code> <p>String. The dead weight of the vessel as reported in the fixture line, i.e. '150249', '167'.</p> <code>scraped_year_built</code> <code>Optional[str]</code> <p>String. The year built of the vessel as reported in the fixture line, i.e. '2004', '09'.</p> <code>imo</code> <code>Optional[int]</code> <p>Integer. The seven-digits number that uniquely identifies the ship reported in the fixture. It is the result of our internally developed Vessel Mapper model.</p> <code>vessel_name</code> <code>Optional[str]</code> <p>String. It is the current vessel name corresponding to the IMO mentioned above. Provided to better specify the vessel and its particulars. Source: our internal Vessel Database.</p> <code>deadweight</code> <code>Optional[int]</code> <p>Integer. The dead weight in tonnes [t] corresponding to the IMO mentioned above.</p> <code>year_built</code> <code>Optional[int]</code> <p>Integer, YYYY format. The year the vessel was built. Source: our internal Vessel Database.</p> <code>liquid_capacity</code> <code>Optional[int]</code> <p>Integer, measured in cbm [cbm]. The liquid capacity of the IMO mentioned above. Source: our internal Vessel Database.</p> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the different values of the VesselType field. 1-&gt; Tanker, 3-&gt; Dry, 4 -&gt; Containers, 5 -&gt;LNG (Liquified Natural gas), 6-&gt; LPG (Liquified Petroleum Gas).</p> <code>vessel_type</code> <code>Optional[str]</code> <p>String. Description of the type of the vessel (VesselTypeID), based on the carried cargo. Main categories are Tankers, Dry (bulk carriers), Containers, LNG and LPG.</p> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Integer. It is an ID corresponding to the different vessel classes of a certain vessel type, as split according to our internal Vessel Database. For example 84-&gt;VLCC, 85-&gt;Suezmax, 70-&gt;Capesize.</p> <code>vessel_class</code> <code>Optional[str]</code> <p>String. Name of the vessel class the vessel belongs to. Assignment of a vessel to a certain VesselClass is based on the VesselType and the value of its Deadweight (if Tanker or Dry), its LiquidCap (if LNG/LPG) or its TEU (if Containers). For example, an Aframax is a Tanker vessel with Deadweight within the range 82kt - 125kt, while a Capesize is a Dry vessel with Deadweight within the range 120kt-220kt. LR2 are defined as Aframax, as only Deadweight is used to define vessel classes.</p> <code>commercial_operator_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the current maritime company that commercially manages the vessel corresponding to the IMO mentioned above. Source: Signal's proprietary algorithm.</p> <code>commercial_operator</code> <code>Optional[str]</code> <p>String. Name of the current maritime company associated to CommercialOperatorID. Source: our internal Companies Database.</p> <code>scraped_laycan</code> <code>Optional[str]</code> <p>String. The laycan (latest day of cancellation) of the fixture as reported in the original text. It is often reported as a date range, e.g. '25-jan 27-jan', '31-1 feb',  '11-12 apr'. The string 'dnr' (date not reported) can also be found.</p> <code>laycan_from</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the beginning of the laycan date range.</p> <code>laycan_to</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the end of the laycan date range.</p> <code>scraped_load</code> <code>Optional[str]</code> <p>String. The loading location reported in the original text of the fixture. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. Examples: 'singgi' for Singgi, 'rt' for Ras Tanura, 'waf' for West Africa.</p> <code>load_geo_id</code> <code>Optional[int]</code> <p>Integer. It is the internal ID of the mapped loading location reported in the fixture. Our models convert and map a scraped string containing geo information to a specific entity of the Signal's proprietary geofencing structure. Each geo entity is identified by a taxonomy, an ID and a name. Examples: the string 'bonny' is mapped to a geo asset with name 'Bonny', ID 3679 and taxonomy Port (TaxonomyID=2); the string 'nigeria' is mapped to a geoasset with name 'Nigeria', ID 171 and taxonomy Country (TaxonomyID=3); the string 'wafr' is mapped to a geoasset with name 'Africa Atlantic Coast', ID 24772 and taxonomy Level0 (TaxonomyID=4).</p> <code>load_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the reported loading location of the fixture. Examples: 'Bonny', 'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf', 'Singapore', 'East Coast Mexico'.</p> <code>load_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to each taxonomy, the level of geo details, from 1 to 7. A terminal (geoasset) has the lowest taxonomy (TaxonomyID=1), a port has TaxonomyID=2, while countries and wider areas have higher taxonomy (TaxonomyID&gt;=3). Examples of Level 0 areas (TaxonomyID=4) include 'Arabian Gulf', 'US Gulf' and 'East Mediterranean'. Level 1 areas (TaxonomyID=5) consist of multiple level 0 areas (TaxonomyID=4). For example, level 1 area 'Mediterranean' groups together the level 0 areas 'West Mediterranean', 'Central Mediterranean' and 'East Mediterranean'. Level 2 areas (TaxonomyID=6) consist of multiple level 1 areas (TaxonomyID=4). For example, level 2 area 'Mediterranean/UK Continent' groups together the 'Mediterranean' and 'UK Continent' level 1 areas. Level 3 areas (TaxonomyID=7) are the highest area grouping in our taxonomy and consist of multiple level 2 areas (TaxonomyID=6). Examples of such areas are 'Pacific America' or 'Africa'. These group together level 2 areas. For instance, 'Pacific America' groups together the level 2 areas 'West Coast North America', 'West Coast Mexico', 'West Coast Central America' and 'West Coast South America'.\"</p> <code>load_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt; 4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_load2</code> <code>Optional[str]</code> <p>String. The second loading location reported in the original text of the fixture. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. Examples: 'singgi' for Singgi, 'rt' for Ras Tanura, 'waf' for West Africa.\"</p> <code>load_geo_id2</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped second loading location of the fixture. See LoadGeoID for more details.</p> <code>load_name2</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the reported second loading location of the fixture. Examples: 'Bonny', 'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf', 'Singapore', 'East Coast Mexico'.</p> <code>load_taxonomy_id2</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped discharging location. See LoadTaxonomyID for more details.</p> <code>load_taxonomy2</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt; 4, Level1-&gt; 5, Level2-&gt; 6, Level3-&gt; 7.</p> <code>scraped_discharge</code> <code>Optional[str]</code> <p>String. The discharging port reported in the original text of the fixture. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. For fixtures reporting multiple discharge options, this field contains only the first string. For example in the fixture 'minerva aries subs mercuria 75 ulsd n. mangalore ukc-wafr-jpn 14/jan 2.425m-2.375m-ws125' the field ScrapedDischarge contains 'ukc' only.\"</p> <code>scraped_discharge_options</code> <code>Optional[str]</code> <p>String. All the discharging options reported in the original text of the fixture. For example in the fixture 'minerva aries subs mercuria 75 ulsd n. mangalore ukc-wafr-jpn 14/jan 2.425m-2.375m-ws125' the field ScrapedDischargeOptions contains 'wafr-jpn'.\"</p> <code>discharge_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped discharging location of the fixture. See LoadGeoID for more details.</p> <code>discharge_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the discharging location of the fixture. Examples: 'Indonesia', 'Japan', 'Argentina'.</p> <code>discharge_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped discharging location. See LoadTaxonomyID for more details.</p> <code>discharge_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped discharging location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_discharge2</code> <code>Optional[str]</code> <p>String. The second discharging port reported in the original text of the fixture. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. For example in the fixture 'al agaila 130 gabon+algeria/ feast 14/01 rnr lord energy' the field ScrapedDischarge2 contains 'algeria'.\"</p> <code>discharge_geo_id2</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped second discharging location of the fixture. See LoadGeoID for more details.</p> <code>discharge_name2</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the second discharging location of the fixture. Examples: 'Algeria', 'Greece', 'France'.</p> <code>discharge_taxonomy_id2</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped second discharging location. See LoadTaxonomyID for more details.</p> <code>discharge_taxonomy2</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_charterer</code> <code>Optional[str]</code> <p>String. The fixture charterer as reported in the original text.  Examples: 'atc', 'unipec', 'enoc', 'ioc', 'pbras'\"</p> <code>charterer_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the chartering company that it is reported in the line. We use an internal mapper to find the correspondence between the reported string and our database.</p> <code>charterer</code> <code>Optional[str]</code> <p>String. The company name corresponding to the ChartererID field.  Provided to better specify the company involved in the business. Source: our internal Company Database.</p> <code>scraped_cargo_type</code> <code>Optional[str]</code> <p>String. The fixture cargo type as reported in the original text, often shortened. Examples: 'nhc', 'ulsd', 'ums', 'nap', 'go'.</p> <code>cargo_type_id</code> <code>Optional[int]</code> <p>Integer. It is an internal ID corresponding to the mapped cargo type of the fixture. A proprietary model is responsible to match the reported cargo type string to a specific cargo type in our hierarchy. Examples: 19-&gt; Crude Oil, 16-&gt;Fueloil, 9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil, 60-&gt; 'Ultra Low Sulphur Diesel (ULSD 10ppm)'.</p> <code>cargo_type</code> <code>Optional[str]</code> <p>String. The extended name corresponding to the CargoTypeID field. Source: our internal CargoTypes database.</p> <code>cargo_group_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the high-level cargo type of the fixture cargo type. It is provided to group fixtures and facilitate analytics. Examples: 130000-&gt;Dirty, 120000-&gt; Clean, 110000-&gt;IMO.</p> <code>cargo_group</code> <code>Optional[str]</code> <p>String. The extended name corresponding to the CargoGroupID field. Source: our internal CargoTypes database.</p> <code>scraped_quantity</code> <code>Optional[str]</code> <p>String. The fixture quantity as reported in the original text, including ranges and buffer. Examples: '80', '75000/10', '270', '180/10'.</p> <code>quantity</code> <code>Optional[float]</code> <p>Numeric. The mapped quantity measured in tonnes [t]. Quantity would be equal to '180000', both for ScrapedQuantity '180/10' and '180000/5'.</p> <code>quantity_buffer</code> <code>Optional[float]</code> <p>Numeric. The quantity buffer if reported in the fixture line, expressed as a fraction of 1. Examples: for ScrapedQuantity='75/10', QuantityBuffer=0.1. For ScrapedQuantity='180000/5', QuantityBuffer=0.05.</p> <code>quantity_from</code> <code>Optional[float]</code> <p>Numeric. The lower limit of the quantity range measured in tonnes [t], computed as QuantityFrom=(1-QuantityBuffer)*Quantity. Examples: for ScrapedQuantity='170/10', QuantityFrom=153000. For ScrapedQuantity='150000/10', QuantityFrom=135000. If QuantityBuffer=-0, we have Quantity=QuantityFrom=QuantityTo.</p> <code>quantity_to</code> <code>Optional[float]</code> <p>Numeric. The upper limit of the quantity range measured in tonnes [t], computed as QuantityFrom=(1+QuantityBuffer)*Quantity. Examples: for ScrapedQuantity='170/10', QuantityFrom=187000. For ScrapedQuantity='150000/10', QuantityFrom=165000. If QuantityBuffer=-0, we have Quantity=QuantityFrom=QuantityTo.</p> <code>scraped_rate</code> <code>Optional[str]</code> <p>String. The fixture rate as reported in the original text, including its units or type. Examples: 'usd 240k', 'w100', '$18.95'. Values 'coa' and 'rnr' can also be found. For fixtures reporting multiple discharge options, this field contains only the rate for the first discharge.</p> <code>scraped_rate_options</code> <code>Optional[str]</code> <p>String. All the rates corresponding to the discharging options reported in the original text of the fixture. For example in the fixture 'minerva aries subs mercuria 75 ulsd n. mangalore ukc-wafr-jpn 14/jan 2.425m-2.375m-ws125' the field ScrapedRateOptions contains '2.375m-ws125'.</p> <code>rate_value</code> <code>Optional[float]</code> <p>Numeric. The mapped rate of the fixture. If lump sum, the rate is reported in USD. Example: for ScrapedRate='usd 240k', RateValue=240000.00 and RateType='LS'.</p> <code>rate_type</code> <code>Optional[str]</code> <p>String. The type associated to the RateValue. Possible values are 'LS' for 'Lump Sum' (in usd), 'WS' for World Scale, 'PMT' for $/pmt, 'TCE' for Time Charter Equivalent or $/day.</p> <code>demurrage_rate_value</code> <code>Optional[float]</code> <p>Numeric. The demurrage rate mapped for the fixture provided by the user, expressed in USD per day.</p> <code>demurrage_rate_type</code> <code>Optional[str]</code> <p>String. The type associated to the DemurrageRateValue. Possible value: \"$/day\".</p> <code>open_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped open location. The fields starting with 'Open' (OpeGeoID, OpenGeoName, OpenTaxonomyID, OpenTaxonomy and OpenDate) are populated if a fixture is partial. Such a fixture is marked by the boolean 'IsPartial' (see below) being true. In our system a fixture is partial if the discharge location is missing. There are two main sources of partial fixtures: the most common one is the case of a line in a tonnage list containing a subs indication and the second one is a fixture with no details contained in a fixture report. Example: a tonnage list line such as 'eagle san antonio mundra 04th subs' generates a partial fixture because only a limited number of fields is available. In this case we know the vessel name, the open location and the open date. There are no scraped fields corresponding to a partial fixture generated from a tonnage list, but only mapped ones. In the case of the example we have the vessel 'eagle san antonio' mapped to IMO 9594822, 'mundra' mapped to OpenGeoID 3527 of taxonomy Port (TaxonomyID=2), '04th' napped to OpenDate '2022-02-04' as the tonnage list was received at the end of January. The status of this partial fixture is 'on subs'.</p> <code>open_geo_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the open location of the partial fixture. Examples: 'Singapore', 'Japan', 'Argentina'.</p> <code>open_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped open location. See LoadTaxonomyID for more details.</p> <code>open_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped open location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>open_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped open date.</p> <code>scraped_delivery_date</code> <code>Optional[str]</code> <p>String. The delivery date of the time charter fixture as reported in the original text. It if often reported as a date range, e.g. '16/18 Nov', '17/19'.</p> <code>delivery_date_from</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the beginning of the delivery date range.</p> <code>delivery_date_to</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the end of the delivery date range.</p> <code>scraped_delivery</code> <code>Optional[str]</code> <p>String. The delivery location reported in the original text of the fixture. Very common in the case of time charter fixtures. The string can refer to waypoints, ports, countries or wider areas. Examples: 'Corpus Christi', 'EC South America', 'PDM', 'E.Med'.</p> <code>delivery_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped delivery location of the fixture. See LoadGeoID for more details.</p> <code>delivery_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the delivery location of the fixture. Examples: 'E.Med' matches to 'East Mediterranean' (DeliveryGeoID=24737, DeliveryTaxonomyID=4, DeliveryTaxonomy='Level0'); 'PDM' matches to 'Ponta Da Madeira' (DeliveryGeoID=13013, DeliveryTaxonomyID=2, DeliveryTaxonomy='Port').</p> <code>delivery_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped delivery location. Values from 1 to 7. See LoadTaxonomyID for more details.</p> <code>delivery_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped delivery location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_redelivery_from</code> <code>Optional[str]</code> <p>String. The redelivery location reported in the original text of the fixture. Very common in the case of time charter fixtures. If the redelivery is reported as a geographical range, this field contains the first string. Otherwise the only delivery location reported. Example: In a dry fixture like ''Atrotos Heracles' 2014 81922 dwt dely Corpus Christi 6/10 Oct trip via US Gulf redel Skaw-Gibraltar $35,000 + $800,000 bb - XO Shipping' we have ScrapedRedeliveryFrom = 'Skaw' and ScrapedRedeliveryTo = 'Gibraltar'. For the fixture ''Gorgoypikoos' 2005 76498 dwt dely Belawan 20/21 Sep trip via Indonesia redel N China $39,000 - cnr' we have ScrapedRedeliveryFrom = 'N China'.</p> <code>redelivery_from_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped redelivery location of the fixture. See LoadGeoID for more details.</p> <code>redelivery_from_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the redelivery location of the fixture. Example: 'N China' matches to 'North China' (RedeliveryFromGeoID=24666, DeliveryTaxonomyID=4, DeliveryTaxonomy='Level0').</p> <code>redelivery_from_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped redelivery location. Values from 1 to 7. See LoadTaxonomyID for more details.</p> <code>redelivery_from_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped redelivery location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_redelivery_to</code> <code>Optional[str]</code> <p>String. If the redelivery is reported as a geographical range, this field contains the end of the range as reported in the original text of the fixture. Example: In a dry fixture like ''Atrotos Heracles' 2014 81922 dwt dely Corpus Christi 6/10 Oct trip via US Gulf redel Skaw-Gibraltar $35,000 + $800,000 bb - XO Shipping' we have ScrapedRedeliveryTo = 'Gibraltar'.</p> <code>redelivery_to_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped redelivery location of the fixture. See LoadGeoID for more details.</p> <code>redelivery_to_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the redelivery location of the fixture. Example: 'Gibraltar' matches to 'Gibraltar' (RedeliveryToGeoID=7345, DeliveryTaxonomyID=2, DeliveryTaxonomy='Port').</p> <code>redelivery_to_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped redelivery location. Values from 1 to 7. See LoadTaxonomyID for more details.</p> <code>redelivery_to_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the taxonomy of the mapped redelivery location. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>charter_type_id</code> <code>Optional[int]</code> <p>Integer. An internal ID to distinguish fixtures reporting voyage charter and time charter agreements. Possible values are 0 and 1.</p> <code>charter_type</code> <code>Optional[str]</code> <p>String. The extended name of the type of shipping contract reported in the fixture. Values currently supported are 'Voyage'-&gt;0, 'Time charter'-&gt;1.</p> <code>fixture_status_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the different values of the FixtureStatus field. 0-&gt; OnSubs, 1-&gt; FullyFixed, 2 -&gt; Failed, 3 -&gt;Cancelled , 4-&gt; Available, -2 -&gt; NotSet, -1 -&gt; Unknown.</p> <code>fixture_status</code> <code>Optional[str]</code> <p>String denoting the commercial status of a fixture if explicitly mentioned, like 'ffxd' for fully fixed or 'subs'/'-s-' for on subs.</p> <code>broker_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the broker company provided by the user.</p> <code>broker</code> <code>Optional[str]</code> <p>String. The company name corresponding to the BrokerID field. Provided to better specify the company involved in the business.     Source: our internal Company Database.</p> <code>is_owners_option</code> <code>Optional[bool]</code> <p>Boolean. This value is true if 'o/o' (Owner's Option) or 'oos' is explicitly reported in the original text of the fixture.</p> <code>is_coa</code> <code>Optional[bool]</code> <p>Boolean. This value is true if 'COA' (Contract of Affreightment) or 'o/p' (Own Program) is explicitly reported in the original text of the fixture.</p> <code>content</code> <code>Optional[str]</code> <p>String. The full content of the fixture. For a single line fixture it is the line content. Example of a dry fixture ''Atrotos Heracles' 2014 81922 dwt dely Corpus Christi 6/10 Oct trip via US Gulf redel Skaw-Gibraltar $35,000 + $800,000 bb - XO Shipping'. For multi line fixtures it is the collection of all the relevant parts of the text.</p> <code>subject</code> <code>Optional[str]</code> <p>String. The email subject of the fixture. This field has content when Source=\"Email\".</p> <code>sender</code> <code>Optional[str]</code> <p>String. Our own mapping of the shipping company sending out the market report through email. This string helps grouping emails sent by the same organization, but from different domains. It is often the case for big organizations operating worldwide. For example Sender= 'SSY' for both domains 'ssysin.com' and 'ssy.co'.</p> <code>is_private</code> <code>Optional[bool]</code> <p>Boolean. A fixture is private if injected by a user into his own private account within TSOP. A user can provide private information through email forwarding, through manual contributions or through Slack. Private fixture information stay in the account, are accessible by the account users only (people within the same company) and are the most valuable ones.</p> <code>is_invalidated</code> <code>Optional[bool]</code> <p>Boolean. A fixture is invalidated whenever a user selects 'Ignore this fixture' from the Reported Fixtures dashboard in TSOP.</p> <code>is_partial</code> <code>Optional[bool]</code> <p>Boolean. A fixture is partial if the discharge field is missing. The two most common categories of partial fixtures are the fixtures generated by an 'on subs' indication in a tonnage list line and those included in a fixture report with vessel name, laycan and load port only. See OpenGeoID for more details.</p> <code>note</code> <code>Optional[str]</code> <p>String. A note added by the user for the fixture.</p> Source code in <code>signal_ocean/scraped_fixtures/models.py</code> <pre><code>@dataclass(frozen=True)\nclass ScrapedFixture:\n    \"\"\"Detailed information about a scraped fixture.\n\n    Attributes:\n        fixture_id: Integer. A unique identifier of the fixture line.\n        message_id: Integer. A unique identifier of the message containing the\n            specific fixture.\n            A message can contain more than one fixture.\n        external_message_id: String. It serves as a unique identifier for a\n            message, supplied by any company that has integrated with Signal.\n        parsed_part_id: Integer. A unique identifier for each email part.\n            The email body and each attachment are considered different parsed\n            parts. For an example the email body and its pdf attachment have\n            same MessageID and different ParsedPartID.\n        line_from: Nullable integer. The starting line from which the fixture\n            is extracted. The email subject counts as  line 0 and the body\n            content starts from line 1.\n        line_to: Nullable integer. The final line from which the fixture is\n            extracted. For single line fixtures LineFrom is equal to LineTo.\n            For descriptive fixtures that span across multiple lines we have\n            LineTo&gt;LineFrom. These two numbers help the user identify which\n            part of the text has been used to extract the fixture data.\n        in_line_order: Nullable integer. This integer is used to list different\n            fixtures extracted from the same line. It is the case for fixtures\n            with different discharge options. A fixture with a discharge and an\n            option like 'med-ukc' is interpreted in our system as 2 fixtures\n            with same MessageID, same ParsedPartID, same LineNumber, same IMO,\n            different FixtureID and an incremental InLineOrder number.\n        source: String. It describes the source of the information.\n            Our system allows the user to inject data in many different ways,\n            namely through email (Source='Email'), through Slack channels\n            (Source='Slack') or through manual contributions directly\n            from our frontend platform TSOP (Source='User').\n        updated_date: String, format YYYY-MM-DD HH:MM:SS, UTC timezone.\n            Date on which the fixture has been reevaluated for the last time.\n            In case of an email received by a broker one month ago and\n            reprocessed through our engine today, this date will be today's.\n        received_date: String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date\n            on which the fixture has been injected into our system and\n            processed.\n        is_deleted: Boolean. This value is true if the fixture is marked as\n            Deleted.\n        low_confidence: Boolean. This value is true when the data extraction\n            process does not return as output some fields that we believe to\n            be more important than others in business terms. These fields are\n            called critical fields. The value is true if at least one of the\n            critical fields is missing.For example missing charterer or laycan.\n        scraped_vessel_name: String. The vessel name as reported in the fixture\n            line, i.e. 'Signal Alpha', 'Cpt A Stellatos', 'Genco Tiberius'.\n            'TBN' can also be found.\n        scraped_deadweight: String. The dead weight of the vessel as reported\n            in the fixture line, i.e. '150249', '167'.\n        scraped_year_built: String. The year built of the vessel as reported in\n            the fixture line, i.e. '2004', '09'.\n        imo: Integer. The seven-digits number that uniquely identifies the ship\n            reported in the fixture. It is the result of our internally\n            developed Vessel Mapper model.\n        vessel_name: String. It is the current vessel name corresponding to the\n            IMO mentioned above. Provided to better specify the vessel and its\n            particulars. Source: our internal Vessel Database.\n        deadweight: Integer. The dead weight in tonnes [t] corresponding to the\n            IMO mentioned above.\n        year_built: Integer, YYYY format. The year the vessel was built.\n            Source: our internal Vessel Database.\n        liquid_capacity: Integer, measured in cbm [cbm]. The liquid capacity of\n            the IMO mentioned above. Source: our internal Vessel Database.\n        vessel_type_id: Integer. Numeric ID corresponding to the different\n            values of the VesselType field. 1-&gt; Tanker, 3-&gt; Dry,\n            4 -&gt; Containers, 5 -&gt;LNG (Liquified Natural gas),\n            6-&gt; LPG (Liquified Petroleum Gas).\n        vessel_type: String. Description of the type of the vessel\n            (VesselTypeID), based on the carried cargo. Main categories are\n            Tankers, Dry (bulk carriers), Containers, LNG and LPG.\n        vessel_class_id: Integer. It is an ID corresponding to the different\n            vessel classes of a certain vessel type, as split according to our\n            internal Vessel Database. For example 84-&gt;VLCC, 85-&gt;Suezmax,\n            70-&gt;Capesize.\n        vessel_class: String. Name of the vessel class the vessel belongs to.\n            Assignment of a vessel to a certain VesselClass is based on the\n            VesselType and the value of its Deadweight (if Tanker or Dry),\n            its LiquidCap (if LNG/LPG) or its TEU (if Containers).\n            For example, an Aframax is a Tanker vessel with Deadweight within\n            the range 82kt - 125kt, while a Capesize is a Dry vessel with\n            Deadweight within the range 120kt-220kt. LR2 are defined as\n            Aframax, as only Deadweight is used to define vessel classes.\n        commercial_operator_id: Integer. Numeric ID corresponding to the\n            current maritime company that commercially manages the vessel\n            corresponding to the IMO mentioned above. Source: Signal's\n            proprietary algorithm.\n        commercial_operator: String. Name of the current maritime company\n            associated to CommercialOperatorID. Source: our internal Companies\n            Database.\n        scraped_laycan: String. The laycan (latest day of cancellation) of the\n            fixture as reported in the original text. It is often reported as a\n            date range, e.g. '25-jan 27-jan', '31-1 feb',  '11-12 apr'.\n            The string 'dnr' (date not reported) can also be found.\n        laycan_from: Date, format YYYY-MM-DD. The mapped date corresponding to\n            the beginning of the laycan date range.\n        laycan_to: Date, format YYYY-MM-DD. The mapped date corresponding to\n            the end of the laycan date range.\n        scraped_load: String. The loading location reported in the original\n            text of the fixture. It is very often shortened, very compact and\n            can refer to terminals, ports, countries or wider areas. Examples:\n            'singgi' for Singgi, 'rt' for Ras Tanura, 'waf' for West Africa.\n        load_geo_id: Integer. It is the internal ID of the mapped loading\n            location reported in the fixture. Our models convert and map a\n            scraped string containing geo information to a specific entity of\n            the Signal's proprietary geofencing structure. Each geo entity is\n            identified by a taxonomy, an ID and a name. Examples: the string\n            'bonny' is mapped to a geo asset with name 'Bonny', ID 3679 and\n            taxonomy Port (TaxonomyID=2); the string 'nigeria' is mapped to a\n            geoasset with name 'Nigeria', ID 171 and taxonomy Country\n            (TaxonomyID=3); the string 'wafr' is mapped to a geoasset with name\n            'Africa Atlantic Coast', ID 24772 and taxonomy Level0\n            (TaxonomyID=4).\n        load_name: String. The name of the Signal geo entity related to the\n            reported loading location of the fixture. Examples: 'Bonny',\n            'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf', 'Singapore',\n            'East Coast Mexico'.\n        load_taxonomy_id: Integer. An internal ID corresponding to each\n            taxonomy, the level of geo details, from 1 to 7. A terminal\n            (geoasset) has the lowest taxonomy (TaxonomyID=1), a port has\n            TaxonomyID=2, while countries and wider areas have higher taxonomy\n            (TaxonomyID&gt;=3). Examples of Level 0 areas (TaxonomyID=4) include\n            'Arabian Gulf', 'US Gulf' and 'East Mediterranean'. Level 1 areas\n            (TaxonomyID=5) consist of multiple level 0 areas (TaxonomyID=4).\n            For example, level 1 area 'Mediterranean' groups together\n            the level 0 areas 'West Mediterranean', 'Central Mediterranean' and\n            'East Mediterranean'. Level 2 areas (TaxonomyID=6) consist of\n            multiple level 1 areas (TaxonomyID=4). For example, level 2 area\n            'Mediterranean/UK Continent' groups together the 'Mediterranean'\n            and 'UK Continent' level 1 areas. Level 3 areas (TaxonomyID=7) are\n            the highest area grouping in our taxonomy and consist of multiple\n            level 2 areas (TaxonomyID=6). Examples of such areas are\n            'Pacific America' or 'Africa'. These group together level 2 areas.\n            For instance, 'Pacific America' groups together the level 2 areas\n            'West Coast North America', 'West Coast Mexico',\n            'West Coast Central America' and 'West Coast South America'.\"\n        load_taxonomy: String. The extended name identifying the TaxonomyID.\n            Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3,\n            Level0-&gt; 4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_load2: String. The second loading location reported in the\n            original text of the fixture. It is very often shortened, very\n            compact and can refer to terminals, ports, countries or wider\n            areas. Examples: 'singgi' for Singgi, 'rt' for Ras Tanura, 'waf'\n            for West Africa.\"\n        load_geo_id2: Integer. An internal ID corresponding to the mapped\n            second loading location of the fixture. See LoadGeoID for more\n            details.\n        load_name2: String. The name of the Signal geo entity related to\n            the reported second loading location of the fixture.\n            Examples: 'Bonny', 'Nigeria', 'Africa Atlantic Coast',\n            'Arabian Gulf', 'Singapore', 'East Coast Mexico'.\n        load_taxonomy_id2: Integer. An internal ID corresponding to the\n            taxonomy of the mapped discharging location. See LoadTaxonomyID for\n            more details.\n        load_taxonomy2: String. The extended name identifying the TaxonomyID.\n            Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3,\n            Level0-&gt; 4, Level1-&gt; 5, Level2-&gt; 6, Level3-&gt; 7.\n        scraped_discharge: String. The discharging port reported in the\n            original text of the fixture. It is very often shortened, very\n            compact and can refer to terminals, ports, countries or wider\n            areas. For fixtures reporting multiple discharge options, this\n            field contains only the first string. For example in the fixture\n            'minerva aries subs mercuria 75 ulsd n. mangalore ukc-wafr-jpn\n            14/jan 2.425m-2.375m-ws125' the field ScrapedDischarge contains\n            'ukc' only.\"\n        scraped_discharge_options: String. All the discharging options reported\n            in the original text of the fixture. For example in the fixture\n            'minerva aries subs mercuria 75 ulsd n. mangalore ukc-wafr-jpn\n            14/jan 2.425m-2.375m-ws125' the field ScrapedDischargeOptions\n            contains 'wafr-jpn'.\"\n        discharge_geo_id: Integer. An internal ID corresponding to the mapped\n            discharging location of the fixture. See LoadGeoID for more\n            details.\n        discharge_name: String. The name of the Signal geo entity related to\n            the discharging location of the fixture. Examples: 'Indonesia',\n            'Japan', 'Argentina'.\n        discharge_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped discharging location. See LoadTaxonomyID for\n            more details.\n        discharge_taxonomy: String. The extended name identifying the taxonomy\n            of the mapped discharging location. Possible values are:\n            GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5,\n            Level2-&gt;6, Level3-&gt;7.\n        scraped_discharge2: String. The second discharging port reported in the\n            original text of the fixture. It is very often shortened, very\n            compact and can refer to terminals, ports, countries or wider\n            areas. For example in the fixture 'al agaila 130 gabon+algeria/\n            feast 14/01 rnr lord energy' the field ScrapedDischarge2 contains\n            'algeria'.\"\n        discharge_geo_id2: Integer. An internal ID corresponding to the mapped\n            second discharging location of the fixture. See LoadGeoID for more\n            details.\n        discharge_name2: String. The name of the Signal geo entity related to\n            the second discharging location of the fixture. Examples:\n            'Algeria', 'Greece', 'France'.\n        discharge_taxonomy_id2: Integer. An internal ID corresponding to the\n            taxonomy of the mapped second discharging location. See\n            LoadTaxonomyID for more details.\n        discharge_taxonomy2: String. The extended name identifying the\n            TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2,\n            Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_charterer: String. The fixture charterer as reported in the\n            original text.  Examples: 'atc', 'unipec', 'enoc', 'ioc', 'pbras'\"\n        charterer_id: Integer. Numeric ID corresponding to the chartering\n            company that it is reported in the line. We use an internal mapper\n            to find the correspondence between the reported string and our\n            database.\n        charterer: String. The company name corresponding to the ChartererID\n            field.  Provided to better specify the company involved in the\n            business. Source: our internal Company Database.\n        scraped_cargo_type: String. The fixture cargo type as reported in the\n            original text, often shortened. Examples: 'nhc', 'ulsd', 'ums',\n            'nap', 'go'.\n        cargo_type_id: Integer. It is an internal ID corresponding to the\n            mapped cargo type of the fixture. A proprietary model is\n            responsible to match the reported cargo type string to a specific\n            cargo type in our hierarchy. Examples: 19-&gt; Crude Oil, 16-&gt;Fueloil,\n            9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil,\n            60-&gt; 'Ultra Low Sulphur Diesel (ULSD 10ppm)'.\n        cargo_type: String. The extended name corresponding to the CargoTypeID\n            field. Source: our internal CargoTypes database.\n        cargo_group_id: Integer. Numeric ID corresponding to the high-level\n            cargo type of the fixture cargo type. It is provided to group\n            fixtures and facilitate analytics. Examples: 130000-&gt;Dirty,\n            120000-&gt; Clean, 110000-&gt;IMO.\n        cargo_group: String. The extended name corresponding to the\n            CargoGroupID field. Source: our internal CargoTypes database.\n        scraped_quantity: String. The fixture quantity as reported in the\n            original text, including ranges and buffer. Examples: '80',\n            '75000/10', '270', '180/10'.\n        quantity: Numeric. The mapped quantity measured in tonnes [t].\n            Quantity would be equal to '180000', both for ScrapedQuantity\n            '180/10' and '180000/5'.\n        quantity_buffer: Numeric. The quantity buffer if reported in the\n            fixture line, expressed as a fraction of 1.\n            Examples: for ScrapedQuantity='75/10', QuantityBuffer=0.1.\n            For ScrapedQuantity='180000/5', QuantityBuffer=0.05.\n        quantity_from: Numeric. The lower limit of the quantity range measured\n            in tonnes [t], computed as\n            QuantityFrom=(1-QuantityBuffer)*Quantity.\n            Examples: for ScrapedQuantity='170/10', QuantityFrom=153000.\n            For ScrapedQuantity='150000/10', QuantityFrom=135000.\n            If QuantityBuffer=-0, we have Quantity=QuantityFrom=QuantityTo.\n        quantity_to: Numeric. The upper limit of the quantity range measured in\n            tonnes [t], computed as QuantityFrom=(1+QuantityBuffer)*Quantity.\n            Examples: for ScrapedQuantity='170/10', QuantityFrom=187000.\n            For ScrapedQuantity='150000/10', QuantityFrom=165000.\n            If QuantityBuffer=-0, we have Quantity=QuantityFrom=QuantityTo.\n        scraped_rate: String. The fixture rate as reported in the original\n            text, including its units or type. Examples: 'usd 240k', 'w100',\n            '$18.95'. Values 'coa' and 'rnr' can also be found. For fixtures\n            reporting multiple discharge options, this field contains only the\n            rate for the first discharge.\n        scraped_rate_options: String. All the rates corresponding to the\n            discharging options reported in the original text of the fixture.\n            For example in the fixture 'minerva aries subs mercuria 75 ulsd\n            n. mangalore ukc-wafr-jpn 14/jan 2.425m-2.375m-ws125'\n            the field ScrapedRateOptions contains '2.375m-ws125'.\n        rate_value: Numeric. The mapped rate of the fixture. If lump sum, the\n            rate is reported in USD. Example: for ScrapedRate='usd 240k',\n            RateValue=240000.00 and RateType='LS'.\n        rate_type: String. The type associated to the RateValue.\n            Possible values are 'LS' for 'Lump Sum' (in usd), 'WS' for World\n            Scale, 'PMT' for $/pmt, 'TCE' for Time Charter Equivalent or $/day.\n        demurrage_rate_value: Numeric. The demurrage rate mapped for the\n            fixture provided by the user, expressed in USD per day.\n        demurrage_rate_type: String. The type associated to the\n            DemurrageRateValue. Possible value: \"$/day\".\n        open_geo_id: Integer. An internal ID corresponding to the mapped open\n            location. The fields starting with 'Open' (OpeGeoID, OpenGeoName,\n            OpenTaxonomyID, OpenTaxonomy and OpenDate) are populated if a\n            fixture is partial. Such a fixture is marked by the boolean\n            'IsPartial' (see below) being true. In our system a fixture is\n            partial if the discharge location is missing. There are two main\n            sources of partial fixtures: the most common one is the case of a\n            line in a tonnage list containing a subs indication and the second\n            one is a fixture with no details contained in a fixture report.\n            Example: a tonnage list line such as 'eagle san antonio mundra 04th\n            subs' generates a partial fixture because only a limited number of\n            fields is available. In this case we know the vessel name, the open\n            location and the open date. There are no scraped fields\n            corresponding to a partial fixture generated from a tonnage list,\n            but only mapped ones. In the case of the example we have the vessel\n            'eagle san antonio' mapped to IMO 9594822, 'mundra' mapped to\n            OpenGeoID 3527 of taxonomy Port (TaxonomyID=2), '04th' napped to\n            OpenDate '2022-02-04' as the tonnage list was received at the end\n            of January. The status of this partial fixture is 'on subs'.\n        open_geo_name: String. The name of the Signal geo entity related to the\n            open location of the partial fixture. Examples: 'Singapore',\n            'Japan', 'Argentina'.\n        open_taxonomy_id: Integer. An internal ID corresponding to the taxonomy\n            of the mapped open location. See LoadTaxonomyID for more details.\n        open_taxonomy: String. The extended name identifying the taxonomy of\n            the mapped open location. Possible values are: GeoAsset-&gt; 1,\n            Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        open_date: Date, format YYYY-MM-DD. The mapped open date.\n        scraped_delivery_date: String. The delivery date of the time charter\n            fixture as reported in the original text. It if often reported as a\n            date range, e.g. '16/18 Nov', '17/19'.\n        delivery_date_from: Date, format YYYY-MM-DD. The mapped date\n            corresponding to the beginning of the delivery date range.\n        delivery_date_to: Date, format YYYY-MM-DD. The mapped date\n            corresponding to the end of the delivery date range.\n        scraped_delivery: String. The delivery location reported in the\n            original text of the fixture. Very common in the case of time\n            charter fixtures. The string can refer to waypoints, ports,\n            countries or wider areas. Examples: 'Corpus Christi',\n            'EC South America', 'PDM', 'E.Med'.\n        delivery_geo_id: Integer. An internal ID corresponding to the mapped\n            delivery location of the fixture. See LoadGeoID for more details.\n        delivery_name: String. The name of the Signal geo entity related to the\n            delivery location of the fixture. Examples: 'E.Med' matches to\n            'East Mediterranean' (DeliveryGeoID=24737, DeliveryTaxonomyID=4,\n            DeliveryTaxonomy='Level0'); 'PDM' matches to 'Ponta Da Madeira'\n            (DeliveryGeoID=13013, DeliveryTaxonomyID=2,\n            DeliveryTaxonomy='Port').\n        delivery_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped delivery location. Values from 1 to 7. See\n            LoadTaxonomyID for more details.\n        delivery_taxonomy: String. The extended name identifying the taxonomy\n            of the mapped delivery location. Possible values are: GeoAsset-&gt; 1,\n            Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_redelivery_from: String. The redelivery location reported in\n            the original text of the fixture. Very common in the case of time\n            charter fixtures. If the redelivery is reported as a geographical\n            range, this field contains the first string. Otherwise the only\n            delivery location reported. Example: In a dry fixture like\n            ''Atrotos Heracles' 2014 81922 dwt dely Corpus Christi 6/10 Oct\n            trip via US Gulf redel Skaw-Gibraltar $35,000 + $800,000 bb - XO\n            Shipping' we have ScrapedRedeliveryFrom = 'Skaw' and\n            ScrapedRedeliveryTo = 'Gibraltar'. For the fixture ''Gorgoypikoos'\n            2005 76498 dwt dely Belawan 20/21 Sep trip via Indonesia redel N\n            China $39,000 - cnr' we have ScrapedRedeliveryFrom = 'N China'.\n        redelivery_from_geo_id: Integer. An internal ID corresponding to the\n            mapped redelivery location of the fixture. See LoadGeoID for more\n            details.\n        redelivery_from_name: String. The name of the Signal geo entity related\n            to the redelivery location of the fixture. Example: 'N China'\n            matches to 'North China' (RedeliveryFromGeoID=24666,\n            DeliveryTaxonomyID=4, DeliveryTaxonomy='Level0').\n        redelivery_from_taxonomy_id: Integer. An internal ID corresponding to\n            the taxonomy of the mapped redelivery location. Values from 1 to 7.\n            See LoadTaxonomyID for more details.\n        redelivery_from_taxonomy: String. The extended name identifying the\n            taxonomy of the mapped redelivery location. Possible values are:\n            GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5,\n            Level2-&gt;6, Level3-&gt;7.\n        scraped_redelivery_to: String. If the redelivery is reported as a\n            geographical range, this field contains the end of the range as\n            reported in the original text of the fixture. Example: In a dry\n            fixture like ''Atrotos Heracles' 2014 81922 dwt dely Corpus Christi\n            6/10 Oct trip via US Gulf redel Skaw-Gibraltar $35,000 +\n            $800,000 bb - XO Shipping' we have\n            ScrapedRedeliveryTo = 'Gibraltar'.\n        redelivery_to_geo_id: Integer. An internal ID corresponding to the\n            mapped redelivery location of the fixture. See LoadGeoID for more\n            details.\n        redelivery_to_name: String. The name of the Signal geo entity related\n            to the redelivery location of the fixture. Example: 'Gibraltar'\n            matches to 'Gibraltar' (RedeliveryToGeoID=7345,\n            DeliveryTaxonomyID=2, DeliveryTaxonomy='Port').\n        redelivery_to_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped redelivery location. Values from 1 to 7.\n            See LoadTaxonomyID for more details.\n        redelivery_to_taxonomy: String. The extended name identifying the\n            taxonomy of the mapped redelivery location. Possible values are:\n            GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5,\n            Level2-&gt;6, Level3-&gt;7.\n        charter_type_id: Integer. An internal ID to distinguish fixtures\n            reporting voyage charter and time charter agreements. Possible\n            values are 0 and 1.\n        charter_type: String. The extended name of the type of shipping\n            contract reported in the fixture. Values currently supported are\n            'Voyage'-&gt;0, 'Time charter'-&gt;1.\n        fixture_status_id: Numeric ID corresponding to the different values of\n            the FixtureStatus field. 0-&gt; OnSubs, 1-&gt; FullyFixed, 2 -&gt; Failed,\n            3 -&gt;Cancelled , 4-&gt; Available, -2 -&gt; NotSet, -1 -&gt; Unknown.\n        fixture_status: String denoting the commercial status of a fixture if\n            explicitly mentioned, like 'ffxd' for fully fixed or 'subs'/'-s-'\n            for on subs.\n        broker_id: Integer. Numeric ID corresponding to the broker company\n            provided by the user.\n        broker: String. The company name corresponding to the BrokerID field.\n            Provided to better specify the company involved in the business.\n                Source: our internal Company Database.\n        is_owners_option: Boolean. This value is true if 'o/o' (Owner's Option)\n            or 'oos' is explicitly reported in the original text of the\n            fixture.\n        is_coa: Boolean. This value is true if 'COA' (Contract of\n            Affreightment) or 'o/p' (Own Program) is explicitly reported in the\n            original text of the fixture.\n        content: String. The full content of the fixture. For a single line\n            fixture it is the line content. Example of a dry fixture\n            ''Atrotos Heracles' 2014 81922 dwt dely Corpus Christi 6/10 Oct\n            trip via US Gulf redel Skaw-Gibraltar $35,000 + $800,000 bb - XO\n            Shipping'. For multi line fixtures it is the collection of all the\n            relevant parts of the text.\n        subject: String. The email subject of the fixture. This field has\n            content when Source=\"Email\".\n        sender: String. Our own mapping of the shipping company sending out the\n            market report through email. This string helps grouping emails sent\n            by the same organization, but from different domains. It is often\n            the case for big organizations operating worldwide. For example\n            Sender= 'SSY' for both domains 'ssysin.com' and 'ssy.co'.\n        is_private: Boolean. A fixture is private if injected by a user into\n            his own private account within TSOP. A user can provide private\n            information through email forwarding, through manual contributions\n            or through Slack. Private fixture information stay in the account,\n            are accessible by the account users only (people within the same\n            company) and are the most valuable ones.\n        is_invalidated: Boolean. A fixture is invalidated whenever a user\n            selects 'Ignore this fixture' from the Reported Fixtures dashboard\n            in TSOP.\n        is_partial: Boolean. A fixture is partial if the discharge field is\n            missing. The two most common categories of partial fixtures are the\n            fixtures generated by an 'on subs' indication in a tonnage list\n            line and those included in a fixture report with vessel name,\n            laycan and load port only. See OpenGeoID for more details.\n        note: String. A note added by the user for the fixture.\n    \"\"\"\n\n    # entity details\n    fixture_id: int\n    message_id: Optional[int] = None\n    external_message_id: Optional[str] = None\n    parsed_part_id: Optional[int] = None\n    line_from: Optional[int] = None\n    line_to: Optional[int] = None\n    in_line_order: Optional[int] = None\n    source: Optional[str] = None\n    updated_date: Optional[datetime] = None\n    received_date: Optional[datetime] = None\n    is_deleted: Optional[bool] = False\n    low_confidence: Optional[bool] = False\n\n    # vessel\n    scraped_vessel_name: Optional[str] = None\n    scraped_deadweight: Optional[str] = None\n    scraped_year_built: Optional[str] = None\n    imo: Optional[int] = None\n    vessel_name: Optional[str] = None\n    deadweight: Optional[int] = None\n    year_built: Optional[int] = None\n    liquid_capacity: Optional[int] = None\n    vessel_type_id: Optional[int] = None\n    vessel_type: Optional[str] = None\n    vessel_class_id: Optional[int] = None\n    vessel_class: Optional[str] = None\n    commercial_operator_id: Optional[int] = None\n    commercial_operator: Optional[str] = None\n\n    # laycan\n    scraped_laycan: Optional[str] = None\n    laycan_from: Optional[datetime] = None\n    laycan_to: Optional[datetime] = None\n\n    # load\n    scraped_load: Optional[str] = None\n    load_geo_id: Optional[int] = None\n    load_name: Optional[str] = None\n    load_taxonomy_id: Optional[int] = None\n    load_taxonomy: Optional[str] = None\n\n    # load 2\n    scraped_load2: Optional[str] = None\n    load_geo_id2: Optional[int] = None\n    load_name2: Optional[str] = None\n    load_taxonomy_id2: Optional[int] = None\n    load_taxonomy2: Optional[str] = None\n\n    # discharge\n    scraped_discharge: Optional[str] = None\n    scraped_discharge_options: Optional[str] = None\n    discharge_geo_id: Optional[int] = None\n    discharge_name: Optional[str] = None\n    discharge_taxonomy_id: Optional[int] = None\n    discharge_taxonomy: Optional[str] = None\n\n    # discharge 2\n    scraped_discharge2: Optional[str] = None\n    discharge_geo_id2: Optional[int] = None\n    discharge_name2: Optional[str] = None\n    discharge_taxonomy_id2: Optional[int] = None\n    discharge_taxonomy2: Optional[str] = None\n\n    # charterer\n    scraped_charterer: Optional[str] = None\n    charterer_id: Optional[int] = None\n    charterer: Optional[str] = None\n\n    # cargo type\n    scraped_cargo_type: Optional[str] = None\n    cargo_type_id: Optional[int] = None\n    cargo_type: Optional[str] = None\n    cargo_group_id: Optional[int] = None\n    cargo_group: Optional[str] = None\n\n    # quantity\n    scraped_quantity: Optional[str] = None\n    quantity: Optional[float] = None\n    quantity_buffer: Optional[float] = None\n    quantity_from: Optional[float] = None\n    quantity_to: Optional[float] = None\n\n    # rate\n    scraped_rate: Optional[str] = None\n    scraped_rate_options: Optional[str] = None\n    rate_value: Optional[float] = None\n    rate_type: Optional[str] = None\n\n    # demurrage\n    demurrage_rate_value: Optional[float] = None\n    demurrage_rate_type: Optional[str] = None\n\n    # open\n    open_geo_id: Optional[int] = None\n    open_geo_name: Optional[str] = None\n    open_taxonomy_id: Optional[int] = None\n    open_taxonomy: Optional[str] = None\n    open_date: Optional[datetime] = None\n\n    # delivery date\n    scraped_delivery_date: Optional[str] = None\n    delivery_date_from: Optional[datetime] = None\n    delivery_date_to: Optional[datetime] = None\n\n    # delivery\n    scraped_delivery: Optional[str] = None\n    delivery_geo_id: Optional[int] = None\n    delivery_name: Optional[str] = None\n    delivery_taxonomy_id: Optional[int] = None\n    delivery_taxonomy: Optional[str] = None\n\n    # redelivery from\n    scraped_redelivery_from: Optional[str] = None\n    redelivery_from_geo_id: Optional[int] = None\n    redelivery_from_name: Optional[str] = None\n    redelivery_from_taxonomy_id: Optional[int] = None\n    redelivery_from_taxonomy: Optional[str] = None\n\n    # redelivery to\n    scraped_redelivery_to: Optional[str] = None\n    redelivery_to_geo_id: Optional[int] = None\n    redelivery_to_name: Optional[str] = None\n    redelivery_to_taxonomy_id: Optional[int] = None\n    redelivery_to_taxonomy: Optional[str] = None\n\n    # charter type\n    charter_type_id: Optional[int] = None\n    charter_type: Optional[str] = None\n\n    # fixture status\n    fixture_status_id: Optional[int] = None\n    fixture_status: Optional[str] = None\n\n    # broker\n    broker_id: Optional[int] = None\n    broker: Optional[str] = None\n\n    # fixture indicators\n    is_owners_option: Optional[bool] = False\n    is_coa: Optional[bool] = False\n\n    # content\n    content: Optional[str] = None\n    subject: Optional[str] = None\n\n    # sender\n    sender: Optional[str] = None\n\n    # debug info\n    is_private: Optional[bool] = False\n    is_invalidated: Optional[bool] = False\n    is_partial: Optional[bool] = False\n    note: Optional[str] = None\n</code></pre>"},{"location":"scraped_fixtures/#signal_ocean.scraped_fixtures.ScrapedFixturesAPI","title":"<code>ScrapedFixturesAPI</code>","text":"<p>               Bases: <code>ScrapedDataAPI[ScrapedFixturesResponse, ScrapedFixture]</code></p> <p>Represents Signal's Scraped Fixtures API.</p> Source code in <code>signal_ocean/scraped_fixtures/scraped_fixtures_api.py</code> <pre><code>class ScrapedFixturesAPI(\n    ScrapedDataAPI[ScrapedFixturesResponse, ScrapedFixture]\n):\n    \"\"\"Represents Signal's Scraped Fixtures API.\"\"\"\n\n    relative_url = \"scraped-fixtures-api/v6.0/fixtures\"\n    response_class = ScrapedFixturesResponse\n\n    def get_fixtures(\n        self,\n        vessel_type: int,\n        fixture_ids: Optional[List[int]] = None,\n        message_ids: Optional[List[int]] = None,\n        external_message_ids: Optional[List[str]] = None,\n        received_date_from: Optional[datetime] = None,\n        received_date_to: Optional[datetime] = None,\n        updated_date_from: Optional[datetime] = None,\n        updated_date_to: Optional[datetime] = None,\n        imos: Optional[List[int]] = None,\n        include_details: Optional[bool] = True,\n        include_scraped_fields: Optional[bool] = True,\n        include_vessel_details: Optional[bool] = True,\n        include_labels: Optional[bool] = True,\n        include_content: Optional[bool] = True,\n        include_sender: Optional[bool] = True,\n        include_debug_info: Optional[bool] = True,\n    ) -&gt; Tuple[ScrapedFixture, ...]:\n        \"\"\"This function collects and returns the fixtures by the given filters.\n\n        Args:\n            vessel_type: Format - int32. Available values\n                Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n            fixture_ids: List - Comma separated list of FixtureIDs\n            message_ids: List - Comma separated list of MessageIDs\n            external_message_ids: List - Comma separated list of\n                ExternalMessageIDs\n            received_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the fixture received.\n                Cannot be combined with 'Updated' dates\n            received_date_to: Format - date-time (as date-time in RFC3339).\n                Latest date the fixture received.\n                Cannot be combined with 'Updated' dates\n            updated_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the fixture updated.\n                Cannot be combined with 'Received' dates\n            updated_date_to: Format - date-time (as date-time in RFC3339).\n                Latest date the fixture updated.\n                Cannot be combined with 'Received' dates\n            imos: List - Comma separated list of IMOs\n            include_details: Boolean - Whether to include\n                additional fixture details in the response.\n            include_scraped_fields: Boolean - Whether to include the relative\n                scraped fields in the response.\n            include_vessel_details: Boolean - Whether to include some vessel\n                details in the response.\n            include_labels: Boolean - Whether to include the relative labels in\n                the response.\n            include_content: Boolean - Whether to include the original message\n                line (untouched) in the response.\n            include_sender: Boolean - Whether to include some of the message\n                sender details in the response.\n            include_debug_info: Boolean - Whether to include some information\n                about the distribution of the fixture in the response.\n\n        Returns:\n            An Iterable of ScrapedFixture objects, as we have defined in\n            models.py Python file.\n        \"\"\"\n        return self.get_data(\n            vessel_type=vessel_type,\n            fixture_ids=fixture_ids,\n            message_ids=message_ids,\n            external_message_ids=external_message_ids,\n            received_date_from=received_date_from,\n            received_date_to=received_date_to,\n            updated_date_from=updated_date_from,\n            updated_date_to=updated_date_to,\n            imos=imos,\n            include_details=include_details,\n            include_scraped_fields=include_scraped_fields,\n            include_vessel_details=include_vessel_details,\n            include_labels=include_labels,\n            include_content=include_content,\n            include_sender=include_sender,\n            include_debug_info=include_debug_info,\n        )\n\n    def get_fixtures_incremental(\n            self,\n            vessel_type: int,\n            page_token: Optional[str] = None,\n            include_details: Optional[bool] = True,\n            include_scraped_fields: Optional[bool] = True,\n            include_vessel_details: Optional[bool] = True,\n            include_labels: Optional[bool] = True,\n            include_content: Optional[bool] = True,\n            include_sender: Optional[bool] = True,\n            include_debug_info: Optional[bool] = True,\n    ) -&gt; IncrementalDataResponse[ScrapedFixture]:\n        \"\"\"This function collects and returns fixtures.\n\n           Specifically, all the fixtures updated after the given page token.\n           If page token is nullable, function will return all fixtures.\n\n        Args:\n            vessel_type: Format - int32. Available values\n                Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n            page_token: String. The key that should be used as a parameter of\n                the token to retrieve the relevant page.\n            include_details: Boolean - Whether to include\n                additional fixture details in the response.\n            include_scraped_fields: Boolean - Whether to include the relative\n                scraped fields in the response.\n            include_vessel_details: Boolean - Whether to include some vessel\n                details in the response.\n            include_labels: Boolean - Whether to include the relative labels in\n                the response.\n            include_content: Boolean - Whether to include the original message\n                line (untouched) in the response.\n            include_sender: Boolean - Whether to include some of the message\n                sender details in the response.\n            include_debug_info: Boolean - Whether to include some information\n                about the distribution of the fixture in the response.\n\n        Returns:\n            A dictionary containing a tuple of ScrapedFixture objects and\n            NextRequestToken.\n            ScrapedFixture object is defined in models.py Python file.\n            Next Request Token is used as page_token.\n        \"\"\"\n        return self.get_data_incremental(\n            vessel_type=vessel_type,\n            page_token=page_token,\n            include_details=include_details,\n            include_scraped_fields=include_scraped_fields,\n            include_vessel_details=include_vessel_details,\n            include_labels=include_labels,\n            include_content=include_content,\n            include_sender=include_sender,\n            include_debug_info=include_debug_info,\n        )\n\n    def get_fixtures_incremental_token(\n            self,\n            updated_date_from: datetime,\n    ) -&gt; Optional[str]:\n        \"\"\"This function returns a token to use in the incremental fixtures endpoint.\n\n        Args:\n            updated_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the cargo updated.\n                Cannot be combined with 'Received' dates\n\n        Returns:\n            A string containing the corresponding page token to\n            the provided datetime input.\n        \"\"\"\n        return self.get_data_incremental_token(\n            updated_date_from=updated_date_from,\n        )\n</code></pre>"},{"location":"scraped_fixtures/#signal_ocean.scraped_fixtures.ScrapedFixturesAPI.get_fixtures","title":"<code>get_fixtures(vessel_type, fixture_ids=None, message_ids=None, external_message_ids=None, received_date_from=None, received_date_to=None, updated_date_from=None, updated_date_to=None, imos=None, include_details=True, include_scraped_fields=True, include_vessel_details=True, include_labels=True, include_content=True, include_sender=True, include_debug_info=True)</code>","text":"<p>This function collects and returns the fixtures by the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_type</code> <code>int</code> <p>Format - int32. Available values Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6</p> required <code>fixture_ids</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of FixtureIDs</p> <code>None</code> <code>message_ids</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of MessageIDs</p> <code>None</code> <code>external_message_ids</code> <code>Optional[List[str]]</code> <p>List - Comma separated list of ExternalMessageIDs</p> <code>None</code> <code>received_date_from</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the fixture received. Cannot be combined with 'Updated' dates</p> <code>None</code> <code>received_date_to</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Latest date the fixture received. Cannot be combined with 'Updated' dates</p> <code>None</code> <code>updated_date_from</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the fixture updated. Cannot be combined with 'Received' dates</p> <code>None</code> <code>updated_date_to</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Latest date the fixture updated. Cannot be combined with 'Received' dates</p> <code>None</code> <code>imos</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of IMOs</p> <code>None</code> <code>include_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include additional fixture details in the response.</p> <code>True</code> <code>include_scraped_fields</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative scraped fields in the response.</p> <code>True</code> <code>include_vessel_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some vessel details in the response.</p> <code>True</code> <code>include_labels</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative labels in the response.</p> <code>True</code> <code>include_content</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the original message line (untouched) in the response.</p> <code>True</code> <code>include_sender</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some of the message sender details in the response.</p> <code>True</code> <code>include_debug_info</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some information about the distribution of the fixture in the response.</p> <code>True</code> <p>Returns:</p> Type Description <code>ScrapedFixture</code> <p>An Iterable of ScrapedFixture objects, as we have defined in</p> <code>...</code> <p>models.py Python file.</p> Source code in <code>signal_ocean/scraped_fixtures/scraped_fixtures_api.py</code> <pre><code>def get_fixtures(\n    self,\n    vessel_type: int,\n    fixture_ids: Optional[List[int]] = None,\n    message_ids: Optional[List[int]] = None,\n    external_message_ids: Optional[List[str]] = None,\n    received_date_from: Optional[datetime] = None,\n    received_date_to: Optional[datetime] = None,\n    updated_date_from: Optional[datetime] = None,\n    updated_date_to: Optional[datetime] = None,\n    imos: Optional[List[int]] = None,\n    include_details: Optional[bool] = True,\n    include_scraped_fields: Optional[bool] = True,\n    include_vessel_details: Optional[bool] = True,\n    include_labels: Optional[bool] = True,\n    include_content: Optional[bool] = True,\n    include_sender: Optional[bool] = True,\n    include_debug_info: Optional[bool] = True,\n) -&gt; Tuple[ScrapedFixture, ...]:\n    \"\"\"This function collects and returns the fixtures by the given filters.\n\n    Args:\n        vessel_type: Format - int32. Available values\n            Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n        fixture_ids: List - Comma separated list of FixtureIDs\n        message_ids: List - Comma separated list of MessageIDs\n        external_message_ids: List - Comma separated list of\n            ExternalMessageIDs\n        received_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the fixture received.\n            Cannot be combined with 'Updated' dates\n        received_date_to: Format - date-time (as date-time in RFC3339).\n            Latest date the fixture received.\n            Cannot be combined with 'Updated' dates\n        updated_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the fixture updated.\n            Cannot be combined with 'Received' dates\n        updated_date_to: Format - date-time (as date-time in RFC3339).\n            Latest date the fixture updated.\n            Cannot be combined with 'Received' dates\n        imos: List - Comma separated list of IMOs\n        include_details: Boolean - Whether to include\n            additional fixture details in the response.\n        include_scraped_fields: Boolean - Whether to include the relative\n            scraped fields in the response.\n        include_vessel_details: Boolean - Whether to include some vessel\n            details in the response.\n        include_labels: Boolean - Whether to include the relative labels in\n            the response.\n        include_content: Boolean - Whether to include the original message\n            line (untouched) in the response.\n        include_sender: Boolean - Whether to include some of the message\n            sender details in the response.\n        include_debug_info: Boolean - Whether to include some information\n            about the distribution of the fixture in the response.\n\n    Returns:\n        An Iterable of ScrapedFixture objects, as we have defined in\n        models.py Python file.\n    \"\"\"\n    return self.get_data(\n        vessel_type=vessel_type,\n        fixture_ids=fixture_ids,\n        message_ids=message_ids,\n        external_message_ids=external_message_ids,\n        received_date_from=received_date_from,\n        received_date_to=received_date_to,\n        updated_date_from=updated_date_from,\n        updated_date_to=updated_date_to,\n        imos=imos,\n        include_details=include_details,\n        include_scraped_fields=include_scraped_fields,\n        include_vessel_details=include_vessel_details,\n        include_labels=include_labels,\n        include_content=include_content,\n        include_sender=include_sender,\n        include_debug_info=include_debug_info,\n    )\n</code></pre>"},{"location":"scraped_fixtures/#signal_ocean.scraped_fixtures.ScrapedFixturesAPI.get_fixtures_incremental","title":"<code>get_fixtures_incremental(vessel_type, page_token=None, include_details=True, include_scraped_fields=True, include_vessel_details=True, include_labels=True, include_content=True, include_sender=True, include_debug_info=True)</code>","text":"<p>This function collects and returns fixtures.</p> <p>Specifically, all the fixtures updated after the given page token.    If page token is nullable, function will return all fixtures.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_type</code> <code>int</code> <p>Format - int32. Available values Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6</p> required <code>page_token</code> <code>Optional[str]</code> <p>String. The key that should be used as a parameter of the token to retrieve the relevant page.</p> <code>None</code> <code>include_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include additional fixture details in the response.</p> <code>True</code> <code>include_scraped_fields</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative scraped fields in the response.</p> <code>True</code> <code>include_vessel_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some vessel details in the response.</p> <code>True</code> <code>include_labels</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative labels in the response.</p> <code>True</code> <code>include_content</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the original message line (untouched) in the response.</p> <code>True</code> <code>include_sender</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some of the message sender details in the response.</p> <code>True</code> <code>include_debug_info</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some information about the distribution of the fixture in the response.</p> <code>True</code> <p>Returns:</p> Type Description <code>IncrementalDataResponse[ScrapedFixture]</code> <p>A dictionary containing a tuple of ScrapedFixture objects and</p> <code>IncrementalDataResponse[ScrapedFixture]</code> <p>NextRequestToken.</p> <code>IncrementalDataResponse[ScrapedFixture]</code> <p>ScrapedFixture object is defined in models.py Python file.</p> <code>IncrementalDataResponse[ScrapedFixture]</code> <p>Next Request Token is used as page_token.</p> Source code in <code>signal_ocean/scraped_fixtures/scraped_fixtures_api.py</code> <pre><code>def get_fixtures_incremental(\n        self,\n        vessel_type: int,\n        page_token: Optional[str] = None,\n        include_details: Optional[bool] = True,\n        include_scraped_fields: Optional[bool] = True,\n        include_vessel_details: Optional[bool] = True,\n        include_labels: Optional[bool] = True,\n        include_content: Optional[bool] = True,\n        include_sender: Optional[bool] = True,\n        include_debug_info: Optional[bool] = True,\n) -&gt; IncrementalDataResponse[ScrapedFixture]:\n    \"\"\"This function collects and returns fixtures.\n\n       Specifically, all the fixtures updated after the given page token.\n       If page token is nullable, function will return all fixtures.\n\n    Args:\n        vessel_type: Format - int32. Available values\n            Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n        page_token: String. The key that should be used as a parameter of\n            the token to retrieve the relevant page.\n        include_details: Boolean - Whether to include\n            additional fixture details in the response.\n        include_scraped_fields: Boolean - Whether to include the relative\n            scraped fields in the response.\n        include_vessel_details: Boolean - Whether to include some vessel\n            details in the response.\n        include_labels: Boolean - Whether to include the relative labels in\n            the response.\n        include_content: Boolean - Whether to include the original message\n            line (untouched) in the response.\n        include_sender: Boolean - Whether to include some of the message\n            sender details in the response.\n        include_debug_info: Boolean - Whether to include some information\n            about the distribution of the fixture in the response.\n\n    Returns:\n        A dictionary containing a tuple of ScrapedFixture objects and\n        NextRequestToken.\n        ScrapedFixture object is defined in models.py Python file.\n        Next Request Token is used as page_token.\n    \"\"\"\n    return self.get_data_incremental(\n        vessel_type=vessel_type,\n        page_token=page_token,\n        include_details=include_details,\n        include_scraped_fields=include_scraped_fields,\n        include_vessel_details=include_vessel_details,\n        include_labels=include_labels,\n        include_content=include_content,\n        include_sender=include_sender,\n        include_debug_info=include_debug_info,\n    )\n</code></pre>"},{"location":"scraped_fixtures/#signal_ocean.scraped_fixtures.ScrapedFixturesAPI.get_fixtures_incremental_token","title":"<code>get_fixtures_incremental_token(updated_date_from)</code>","text":"<p>This function returns a token to use in the incremental fixtures endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>updated_date_from</code> <code>datetime</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the cargo updated. Cannot be combined with 'Received' dates</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>A string containing the corresponding page token to</p> <code>Optional[str]</code> <p>the provided datetime input.</p> Source code in <code>signal_ocean/scraped_fixtures/scraped_fixtures_api.py</code> <pre><code>def get_fixtures_incremental_token(\n        self,\n        updated_date_from: datetime,\n) -&gt; Optional[str]:\n    \"\"\"This function returns a token to use in the incremental fixtures endpoint.\n\n    Args:\n        updated_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the cargo updated.\n            Cannot be combined with 'Received' dates\n\n    Returns:\n        A string containing the corresponding page token to\n        the provided datetime input.\n    \"\"\"\n    return self.get_data_incremental_token(\n        updated_date_from=updated_date_from,\n    )\n</code></pre>"},{"location":"scraped_lineups/","title":"Package Documentation","text":"<p>Scraped Lineups API Package.</p> <p>Classes:</p> Name Description <code>ScrapedLineupsAPI</code> <p>Represents Signal's Scraped Lineups API.</p> <code>ScrapedLineup</code> <p>Scraped Lineup.</p>"},{"location":"scraped_lineups/#signal_ocean.scraped_lineups.ScrapedLineup","title":"<code>ScrapedLineup</code>  <code>dataclass</code>","text":"<p>Detailed information about a scraped lineup.</p> <p>Attributes:</p> Name Type Description <code>lineup_id</code> <code>int</code> <p>Integer. A unique identifier of the lineup line.</p> <code>message_id</code> <code>Optional[int]</code> <p>Integer. A unique identifier of the message containing the specific lineup. A message can contain more than one lineup.</p> <code>external_message_id</code> <code>Optional[str]</code> <p>String. It serves as a unique identifier for a message, supplied by any company that has integrated with Signal.</p> <code>parsed_part_id</code> <code>Optional[int]</code> <p>Integer. A unique identifier for each email part. The email body and each attachment are considered different parsed parts. For an example the email body and its pdf attachment have same MessageID and different ParsedPartID.</p> <code>line_from</code> <code>Optional[int]</code> <p>Nullable integer. The starting line from which the lineup is extracted. The email subject counts as line 0 and the body content starts from line 1.</p> <code>line_to</code> <code>Optional[int]</code> <p>Nullable integer. The final line from which the lineup is extracted. For single line lineups LineFrom is equal to LineTo. For descriptive lineups that span across multiple lines we have LineTo&gt;LineFrom. These two numbers help the user identify which part of the text has been used to extract the lineup data.</p> <code>in_line_order</code> <code>Optional[int]</code> <p>Nullable integer. This integer is used to list different cargoes extracted from the same line. It is the case for lineups with multiple cargoes or buyers. A lineup with two cargoes like 'gasoil + fuel oil' is interpreted in our system as 2 lineups with same MessageID, same ParsedPartID, same LineNumber,  same IMO, different LineupID and an incremental InLineOrder number.</p> <code>source</code> <code>Optional[str]</code> <p>String. It describes the source of the information. Our system allows the user to inject data in many different ways, namely through email (Source='Email'), through Slack channels (Source='Slack') or through manual contributions directly from our frontend platform TSOP (Source='User').</p> <code>updated_date</code> <code>Optional[datetime]</code> <p>String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on which the lineup has been reevaluated for the last time. In case of an email received by a broker one month ago and reprocessed through our engine today, this date will be today's.</p> <code>received_date</code> <code>Optional[datetime]</code> <p>String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on which the lineup has been injected into our system and processed.</p> <code>is_deleted</code> <code>Optional[bool]</code> <p>Boolean. This value is true if the lineup is marked as Deleted.</p> <code>low_confidence</code> <code>Optional[bool]</code> <p>Boolean. This value is true when the data extraction process does not return as output some fields that we believe to be more important than others in business terms. These fields are called critical fields. The value is true if at least one of the critical fields is missing.For example missing charterer or laycan.</p> <code>scraped_vessel_name</code> <code>Optional[str]</code> <p>String. The vessel name as reported in the lineup line, i.e. 'Signal Alpha', 'Cpt A Stellatos', 'Genco Tiberius'. 'TBN' can also be found.</p> <code>scraped_imo</code> <code>Optional[str]</code> <p>String. Vessel's IMO as reported in the lineup line, i.e. '9412036', '9439670', '9331555'.</p> <code>scraped_deadweight</code> <code>Optional[str]</code> <p>String. The dead weight of the vessel as reported in the lineup line, i.e. '150249', '167'.</p> <code>scraped_year_built</code> <code>Optional[str]</code> <p>String. The year built of the vessel as reported in the lineup line, i.e. '2004', '09'.</p> <code>imo</code> <code>Optional[int]</code> <p>Integer. The seven-digits number that uniquely identifies the ship reported in the lineup. It is the result of our internally developed Vessel Mapper model.</p> <code>vessel_name</code> <code>Optional[str]</code> <p>String. It is the current vessel name corresponding to the IMO mentioned above. Provided to better specify the vessel and its particulars. Source: our internal Vessel Database.</p> <code>deadweight</code> <code>Optional[int]</code> <p>Integer. The dead weight in tonnes [t] corresponding to the IMO mentioned above.</p> <code>year_built</code> <code>Optional[int]</code> <p>Integer, YYYY format. The year the vessel was built. Source: our internal Vessel Database.</p> <code>liquid_capacity</code> <code>Optional[int]</code> <p>Integer, measured in cbm [cbm]. The liquid capacity of the IMO mentioned above. Source: our internal Vessel Database.</p> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the different values of the VesselType field. 1-&gt; Tanker, 3-&gt; Dry, 4 -&gt; Containers, 5 -&gt;LNG (Liquified Natural gas), 6-&gt; LPG (Liquified Petroleum Gas).</p> <code>vessel_type</code> <code>Optional[str]</code> <p>String. Description of the type of the vessel (VesselTypeID), based on the carried cargo. Main categories are Tankers, Dry (bulk carriers), Containers, LNG and LPG.</p> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Integer. It is an ID corresponding to the different vessel classes of a certain vessel type, as split according to our internal Vessel Database. For example 84-&gt;VLCC, 85-&gt;Suezmax, 70-&gt;Capesize.</p> <code>vessel_class</code> <code>Optional[str]</code> <p>String. Name of the vessel class the vessel belongs to. Assignment of a vessel to a certain VesselClass is based on the VesselType and the value of its Deadweight (if Tanker or Dry), its LiquidCap (if LNG/LPG) or its TEU (if Containers). For example, an Aframax is a Tanker vessel with Deadweight within the range 82kt - 125kt, while a Capesize is a Dry vessel with Deadweight within the range 120kt-220kt. LR2 are defined as Aframax, as only Deadweight is used to define vessel classes.</p> <code>commercial_operator_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the current maritime company that commercially manages the vessel corresponding to the IMO mentioned above. Source: Signal's proprietary algorithm.</p> <code>commercial_operator</code> <code>Optional[str]</code> <p>String. Name of the current maritime company associated to CommercialOperatorID. Source: our internal Companies Database.</p> <code>scraped_eta</code> <code>Optional[str]</code> <p>String. The estimated time of arrival of the lineup as reported in the original text.</p> <code>eta</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the estimated time of arrival date.</p> <code>scraped_etb</code> <code>Optional[str]</code> <p>String. The estimated time of berthing of the lineup as reported in the original text. Strings tba (to be announced) and tbc (to be confirmed) can also be found.</p> <code>etb</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the estimated time of berthing date.</p> <code>scraped_etd</code> <code>Optional[str]</code> <p>String. The estimated time of departure of the lineup as reported in the original text. Strings tba (to be announced) and tbc (to be confirmed) can also be found.</p> <code>etd</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the estimated time of departure date.</p> <code>scraped_location</code> <code>Optional[str]</code> <p>String. The location reported in the original text of the lineup. Also, It could be reported in the subject of email.</p> <code>location_geo_id</code> <code>Optional[int]</code> <p>Integer. It is the internal ID of the mapped location reported in the lineup. Our models convert and map a scraped string containing geo information to a specific entity of the Signal's proprietary geofencing structure. Each geo entity is identified by a taxonomy, an ID and a name. Examples: the string 'turkmenbashi' is mapped to a geo asset with name 'Turkmenbashi Refinery', ID 5086 and taxonomy GoeAsset (TaxonomyID=1); the string 'murmansk' is mapped to a geoasset with name 'Murmansk', ID 3761 and taxonomy Port (TaxonomyID=2); the string 'congo' is mapped to a geoasset with name 'Congo', ID 49 and taxonomy Country (TaxonomyID=3).</p> <code>location_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the reported location of the lineup. Examples: 'Qingdao', 'Nigeria', 'Yangpu', 'Quanzhou'.</p> <code>location_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to each taxonomy, the level of geo details, from 1 to 7. A terminal (geoasset) has the lowest taxonomy (TaxonomyID=1), a port has TaxonomyID=2, while countries and wider areas have higher taxonomy (TaxonomyID&gt;=3). Examples of Level 0 areas (TaxonomyID=4) include 'Arabian Gulf', 'US Gulf' and 'East Mediterranean'. Level 1 areas (TaxonomyID=5) consist of multiple level 0 areas (TaxonomyID=4). For example, level 1 area 'Mediterranean' groups together the level 0 areas 'West Mediterranean', 'Central Mediterranean' and 'East Mediterranean'. Level 2 areas (TaxonomyID=6) consist of multiple level 1 areas (TaxonomyID=4). For example, level 2 area 'Mediterranean/UK Continent' groups together the 'Mediterranean' and 'UK Continent' level 1 areas. Level 3 areas (TaxonomyID=7) are the highest area grouping in our taxonomy and consist of multiple level 2 areas (TaxonomyID=6). Examples of such areas are 'Pacific America' or 'Africa'. These group together level 2 areas. For instance, 'Pacific America' groups together the level 2 areas  West Coast North America', 'West Coast Mexico', 'West Coast Central America' and 'West Coast South America'.</p> <code>location_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>operation_type_id</code> <code>Optional[int]</code> <p>Interger. Numeric ID corresponding to the different values of the OperationType field. 1-&gt; Loading, 2-&gt; Discharge, 3 -&gt; Waypoint, -2 -&gt; NotSet, -1 -&gt; Unknown.</p> <code>operation_type</code> <code>Optional[str]</code> <p>String. Denotes the operation type of the lineup if explicitly mentioned, like 'loading' for load.</p> <code>scraped_quantity</code> <code>Optional[str]</code> <p>String. The quantity as reported in the original text of the lineup.</p> <code>quantity</code> <code>Optional[float]</code> <p>Integer. The mapped quantity measured in the corresponding value of QuantityUnit filed.</p> <code>quantity_unit</code> <code>Optional[str]</code> <p>String. Denotes the quantity unit of the lineup. 1-&gt; Tonnes, 2-&gt; Barrels, -2 -&gt; NotSet, -1 -&gt; Unknown.</p> <code>scraped_cargo_type</code> <code>Optional[str]</code> <p>String. The cargo type of the cargo as reported in the original text, often shortened. Examples: 'nhc', 'ulsd', 'ums', 'nap', 'go'.</p> <code>cargo_type_id</code> <code>Optional[int]</code> <p>Integer. It is an internal ID corresponding to the mapped cargo type of the cargo. A proprietary model is responsible to match the reported cargo string to a specific cargo type in our hierarchy. Examples: 19-&gt; Crude Oil, 16-&gt;Fueloil, 9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil, 60-&gt; 'Ultra Low Sulphur Diesel (ULSD 10ppm)'.</p> <code>cargo_type</code> <code>Optional[str]</code> <p>String. The extended name corresponding to the CargoTypeID field. Source: our internal CargoTypes database.</p> <code>cargo_group_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the high-level cargo type of the reported cargo type. It is provided to group cargoes and facilitate analytics. Examples: 130000-&gt;Dirty, 120000-&gt;Clean, 110000-&gt;IMO.</p> <code>cargo_group</code> <code>Optional[str]</code> <p>String. The extended name corresponding to the CargoGroupID field. Source: our internal CargoTypes database.</p> <code>scraped_api_gravity</code> <code>Optional[str]</code> <p>String. The API gravity reported in the original text on the lineup.</p> <code>api_gravity</code> <code>Optional[int]</code> <p>Numeric. The mapped value corresponding to the API gravity.</p> <code>scraped_origin</code> <code>Optional[str]</code> <p>String. The origin location reported in the original text of the lineup.</p> <code>origin_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped origin location of the lineup. See LocationGeoID for more details.</p> <code>origin_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the reported origin location of the lineup. Examples: 'Fuel Pier', 'Port Of Arzew Terminal 2', 'CPC (Novorossiysk) SBM', 'Sheskharis Oil Terminal'.</p> <code>origin_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped origin location. See LocationTaxonomyID for more details.</p> <code>origin_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_destination</code> <code>Optional[str]</code> <p>String. The destination location reported in the original text of the lineup. Strings tba (to be announced) and tbn (to be nominated) can also be found</p> <code>destination_geo_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the mapped destination location of the lineup. See LocationGeoID for more details.</p> <code>destination_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the reported destination location of the lineup. Examples: 'Fuel Pier', 'Port Of Arzew Terminal 2', 'CPC (Novorossiysk) SBM', 'Sheskharis Oil Terminal'.</p> <code>destination_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to the taxonomy of the mapped destination location. See LocationTaxonomyID for more details.</p> <code>destination_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_supplier</code> <code>Optional[str]</code> <p>String. The supplier as reported in the original text of the lineup.</p> <code>supplier_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the supplier company that it is reported in the line. We use an internal mapper to find the correspondence between the reported string and our database.</p> <code>supplier</code> <code>Optional[str]</code> <p>String. The company name corresponding to the SupplierID field. Provided to better specify the company involved in the business. Source: our internal Company Database.</p> <code>scraped_charterer</code> <code>Optional[str]</code> <p>String. The charterer as reported in the original text of the lineup.</p> <code>charterer_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the chartering company that it is reported in the line. We use an internal mapper to find the correspondence between the reported string and our database.</p> <code>charterer</code> <code>Optional[str]</code> <p>String. The company name corresponding to the ChartererID field. Provided to better specify the company involved in the business. Source: our internal Company Database.</p> <code>scraped_buyer</code> <code>Optional[str]</code> <p>String. The buyer as reported in the original text of the lineup.</p> <code>buyer_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the buyer company that it is reported in the line. We use an internal mapper to find the correspondence between the reported string and our database.</p> <code>buyer</code> <code>Optional[str]</code> <p>String. The company name corresponding to the BuyerID field. Provided to better specify the company involved in the business. Source: our internal Company Database.</p> <code>scraped_port_agent</code> <code>Optional[str]</code> <p>String. The port agent as reported in the original text of the lineup.</p> <code>port_agent_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the port agent company that it is reported in the line.</p> <code>port_agent</code> <code>Optional[str]</code> <p>String. The company name corresponding to the PortAgentID field. Provided to better specify the company involved in the business. Source: our internal Company Database.</p> <code>vessel_status_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the different values of the VesselStatus field. 1-&gt; Expected, 2-&gt; Arrived, 3-&gt; At anchor, 4-&gt; At berth, 5-&gt; Sailed, 6-&gt; Failed, 7-&gt; Cancelled, 8-&gt; Substituted, -2 -&gt; NotSet, -1 -&gt; Unknown.</p> <code>vessel_status</code> <code>Optional[str]</code> <p>String denoting the vessel status of a lineup if explicitly mentioned, like 'expected for expected or 'waiting' for at anchor.</p> <code>content</code> <code>Optional[str]</code> <p>String. The full content of the lineup. For a single line lineup it is the line content. For multi line lineups it is the collection of all the relevant parts of the text.</p> <code>subject</code> <code>Optional[str]</code> <p>String. The email subject of the lineup. This field has content when Source='Email'.</p> <code>sender</code> <code>Optional[str]</code> <p>String. Our own mapping of the shipping company sending out the market report through email. This string helps grouping emails sent by the same organization, but from different domains. It is often the case for big organizations operating worldwide. For example Sender= 'SSY' for both domains 'ssysin.com' and 'ssy.co'.</p> <code>is_private</code> <code>Optional[bool]</code> <p>Boolean. A lineup is private if injected by a user into his own private account within TSOP. A user can provide private information through email forwarding or through Slack. Private lineup information stay in the account, are accessible by the account users only (people within the same company) and are the most valuable ones.</p> Source code in <code>signal_ocean/scraped_lineups/models.py</code> <pre><code>@dataclass(frozen=True)\nclass ScrapedLineup:\n    \"\"\"Detailed information about a scraped lineup.\n\n    Attributes:\n        lineup_id: Integer. A unique identifier of the lineup line.\n        message_id: Integer. A unique identifier of the message containing the\n            specific lineup. A message can contain more than one lineup.\n        external_message_id: String. It serves as a unique identifier for a\n            message, supplied by any company that has integrated with Signal.\n        parsed_part_id: Integer. A unique identifier for each email part. The\n            email body and each attachment are considered different parsed\n            parts. For an example the email body and its pdf attachment have\n            same MessageID and different ParsedPartID.\n        line_from: Nullable integer. The starting line from which the lineup\n            is extracted. The email subject counts as line 0 and the body\n            content starts from line 1.\n        line_to: Nullable integer. The final line from which the lineup is\n            extracted. For single line lineups LineFrom is equal to LineTo.\n            For descriptive lineups that span across multiple lines we have\n            LineTo&gt;LineFrom. These two numbers help the user identify which\n            part of the text has been used to extract the lineup data.\n        in_line_order: Nullable integer. This integer is used to list different\n            cargoes extracted from the same line. It is the case for lineups\n            with multiple cargoes or buyers. A lineup with two cargoes like\n            'gasoil + fuel oil' is interpreted in our system as 2 lineups with\n            same MessageID, same ParsedPartID, same LineNumber,  same IMO,\n            different LineupID and an incremental InLineOrder number.\n        source: String. It describes the source of the information. Our system\n            allows the user to inject data in many different ways, namely\n            through email (Source='Email'), through Slack channels\n            (Source='Slack') or through manual contributions directly from\n            our frontend platform TSOP (Source='User').\n        updated_date: String, format YYYY-MM-DD HH:MM:SS, UTC timezone.\n            Date on which the lineup has been reevaluated for the last time.\n            In case of an email received by a broker one month ago and\n            reprocessed through our engine today, this date will be today's.\n        received_date: String, format YYYY-MM-DD HH:MM:SS, UTC timezone.\n            Date on which the lineup has been injected into our system\n            and processed.\n        is_deleted: Boolean. This value is true if the lineup is marked as\n            Deleted.\n        low_confidence: Boolean. This value is true when the data extraction\n            process does not return as output some fields that we believe to\n            be more important than others in business terms. These fields are\n            called critical fields. The value is true if at least one of the\n            critical fields is missing.For example missing charterer or laycan.\n        scraped_vessel_name: String. The vessel name as reported in the lineup\n            line, i.e. 'Signal Alpha', 'Cpt A Stellatos', 'Genco Tiberius'.\n            'TBN' can also be found.\n        scraped_imo: String. Vessel's IMO as reported in the lineup line,\n            i.e. '9412036', '9439670', '9331555'.\n        scraped_deadweight: String. The dead weight of the vessel as reported\n            in the lineup line, i.e. '150249', '167'.\n        scraped_year_built: String. The year built of the vessel as reported\n            in the lineup line, i.e. '2004', '09'.\n        imo: Integer. The seven-digits number that uniquely identifies the\n            ship reported in the lineup. It is the result of our internally\n            developed Vessel Mapper model.\n        vessel_name: String. It is the current vessel name corresponding to\n            the IMO mentioned above. Provided to better specify the vessel and\n            its particulars. Source: our internal Vessel Database.\n        deadweight: Integer. The dead weight in tonnes [t] corresponding to\n            the IMO mentioned above.\n        year_built: Integer, YYYY format. The year the vessel was built.\n            Source: our internal Vessel Database.\n        liquid_capacity: Integer, measured in cbm [cbm]. The liquid capacity\n            of the IMO mentioned above. Source: our internal Vessel Database.\n        vessel_type_id: Integer. Numeric ID corresponding to the different\n            values of the VesselType field. 1-&gt; Tanker, 3-&gt; Dry,\n            4 -&gt; Containers, 5 -&gt;LNG (Liquified Natural gas),\n            6-&gt; LPG (Liquified Petroleum Gas).\n        vessel_type: String. Description of the type of the vessel\n            (VesselTypeID), based on the carried cargo. Main categories are\n            Tankers, Dry (bulk carriers), Containers, LNG and LPG.\n        vessel_class_id: Integer. It is an ID corresponding to the different\n            vessel classes of a certain vessel type, as split according\n            to our internal Vessel Database.\n            For example 84-&gt;VLCC, 85-&gt;Suezmax, 70-&gt;Capesize.\n        vessel_class: String. Name of the vessel class the vessel belongs to.\n            Assignment of a vessel to a certain VesselClass is based on the\n            VesselType and the value of its Deadweight (if Tanker or Dry),\n            its LiquidCap (if LNG/LPG) or its TEU (if Containers).\n            For example, an Aframax is a Tanker vessel with Deadweight within\n            the range 82kt - 125kt, while a Capesize is a Dry vessel with\n            Deadweight within the range 120kt-220kt. LR2 are defined\n            as Aframax, as only Deadweight is used to define vessel classes.\n        commercial_operator_id: Integer. Numeric ID corresponding to the\n            current maritime company that commercially manages the vessel\n            corresponding to the IMO mentioned above.\n            Source: Signal's proprietary algorithm.\n        commercial_operator: String. Name of the current maritime company\n            associated to CommercialOperatorID.\n            Source: our internal Companies Database.\n        scraped_eta: String. The estimated time of arrival of the lineup as\n            reported in the original text.\n        eta: Date, format YYYY-MM-DD. The mapped date corresponding to the\n            estimated time of arrival date.\n        scraped_etb: String. The estimated time of berthing of the lineup as\n            reported in the original text. Strings tba (to be announced) and\n            tbc (to be confirmed) can also be found.\n        etb: Date, format YYYY-MM-DD. The mapped date corresponding to the\n            estimated time of berthing date.\n        scraped_etd: String. The estimated time of departure of the lineup as\n            reported in the original text. Strings tba (to be announced) and\n            tbc (to be confirmed) can also be found.\n        etd: Date, format YYYY-MM-DD. The mapped date corresponding to the\n            estimated time of departure date.\n        scraped_location: String. The location reported in the original text\n            of the lineup. Also, It could be reported in the subject of email.\n        location_geo_id: Integer. It is the internal ID of the mapped location\n            reported in the lineup. Our models convert and map a scraped string\n            containing geo information to a specific entity of the Signal's\n            proprietary geofencing structure. Each geo entity is identified by\n            a taxonomy, an ID and a name. Examples: the string 'turkmenbashi'\n            is mapped to a geo asset with name 'Turkmenbashi Refinery', ID\n            5086 and taxonomy GoeAsset (TaxonomyID=1); the string 'murmansk' is\n            mapped to a geoasset with name 'Murmansk', ID 3761 and taxonomy\n            Port (TaxonomyID=2); the string 'congo' is mapped to a geoasset\n            with name 'Congo', ID 49 and taxonomy Country (TaxonomyID=3).\n        location_name: String. The name of the Signal geo entity related to\n            the reported location of the lineup. Examples: 'Qingdao',\n            'Nigeria', 'Yangpu', 'Quanzhou'.\n        location_taxonomy_id: Integer. An internal ID corresponding to each\n            taxonomy, the level of geo details, from 1 to 7. A terminal\n            (geoasset) has the lowest taxonomy (TaxonomyID=1), a port has\n            TaxonomyID=2, while countries and wider areas have higher taxonomy\n            (TaxonomyID&gt;=3). Examples of Level 0 areas (TaxonomyID=4) include\n            'Arabian Gulf', 'US Gulf' and 'East Mediterranean'. Level 1 areas\n            (TaxonomyID=5) consist of multiple level 0 areas (TaxonomyID=4).\n            For example, level 1 area 'Mediterranean' groups together the\n            level 0 areas 'West Mediterranean', 'Central Mediterranean' and\n            'East Mediterranean'. Level 2 areas (TaxonomyID=6) consist of\n            multiple level 1 areas (TaxonomyID=4). For example, level 2 area\n            'Mediterranean/UK Continent' groups together the 'Mediterranean'\n            and 'UK Continent' level 1 areas. Level 3 areas (TaxonomyID=7) are\n            the highest area grouping in our taxonomy and consist of multiple\n            level 2 areas (TaxonomyID=6). Examples of such areas are\n            'Pacific America' or 'Africa'. These group together level 2 areas.\n            For instance, 'Pacific America' groups together the level 2 areas\n             West Coast North America', 'West Coast Mexico',\n            'West Coast Central America' and 'West Coast South America'.\n        location_taxonomy: String. The extended name identifying the\n            TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2,\n            Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        operation_type_id: Interger. Numeric ID corresponding to the different\n            values of the OperationType field. 1-&gt; Loading, 2-&gt; Discharge,\n            3 -&gt; Waypoint, -2 -&gt; NotSet, -1 -&gt; Unknown.\n        operation_type: String. Denotes the operation type of the lineup if\n            explicitly mentioned, like 'loading' for load.\n        scraped_quantity: String. The quantity as reported in the original\n            text of the lineup.\n        quantity: Integer. The mapped quantity measured in the corresponding\n            value of QuantityUnit filed.\n        quantity_unit: String. Denotes the quantity unit of the lineup.\n            1-&gt; Tonnes, 2-&gt; Barrels, -2 -&gt; NotSet, -1 -&gt; Unknown.\n        scraped_cargo_type: String. The cargo type of the cargo as reported in\n            the original text, often shortened. Examples: 'nhc', 'ulsd',\n            'ums', 'nap', 'go'.\n        cargo_type_id: Integer. It is an internal ID corresponding to the\n            mapped cargo type of the cargo. A proprietary model is responsible\n            to match the reported cargo string to a specific cargo type in our\n            hierarchy. Examples: 19-&gt; Crude Oil, 16-&gt;Fueloil, 9-&gt; Naphtha,\n            135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil,\n            60-&gt; 'Ultra Low Sulphur Diesel (ULSD 10ppm)'.\n        cargo_type: String. The extended name corresponding to the CargoTypeID\n            field. Source: our internal CargoTypes database.\n        cargo_group_id: Integer. Numeric ID corresponding to the high-level\n            cargo type of the reported cargo type. It is provided to group\n            cargoes and facilitate analytics. Examples: 130000-&gt;Dirty,\n            120000-&gt;Clean, 110000-&gt;IMO.\n        cargo_group: String. The extended name corresponding to the\n            CargoGroupID field. Source: our internal CargoTypes database.\n        scraped_api_gravity: String. The API gravity reported in the original\n            text on the lineup.\n        api_gravity: Numeric. The mapped value corresponding to the API\n            gravity.\n        scraped_origin: String. The origin location reported in the original\n            text of the lineup.\n        origin_geo_id: Integer. An internal ID corresponding to the mapped\n            origin location of the lineup. See LocationGeoID for more details.\n        origin_name: String. The name of the Signal geo entity related to the\n            reported origin location of the lineup. Examples: 'Fuel Pier',\n            'Port Of Arzew Terminal 2', 'CPC (Novorossiysk) SBM',\n            'Sheskharis Oil Terminal'.\n        origin_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped origin location. See LocationTaxonomyID\n            for more details.\n        origin_taxonomy: String. The extended name identifying the TaxonomyID.\n            Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3,\n            Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_destination: String. The destination location reported in the\n            original text of the lineup. Strings tba (to be announced) and tbn\n            (to be nominated) can also be found\n        destination_geo_id: Integer. An internal ID corresponding to the\n            mapped destination location of the lineup. See LocationGeoID for\n            more details.\n        destination_name: String. The name of the Signal geo entity related to\n            the reported destination location of the lineup. Examples:\n            'Fuel Pier', 'Port Of Arzew Terminal 2',\n            'CPC (Novorossiysk) SBM', 'Sheskharis Oil Terminal'.\n        destination_taxonomy_id: Integer. An internal ID corresponding to the\n            taxonomy of the mapped destination location.\n            See LocationTaxonomyID for more details.\n        destination_taxonomy: String. The extended name identifying the\n            TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2,\n            Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_supplier: String. The supplier as reported in the original\n            text of the lineup.\n        supplier_id: Integer. Numeric ID corresponding to the supplier company\n            that it is reported in the line. We use an internal mapper to find\n            the correspondence between the reported string and our database.\n        supplier: String. The company name corresponding to the SupplierID\n            field. Provided to better specify the company involved in the\n            business. Source: our internal Company Database.\n        scraped_charterer: String. The charterer as reported in the original\n            text of the lineup.\n        charterer_id: Integer. Numeric ID corresponding to the chartering\n            company that it is reported in the line. We use an internal mapper\n            to find the correspondence between the reported string and our\n            database.\n        charterer: String. The company name corresponding to the ChartererID\n            field. Provided to better specify the company involved in the\n            business. Source: our internal Company Database.\n        scraped_buyer: String. The buyer as reported in the original text of\n            the lineup.\n        buyer_id: Integer. Numeric ID corresponding to the buyer company that\n            it is reported in the line. We use an internal mapper to find the\n            correspondence between the reported string and our database.\n        buyer: String. The company name corresponding to the BuyerID field.\n            Provided to better specify the company involved in the business.\n            Source: our internal Company Database.\n        scraped_port_agent: String. The port agent as reported in the original\n            text of the lineup.\n        port_agent_id: Integer. Numeric ID corresponding to the port agent\n            company that it is reported in the line.\n        port_agent: String. The company name corresponding to the PortAgentID\n            field. Provided to better specify the company involved in the\n            business. Source: our internal Company Database.\n        vessel_status_id: Integer. Numeric ID corresponding to the different\n            values of the VesselStatus field. 1-&gt; Expected, 2-&gt; Arrived,\n            3-&gt; At anchor, 4-&gt; At berth, 5-&gt; Sailed, 6-&gt; Failed,\n            7-&gt; Cancelled, 8-&gt; Substituted, -2 -&gt; NotSet, -1 -&gt; Unknown.\n        vessel_status: String denoting the vessel status of a lineup if\n            explicitly mentioned, like 'expected for expected or 'waiting' for\n            at anchor.\n        content: String. The full content of the lineup. For a single line\n            lineup it is the line content. For multi line lineups it is the\n            collection of all the relevant parts of the text.\n        subject: String. The email subject of the lineup. This field has\n            content when Source='Email'.\n        sender: String. Our own mapping of the shipping company sending out the\n            market report through email. This string helps grouping emails\n            sent by the same organization, but from different domains. It is\n            often the case for big organizations operating worldwide. For\n            example Sender= 'SSY' for both domains 'ssysin.com' and 'ssy.co'.\n        is_private: Boolean. A lineup is private if injected by a user into\n            his own private account within TSOP. A user can provide private\n            information through email forwarding or through Slack.\n            Private lineup information stay in the account, are accessible by\n            the account users only (people within the same company) and are\n            the most valuable ones.\n    \"\"\"\n\n    # entity details\n    lineup_id: int\n    message_id: Optional[int] = None\n    external_message_id: Optional[str] = None\n    parsed_part_id: Optional[int] = None\n    line_from: Optional[int] = None\n    line_to: Optional[int] = None\n    in_line_order: Optional[int] = None\n    source: Optional[str] = None\n    updated_date: Optional[datetime] = None\n    received_date: Optional[datetime] = None\n    is_deleted: Optional[bool] = False\n    low_confidence: Optional[bool] = False\n\n    # vessel\n    scraped_vessel_name: Optional[str] = None\n    scraped_imo: Optional[str] = None\n    scraped_deadweight: Optional[str] = None\n    scraped_year_built: Optional[str] = None\n    imo: Optional[int] = None\n    vessel_name: Optional[str] = None\n    deadweight: Optional[int] = None\n    year_built: Optional[int] = None\n    liquid_capacity: Optional[int] = None\n    vessel_type_id: Optional[int] = None\n    vessel_type: Optional[str] = None\n    vessel_class_id: Optional[int] = None\n    vessel_class: Optional[str] = None\n    commercial_operator_id: Optional[int] = None\n    commercial_operator: Optional[str] = None\n\n    # eta\n    scraped_eta: Optional[str] = None\n    eta: Optional[datetime] = None\n\n    # etb\n    scraped_etb: Optional[str] = None\n    etb: Optional[datetime] = None\n\n    # etd\n    scraped_etd: Optional[str] = None\n    etd: Optional[datetime] = None\n\n    # location\n    scraped_location: Optional[str] = None\n    location_geo_id: Optional[int] = None\n    location_name: Optional[str] = None\n    location_taxonomy_id: Optional[int] = None\n    location_taxonomy: Optional[str] = None\n\n    # operation_type\n    operation_type_id: Optional[int] = None\n    operation_type: Optional[str] = None\n\n    # quantity\n    scraped_quantity: Optional[str] = None\n    quantity: Optional[float] = None\n    quantity_unit: Optional[str] = None\n\n    # cargo type\n    scraped_cargo_type: Optional[str] = None\n    cargo_type_id: Optional[int] = None\n    cargo_type: Optional[str] = None\n    cargo_group_id: Optional[int] = None\n    cargo_group: Optional[str] = None\n\n    # api_gravity\n    scraped_api_gravity: Optional[str] = None\n    api_gravity: Optional[int] = None\n\n    # origin\n    scraped_origin: Optional[str] = None\n    origin_geo_id: Optional[int] = None\n    origin_name: Optional[str] = None\n    origin_taxonomy_id: Optional[int] = None\n    origin_taxonomy: Optional[str] = None\n\n    # destination\n    scraped_destination: Optional[str] = None\n    destination_geo_id: Optional[int] = None\n    destination_name: Optional[str] = None\n    destination_taxonomy_id: Optional[int] = None\n    destination_taxonomy: Optional[str] = None\n\n    # supplier\n    scraped_supplier: Optional[str] = None\n    supplier_id: Optional[int] = None\n    supplier: Optional[str] = None\n\n    # charterer\n    scraped_charterer: Optional[str] = None\n    charterer_id: Optional[int] = None\n    charterer: Optional[str] = None\n\n    # buyer\n    scraped_buyer: Optional[str] = None\n    buyer_id: Optional[int] = None\n    buyer: Optional[str] = None\n\n    # port agent\n    scraped_port_agent: Optional[str] = None\n    port_agent_id: Optional[int] = None\n    port_agent: Optional[str] = None\n\n    # vessel status\n    vessel_status_id: Optional[int] = None\n    vessel_status: Optional[str] = None\n\n    # content\n    content: Optional[str] = None\n    subject: Optional[str] = None\n\n    # sender\n    sender: Optional[str] = None\n\n    # debug info\n    is_private: Optional[bool] = False\n</code></pre>"},{"location":"scraped_lineups/#signal_ocean.scraped_lineups.ScrapedLineupsAPI","title":"<code>ScrapedLineupsAPI</code>","text":"<p>               Bases: <code>ScrapedDataAPI[ScrapedLineupsResponse, ScrapedLineup]</code></p> <p>Represents Signal's Scraped Lineups API.</p> Source code in <code>signal_ocean/scraped_lineups/scraped_lineups_api.py</code> <pre><code>class ScrapedLineupsAPI(ScrapedDataAPI[ScrapedLineupsResponse, ScrapedLineup]):\n    \"\"\"Represents Signal's Scraped Lineups API.\"\"\"\n\n    relative_url = \"scraped-lineups-api/v6.0/lineups\"\n    response_class = ScrapedLineupsResponse\n\n    def get_lineups(\n        self,\n        vessel_type: int,\n        lineup_ids: Optional[List[int]] = None,\n        message_ids: Optional[List[int]] = None,\n        external_message_ids: Optional[List[str]] = None,\n        received_date_from: Optional[datetime] = None,\n        received_date_to: Optional[datetime] = None,\n        updated_date_from: Optional[datetime] = None,\n        updated_date_to: Optional[datetime] = None,\n        imos: Optional[List[int]] = None,\n        include_details: Optional[bool] = True,\n        include_scraped_fields: Optional[bool] = True,\n        include_vessel_details: Optional[bool] = True,\n        include_labels: Optional[bool] = True,\n        include_content: Optional[bool] = True,\n        include_sender: Optional[bool] = True,\n        include_debug_info: Optional[bool] = True,\n    ) -&gt; Tuple[ScrapedLineup, ...]:\n        \"\"\"This function collects and returns the lineups by the given filters.\n\n        Args:\n            vessel_type: Format - int32. Available values\n                Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n            lineup_ids: List - Comma separated list of LineupIDs\n            message_ids: List - Comma separated list of MessageIDs\n            external_message_ids: List - Comma separated list of\n                ExternalMessageIDs\n            received_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the lineup received.\n                Cannot be combined with 'Updated' dates\n            received_date_to: Format - date-time (as date-time in RFC3339).\n                Latest date the lineup received.\n                Cannot be combined with 'Updated' dates\n            updated_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the lineup updated.\n                Cannot be combined with 'Received' dates\n            updated_date_to: Format - date-time (as date-time in RFC3339).\n                Latest date the lineup updated.\n                Cannot be combined with 'Received' dates\n            imos: List - Comma separated list of IMOs\n            include_details: Boolean - Whether to include\n                additional lineup details in the response.\n            include_scraped_fields: Boolean - Whether to include the relative\n                scraped fields in the response.\n            include_vessel_details: Boolean - Whether to include some vessel\n                details in the response.\n            include_labels: Boolean - Whether to include the relative labels in\n                the response.\n            include_content: Boolean - Whether to include the original message\n                line (untouched) in the response.\n            include_sender: Boolean - Whether to include some of the message\n                sender details in the response.\n            include_debug_info: Boolean - Whether to include some information\n                about the distribution of the lineup in the response.\n\n        Returns:\n            An Iterable of ScrapedLineup objects, as we have defined in\n            models.py Python file.\n        \"\"\"\n        return self.get_data(\n            vessel_type=vessel_type,\n            lineup_ids=lineup_ids,\n            message_ids=message_ids,\n            external_message_ids=external_message_ids,\n            received_date_from=received_date_from,\n            received_date_to=received_date_to,\n            updated_date_from=updated_date_from,\n            updated_date_to=updated_date_to,\n            imos=imos,\n            include_details=include_details,\n            include_scraped_fields=include_scraped_fields,\n            include_vessel_details=include_vessel_details,\n            include_labels=include_labels,\n            include_content=include_content,\n            include_sender=include_sender,\n            include_debug_info=include_debug_info,\n        )\n\n    def get_lineups_incremental(\n            self,\n            vessel_type: int,\n            page_token: Optional[str] = None,\n            include_details: Optional[bool] = True,\n            include_scraped_fields: Optional[bool] = True,\n            include_vessel_details: Optional[bool] = True,\n            include_labels: Optional[bool] = True,\n            include_content: Optional[bool] = True,\n            include_sender: Optional[bool] = True,\n            include_debug_info: Optional[bool] = True,\n    ) -&gt; IncrementalDataResponse[ScrapedLineup]:\n        \"\"\"This function collects and returns lineups.\n\n           Specifically, all the lineups updated after the given page token.\n           If page token is nullable, function will return all lineups.\n\n        Args:\n            vessel_type: Format - int32. Available values\n                Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n            page_token: String. The key that should be used as a parameter of\n                the token to retrieve the relevant page.\n            include_details: Boolean - Whether to include\n                additional lineup details in the response.\n            include_scraped_fields: Boolean - Whether to include the relative\n                scraped fields in the response.\n            include_vessel_details: Boolean - Whether to include some vessel\n                details in the response.\n            include_labels: Boolean - Whether to include the relative labels in\n                the response.\n            include_content: Boolean - Whether to include the original message\n                line (untouched) in the response.\n            include_sender: Boolean - Whether to include some of the message\n                sender details in the response.\n            include_debug_info: Boolean - Whether to include some information\n                about the distribution of the lineup in the response.\n\n        Returns:\n            A dictionary containing a tuple of ScrapedLineup objects and\n            NextRequestToken.\n            ScrapedLineup object is defined in models.py Python file.\n            Next Request Token is used as page_token.\n        \"\"\"\n        return self.get_data_incremental(\n            vessel_type=vessel_type,\n            page_token=page_token,\n            include_details=include_details,\n            include_scraped_fields=include_scraped_fields,\n            include_vessel_details=include_vessel_details,\n            include_labels=include_labels,\n            include_content=include_content,\n            include_sender=include_sender,\n            include_debug_info=include_debug_info,\n        )\n\n    def get_lineups_incremental_token(\n            self,\n            updated_date_from: datetime,\n    ) -&gt; Optional[str]:\n        \"\"\"This function returns a token to use in the incremental lineups endpoint.\n\n        Args:\n            updated_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the cargo updated.\n                Cannot be combined with 'Received' dates\n\n        Returns:\n            A string containing the corresponding page token to\n            the provided datetime input.\n        \"\"\"\n        return self.get_data_incremental_token(\n            updated_date_from=updated_date_from,\n        )\n</code></pre>"},{"location":"scraped_lineups/#signal_ocean.scraped_lineups.ScrapedLineupsAPI.get_lineups","title":"<code>get_lineups(vessel_type, lineup_ids=None, message_ids=None, external_message_ids=None, received_date_from=None, received_date_to=None, updated_date_from=None, updated_date_to=None, imos=None, include_details=True, include_scraped_fields=True, include_vessel_details=True, include_labels=True, include_content=True, include_sender=True, include_debug_info=True)</code>","text":"<p>This function collects and returns the lineups by the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_type</code> <code>int</code> <p>Format - int32. Available values Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6</p> required <code>lineup_ids</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of LineupIDs</p> <code>None</code> <code>message_ids</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of MessageIDs</p> <code>None</code> <code>external_message_ids</code> <code>Optional[List[str]]</code> <p>List - Comma separated list of ExternalMessageIDs</p> <code>None</code> <code>received_date_from</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the lineup received. Cannot be combined with 'Updated' dates</p> <code>None</code> <code>received_date_to</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Latest date the lineup received. Cannot be combined with 'Updated' dates</p> <code>None</code> <code>updated_date_from</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the lineup updated. Cannot be combined with 'Received' dates</p> <code>None</code> <code>updated_date_to</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Latest date the lineup updated. Cannot be combined with 'Received' dates</p> <code>None</code> <code>imos</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of IMOs</p> <code>None</code> <code>include_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include additional lineup details in the response.</p> <code>True</code> <code>include_scraped_fields</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative scraped fields in the response.</p> <code>True</code> <code>include_vessel_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some vessel details in the response.</p> <code>True</code> <code>include_labels</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative labels in the response.</p> <code>True</code> <code>include_content</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the original message line (untouched) in the response.</p> <code>True</code> <code>include_sender</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some of the message sender details in the response.</p> <code>True</code> <code>include_debug_info</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some information about the distribution of the lineup in the response.</p> <code>True</code> <p>Returns:</p> Type Description <code>ScrapedLineup</code> <p>An Iterable of ScrapedLineup objects, as we have defined in</p> <code>...</code> <p>models.py Python file.</p> Source code in <code>signal_ocean/scraped_lineups/scraped_lineups_api.py</code> <pre><code>def get_lineups(\n    self,\n    vessel_type: int,\n    lineup_ids: Optional[List[int]] = None,\n    message_ids: Optional[List[int]] = None,\n    external_message_ids: Optional[List[str]] = None,\n    received_date_from: Optional[datetime] = None,\n    received_date_to: Optional[datetime] = None,\n    updated_date_from: Optional[datetime] = None,\n    updated_date_to: Optional[datetime] = None,\n    imos: Optional[List[int]] = None,\n    include_details: Optional[bool] = True,\n    include_scraped_fields: Optional[bool] = True,\n    include_vessel_details: Optional[bool] = True,\n    include_labels: Optional[bool] = True,\n    include_content: Optional[bool] = True,\n    include_sender: Optional[bool] = True,\n    include_debug_info: Optional[bool] = True,\n) -&gt; Tuple[ScrapedLineup, ...]:\n    \"\"\"This function collects and returns the lineups by the given filters.\n\n    Args:\n        vessel_type: Format - int32. Available values\n            Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n        lineup_ids: List - Comma separated list of LineupIDs\n        message_ids: List - Comma separated list of MessageIDs\n        external_message_ids: List - Comma separated list of\n            ExternalMessageIDs\n        received_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the lineup received.\n            Cannot be combined with 'Updated' dates\n        received_date_to: Format - date-time (as date-time in RFC3339).\n            Latest date the lineup received.\n            Cannot be combined with 'Updated' dates\n        updated_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the lineup updated.\n            Cannot be combined with 'Received' dates\n        updated_date_to: Format - date-time (as date-time in RFC3339).\n            Latest date the lineup updated.\n            Cannot be combined with 'Received' dates\n        imos: List - Comma separated list of IMOs\n        include_details: Boolean - Whether to include\n            additional lineup details in the response.\n        include_scraped_fields: Boolean - Whether to include the relative\n            scraped fields in the response.\n        include_vessel_details: Boolean - Whether to include some vessel\n            details in the response.\n        include_labels: Boolean - Whether to include the relative labels in\n            the response.\n        include_content: Boolean - Whether to include the original message\n            line (untouched) in the response.\n        include_sender: Boolean - Whether to include some of the message\n            sender details in the response.\n        include_debug_info: Boolean - Whether to include some information\n            about the distribution of the lineup in the response.\n\n    Returns:\n        An Iterable of ScrapedLineup objects, as we have defined in\n        models.py Python file.\n    \"\"\"\n    return self.get_data(\n        vessel_type=vessel_type,\n        lineup_ids=lineup_ids,\n        message_ids=message_ids,\n        external_message_ids=external_message_ids,\n        received_date_from=received_date_from,\n        received_date_to=received_date_to,\n        updated_date_from=updated_date_from,\n        updated_date_to=updated_date_to,\n        imos=imos,\n        include_details=include_details,\n        include_scraped_fields=include_scraped_fields,\n        include_vessel_details=include_vessel_details,\n        include_labels=include_labels,\n        include_content=include_content,\n        include_sender=include_sender,\n        include_debug_info=include_debug_info,\n    )\n</code></pre>"},{"location":"scraped_lineups/#signal_ocean.scraped_lineups.ScrapedLineupsAPI.get_lineups_incremental","title":"<code>get_lineups_incremental(vessel_type, page_token=None, include_details=True, include_scraped_fields=True, include_vessel_details=True, include_labels=True, include_content=True, include_sender=True, include_debug_info=True)</code>","text":"<p>This function collects and returns lineups.</p> <p>Specifically, all the lineups updated after the given page token.    If page token is nullable, function will return all lineups.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_type</code> <code>int</code> <p>Format - int32. Available values Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6</p> required <code>page_token</code> <code>Optional[str]</code> <p>String. The key that should be used as a parameter of the token to retrieve the relevant page.</p> <code>None</code> <code>include_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include additional lineup details in the response.</p> <code>True</code> <code>include_scraped_fields</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative scraped fields in the response.</p> <code>True</code> <code>include_vessel_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some vessel details in the response.</p> <code>True</code> <code>include_labels</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative labels in the response.</p> <code>True</code> <code>include_content</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the original message line (untouched) in the response.</p> <code>True</code> <code>include_sender</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some of the message sender details in the response.</p> <code>True</code> <code>include_debug_info</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some information about the distribution of the lineup in the response.</p> <code>True</code> <p>Returns:</p> Type Description <code>IncrementalDataResponse[ScrapedLineup]</code> <p>A dictionary containing a tuple of ScrapedLineup objects and</p> <code>IncrementalDataResponse[ScrapedLineup]</code> <p>NextRequestToken.</p> <code>IncrementalDataResponse[ScrapedLineup]</code> <p>ScrapedLineup object is defined in models.py Python file.</p> <code>IncrementalDataResponse[ScrapedLineup]</code> <p>Next Request Token is used as page_token.</p> Source code in <code>signal_ocean/scraped_lineups/scraped_lineups_api.py</code> <pre><code>def get_lineups_incremental(\n        self,\n        vessel_type: int,\n        page_token: Optional[str] = None,\n        include_details: Optional[bool] = True,\n        include_scraped_fields: Optional[bool] = True,\n        include_vessel_details: Optional[bool] = True,\n        include_labels: Optional[bool] = True,\n        include_content: Optional[bool] = True,\n        include_sender: Optional[bool] = True,\n        include_debug_info: Optional[bool] = True,\n) -&gt; IncrementalDataResponse[ScrapedLineup]:\n    \"\"\"This function collects and returns lineups.\n\n       Specifically, all the lineups updated after the given page token.\n       If page token is nullable, function will return all lineups.\n\n    Args:\n        vessel_type: Format - int32. Available values\n            Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n        page_token: String. The key that should be used as a parameter of\n            the token to retrieve the relevant page.\n        include_details: Boolean - Whether to include\n            additional lineup details in the response.\n        include_scraped_fields: Boolean - Whether to include the relative\n            scraped fields in the response.\n        include_vessel_details: Boolean - Whether to include some vessel\n            details in the response.\n        include_labels: Boolean - Whether to include the relative labels in\n            the response.\n        include_content: Boolean - Whether to include the original message\n            line (untouched) in the response.\n        include_sender: Boolean - Whether to include some of the message\n            sender details in the response.\n        include_debug_info: Boolean - Whether to include some information\n            about the distribution of the lineup in the response.\n\n    Returns:\n        A dictionary containing a tuple of ScrapedLineup objects and\n        NextRequestToken.\n        ScrapedLineup object is defined in models.py Python file.\n        Next Request Token is used as page_token.\n    \"\"\"\n    return self.get_data_incremental(\n        vessel_type=vessel_type,\n        page_token=page_token,\n        include_details=include_details,\n        include_scraped_fields=include_scraped_fields,\n        include_vessel_details=include_vessel_details,\n        include_labels=include_labels,\n        include_content=include_content,\n        include_sender=include_sender,\n        include_debug_info=include_debug_info,\n    )\n</code></pre>"},{"location":"scraped_lineups/#signal_ocean.scraped_lineups.ScrapedLineupsAPI.get_lineups_incremental_token","title":"<code>get_lineups_incremental_token(updated_date_from)</code>","text":"<p>This function returns a token to use in the incremental lineups endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>updated_date_from</code> <code>datetime</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the cargo updated. Cannot be combined with 'Received' dates</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>A string containing the corresponding page token to</p> <code>Optional[str]</code> <p>the provided datetime input.</p> Source code in <code>signal_ocean/scraped_lineups/scraped_lineups_api.py</code> <pre><code>def get_lineups_incremental_token(\n        self,\n        updated_date_from: datetime,\n) -&gt; Optional[str]:\n    \"\"\"This function returns a token to use in the incremental lineups endpoint.\n\n    Args:\n        updated_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the cargo updated.\n            Cannot be combined with 'Received' dates\n\n    Returns:\n        A string containing the corresponding page token to\n        the provided datetime input.\n    \"\"\"\n    return self.get_data_incremental_token(\n        updated_date_from=updated_date_from,\n    )\n</code></pre>"},{"location":"scraped_positions/","title":"Package Documentation","text":"<p>Scraped Positions API Package.</p> <p>Classes:</p> Name Description <code>ScrapedPositionsAPI</code> <p>Represents Signal's Scraped Positions API.</p> <code>ScrapedPosition</code> <p>Scraped Position.</p>"},{"location":"scraped_positions/#signal_ocean.scraped_positions.ScrapedPosition","title":"<code>ScrapedPosition</code>  <code>dataclass</code>","text":"<p>Detailed information about a scraped position.</p> <p>Attributes:</p> Name Type Description <code>position_id</code> <code>int</code> <p>Integer. A unique identifier of the position line.</p> <code>message_id</code> <code>Optional[int]</code> <p>Integer. A unique identifier of the message containing the specific position. A message can contain more than one positions.</p> <code>external_message_id</code> <code>Optional[str]</code> <p>String. It serves as a unique identifier for a message, supplied by any company that has integrated with Signal.</p> <code>parsed_part_id</code> <code>Optional[int]</code> <p>Integer. A unique identifier for each email part. The email body and each attachment are considered different parsed parts. For an example the email body and its pdf attachment have same MessageID and different ParsedPartID.</p> <code>line_from</code> <code>Optional[int]</code> <p>Nullable integer. The starting line from which the position is extracted. The email subject counts as  line 0 and the body content starts from line 1.</p> <code>line_to</code> <code>Optional[int]</code> <p>Nullable integer. The final line from which the position is extracted. For single line positions LineFrom is equal to LineTo. For descriptive positions that span across multiple lines we have LineTo&gt;LineFrom. These two numbers help the user identify which part of the text has been used to extract the position data.</p> <code>source</code> <code>Optional[str]</code> <p>String. It describes the source of the information. Our system allows the user to inject data in many different ways, namely through email (Source='Email'), through Slack channels (Source='Slack') or through manual contributions directly from our frontend platform TSOP (Source='User').</p> <code>updated_date</code> <code>Optional[datetime]</code> <p>String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on which the position has been reevaluated for the last time. In case of an email received by a broker one month ago and reprocessed through our engine today, this date will be today's.</p> <code>received_date</code> <code>Optional[datetime]</code> <p>String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on which the position has been injected into our system and processed.</p> <code>is_deleted</code> <code>Optional[bool]</code> <p>Boolean. This value is true if the position is marked as Deleted.</p> <code>low_confidence</code> <code>Optional[bool]</code> <p>Boolean. This value is true when the data extraction process does not return as output some fields that we believe to be more important than others in business terms. These fields are called critical fields. The value is true if at least one of the critical fields is missing.For example missing charterer or laycan.</p> <code>scraped_vessel_name</code> <code>Optional[str]</code> <p>String. The vessel name as reported in the position line, i.e. 'Signal Alpha', 'Cpt A Stellatos', 'Genco Tiberius'. 'TBN' can also be found.</p> <code>scraped_deadweight</code> <code>Optional[str]</code> <p>String. The dead weight of the vessel as reported in the position line, i.e. '150249', '167'.</p> <code>scraped_year_built</code> <code>Optional[str]</code> <p>String. The year built of the vessel as reported in the position line, i.e. '2004', '09'.</p> <code>imo</code> <code>Optional[int]</code> <p>Integer. The seven-digits number that uniquely identifies the ship reported in the position. It is the result of our internally developed Vessel Mapper model.</p> <code>vessel_name</code> <code>Optional[str]</code> <p>String. It is the current vessel name corresponding to the IMO mentioned above. Provided to better specify the vessel and its particulars. Source: our internal Vessel Database.</p> <code>deadweight</code> <code>Optional[int]</code> <p>Integer. The dead weight in tonnes [t] corresponding to the IMO mentioned above.</p> <code>year_built</code> <code>Optional[int]</code> <p>Integer, YYYY format. The year the vessel was built. Source: our internal Vessel Database.</p> <code>liquid_capacity</code> <code>Optional[int]</code> <p>Integer, measured in cbm [cbm]. The liquid capacity of the IMO mentioned above. Source: our internal Vessel Database.</p> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the different values of the VesselType field. 1-&gt; Tanker, 3-&gt; Dry, 4 -&gt; Containers, 5 -&gt;LNG (Liquified Natural gas), 6-&gt; LPG (Liquified Petroleum Gas).</p> <code>vessel_type</code> <code>Optional[str]</code> <p>String. Description of the type of the vessel (VesselTypeID), based on the carried cargo. Main categories are Tankers, Dry (bulk carriers), Containers, LNG and LPG.</p> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Integer. It is an ID corresponding to the different vessel classes of a certain vessel type, as split according to our internal Vessel Database. For example 84-&gt;VLCC, 85-&gt;Suezmax, 70-&gt;Capesize.</p> <code>vessel_class</code> <code>Optional[str]</code> <p>String. Name of the vessel class the vessel belongs to. Assignment of a vessel to a certain VesselClass is based on the VesselType and the value of its Deadweight (if Tanker or Dry), its LiquidCap (if LNG/LPG) or its TEU (if Containers). For example, an Aframax is a Tanker vessel with Deadweight within the range 82kt - 125kt, while a Capesize is a Dry vessel with Deadweight within the range 120kt-220kt. LR2 are defined as Aframax, as only Deadweight is used to define vessel classes.</p> <code>scraped_open_date</code> <code>Optional[str]</code> <p>String. The open date of the position as reported in the original text. It is often reported as a date range, e.g. '13/16 April'.</p> <code>open_date_from</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the beginning of the open date range.</p> <code>open_date_to</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD. The mapped date corresponding to the end of the open date range.</p> <code>scraped_open_port</code> <code>Optional[str]</code> <p>String. The open location reported in the original text of the position. It is very often shortened, very compact and can refer to terminals, ports, countries or wider areas. Examples: 'singgi' for Singgi, 'rt' for Ras Tanura, 'waf' for West Africa.</p> <code>open_geo_id</code> <code>Optional[int]</code> <p>Integer. It is the internal ID of the mapped open location reported in the position. Our models convert and map a scraped string containing geo information to a specific entity of the Signal's proprietary geofencing structure. Each geo entity is identified by a taxonomy, an ID and a name. Examples: the string 'bonny' is mapped to a geo asset with name 'Bonny', ID 3679 and taxonomy Port (TaxonomyID=2); the string 'nigeria' is mapped to a geoasset with name 'Nigeria', ID 171 and taxonomy Country (TaxonomyID=3); the string 'wafr' is mapped to a geoasset with name 'Africa Atlantic Coast', ID 24772 and taxonomy Level0 (TaxonomyID=4).</p> <code>open_name</code> <code>Optional[str]</code> <p>String. The name of the Signal geo entity related to the reported open location of the position.Examples: 'Bonny', 'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf', 'Singapore', 'East Coast Mexico'.</p> <code>open_taxonomy_id</code> <code>Optional[int]</code> <p>Integer. An internal ID corresponding to each taxonomy, the level of geo details, from 1 to 7. A terminal (geoasset) has the lowest taxonomy (TaxonomyID=1), a port has TaxonomyID=2, while countries and wider areas have higher taxonomy (TaxonomyID&gt;=3). Examples of Level 0 areas (TaxonomyID=4) include 'Arabian Gulf', 'US Gulf' and 'East Mediterranean'. Level 1 areas (TaxonomyID=5) consist of multiple level 0 areas (TaxonomyID=4). For example, level 1 area 'Mediterranean' groups together the level 0 areas 'West Mediterranean', 'Central Mediterranean' and 'East Mediterranean'. Level 2 areas (TaxonomyID=6) consist of multiple level 1 areas (TaxonomyID=4). For example, level 2 area 'Mediterranean/UK Continent' groups together the 'Mediterranean' and 'UK Continent' level 1 areas. Level 3 areas (TaxonomyID=7) are the highest area grouping in our taxonomy and consist of multiple level 2 areas (TaxonomyID=6). Examples of such areas are 'Pacific America' or 'Africa'. These group together level 2 areas. For instance, 'Pacific America' groups together the level 2 areas 'West Coast North America', 'West Coast Mexico', 'West Coast Central America' and 'West Coast South America'.</p> <code>open_taxonomy</code> <code>Optional[str]</code> <p>String. The extended name identifying the TaxonomyID. Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3, Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.</p> <code>scraped_commercial_operator</code> <code>Optional[str]</code> <p>String. The position commercial operator as reported in the original text. Examples: 'aet', 'thenamaris', 'bpcl'</p> <code>commercial_operator_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the commercial operator company that it is reported in the line. We use an internal mapper to find the correspondence between the reported string and our database.</p> <code>commercial_operator</code> <code>Optional[str]</code> <p>String. The company name corresponding to the CommercialOperator field. Provided to better specify the company involved in the business. Source: our internal Company Database.</p> <code>scraped_cargo_type</code> <code>Optional[str]</code> <p>String. The position cargo type as reported in the original text, often shortened. Examples: 'nhc', 'ulsd', 'ums', 'nap', 'go'.</p> <code>cargo_type_id</code> <code>Optional[int]</code> <p>Integer. It is an internal ID corresponding to the mapped cargo type of the position. A proprietary model is responsible to match the reported cargo type string to a specific cargo type in our hierarchy. Examples: 19-&gt; Crude Oil, 16-&gt;Fueloil, 9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil, 60-&gt; 'Ultra Low Sulphur Diesel (ULSD 10ppm)'.</p> <code>cargo_type</code> <code>Optional[str]</code> <p>String. The extended name corresponding to the CargoTypeID field. Source: our internal CargoTypes database.</p> <code>cargo_type_group_id</code> <code>Optional[int]</code> <p>Integer. Numeric ID corresponding to the high-level cargo type of the position cargo type. It is provided to group positions and facilitate analytics. Examples: 130000-&gt;Dirty, 120000-&gt; Clean, 110000-&gt;IMO.</p> <code>cargo_type_group</code> <code>Optional[str]</code> <p>String. The extended name corresponding to the CargoGroupID field. Source: our internal CargoTypes database.</p> <code>scraped_last_cargo_types</code> <code>Optional[str]</code> <p>String. The position last cargo types as reported in the original text. Examples: 'ums/palm/go', 'ums/ulsd/jet+nap', 'salt/limestone/coal'.</p> <code>last_cargo_types_ids</code> <code>Optional[str]</code> <p>List of Lists. Contains the internal ID [Id] and TaxonomyID [TId] corresponding to the mapped cargo types report within last cargo types on position. Each list represents the cargo types of each voyage and contains dicts with [Id] and [TId] for every cargo type of the voyage. For example for ScrapedLastCargoTypes field that contains 'ums/ulsd/jet+nap' corresponding LastCargoTypesIDs field contains '[[{'Id': 135, 'TId': 0}], [{'Id': 60, 'TId': 0}],     [{'Id': 14, 'TId': 1}, {'Id': 9, 'TId': 1}]]' First voyage: ScrapedLastCargoTypes='ums' corresponds to     LastCargoTypesIDs=[{'Id': 135, 'TId': 0}] Second voyage: ScrapedLastCargoTypes='ulsd' corresponds to     LastCargoTypesIDs=[{'Id': 60, 'TId': 0}] Third voyage: ScrapedLastCargoTypes='jet+nap' corresponds     to LastCargoTypesIDs=[{'Id': 14, 'TId': 1},     {'Id': 9, 'TId': 1}]]</p> <code>last_cargo_types</code> <code>Optional[str]</code> <p>String. The extended names corresponding to each CargoTypeID on LastCargoTypeIDs. Voyages are separated with '/'. Cargo Types within same voyage are separated with '+'. Example: ScrapedLastCargoTypes='ums/ulsd/jet+nap' LastCargoTypesIDs=[[{'Id': 135, 'TId': 0}], [{'Id': 60, 'TId': 0}],     [{'Id': 14, 'TId': 1}, {'Id': 9, 'TId': 1}]] LastCargoTypes='Unleaded Motor Spirit / Ultra Low Sulphur Diesel     (ULSD 10ppm) / Jet + Naphtha'</p> <code>has_ballast</code> <code>Optional[bool]</code> <p>Boolean. This value is true when 'ballast', 'in ball' or 'blst' explicitly reported in the original text of the position.</p> <code>has_dry_dock</code> <code>Optional[bool]</code> <p>Boolean. This value is true when 'dd', 'exdd' or 'xdd' explicitly reported in the original text of the position.</p> <code>has_if</code> <code>Optional[bool]</code> <p>Boolean. This value is true when 'if' or 'poss' explicitly reported in the original text of the position.</p> <code>has_on_hold</code> <code>Optional[bool]</code> <p>Boolean. This value is true when 'hold' explicitly reported in the original text of the position.</p> <code>has_on_subs</code> <code>Optional[bool]</code> <p>Boolean. This value is true when 'fxd', 'subs' or '-s-' explicitly reported in the original text of the position.</p> <code>has_prompt</code> <code>Optional[bool]</code> <p>Boolean. This value is true when 'ppt', 'prompt' or 'spot' explicitly reported in the original text of the position.</p> <code>has_uncertain</code> <code>Optional[bool]</code> <p>Boolean. This value is true when 'unc' or 'uncertain' explicitly reported in the original text of the position.</p> <code>is_position_list</code> <code>Optional[bool]</code> <p>Boolean. This value is true if the source of position is the company that commercially manages of the vessel.</p> <code>content</code> <code>Optional[str]</code> <p>String. The full content of the position. For a single line position it is the line content. For multi line positions it is the collection of all the relevant parts of the text.</p> <code>subject</code> <code>Optional[str]</code> <p>String. The email subject of the position. This field has content when Source=\"Email\".</p> <code>sender</code> <code>Optional[str]</code> <p>String. Our own mapping of the shipping company sending out the market report through email. This string helps grouping emails sent by the same organization, but from different domains. It is often the case for big organizations operating worldwide. For example Sender= 'SSY' for both domains 'ssysin.com' and 'ssy.co'.</p> <code>is_private</code> <code>Optional[bool]</code> <p>Boolean. A position is private if injected by a user into his own private account within TSOP. A user can provide private information through email forwarding or through Slack. Private position information stay in the account, are accessible by the account users only (people within the same company) and are the most valuable ones.</p> Source code in <code>signal_ocean/scraped_positions/models.py</code> <pre><code>@dataclass(frozen=True)\nclass ScrapedPosition:\n    \"\"\"Detailed information about a scraped position.\n\n    Attributes:\n        position_id: Integer. A unique identifier of the position line.\n        message_id: Integer. A unique identifier of the message containing the\n            specific position. A message can contain more than one positions.\n        external_message_id: String. It serves as a unique identifier for a\n            message, supplied by any company that has integrated with Signal.\n        parsed_part_id: Integer. A unique identifier for each email part. The\n            email body and each attachment are considered different parsed\n            parts. For an example the email body and its pdf attachment have\n            same MessageID and different ParsedPartID.\n        line_from: Nullable integer. The starting line from which the position\n            is extracted. The email subject counts as  line 0 and the body\n            content starts from line 1.\n        line_to: Nullable integer. The final line from which the position is\n            extracted. For single line positions LineFrom is equal to LineTo.\n            For descriptive positions that span across multiple lines we have\n            LineTo&gt;LineFrom. These two numbers help the user identify which\n            part of the text has been used to extract the position data.\n        source: String. It describes the source of the information. Our system\n            allows the user to inject data in many different ways, namely\n            through email (Source='Email'), through Slack channels\n            (Source='Slack') or through manual contributions directly from our\n            frontend platform TSOP (Source='User').\n        updated_date: String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date on\n            which the position has been reevaluated for the last time. In case\n            of an email received by a broker one month ago and reprocessed\n            through our engine today, this date will be today's.\n        received_date: String, format YYYY-MM-DD HH:MM:SS, UTC timezone. Date\n            on which the position has been injected into our system and\n            processed.\n        is_deleted: Boolean. This value is true if the position is marked as\n            Deleted.\n        low_confidence: Boolean. This value is true when the data extraction\n            process does not return as output some fields that we believe to\n            be more important than others in business terms. These fields are\n            called critical fields. The value is true if at least one of the\n            critical fields is missing.For example missing charterer or laycan.\n        scraped_vessel_name: String. The vessel name as reported in the\n            position line, i.e. 'Signal Alpha', 'Cpt A Stellatos',\n            'Genco Tiberius'. 'TBN' can also be found.\n        scraped_deadweight: String. The dead weight of the vessel as\n            reported in the position line, i.e. '150249', '167'.\n        scraped_year_built: String. The year built of the vessel as reported in\n            the position line, i.e. '2004', '09'.\n        imo: Integer. The seven-digits number that uniquely identifies the ship\n            reported in the position. It is the result of our internally\n            developed Vessel Mapper model.\n        vessel_name: String. It is the current vessel name corresponding to the\n            IMO mentioned above. Provided to better specify the vessel and its\n            particulars. Source: our internal Vessel Database.\n        deadweight: Integer. The dead weight in tonnes [t] corresponding to the\n            IMO mentioned above.\n        year_built: Integer, YYYY format. The year the vessel was built.\n            Source: our internal Vessel Database.\n        liquid_capacity: Integer, measured in cbm [cbm]. The liquid capacity of\n            the IMO mentioned above. Source: our internal Vessel Database.\n        vessel_type_id: Integer. Numeric ID corresponding to the different\n            values of the VesselType field. 1-&gt; Tanker, 3-&gt; Dry,\n            4 -&gt; Containers, 5 -&gt;LNG (Liquified Natural gas),\n            6-&gt; LPG (Liquified Petroleum Gas).\n        vessel_type: String. Description of the type of the vessel\n            (VesselTypeID), based on the carried cargo. Main categories are\n            Tankers, Dry (bulk carriers), Containers, LNG and LPG.\n        vessel_class_id: Integer. It is an ID corresponding to the different\n            vessel classes of a certain vessel type, as split according to our\n            internal Vessel Database. For example 84-&gt;VLCC, 85-&gt;Suezmax,\n            70-&gt;Capesize.\n        vessel_class: String. Name of the vessel class the vessel belongs to.\n            Assignment of a vessel to a certain VesselClass is based on the\n            VesselType and the value of its Deadweight (if Tanker or Dry), its\n            LiquidCap (if LNG/LPG) or its TEU (if Containers). For example, an\n            Aframax is a Tanker vessel with Deadweight within the range\n            82kt - 125kt, while a Capesize is a Dry vessel with Deadweight\n            within the range 120kt-220kt. LR2 are defined as Aframax, as only\n            Deadweight is used to define vessel classes.\n        scraped_open_date: String. The open date of the position as reported in\n            the original text. It is often reported as a date range, e.g.\n            '13/16 April'.\n        open_date_from: Date, format YYYY-MM-DD. The mapped date corresponding\n            to the beginning of the open date range.\n        open_date_to: Date, format YYYY-MM-DD. The mapped date corresponding to\n            the end of the open date range.\n        scraped_open_port: String. The open location reported in the original\n            text of the position. It is very often shortened, very compact and\n            can refer to terminals, ports, countries or wider areas. Examples:\n            'singgi' for Singgi, 'rt' for Ras Tanura, 'waf' for West Africa.\n        open_geo_id: Integer. It is the internal ID of the mapped open location\n            reported in the position. Our models convert and map a scraped\n            string containing geo information to a specific entity of the\n            Signal's proprietary geofencing structure. Each geo entity is\n            identified by a taxonomy, an ID and a name. Examples: the string\n            'bonny' is mapped to a geo asset with name 'Bonny', ID 3679 and\n            taxonomy Port (TaxonomyID=2); the string 'nigeria' is mapped to a\n            geoasset with name 'Nigeria', ID 171 and taxonomy Country\n            (TaxonomyID=3); the string 'wafr' is mapped to a geoasset with name\n            'Africa Atlantic Coast', ID 24772 and taxonomy Level0\n            (TaxonomyID=4).\n        open_name: String. The name of the Signal geo entity related to the\n            reported open location of the position.Examples: 'Bonny',\n            'Nigeria', 'Africa Atlantic Coast', 'Arabian Gulf', 'Singapore',\n            'East Coast Mexico'.\n        open_taxonomy_id: Integer. An internal ID corresponding to each\n            taxonomy, the level of geo details, from 1 to 7. A terminal\n            (geoasset) has the lowest taxonomy (TaxonomyID=1), a port has\n            TaxonomyID=2, while countries and wider areas have higher taxonomy\n            (TaxonomyID&gt;=3). Examples of Level 0 areas (TaxonomyID=4) include\n            'Arabian Gulf', 'US Gulf' and 'East Mediterranean'. Level 1 areas\n            (TaxonomyID=5) consist of multiple level 0 areas (TaxonomyID=4).\n            For example, level 1 area 'Mediterranean' groups together the\n            level 0 areas 'West Mediterranean', 'Central Mediterranean' and\n            'East Mediterranean'. Level 2 areas (TaxonomyID=6) consist of\n            multiple level 1 areas (TaxonomyID=4). For example, level 2 area\n            'Mediterranean/UK Continent' groups together the 'Mediterranean'\n            and 'UK Continent' level 1 areas. Level 3 areas (TaxonomyID=7) are\n            the highest area grouping in our taxonomy and consist of multiple\n            level 2 areas (TaxonomyID=6). Examples of such areas are\n            'Pacific America' or 'Africa'. These group together level 2 areas.\n            For instance, 'Pacific America' groups together the level 2 areas\n            'West Coast North America', 'West Coast Mexico',\n            'West Coast Central America' and 'West Coast South America'.\n        open_taxonomy: String. The extended name identifying the TaxonomyID.\n            Possible values are: GeoAsset-&gt; 1, Port -&gt; 2, Country-&gt; 3,\n            Level0-&gt;4, Level1-&gt;5, Level2-&gt;6, Level3-&gt;7.\n        scraped_commercial_operator: String. The position commercial operator\n            as reported in the original text. Examples: 'aet', 'thenamaris',\n            'bpcl'\n        commercial_operator_id: Integer. Numeric ID corresponding to the\n            commercial operator company that it is reported in the line. We use\n            an internal mapper to find the correspondence between the reported\n            string and our database.\n        commercial_operator: String. The company name corresponding to the\n            CommercialOperator field. Provided to better specify the company\n            involved in the business. Source: our internal Company Database.\n        scraped_cargo_type: String. The position cargo type as reported in the\n            original text, often shortened. Examples: 'nhc', 'ulsd', 'ums',\n            'nap', 'go'.\n        cargo_type_id: Integer. It is an internal ID corresponding to the\n            mapped cargo type of the position. A proprietary model is\n            responsible to match the reported cargo type string to a specific\n            cargo type in our hierarchy. Examples: 19-&gt; Crude Oil, 16-&gt;Fueloil,\n            9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil,\n            60-&gt; 'Ultra Low Sulphur Diesel (ULSD 10ppm)'.\n        cargo_type: String. The extended name corresponding to the CargoTypeID\n            field. Source: our internal CargoTypes database.\n        cargo_type_group_id: Integer. Numeric ID corresponding to the\n            high-level cargo type of the position cargo type. It is provided to\n            group positions and facilitate analytics. Examples: 130000-&gt;Dirty,\n            120000-&gt; Clean, 110000-&gt;IMO.\n        cargo_type_group: String. The extended name corresponding to the\n            CargoGroupID field. Source: our internal CargoTypes database.\n        scraped_last_cargo_types: String. The position last cargo types as\n            reported in the original text. Examples: 'ums/palm/go',\n            'ums/ulsd/jet+nap', 'salt/limestone/coal'.\n        last_cargo_types_ids: List of Lists. Contains the internal ID [Id] and\n            TaxonomyID [TId] corresponding to the mapped cargo types report\n            within last cargo types on position. Each list represents the cargo\n            types of each voyage and contains dicts with [Id] and [TId] for\n            every cargo type of the voyage. For example for\n            ScrapedLastCargoTypes field that contains 'ums/ulsd/jet+nap'\n            corresponding LastCargoTypesIDs field contains\n            '[[{'Id': 135, 'TId': 0}], [{'Id': 60, 'TId': 0}],\n                [{'Id': 14, 'TId': 1}, {'Id': 9, 'TId': 1}]]'\n            First voyage: ScrapedLastCargoTypes='ums' corresponds to\n                LastCargoTypesIDs=[{'Id': 135, 'TId': 0}]\n            Second voyage: ScrapedLastCargoTypes='ulsd' corresponds to\n                LastCargoTypesIDs=[{'Id': 60, 'TId': 0}]\n            Third voyage: ScrapedLastCargoTypes='jet+nap' corresponds\n                to LastCargoTypesIDs=[{'Id': 14, 'TId': 1},\n                {'Id': 9, 'TId': 1}]]\n        last_cargo_types: String. The extended names corresponding to each\n            CargoTypeID on LastCargoTypeIDs. Voyages are separated with '/'.\n            Cargo Types within same voyage are separated with '+'.\n            Example:\n            ScrapedLastCargoTypes='ums/ulsd/jet+nap'\n            LastCargoTypesIDs=[[{'Id': 135, 'TId': 0}], [{'Id': 60, 'TId': 0}],\n                [{'Id': 14, 'TId': 1}, {'Id': 9, 'TId': 1}]]\n            LastCargoTypes='Unleaded Motor Spirit / Ultra Low Sulphur Diesel\n                (ULSD 10ppm) / Jet + Naphtha'\n        has_ballast: Boolean. This value is true when 'ballast', 'in ball' or\n            'blst' explicitly reported in the original text of the position.\n        has_dry_dock: Boolean. This value is true when 'dd', 'exdd' or 'xdd'\n            explicitly reported in the original text of the position.\n        has_if: Boolean. This value is true when 'if' or 'poss'\n            explicitly reported in the original text of the position.\n        has_on_hold: Boolean. This value is true when 'hold'\n            explicitly reported in the original text of the position.\n        has_on_subs: Boolean. This value is true when 'fxd', 'subs' or '-s-'\n            explicitly reported in the original text of the position.\n        has_prompt: Boolean. This value is true when 'ppt', 'prompt' or 'spot'\n            explicitly reported in the original text of the position.\n        has_uncertain: Boolean. This value is true when 'unc' or 'uncertain'\n            explicitly reported in the original text of the position.\n        is_position_list: Boolean. This value is true if the source of position\n            is the company that commercially manages of the vessel.\n        content: String. The full content of the position. For a single line\n            position it is the line content. For multi line positions it is the\n            collection of all the relevant parts of the text.\n        subject: String. The email subject of the position. This field has\n            content when Source=\"Email\".\n        sender: String. Our own mapping of the shipping company sending out the\n            market report through email. This string helps grouping emails sent\n            by the same organization, but from different domains. It is often\n            the case for big organizations operating worldwide. For example\n            Sender= 'SSY' for both domains 'ssysin.com' and 'ssy.co'.\n        is_private: Boolean. A position is private if injected by a user into\n            his own private account within TSOP. A user can provide private\n            information through email forwarding or through Slack. Private\n            position information stay in the account, are accessible by the\n            account users only (people within the same company) and are the\n            most valuable ones.\n    \"\"\"\n\n    # entity details\n    position_id: int\n    message_id: Optional[int] = None\n    external_message_id: Optional[str] = None\n    parsed_part_id: Optional[int] = None\n    line_from: Optional[int] = None\n    line_to: Optional[int] = None\n    source: Optional[str] = None\n    updated_date: Optional[datetime] = None\n    received_date: Optional[datetime] = None\n    is_deleted: Optional[bool] = False\n    low_confidence: Optional[bool] = False\n\n    # vessel\n    scraped_vessel_name: Optional[str] = None\n    scraped_deadweight: Optional[str] = None\n    scraped_year_built: Optional[str] = None\n    imo: Optional[int] = None\n    vessel_name: Optional[str] = None\n    deadweight: Optional[int] = None\n    year_built: Optional[int] = None\n    liquid_capacity: Optional[int] = None\n    vessel_type_id: Optional[int] = None\n    vessel_type: Optional[str] = None\n    vessel_class_id: Optional[int] = None\n    vessel_class: Optional[str] = None\n\n    # open date\n    scraped_open_date: Optional[str] = None\n    open_date_from: Optional[datetime] = None\n    open_date_to: Optional[datetime] = None\n\n    # open port\n    scraped_open_port: Optional[str] = None\n    open_geo_id: Optional[int] = None\n    open_name: Optional[str] = None\n    open_taxonomy_id: Optional[int] = None\n    open_taxonomy: Optional[str] = None\n\n    # commercial operator\n    scraped_commercial_operator: Optional[str] = None\n    commercial_operator_id: Optional[int] = None\n    commercial_operator: Optional[str] = None\n\n    # cargo type\n    scraped_cargo_type: Optional[str] = None\n    cargo_type_id: Optional[int] = None\n    cargo_type: Optional[str] = None\n    cargo_type_group_id: Optional[int] = None\n    cargo_type_group: Optional[str] = None\n\n    # last cargoes\n    scraped_last_cargo_types: Optional[str] = None\n    last_cargo_types_ids: Optional[str] = None\n    last_cargo_types: Optional[str] = None\n\n    # position indicators\n    has_ballast: Optional[bool] = False\n    has_dry_dock: Optional[bool] = False\n    has_if: Optional[bool] = False\n    has_on_hold: Optional[bool] = False\n    has_on_subs: Optional[bool] = False\n    has_prompt: Optional[bool] = False\n    has_uncertain: Optional[bool] = False\n    is_position_list: Optional[bool] = False\n\n    # content\n    content: Optional[str] = None\n    subject: Optional[str] = None\n\n    # sender\n    sender: Optional[str] = None\n\n    # debug info\n    is_private: Optional[bool] = False\n</code></pre>"},{"location":"scraped_positions/#signal_ocean.scraped_positions.ScrapedPositionsAPI","title":"<code>ScrapedPositionsAPI</code>","text":"<p>               Bases: <code>ScrapedDataAPI[ScrapedPositionsResponse, ScrapedPosition]</code></p> <p>Represents Signal's Scraped Positions API.</p> Source code in <code>signal_ocean/scraped_positions/scraped_positions_api.py</code> <pre><code>class ScrapedPositionsAPI(\n    ScrapedDataAPI[ScrapedPositionsResponse, ScrapedPosition]\n):\n    \"\"\"Represents Signal's Scraped Positions API.\"\"\"\n\n    relative_url = \"scraped-positions-api/v6.0/positions\"\n    response_class = ScrapedPositionsResponse\n\n    def get_positions(\n        self,\n        vessel_type: int,\n        position_ids: Optional[List[int]] = None,\n        message_ids: Optional[List[int]] = None,\n        external_message_ids: Optional[List[str]] = None,\n        received_date_from: Optional[datetime] = None,\n        received_date_to: Optional[datetime] = None,\n        updated_date_from: Optional[datetime] = None,\n        updated_date_to: Optional[datetime] = None,\n        imos: Optional[List[int]] = None,\n        include_details: Optional[bool] = True,\n        include_scraped_fields: Optional[bool] = True,\n        include_vessel_details: Optional[bool] = True,\n        include_labels: Optional[bool] = True,\n        include_content: Optional[bool] = True,\n        include_sender: Optional[bool] = True,\n        include_debug_info: Optional[bool] = True,\n    ) -&gt; Tuple[ScrapedPosition, ...]:\n        \"\"\"This function collects and returns the positions by the given filters.\n\n        Args:\n            vessel_type: Format - int32. Available values\n                Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n            position_ids: List - Comma separated list of PositionIDs\n            message_ids: List - Comma separated list of MessageIDs\n            external_message_ids: List - Comma separated list of\n                ExternalMessageIDs\n            received_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the position received.\n                Cannot be combined with 'Updated' dates\n            received_date_to: Format - date-time (as date-time in RFC3339).\n                Latest date the position received.\n                Cannot be combined with 'Updated' dates\n            updated_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the position updated.\n                Cannot be combined with 'Received' dates\n            updated_date_to: Format - date-time (as date-time in RFC3339).\n                Latest date the position updated.\n                Cannot be combined with 'Received' dates\n            imos: List - Comma separated list of IMOs\n            include_details: Boolean - Whether to include\n                additional position details in the response.\n            include_scraped_fields: Boolean - Whether to include the relative\n                scraped fields in the response.\n            include_vessel_details: Boolean - Whether to include some vessel\n                details in the response.\n            include_labels: Boolean - Whether to include the relative labels in\n                the response.\n            include_content: Boolean - Whether to include the original message\n                line (untouched) in the response.\n            include_sender: Boolean - Whether to include some of the message\n                sender details in the response.\n            include_debug_info: Boolean - Whether to include some information\n                about the distribution of the position in the response.\n\n        Returns:\n            An Iterable of ScrapedPosition objects, as we have defined in\n            models.py Python file.\n        \"\"\"\n        return self.get_data(\n            vessel_type=vessel_type,\n            position_ids=position_ids,\n            message_ids=message_ids,\n            external_message_ids=external_message_ids,\n            received_date_from=received_date_from,\n            received_date_to=received_date_to,\n            updated_date_from=updated_date_from,\n            updated_date_to=updated_date_to,\n            imos=imos,\n            include_details=include_details,\n            include_scraped_fields=include_scraped_fields,\n            include_vessel_details=include_vessel_details,\n            include_labels=include_labels,\n            include_content=include_content,\n            include_sender=include_sender,\n            include_debug_info=include_debug_info,\n        )\n\n    def get_positions_incremental(\n            self,\n            vessel_type: int,\n            page_token: Optional[str] = None,\n            include_details: Optional[bool] = True,\n            include_scraped_fields: Optional[bool] = True,\n            include_vessel_details: Optional[bool] = True,\n            include_labels: Optional[bool] = True,\n            include_content: Optional[bool] = True,\n            include_sender: Optional[bool] = True,\n            include_debug_info: Optional[bool] = True,\n    ) -&gt; IncrementalDataResponse[ScrapedPosition]:\n        \"\"\"This function collects and returns positions.\n\n           Specifically, all the positions updated after the given page token.\n           If page token is nullable, function will return all positions.\n\n        Args:\n            vessel_type: Format - int32. Available values\n                Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n            page_token: String. The key that should be used as a parameter of\n                the token to retrieve the relevant page.\n            include_details: Boolean - Whether to include\n                additional position details in the response.\n            include_scraped_fields: Boolean - Whether to include the relative\n                scraped fields in the response.\n            include_vessel_details: Boolean - Whether to include some vessel\n                details in the response.\n            include_labels: Boolean - Whether to include the relative labels in\n                the response.\n            include_content: Boolean - Whether to include the original message\n                line (untouched) in the response.\n            include_sender: Boolean - Whether to include some of the message\n                sender details in the response.\n            include_debug_info: Boolean - Whether to include some information\n                about the distribution of the position in the response.\n\n        Returns:\n            A dictionary containing a tuple of ScrapedPosition objects and\n            NextRequestToken.\n            ScrapedPosition object is defined in models.py Python file.\n            Next Request Token is used as page_token.\n        \"\"\"\n        return self.get_data_incremental(\n            vessel_type=vessel_type,\n            page_token=page_token,\n            include_details=include_details,\n            include_scraped_fields=include_scraped_fields,\n            include_vessel_details=include_vessel_details,\n            include_labels=include_labels,\n            include_content=include_content,\n            include_sender=include_sender,\n            include_debug_info=include_debug_info,\n        )\n\n    def get_positions_incremental_token(\n            self,\n            updated_date_from: datetime,\n    ) -&gt; Optional[str]:\n        \"\"\"This function returns a token to use in the incremental lineups endpoint.\n\n        Args:\n            updated_date_from: Format - date-time (as date-time in RFC3339).\n                Earliest date the cargo updated.\n                Cannot be combined with 'Received' dates\n\n        Returns:\n            A string containing the corresponding page token\n            to the provided datetime input.\n        \"\"\"\n        return self.get_data_incremental_token(\n            updated_date_from=updated_date_from,\n        )\n</code></pre>"},{"location":"scraped_positions/#signal_ocean.scraped_positions.ScrapedPositionsAPI.get_positions","title":"<code>get_positions(vessel_type, position_ids=None, message_ids=None, external_message_ids=None, received_date_from=None, received_date_to=None, updated_date_from=None, updated_date_to=None, imos=None, include_details=True, include_scraped_fields=True, include_vessel_details=True, include_labels=True, include_content=True, include_sender=True, include_debug_info=True)</code>","text":"<p>This function collects and returns the positions by the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_type</code> <code>int</code> <p>Format - int32. Available values Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6</p> required <code>position_ids</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of PositionIDs</p> <code>None</code> <code>message_ids</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of MessageIDs</p> <code>None</code> <code>external_message_ids</code> <code>Optional[List[str]]</code> <p>List - Comma separated list of ExternalMessageIDs</p> <code>None</code> <code>received_date_from</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the position received. Cannot be combined with 'Updated' dates</p> <code>None</code> <code>received_date_to</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Latest date the position received. Cannot be combined with 'Updated' dates</p> <code>None</code> <code>updated_date_from</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the position updated. Cannot be combined with 'Received' dates</p> <code>None</code> <code>updated_date_to</code> <code>Optional[datetime]</code> <p>Format - date-time (as date-time in RFC3339). Latest date the position updated. Cannot be combined with 'Received' dates</p> <code>None</code> <code>imos</code> <code>Optional[List[int]]</code> <p>List - Comma separated list of IMOs</p> <code>None</code> <code>include_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include additional position details in the response.</p> <code>True</code> <code>include_scraped_fields</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative scraped fields in the response.</p> <code>True</code> <code>include_vessel_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some vessel details in the response.</p> <code>True</code> <code>include_labels</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative labels in the response.</p> <code>True</code> <code>include_content</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the original message line (untouched) in the response.</p> <code>True</code> <code>include_sender</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some of the message sender details in the response.</p> <code>True</code> <code>include_debug_info</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some information about the distribution of the position in the response.</p> <code>True</code> <p>Returns:</p> Type Description <code>ScrapedPosition</code> <p>An Iterable of ScrapedPosition objects, as we have defined in</p> <code>...</code> <p>models.py Python file.</p> Source code in <code>signal_ocean/scraped_positions/scraped_positions_api.py</code> <pre><code>def get_positions(\n    self,\n    vessel_type: int,\n    position_ids: Optional[List[int]] = None,\n    message_ids: Optional[List[int]] = None,\n    external_message_ids: Optional[List[str]] = None,\n    received_date_from: Optional[datetime] = None,\n    received_date_to: Optional[datetime] = None,\n    updated_date_from: Optional[datetime] = None,\n    updated_date_to: Optional[datetime] = None,\n    imos: Optional[List[int]] = None,\n    include_details: Optional[bool] = True,\n    include_scraped_fields: Optional[bool] = True,\n    include_vessel_details: Optional[bool] = True,\n    include_labels: Optional[bool] = True,\n    include_content: Optional[bool] = True,\n    include_sender: Optional[bool] = True,\n    include_debug_info: Optional[bool] = True,\n) -&gt; Tuple[ScrapedPosition, ...]:\n    \"\"\"This function collects and returns the positions by the given filters.\n\n    Args:\n        vessel_type: Format - int32. Available values\n            Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n        position_ids: List - Comma separated list of PositionIDs\n        message_ids: List - Comma separated list of MessageIDs\n        external_message_ids: List - Comma separated list of\n            ExternalMessageIDs\n        received_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the position received.\n            Cannot be combined with 'Updated' dates\n        received_date_to: Format - date-time (as date-time in RFC3339).\n            Latest date the position received.\n            Cannot be combined with 'Updated' dates\n        updated_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the position updated.\n            Cannot be combined with 'Received' dates\n        updated_date_to: Format - date-time (as date-time in RFC3339).\n            Latest date the position updated.\n            Cannot be combined with 'Received' dates\n        imos: List - Comma separated list of IMOs\n        include_details: Boolean - Whether to include\n            additional position details in the response.\n        include_scraped_fields: Boolean - Whether to include the relative\n            scraped fields in the response.\n        include_vessel_details: Boolean - Whether to include some vessel\n            details in the response.\n        include_labels: Boolean - Whether to include the relative labels in\n            the response.\n        include_content: Boolean - Whether to include the original message\n            line (untouched) in the response.\n        include_sender: Boolean - Whether to include some of the message\n            sender details in the response.\n        include_debug_info: Boolean - Whether to include some information\n            about the distribution of the position in the response.\n\n    Returns:\n        An Iterable of ScrapedPosition objects, as we have defined in\n        models.py Python file.\n    \"\"\"\n    return self.get_data(\n        vessel_type=vessel_type,\n        position_ids=position_ids,\n        message_ids=message_ids,\n        external_message_ids=external_message_ids,\n        received_date_from=received_date_from,\n        received_date_to=received_date_to,\n        updated_date_from=updated_date_from,\n        updated_date_to=updated_date_to,\n        imos=imos,\n        include_details=include_details,\n        include_scraped_fields=include_scraped_fields,\n        include_vessel_details=include_vessel_details,\n        include_labels=include_labels,\n        include_content=include_content,\n        include_sender=include_sender,\n        include_debug_info=include_debug_info,\n    )\n</code></pre>"},{"location":"scraped_positions/#signal_ocean.scraped_positions.ScrapedPositionsAPI.get_positions_incremental","title":"<code>get_positions_incremental(vessel_type, page_token=None, include_details=True, include_scraped_fields=True, include_vessel_details=True, include_labels=True, include_content=True, include_sender=True, include_debug_info=True)</code>","text":"<p>This function collects and returns positions.</p> <p>Specifically, all the positions updated after the given page token.    If page token is nullable, function will return all positions.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_type</code> <code>int</code> <p>Format - int32. Available values Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6</p> required <code>page_token</code> <code>Optional[str]</code> <p>String. The key that should be used as a parameter of the token to retrieve the relevant page.</p> <code>None</code> <code>include_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include additional position details in the response.</p> <code>True</code> <code>include_scraped_fields</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative scraped fields in the response.</p> <code>True</code> <code>include_vessel_details</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some vessel details in the response.</p> <code>True</code> <code>include_labels</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the relative labels in the response.</p> <code>True</code> <code>include_content</code> <code>Optional[bool]</code> <p>Boolean - Whether to include the original message line (untouched) in the response.</p> <code>True</code> <code>include_sender</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some of the message sender details in the response.</p> <code>True</code> <code>include_debug_info</code> <code>Optional[bool]</code> <p>Boolean - Whether to include some information about the distribution of the position in the response.</p> <code>True</code> <p>Returns:</p> Type Description <code>IncrementalDataResponse[ScrapedPosition]</code> <p>A dictionary containing a tuple of ScrapedPosition objects and</p> <code>IncrementalDataResponse[ScrapedPosition]</code> <p>NextRequestToken.</p> <code>IncrementalDataResponse[ScrapedPosition]</code> <p>ScrapedPosition object is defined in models.py Python file.</p> <code>IncrementalDataResponse[ScrapedPosition]</code> <p>Next Request Token is used as page_token.</p> Source code in <code>signal_ocean/scraped_positions/scraped_positions_api.py</code> <pre><code>def get_positions_incremental(\n        self,\n        vessel_type: int,\n        page_token: Optional[str] = None,\n        include_details: Optional[bool] = True,\n        include_scraped_fields: Optional[bool] = True,\n        include_vessel_details: Optional[bool] = True,\n        include_labels: Optional[bool] = True,\n        include_content: Optional[bool] = True,\n        include_sender: Optional[bool] = True,\n        include_debug_info: Optional[bool] = True,\n) -&gt; IncrementalDataResponse[ScrapedPosition]:\n    \"\"\"This function collects and returns positions.\n\n       Specifically, all the positions updated after the given page token.\n       If page token is nullable, function will return all positions.\n\n    Args:\n        vessel_type: Format - int32. Available values\n            Tanker = 1, Dry = 3, Container = 4, Lng = 5, Lpg = 6\n        page_token: String. The key that should be used as a parameter of\n            the token to retrieve the relevant page.\n        include_details: Boolean - Whether to include\n            additional position details in the response.\n        include_scraped_fields: Boolean - Whether to include the relative\n            scraped fields in the response.\n        include_vessel_details: Boolean - Whether to include some vessel\n            details in the response.\n        include_labels: Boolean - Whether to include the relative labels in\n            the response.\n        include_content: Boolean - Whether to include the original message\n            line (untouched) in the response.\n        include_sender: Boolean - Whether to include some of the message\n            sender details in the response.\n        include_debug_info: Boolean - Whether to include some information\n            about the distribution of the position in the response.\n\n    Returns:\n        A dictionary containing a tuple of ScrapedPosition objects and\n        NextRequestToken.\n        ScrapedPosition object is defined in models.py Python file.\n        Next Request Token is used as page_token.\n    \"\"\"\n    return self.get_data_incremental(\n        vessel_type=vessel_type,\n        page_token=page_token,\n        include_details=include_details,\n        include_scraped_fields=include_scraped_fields,\n        include_vessel_details=include_vessel_details,\n        include_labels=include_labels,\n        include_content=include_content,\n        include_sender=include_sender,\n        include_debug_info=include_debug_info,\n    )\n</code></pre>"},{"location":"scraped_positions/#signal_ocean.scraped_positions.ScrapedPositionsAPI.get_positions_incremental_token","title":"<code>get_positions_incremental_token(updated_date_from)</code>","text":"<p>This function returns a token to use in the incremental lineups endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>updated_date_from</code> <code>datetime</code> <p>Format - date-time (as date-time in RFC3339). Earliest date the cargo updated. Cannot be combined with 'Received' dates</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>A string containing the corresponding page token</p> <code>Optional[str]</code> <p>to the provided datetime input.</p> Source code in <code>signal_ocean/scraped_positions/scraped_positions_api.py</code> <pre><code>def get_positions_incremental_token(\n        self,\n        updated_date_from: datetime,\n) -&gt; Optional[str]:\n    \"\"\"This function returns a token to use in the incremental lineups endpoint.\n\n    Args:\n        updated_date_from: Format - date-time (as date-time in RFC3339).\n            Earliest date the cargo updated.\n            Cannot be combined with 'Received' dates\n\n    Returns:\n        A string containing the corresponding page token\n        to the provided datetime input.\n    \"\"\"\n    return self.get_data_incremental_token(\n        updated_date_from=updated_date_from,\n    )\n</code></pre>"},{"location":"tonnage_list/","title":"Package Documentation","text":"<p>Tonnage List API Package.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Area","title":"<code>Area</code>  <code>dataclass</code>","text":"<p>A geographical area.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The area's id.</p> <code>name</code> <code>str</code> <p>The area's name.</p> <code>location_taxonomy</code> <code>str</code> <p>The area's location taxonomy. See the <code>LocationTaxonomy</code> class for available values.</p> <code>taxonomy_id</code> <code>int</code> <p>Location taxonomy id</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Area:\n    \"\"\"A geographical area.\n\n    Attributes:\n        id: The area's id.\n        name: The area's name.\n        location_taxonomy: The area's location taxonomy. See the\n            `LocationTaxonomy` class for available values.\n        taxonomy_id: Location taxonomy id\n    \"\"\"\n\n    id: int\n    name: str\n    location_taxonomy: str\n    taxonomy_id: int\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column","title":"<code>Column</code>","text":"<p>Contains constants for data frame column names.</p> Source code in <code>signal_ocean/tonnage_list/data_frame.py</code> <pre><code>class Column(metaclass=IterableConstants):\n    \"\"\"Contains constants for data frame column names.\"\"\"\n\n    NAME = \"name\"\n    \"\"\"The vessel's name.\"\"\"\n\n    VESSEL_CLASS = _category(\"vessel_class\")\n    \"\"\"Name of the vessel class the vessel is categorized as.\"\"\"\n\n    ICE_CLASS = _category(\"ice_class\")\n    \"\"\"The vessel's ice class.\"\"\"\n\n    YEAR_BUILT = \"year_built\"\n    \"\"\"The year the vessel has been built.\"\"\"\n\n    DEADWEIGHT = \"deadweight\"\n    \"\"\"The vessel's deadweight.\"\"\"\n\n    LENGTH_OVERALL = \"length_overall\"\n    \"\"\"The vessel's length overall.\"\"\"\n\n    BREADTH_EXTREME = \"breadth_extreme\"\n    \"\"\"The vessel's breadth extreme.\"\"\"\n\n    SUBCLASS = _category(\"subclass\")\n    \"\"\"The vessel's subclass. See the `VesselSubclass` class for available\n    values.\"\"\"\n\n    MARKET_DEPLOYMENT = _category(_pit_col(\"market_deployment\"))\n    \"\"\"Market deployment of the vessel at the tonnage lists' point in time. See\n    the `MarketDeployment` class for available values.\"\"\"\n\n    PUSH_TYPE = _category(_pit_col(\"push_type\"))\n    \"\"\"Push type of the vessel at the tonnage lists' point in time. See the\n    `PushType` class for available values.\"\"\"\n\n    OPEN_PORT_ID = _category(_pit_col(\"open_port_id\"))\n    \"\"\"The vessel's open port id at the tonnage lists' point in time.\"\"\"\n\n    OPEN_PORT = _category(_pit_col(\"open_port\"))\n    \"\"\"The vessel's open port name at the tonnage lists' point in time.\"\"\"\n\n    OPEN_DATE = _pit_col(\"open_date\")\n    \"\"\"The vessel's open date at the tonnage lists' point in time.\"\"\"\n\n    OPERATIONAL_STATUS = _category(_pit_col(\"operational_status\"))\n    \"\"\"Operational status of the vessel at the tonnage lists' point in time.\n    See the `OperationalStatus` class for available values.\"\"\"\n\n    COMMERCIAL_OPERATOR_ID = _category(_pit_col(\"commercial_operator_id\"))\n    \"\"\"The vessel's commercial operator id at the tonnage lists' point in\n    time.\"\"\"\n\n    COMMERCIAL_OPERATOR = _category(_pit_col(\"commercial_operator\"))\n    \"\"\"The vessel's commercial operator at the tonnage lists' point in time.\"\"\"\n\n    COMMERCIAL_STATUS = _category(_pit_col(\"commercial_status\"))\n    \"\"\"Commercial status of the vessel at the tonnage lists' point in time. See\n    the `CommercialStatus` class for available values.\"\"\"\n\n    ETA = _pit_col(\"eta\")\n    \"\"\"Estimated time of arrival at the tonnage lists' point in time.\"\"\"\n\n    LATEST_AIS = _pit_col(\"latest_ais\")\n    \"\"\"Timestamp of the vessel's latest AIS information at the tonnage lists'\n    point in time.\"\"\"\n\n    OPEN_PREDICTION_ACCURACY = _category(_pit_col(\"open_prediction_accuracy\"))\n    \"\"\"How accurate, in terms of location taxonomy, is the vessel's open\n    prediction at the tonnage lists' point in time. See the `LocationTaxonomy`\n    class for available values.\"\"\"\n\n    OPEN_COUNTRY = _category(_pit_col(\"open_country\"))\n    \"\"\"The country at which the vessel opens.\"\"\"\n\n    OPEN_NARROW_AREA = _category(_pit_col(\"open_narrow_area\"))\n    \"\"\"The narrow geographical area at which the vessel opens.\"\"\"\n\n    OPEN_WIDE_AREA = _category(_pit_col(\"open_wide_area\"))\n    \"\"\"The wide geographical area at which the vessel opens.\"\"\"\n\n    AVAILABILITY_PORT_TYPE = _category(_pit_col(\"availability_port_type\"))\n    \"\"\"Prediction source of the vessel's open port at the tonnage lists' point\n    in time. See the `SourceType` class for possible values.\"\"\"\n\n    AVAILABILITY_DATE_TYPE = _category(_pit_col(\"availability_date_type\"))\n    \"\"\"Prediction source of the vessel's open date at the tonnage lists' point\n    in time. See the `SourceType` class for possible values.\"\"\"\n\n    FIXTURE_TYPE = _category(_pit_col(\"fixture_type\"))\n    \"\"\"Fixture type. One of Scraped, Manual, Implied\"\"\"\n\n    CURRENT_VESSEL_SUB_TYPE_ID = _category(\n                                    _pit_col(\"current_vessel_sub_type_id\")\n                                          )\n    \"\"\"Current vessel sub type Id\"\"\"\n\n    CURRENT_VESSEL_SUB_TYPE = _category(_pit_col(\"current_vessel_sub_type\"))\n    \"\"\"One of: -1: Unknown, 1: Dirty, 2: Clean\"\"\"\n\n    WILLING_TO_SWITCH_CURRENT_VESSEL_SUB_TYPE = _pit_col(\n                    \"willing_to_switch_current_vessel_sub_type\"\n                                                         )\n    \"\"\"If the vessel is willing to compete on a different vessel subclass\n    category or not\"\"\"\n\n    @staticmethod\n    def _create_row(\n        name: str,\n        vessel_class: str,\n        ice_class: Optional[str],\n        year_built: int,\n        deadweight: int,\n        length_overall: float,\n        breadth_extreme: int,\n        subclass: str,\n        market_deployment: str,\n        push_type: str,\n        open_port_id: int,\n        open_port: str,\n        open_date: Optional[datetime],\n        operational_status: str,\n        commercial_operator_id: int,\n        commercial_operator: str,\n        commercial_status: str,\n        eta: Optional[datetime],\n        latest_ais: Optional[datetime],\n        open_prediction_accuracy: str,\n        open_country: Optional[str],\n        open_narrow_area: Optional[str],\n        open_wide_area: Optional[str],\n        availability_port_type: str,\n        availability_date_type: str,\n        fixture_type: str,\n        current_vessel_sub_type_id: int,\n        current_vessel_sub_type: str,\n        willing_to_switch_current_vessel_sub_type: bool,\n    ) -&gt; DataFrameRow:\n        return (\n            name,\n            vessel_class,\n            ice_class,\n            year_built,\n            deadweight,\n            length_overall,\n            breadth_extreme,\n            subclass,\n            market_deployment,\n            push_type,\n            open_port_id,\n            open_port,\n            open_date,\n            operational_status,\n            commercial_operator_id,\n            commercial_operator,\n            commercial_status,\n            eta,\n            latest_ais,\n            open_prediction_accuracy,\n            open_country,\n            open_narrow_area,\n            open_wide_area,\n            availability_port_type,\n            availability_date_type,\n            fixture_type,\n            current_vessel_sub_type_id,\n            current_vessel_sub_type,\n            willing_to_switch_current_vessel_sub_type\n        )\n\n    @staticmethod\n    def _get_data_types() -&gt; Dict[str, str]:\n        return _data_types\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.AVAILABILITY_DATE_TYPE","title":"<code>AVAILABILITY_DATE_TYPE = _category(_pit_col('availability_date_type'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Prediction source of the vessel's open date at the tonnage lists' point in time. See the <code>SourceType</code> class for possible values.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.AVAILABILITY_PORT_TYPE","title":"<code>AVAILABILITY_PORT_TYPE = _category(_pit_col('availability_port_type'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Prediction source of the vessel's open port at the tonnage lists' point in time. See the <code>SourceType</code> class for possible values.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.BREADTH_EXTREME","title":"<code>BREADTH_EXTREME = 'breadth_extreme'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's breadth extreme.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.COMMERCIAL_OPERATOR","title":"<code>COMMERCIAL_OPERATOR = _category(_pit_col('commercial_operator'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's commercial operator at the tonnage lists' point in time.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.COMMERCIAL_OPERATOR_ID","title":"<code>COMMERCIAL_OPERATOR_ID = _category(_pit_col('commercial_operator_id'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's commercial operator id at the tonnage lists' point in time.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.COMMERCIAL_STATUS","title":"<code>COMMERCIAL_STATUS = _category(_pit_col('commercial_status'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Commercial status of the vessel at the tonnage lists' point in time. See the <code>CommercialStatus</code> class for available values.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.CURRENT_VESSEL_SUB_TYPE","title":"<code>CURRENT_VESSEL_SUB_TYPE = _category(_pit_col('current_vessel_sub_type'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One of: -1: Unknown, 1: Dirty, 2: Clean</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.CURRENT_VESSEL_SUB_TYPE_ID","title":"<code>CURRENT_VESSEL_SUB_TYPE_ID = _category(_pit_col('current_vessel_sub_type_id'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current vessel sub type Id</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.DEADWEIGHT","title":"<code>DEADWEIGHT = 'deadweight'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's deadweight.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.ETA","title":"<code>ETA = _pit_col('eta')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Estimated time of arrival at the tonnage lists' point in time.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.FIXTURE_TYPE","title":"<code>FIXTURE_TYPE = _category(_pit_col('fixture_type'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixture type. One of Scraped, Manual, Implied</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.ICE_CLASS","title":"<code>ICE_CLASS = _category('ice_class')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's ice class.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.LATEST_AIS","title":"<code>LATEST_AIS = _pit_col('latest_ais')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Timestamp of the vessel's latest AIS information at the tonnage lists' point in time.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.LENGTH_OVERALL","title":"<code>LENGTH_OVERALL = 'length_overall'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's length overall.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.MARKET_DEPLOYMENT","title":"<code>MARKET_DEPLOYMENT = _category(_pit_col('market_deployment'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Market deployment of the vessel at the tonnage lists' point in time. See the <code>MarketDeployment</code> class for available values.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.NAME","title":"<code>NAME = 'name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's name.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.OPEN_COUNTRY","title":"<code>OPEN_COUNTRY = _category(_pit_col('open_country'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The country at which the vessel opens.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.OPEN_DATE","title":"<code>OPEN_DATE = _pit_col('open_date')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's open date at the tonnage lists' point in time.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.OPEN_NARROW_AREA","title":"<code>OPEN_NARROW_AREA = _category(_pit_col('open_narrow_area'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The narrow geographical area at which the vessel opens.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.OPEN_PORT","title":"<code>OPEN_PORT = _category(_pit_col('open_port'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's open port name at the tonnage lists' point in time.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.OPEN_PORT_ID","title":"<code>OPEN_PORT_ID = _category(_pit_col('open_port_id'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's open port id at the tonnage lists' point in time.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.OPEN_PREDICTION_ACCURACY","title":"<code>OPEN_PREDICTION_ACCURACY = _category(_pit_col('open_prediction_accuracy'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How accurate, in terms of location taxonomy, is the vessel's open prediction at the tonnage lists' point in time. See the <code>LocationTaxonomy</code> class for available values.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.OPEN_WIDE_AREA","title":"<code>OPEN_WIDE_AREA = _category(_pit_col('open_wide_area'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wide geographical area at which the vessel opens.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.OPERATIONAL_STATUS","title":"<code>OPERATIONAL_STATUS = _category(_pit_col('operational_status'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Operational status of the vessel at the tonnage lists' point in time. See the <code>OperationalStatus</code> class for available values.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.PUSH_TYPE","title":"<code>PUSH_TYPE = _category(_pit_col('push_type'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Push type of the vessel at the tonnage lists' point in time. See the <code>PushType</code> class for available values.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.SUBCLASS","title":"<code>SUBCLASS = _category('subclass')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's subclass. See the <code>VesselSubclass</code> class for available values.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.VESSEL_CLASS","title":"<code>VESSEL_CLASS = _category('vessel_class')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the vessel class the vessel is categorized as.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.WILLING_TO_SWITCH_CURRENT_VESSEL_SUB_TYPE","title":"<code>WILLING_TO_SWITCH_CURRENT_VESSEL_SUB_TYPE = _pit_col('willing_to_switch_current_vessel_sub_type')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If the vessel is willing to compete on a different vessel subclass category or not</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Column.YEAR_BUILT","title":"<code>YEAR_BUILT = 'year_built'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The year the vessel has been built.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.CommercialStatus","title":"<code>CommercialStatus</code>","text":"<p>Contains constants for available commercial statuses.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class CommercialStatus(metaclass=IterableConstants):\n    \"\"\"Contains constants for available commercial statuses.\"\"\"\n\n    ON_SUBS = \"On Subs\"\n    \"\"\"The vessel is \"on subs\" for a new fixture.\"\"\"\n\n    FAILED = \"Failed\"\n    \"\"\"The last fixture failed for this vessel.\"\"\"\n\n    CANCELLED = \"Cancelled\"\n    \"\"\"The last fixture has been cancelled for this vessel.\"\"\"\n\n    AVAILABLE = \"Available\"\n    \"\"\"The vessel is available for a new voyage after its open date.\"\"\"\n\n    POTENTIALLY_FIXED = \"Poss Fixed\"\n    \"\"\"The vessel is assumed to be fixed for a new voyage based on available\n    AIS information.\n    \"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.CommercialStatus.AVAILABLE","title":"<code>AVAILABLE = 'Available'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is available for a new voyage after its open date.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.CommercialStatus.CANCELLED","title":"<code>CANCELLED = 'Cancelled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The last fixture has been cancelled for this vessel.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.CommercialStatus.FAILED","title":"<code>FAILED = 'Failed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The last fixture failed for this vessel.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.CommercialStatus.ON_SUBS","title":"<code>ON_SUBS = 'On Subs'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is \"on subs\" for a new fixture.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.CommercialStatus.POTENTIALLY_FIXED","title":"<code>POTENTIALLY_FIXED = 'Poss Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is assumed to be fixed for a new voyage based on available AIS information.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.DateRange","title":"<code>DateRange</code>","text":"<p>A range of dates between a start and end date.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class DateRange:\n    \"\"\"A range of dates between a start and end date.\"\"\"\n\n    def __init__(self, start: Optional[date], end: Optional[date]):\n        \"\"\"Creates the date range.\n\n        Args:\n            start: The start date of the range (inclusive).\n            end: The end date of the range (inclusive).\n        \"\"\"\n        if start is not None and end is not None and end &lt; start:\n            raise ValueError(\"Start date cannot be after end date.\")\n\n        self.start = start\n        self.end = end\n\n    def _split(self, max_days: int) -&gt; Iterable[\"DateRange\"]:\n        if max_days &lt; 1:\n            raise ValueError(\n                f\"Date range cannot be split into chunks of {max_days} days.\"\n            )\n\n        max_size = timedelta(days=max_days - 1)\n        current_start = self.start\n\n        if current_start is not None and self.end is not None:\n            while self.end - current_start &gt; max_size:\n                current_end = current_start + max_size\n                yield DateRange(current_start, current_end)\n                current_start = current_end + timedelta(days=1)\n\n        yield DateRange(current_start, self.end)\n\n    def _to_query_string(self) -&gt; QueryString:\n        return {\n            \"startDate\": format_iso_date(self.start),\n            \"endDate\": format_iso_date(self.end),\n        }\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.DateRange.__init__","title":"<code>__init__(start, end)</code>","text":"<p>Creates the date range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Optional[date]</code> <p>The start date of the range (inclusive).</p> required <code>end</code> <code>Optional[date]</code> <p>The end date of the range (inclusive).</p> required Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>def __init__(self, start: Optional[date], end: Optional[date]):\n    \"\"\"Creates the date range.\n\n    Args:\n        start: The start date of the range (inclusive).\n        end: The end date of the range (inclusive).\n    \"\"\"\n    if start is not None and end is not None and end &lt; start:\n        raise ValueError(\"Start date cannot be after end date.\")\n\n    self.start = start\n    self.end = end\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.FixtureType","title":"<code>FixtureType</code>","text":"<p>Contains constants for available fixture types.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class FixtureType(metaclass=IterableConstants):\n    \"\"\"Contains constants for available fixture types.\"\"\"\n\n    SCRAPED = \"Scraped\"\n    \"\"\"The fixture was scraped from an email.\"\"\"\n\n    MANUAL = \"Manual\"\n    \"\"\"The fixture was added manually.\"\"\"\n\n    IMPLIED = \"Implied\"\n    \"\"\"The fixture is implied by the vessel's AIS destination.\"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.FixtureType.IMPLIED","title":"<code>IMPLIED = 'Implied'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fixture is implied by the vessel's AIS destination.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.FixtureType.MANUAL","title":"<code>MANUAL = 'Manual'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fixture was added manually.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.FixtureType.SCRAPED","title":"<code>SCRAPED = 'Scraped'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fixture was scraped from an email.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.HistoricalTonnageList","title":"<code>HistoricalTonnageList</code>","text":"<p>               Bases: <code>Sequence[TonnageList]</code></p> <p>A historical tonnage list.</p> <p>A historical tonnage list consists of a collection of tonnage lists, one for every day between the start and end date specified when querying the Historical Tonnage List API.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class HistoricalTonnageList(Sequence[TonnageList]):\n    \"\"\"A historical tonnage list.\n\n    A historical tonnage list consists of a collection of tonnage lists, one\n    for every day between the start and end date specified when querying the\n    Historical Tonnage List API.\n    \"\"\"\n\n    def __init__(self, tonnage_lists: Iterable[TonnageList]):\n        \"\"\"Initializes the `HistoricalTonnageList`.\n\n        Args:\n            tonnage_lists: Tonnage lists per each day in the historical date\n                range.\n        \"\"\"\n        self.tonnage_lists = tuple(tonnage_lists)\n\n    @overload\n    def __getitem__(self, index: int) -&gt; TonnageList:  # noqa: D105\n        ...\n\n    @overload\n    def __getitem__(self, slice: slice) -&gt; Sequence[TonnageList]:  # noqa: D105\n        ...\n\n    def __getitem__(\n        self, i: Union[int, slice]\n    ) -&gt; Union[TonnageList, Sequence[TonnageList]]:  # noqa: D105\n        return self.tonnage_lists.__getitem__(i)\n\n    def __len__(self) -&gt; int:  # noqa: D105\n        return self.tonnage_lists.__len__()\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        class_name = self.__class__.__name__\n        return f\"{class_name}(tonnage_lists={self.tonnage_lists!r})\"\n\n    def to_data_frame(self) -&gt; pd.DataFrame:\n        \"\"\"Converts the Historical Tonnage List to a pandas data frame.\"\"\"\n        index_tuples = []\n        data = []\n        for tonnage_list in self.tonnage_lists:\n            for vessel in tonnage_list.vessels:\n                index_tuples.append((tonnage_list.date, vessel.imo))\n                data.append(vessel._to_data_frame_row())\n\n        data_frame = pd.DataFrame(\n            data,\n            index=pd.MultiIndex.from_tuples(\n                index_tuples, names=[IndexLevel.DATE, IndexLevel.IMO]\n            ),\n            columns=list(Column),\n        )\n\n        return data_frame.astype(Column._get_data_types())  # type: ignore\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.HistoricalTonnageList.__init__","title":"<code>__init__(tonnage_lists)</code>","text":"<p>Initializes the <code>HistoricalTonnageList</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tonnage_lists</code> <code>Iterable[TonnageList]</code> <p>Tonnage lists per each day in the historical date range.</p> required Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>def __init__(self, tonnage_lists: Iterable[TonnageList]):\n    \"\"\"Initializes the `HistoricalTonnageList`.\n\n    Args:\n        tonnage_lists: Tonnage lists per each day in the historical date\n            range.\n    \"\"\"\n    self.tonnage_lists = tuple(tonnage_lists)\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.HistoricalTonnageList.to_data_frame","title":"<code>to_data_frame()</code>","text":"<p>Converts the Historical Tonnage List to a pandas data frame.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>def to_data_frame(self) -&gt; pd.DataFrame:\n    \"\"\"Converts the Historical Tonnage List to a pandas data frame.\"\"\"\n    index_tuples = []\n    data = []\n    for tonnage_list in self.tonnage_lists:\n        for vessel in tonnage_list.vessels:\n            index_tuples.append((tonnage_list.date, vessel.imo))\n            data.append(vessel._to_data_frame_row())\n\n    data_frame = pd.DataFrame(\n        data,\n        index=pd.MultiIndex.from_tuples(\n            index_tuples, names=[IndexLevel.DATE, IndexLevel.IMO]\n        ),\n        columns=list(Column),\n    )\n\n    return data_frame.astype(Column._get_data_types())  # type: ignore\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.IndexLevel","title":"<code>IndexLevel</code>","text":"<p>Contains constants for available data frame index levels.</p> Source code in <code>signal_ocean/tonnage_list/data_frame.py</code> <pre><code>class IndexLevel(metaclass=IterableConstants):\n    \"\"\"Contains constants for available data frame index levels.\"\"\"\n\n    DATE = \"date\"\n    \"\"\"The point in time at which the data was captured.\"\"\"\n\n    IMO = \"imo\"\n    \"\"\"The vessel's IMO number.\"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.IndexLevel.DATE","title":"<code>DATE = 'date'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The point in time at which the data was captured.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.IndexLevel.IMO","title":"<code>IMO = 'imo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel's IMO number.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.LocationTaxonomy","title":"<code>LocationTaxonomy</code>","text":"<p>Contains constants for available location taxonomies.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class LocationTaxonomy(metaclass=IterableConstants):\n    \"\"\"Contains constants for available location taxonomies.\"\"\"\n\n    PORT = \"Port\"\n    \"\"\"A port.\"\"\"\n\n    COUNTRY = \"Country\"\n    \"\"\"A country.\"\"\"\n\n    NARROW_AREA = \"Narrow Area\"\n    \"\"\"A narrow geographical Area.\"\"\"\n\n    WIDE_AREA = \"Wide Area\"\n    \"\"\"A wide geographical area.\"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.LocationTaxonomy.COUNTRY","title":"<code>COUNTRY = 'Country'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A country.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.LocationTaxonomy.NARROW_AREA","title":"<code>NARROW_AREA = 'Narrow Area'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A narrow geographical Area.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.LocationTaxonomy.PORT","title":"<code>PORT = 'Port'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A port.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.LocationTaxonomy.WIDE_AREA","title":"<code>WIDE_AREA = 'Wide Area'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A wide geographical area.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.MarketDeployment","title":"<code>MarketDeployment</code>","text":"<p>Available market deployments.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class MarketDeployment(metaclass=IterableConstants):\n    \"\"\"Available market deployments.\"\"\"\n\n    SPOT = \"Spot\"\n    \"\"\"Vessels controlled by commercial operators that participate in the spot\n    market and are advertised through tonnage lists and reported fixtures.\n    \"\"\"\n\n    PROGRAM = \"Program\"\n    \"\"\"Vessels that are controlled by charterers that do not participate in the\n    spot market and are either not advertised through tonnage lists or tonnage\n    lists report the fact that they participate in the program market.\n    \"\"\"\n\n    RELET = \"Relet\"\n    \"\"\"Vessels controlled by charterers that participate in the spot market and\n    are advertised through tonnage lists and reported fixtures.\n    \"\"\"\n\n    CONTRACT = \"Contract\"\n    \"\"\"Vessels controlled by commercial operators that do not participate in\n    the spot market and are typically carrying system cargoes with repetitive\n    trading patterns.\n    \"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.MarketDeployment.CONTRACT","title":"<code>CONTRACT = 'Contract'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels controlled by commercial operators that do not participate in the spot market and are typically carrying system cargoes with repetitive trading patterns.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.MarketDeployment.PROGRAM","title":"<code>PROGRAM = 'Program'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels that are controlled by charterers that do not participate in the spot market and are either not advertised through tonnage lists or tonnage lists report the fact that they participate in the program market.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.MarketDeployment.RELET","title":"<code>RELET = 'Relet'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels controlled by charterers that participate in the spot market and are advertised through tonnage lists and reported fixtures.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.MarketDeployment.SPOT","title":"<code>SPOT = 'Spot'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels controlled by commercial operators that participate in the spot market and are advertised through tonnage lists and reported fixtures.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus","title":"<code>OperationalStatus</code>","text":"<p>Contains constants for available operational statuses.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class OperationalStatus(metaclass=IterableConstants):\n    \"\"\"Contains constants for available operational statuses.\"\"\"\n\n    BALLAST_FIXED = \"Ballast Fixed\"\n    \"\"\"The vessel is currently without cargo but fixed.\"\"\"\n\n    REPAIRS = \"Repairs\"\n    \"\"\"The vessel is undergoing repairs or is in dry dock.\"\"\"\n\n    WAITING_TO_LOAD = \"Waiting to Load\"\n    \"\"\"The vessel is waiting to load.\"\"\"\n\n    LOADING = \"Loading\"\n    \"\"\"The vessel is loading.\n\n    This means the vessel has entered a jetty or is performing a ship-to-ship\n    operation.\"\"\"\n\n    LADEN = \"Laden\"\n    \"\"\"The vesel has loaded.\"\"\"\n\n    WAITING_TO_DISCHARGE = \"Waiting to Discharge\"\n    \"\"\"The vessel is waiting to Discharge.\"\"\"\n\n    DISCHARGING = \"Discharging\"\n    \"\"\"The vessel is discharging.\n\n    This means the vessel has entered a jetty or is performing a ship-to-ship\n    operation.\"\"\"\n\n    ACTIVE_STORAGE = \"Active Storage\"\n    \"\"\"The vessel is in active storage.\n\n    This means the vessel acts as short-term storage (in comparison to storage\n    vessels).\n    \"\"\"\n\n    BALLAST_UNFIXED = \"Ballast Unfixed\"\n    \"\"\"The vessel is currently without cargo and is not fixed (is prompt).\"\"\"\n\n    BALLAST_FIXED_IMPLIED = \"Ballast Fixed (implied)\"\n    \"\"\"The vessel is currently without cargo and its AIS destination implies\n    that it's fixed.\"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.ACTIVE_STORAGE","title":"<code>ACTIVE_STORAGE = 'Active Storage'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is in active storage.</p> <p>This means the vessel acts as short-term storage (in comparison to storage vessels).</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.BALLAST_FIXED","title":"<code>BALLAST_FIXED = 'Ballast Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is currently without cargo but fixed.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.BALLAST_FIXED_IMPLIED","title":"<code>BALLAST_FIXED_IMPLIED = 'Ballast Fixed (implied)'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is currently without cargo and its AIS destination implies that it's fixed.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.BALLAST_UNFIXED","title":"<code>BALLAST_UNFIXED = 'Ballast Unfixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is currently without cargo and is not fixed (is prompt).</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.DISCHARGING","title":"<code>DISCHARGING = 'Discharging'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is discharging.</p> <p>This means the vessel has entered a jetty or is performing a ship-to-ship operation.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.LADEN","title":"<code>LADEN = 'Laden'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vesel has loaded.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.LOADING","title":"<code>LOADING = 'Loading'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is loading.</p> <p>This means the vessel has entered a jetty or is performing a ship-to-ship operation.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.REPAIRS","title":"<code>REPAIRS = 'Repairs'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is undergoing repairs or is in dry dock.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.WAITING_TO_DISCHARGE","title":"<code>WAITING_TO_DISCHARGE = 'Waiting to Discharge'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is waiting to Discharge.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.OperationalStatus.WAITING_TO_LOAD","title":"<code>WAITING_TO_LOAD = 'Waiting to Load'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The vessel is waiting to load.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Port","title":"<code>Port</code>  <code>dataclass</code>","text":"<p>A maritime facility where vessels can dock.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the port.</p> <code>name</code> <code>str</code> <p>The name of the port.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass Port:\n    \"\"\"A maritime facility where vessels can dock.\n\n    Attributes:\n        id: The ID of the port.\n        name: The name of the port.\n    \"\"\"\n\n    id: int\n    name: str\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.PortFilter","title":"<code>PortFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific ports.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find ports by name. When specified, ports whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>@dataclass(eq=False)\nclass PortFilter:\n    \"\"\"A filter used to find specific ports.\n\n    Attributes:\n        name_like: Used to find ports by name. When specified, ports whose\n            names partially match (contain) the attribute's value will be\n            returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(self, ports: Iterable[Port]) -&gt; Iterable[Port]:\n        return filter(self.__does_port_match, ports)\n\n    def __does_port_match(self, port: Port) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, port.name\n        )\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.PushType","title":"<code>PushType</code>","text":"<p>Available push types.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class PushType(metaclass=IterableConstants):\n    \"\"\"Available push types.\"\"\"\n\n    NOT_PUSHED = \"Not Pushed\"\n    \"\"\"Vessels that are not pushed anymore.\"\"\"\n\n    PUSHED_POSS = \"Pushed POSS\"\n    \"\"\"Vessels actively pushed in the market with notification \"Poss\".\n\n    \"Poss\" stands for \"Possibly\", meaning that vessels marked with this type\n    are a broker projection.\n    \"\"\"\n\n    PUSHED = \"Pushed\"\n    \"\"\"Vessels actively pushed in the market through tonnage or position lists.\n    \"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.PushType.NOT_PUSHED","title":"<code>NOT_PUSHED = 'Not Pushed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels that are not pushed anymore.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.PushType.PUSHED","title":"<code>PUSHED = 'Pushed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels actively pushed in the market through tonnage or position lists.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.PushType.PUSHED_POSS","title":"<code>PUSHED_POSS = 'Pushed POSS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels actively pushed in the market with notification \"Poss\".</p> <p>\"Poss\" stands for \"Possibly\", meaning that vessels marked with this type are a broker projection.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.SourceType","title":"<code>SourceType</code>","text":"<p>Contains constants for available prediction source types.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class SourceType(metaclass=IterableConstants):\n    \"\"\"Contains constants for available prediction source types.\"\"\"\n\n    SOURCE = \"Source\"\n    \"\"\"There is hard evidence backing the given prediction.\"\"\"\n\n    PREDICTION = \"Prediction\"\n    \"\"\"The prediction was made based on an algorithm.\"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.SourceType.PREDICTION","title":"<code>PREDICTION = 'Prediction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The prediction was made based on an algorithm.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.SourceType.SOURCE","title":"<code>SOURCE = 'Source'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>There is hard evidence backing the given prediction.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageList","title":"<code>TonnageList</code>","text":"<p>               Bases: <code>Sequence[Vessel]</code></p> <p>A tonnage list as it occurred at a certain point in time.</p> <p>Attributes:</p> Name Type Description <code>vessels</code> <p>Vessels present in the tonnage list at the time it was captured. For more details see the <code>Vessel</code> class.</p> <code>date</code> <p>The date and time at which the tonnage list was captured.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class TonnageList(Sequence[Vessel]):\n    \"\"\"A tonnage list as it occurred at a certain point in time.\n\n    Attributes:\n        vessels: Vessels present in the tonnage list at the time it was\n            captured. For more details see the `Vessel` class.\n        date: The date and time at which the tonnage list was captured.\n    \"\"\"\n\n    def __init__(self, vessels: Iterable[Vessel], date: datetime):\n        \"\"\"Initializes the tonnage list.\n\n        Args:\n            vessels: Vessels present in the tonnage list at the time it was\n                captured. For more details see the `Vessel` class.\n            date: The date and time at which the tonnage list was captured.\n        \"\"\"\n        self.vessels = tuple(vessels)\n        self.date = date\n\n    @overload\n    def __getitem__(self, index: int) -&gt; Vessel:  # noqa: D105\n        ...\n\n    @overload\n    def __getitem__(self, slice: slice) -&gt; Sequence[Vessel]:  # noqa: D105\n        ...\n\n    def __getitem__(\n        self, i: Union[int, slice]\n    ) -&gt; Union[Vessel, Sequence[Vessel]]:  # noqa: D105\n        return self.vessels.__getitem__(i)\n\n    def __len__(self) -&gt; int:  # noqa: D105\n        return self.vessels.__len__()\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        class_name = self.__class__.__name__\n        return f\"{class_name}(vessels={self.vessels!r})\"\n\n    def to_data_frame(self) -&gt; pd.DataFrame:\n        \"\"\"Converts the tonnage list to a pandas data frame.\"\"\"\n        vessels_by_imo = {v.imo: v._to_data_frame_row() for v in self.vessels}\n        data_frame = pd.DataFrame.from_dict(vessels_by_imo, orient=\"index\", columns=list(Column))   # noqa\n        data_frame.index.set_names(IndexLevel.IMO)\n\n        return data_frame.astype(Column._get_data_types())  # type: ignore\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageList.__init__","title":"<code>__init__(vessels, date)</code>","text":"<p>Initializes the tonnage list.</p> <p>Parameters:</p> Name Type Description Default <code>vessels</code> <code>Iterable[Vessel]</code> <p>Vessels present in the tonnage list at the time it was captured. For more details see the <code>Vessel</code> class.</p> required <code>date</code> <code>datetime</code> <p>The date and time at which the tonnage list was captured.</p> required Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>def __init__(self, vessels: Iterable[Vessel], date: datetime):\n    \"\"\"Initializes the tonnage list.\n\n    Args:\n        vessels: Vessels present in the tonnage list at the time it was\n            captured. For more details see the `Vessel` class.\n        date: The date and time at which the tonnage list was captured.\n    \"\"\"\n    self.vessels = tuple(vessels)\n    self.date = date\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageList.to_data_frame","title":"<code>to_data_frame()</code>","text":"<p>Converts the tonnage list to a pandas data frame.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>def to_data_frame(self) -&gt; pd.DataFrame:\n    \"\"\"Converts the tonnage list to a pandas data frame.\"\"\"\n    vessels_by_imo = {v.imo: v._to_data_frame_row() for v in self.vessels}\n    data_frame = pd.DataFrame.from_dict(vessels_by_imo, orient=\"index\", columns=list(Column))   # noqa\n    data_frame.index.set_names(IndexLevel.IMO)\n\n    return data_frame.astype(Column._get_data_types())  # type: ignore\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageListAPI","title":"<code>TonnageListAPI</code>","text":"<p>Handles communication with Signal's Tonnage List API.</p> Source code in <code>signal_ocean/tonnage_list/api.py</code> <pre><code>class TonnageListAPI:\n    \"\"\"Handles communication with Signal's Tonnage List API.\"\"\"\n\n    __MAX_DATE_RANGE_DAYS = 365\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes `TonnageListAPI`.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_tonnage_list(\n        self,\n        loading_port: Port,\n        vessel_class: VesselClass,\n        laycan_end_in_days: Optional[int] = None,\n        vessel_filter: Optional[VesselFilter] = None,\n    ) -&gt; TonnageList:\n        \"\"\"Retrieves a tonnage list.\n\n        Args:\n            loading_port: A loading port from which ETA will be calculated.\n            vessel_class: The vessel class of vessels in the tonnage list.\n            laycan_end_in_days: The maximum ETA expressed as a number of days\n                from now.\n            vessel_filter: A filter defining which vessels should be included\n                in the response. See the `VesselFilter` class for details.\n\n        Returns:\n            Returns a `TonnageList` containing vessels that match the specified\n            criteria.\n        \"\"\"\n        query_string: QueryString = {\n            \"loadingPort\": loading_port.id,\n            \"vesselClass\": vessel_class.id,\n            \"laycanEndInDays\": laycan_end_in_days,\n            **(vessel_filter._to_query_string() if vessel_filter else {}),\n        }\n\n        response = self.__connection._make_get_request(\n            \"htl-api/tonnage-list/\", query_string\n        )\n\n        response.raise_for_status()\n        return _json.parse_tonnage_list_response(response.json())\n\n    def get_historical_tonnage_list(\n        self,\n        loading_port: Port,\n        vessel_class: VesselClass,\n        laycan_end_in_days: Optional[int] = None,\n        date_range: Optional[DateRange] = None,\n        vessel_filter: Optional[VesselFilter] = None,\n    ) -&gt; HistoricalTonnageList:\n        \"\"\"Retrieves a historical tonnage list.\n\n        If no input dates are provided, the last 10 days will be fetched\n        (including today).\n\n        To get a tonnage list for a specific day, set both date parameters to\n        the desired date.\n\n        Args:\n            loading_port: A loading port from which ETA will be calculated.\n            vessel_class: The vessel class of vessels in the tonnage list.\n            laycan_end_in_days: The maximum ETA expressed as a number of days\n                after the end date.\n            date_range: A range of dates for which to get historical tonnage\n                lists.\n            vessel_filter: A filter defining which vessels should be included\n                in the response. See `VesselFilter` class for details.\n\n        Returns:\n            Given a time-range, returns a `HistoricalTonnageList` containing a\n            `TonnageList` for every day between the start and end dates.\n        \"\"\"\n        date_ranges = (date_range or DateRange(start=None, end=None))._split(\n            TonnageListAPI.__MAX_DATE_RANGE_DAYS\n        )\n\n        tonnage_lists = (\n            tonnage_list\n            for dr in date_ranges\n            for tonnage_list in self._get_htl_chunk(\n                loading_port,\n                vessel_class,\n                dr,\n                laycan_end_in_days,\n                vessel_filter,\n            )\n        )\n\n        return HistoricalTonnageList(tonnage_lists)\n\n    def _get_htl_chunk(\n        self,\n        loading_port: Port,\n        vessel_class: VesselClass,\n        date_range: DateRange,\n        laycan_end_in_days: Optional[int] = None,\n        vessel_filter: Optional[VesselFilter] = None,\n    ) -&gt; HistoricalTonnageList:\n        query_string: QueryString = {\n            \"loadingPort\": loading_port.id,\n            \"vesselClass\": vessel_class.id,\n            \"laycanEndInDays\": laycan_end_in_days,\n            **date_range._to_query_string(),\n            **(vessel_filter._to_query_string() if vessel_filter else {}),\n        }\n\n        response = self.__connection._make_get_request(\n            \"htl-api/historical-tonnage-list/\", query_string\n        )\n\n        response.raise_for_status()\n        return _json.parse_historical_tonnage_list_response(response.json())\n\n    def get_ports(\n        self, port_filter: Optional[PortFilter] = None\n    ) -&gt; Tuple[Port, ...]:\n        \"\"\"Retrieves available ports.\n\n        Args:\n            port_filter: A filter used to find specific ports. If not\n                specified, returns all available ports.\n\n        Returns:\n            A tuple of available ports that match the filter.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"htl-api/historical-tonnage-list/ports\"\n        )\n        response.raise_for_status()\n\n        ports = (Port(**p) for p in response.json())\n        port_filter = port_filter or PortFilter()\n\n        return tuple(port_filter._apply(ports))\n\n    def get_vessel_classes(\n        self, class_filter: Optional[VesselClassFilter] = None\n    ) -&gt; Tuple[VesselClass, ...]:\n        \"\"\"Retrieves available vessel classes.\n\n        Args:\n            class_filter: A filter used to find specific vessel classes. If not\n                specified, returns all available vessel classes.\n\n        Returns:\n            A tuple of available vessel classes that match the filter.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"htl-api/historical-tonnage-list/vessel-classes\"\n        )\n        response.raise_for_status()\n\n        classes = (VesselClass(**c) for c in response.json())\n        class_filter = class_filter or VesselClassFilter()\n\n        return tuple(class_filter._apply(classes))\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageListAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes <code>TonnageListAPI</code>.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/tonnage_list/api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes `TonnageListAPI`.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageListAPI.get_historical_tonnage_list","title":"<code>get_historical_tonnage_list(loading_port, vessel_class, laycan_end_in_days=None, date_range=None, vessel_filter=None)</code>","text":"<p>Retrieves a historical tonnage list.</p> <p>If no input dates are provided, the last 10 days will be fetched (including today).</p> <p>To get a tonnage list for a specific day, set both date parameters to the desired date.</p> <p>Parameters:</p> Name Type Description Default <code>loading_port</code> <code>Port</code> <p>A loading port from which ETA will be calculated.</p> required <code>vessel_class</code> <code>VesselClass</code> <p>The vessel class of vessels in the tonnage list.</p> required <code>laycan_end_in_days</code> <code>Optional[int]</code> <p>The maximum ETA expressed as a number of days after the end date.</p> <code>None</code> <code>date_range</code> <code>Optional[DateRange]</code> <p>A range of dates for which to get historical tonnage lists.</p> <code>None</code> <code>vessel_filter</code> <code>Optional[VesselFilter]</code> <p>A filter defining which vessels should be included in the response. See <code>VesselFilter</code> class for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>HistoricalTonnageList</code> <p>Given a time-range, returns a <code>HistoricalTonnageList</code> containing a</p> <code>HistoricalTonnageList</code> <p><code>TonnageList</code> for every day between the start and end dates.</p> Source code in <code>signal_ocean/tonnage_list/api.py</code> <pre><code>def get_historical_tonnage_list(\n    self,\n    loading_port: Port,\n    vessel_class: VesselClass,\n    laycan_end_in_days: Optional[int] = None,\n    date_range: Optional[DateRange] = None,\n    vessel_filter: Optional[VesselFilter] = None,\n) -&gt; HistoricalTonnageList:\n    \"\"\"Retrieves a historical tonnage list.\n\n    If no input dates are provided, the last 10 days will be fetched\n    (including today).\n\n    To get a tonnage list for a specific day, set both date parameters to\n    the desired date.\n\n    Args:\n        loading_port: A loading port from which ETA will be calculated.\n        vessel_class: The vessel class of vessels in the tonnage list.\n        laycan_end_in_days: The maximum ETA expressed as a number of days\n            after the end date.\n        date_range: A range of dates for which to get historical tonnage\n            lists.\n        vessel_filter: A filter defining which vessels should be included\n            in the response. See `VesselFilter` class for details.\n\n    Returns:\n        Given a time-range, returns a `HistoricalTonnageList` containing a\n        `TonnageList` for every day between the start and end dates.\n    \"\"\"\n    date_ranges = (date_range or DateRange(start=None, end=None))._split(\n        TonnageListAPI.__MAX_DATE_RANGE_DAYS\n    )\n\n    tonnage_lists = (\n        tonnage_list\n        for dr in date_ranges\n        for tonnage_list in self._get_htl_chunk(\n            loading_port,\n            vessel_class,\n            dr,\n            laycan_end_in_days,\n            vessel_filter,\n        )\n    )\n\n    return HistoricalTonnageList(tonnage_lists)\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageListAPI.get_ports","title":"<code>get_ports(port_filter=None)</code>","text":"<p>Retrieves available ports.</p> <p>Parameters:</p> Name Type Description Default <code>port_filter</code> <code>Optional[PortFilter]</code> <p>A filter used to find specific ports. If not specified, returns all available ports.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Port, ...]</code> <p>A tuple of available ports that match the filter.</p> Source code in <code>signal_ocean/tonnage_list/api.py</code> <pre><code>def get_ports(\n    self, port_filter: Optional[PortFilter] = None\n) -&gt; Tuple[Port, ...]:\n    \"\"\"Retrieves available ports.\n\n    Args:\n        port_filter: A filter used to find specific ports. If not\n            specified, returns all available ports.\n\n    Returns:\n        A tuple of available ports that match the filter.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"htl-api/historical-tonnage-list/ports\"\n    )\n    response.raise_for_status()\n\n    ports = (Port(**p) for p in response.json())\n    port_filter = port_filter or PortFilter()\n\n    return tuple(port_filter._apply(ports))\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageListAPI.get_tonnage_list","title":"<code>get_tonnage_list(loading_port, vessel_class, laycan_end_in_days=None, vessel_filter=None)</code>","text":"<p>Retrieves a tonnage list.</p> <p>Parameters:</p> Name Type Description Default <code>loading_port</code> <code>Port</code> <p>A loading port from which ETA will be calculated.</p> required <code>vessel_class</code> <code>VesselClass</code> <p>The vessel class of vessels in the tonnage list.</p> required <code>laycan_end_in_days</code> <code>Optional[int]</code> <p>The maximum ETA expressed as a number of days from now.</p> <code>None</code> <code>vessel_filter</code> <code>Optional[VesselFilter]</code> <p>A filter defining which vessels should be included in the response. See the <code>VesselFilter</code> class for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>TonnageList</code> <p>Returns a <code>TonnageList</code> containing vessels that match the specified</p> <code>TonnageList</code> <p>criteria.</p> Source code in <code>signal_ocean/tonnage_list/api.py</code> <pre><code>def get_tonnage_list(\n    self,\n    loading_port: Port,\n    vessel_class: VesselClass,\n    laycan_end_in_days: Optional[int] = None,\n    vessel_filter: Optional[VesselFilter] = None,\n) -&gt; TonnageList:\n    \"\"\"Retrieves a tonnage list.\n\n    Args:\n        loading_port: A loading port from which ETA will be calculated.\n        vessel_class: The vessel class of vessels in the tonnage list.\n        laycan_end_in_days: The maximum ETA expressed as a number of days\n            from now.\n        vessel_filter: A filter defining which vessels should be included\n            in the response. See the `VesselFilter` class for details.\n\n    Returns:\n        Returns a `TonnageList` containing vessels that match the specified\n        criteria.\n    \"\"\"\n    query_string: QueryString = {\n        \"loadingPort\": loading_port.id,\n        \"vesselClass\": vessel_class.id,\n        \"laycanEndInDays\": laycan_end_in_days,\n        **(vessel_filter._to_query_string() if vessel_filter else {}),\n    }\n\n    response = self.__connection._make_get_request(\n        \"htl-api/tonnage-list/\", query_string\n    )\n\n    response.raise_for_status()\n    return _json.parse_tonnage_list_response(response.json())\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.TonnageListAPI.get_vessel_classes","title":"<code>get_vessel_classes(class_filter=None)</code>","text":"<p>Retrieves available vessel classes.</p> <p>Parameters:</p> Name Type Description Default <code>class_filter</code> <code>Optional[VesselClassFilter]</code> <p>A filter used to find specific vessel classes. If not specified, returns all available vessel classes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VesselClass, ...]</code> <p>A tuple of available vessel classes that match the filter.</p> Source code in <code>signal_ocean/tonnage_list/api.py</code> <pre><code>def get_vessel_classes(\n    self, class_filter: Optional[VesselClassFilter] = None\n) -&gt; Tuple[VesselClass, ...]:\n    \"\"\"Retrieves available vessel classes.\n\n    Args:\n        class_filter: A filter used to find specific vessel classes. If not\n            specified, returns all available vessel classes.\n\n    Returns:\n        A tuple of available vessel classes that match the filter.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"htl-api/historical-tonnage-list/vessel-classes\"\n    )\n    response.raise_for_status()\n\n    classes = (VesselClass(**c) for c in response.json())\n    class_filter = class_filter or VesselClassFilter()\n\n    return tuple(class_filter._apply(classes))\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Vessel","title":"<code>Vessel</code>  <code>dataclass</code>","text":"<p>Holds information for a vessel that's present in a <code>TonnageList</code>.</p> <p>Contains both static and point-in-time vessel data. When converted to a data frame, all point-in-time data is suffixed with <code>_point_in_time</code>. See the <code>Column</code> class for the available data frame column names.</p> <p>Attributes:</p> Name Type Description <code>imo</code> <code>int</code> <p>The vessel's IMO number.</p> <code>name</code> <code>str</code> <p>The vessel's name.</p> <code>vessel_class</code> <code>str</code> <p>Name of the vessel class the vessel is categorized as.</p> <code>ice_class</code> <code>Optional[str]</code> <p>The vessel's ice class.</p> <code>year_built</code> <code>int</code> <p>The year the vessel has been built.</p> <code>deadweight</code> <code>int</code> <p>The vessel's deadweight.</p> <code>length_overall</code> <code>float</code> <p>The vessel's length overall.</p> <code>breadth_extreme</code> <code>int</code> <p>The vessel's breadth extreme.</p> <code>market_deployment</code> <code>str</code> <p>Market deployment of the vessel at the tonnage lists' point in time. See the <code>MarketDeployment</code> class for available values.</p> <code>push_type</code> <code>str</code> <p>Push type of the vessel at the tonnage lists' point in time. See the <code>PushType</code> class for available values.</p> <code>open_port_id</code> <code>int</code> <p>The vessel's open port id at the tonnage lists' point in time.</p> <code>open_port</code> <code>str</code> <p>The vessel's open port name at the tonnage lists' point in time.</p> <code>open_date</code> <code>Optional[datetime]</code> <p>The vessel's open date at the tonnage lists' point in time.</p> <code>operational_status</code> <code>str</code> <p>Operational status of the vessel at the tonnage lists' point in time. See the <code>OperationalStatus</code> class for available values.</p> <code>commercial_operator_id</code> <code>int</code> <p>The vessel's commercial operator id at the tonnage lists' point in time.</p> <code>commercial_operator</code> <code>str</code> <p>The vessel's commercial operator at the tonnage lists' point in time.</p> <code>commercial_status</code> <code>str</code> <p>Commercial status of the vessel at the tonnage lists' point in time. See the <code>CommercialStatus</code> class for available values.</p> <code>eta</code> <code>Optional[datetime]</code> <p>Estimated time of arrival at the tonnage lists' point in time.</p> <code>latest_ais</code> <code>Optional[datetime]</code> <p>Timestamp of the vessel's latest AIS information at the tonnage lists' point in time.</p> <code>subclass</code> <code>str</code> <p>The vessel's subclass. See the <code>VesselSubclass</code> class for available values.</p> <code>willing_to_switch_subclass</code> <code>bool</code> <p>When <code>True</code>, the vessel is willing to switch its subclass.</p> <code>open_prediction_accuracy</code> <code>str</code> <p>How accurate, in terms of location taxonomy, is the vessel's open prediction at the tonnage lists' point in time. See the <code>LocationTaxonomy</code> class for available values.</p> <code>open_areas</code> <code>Tuple[Area, ...]</code> <p>A hierarchical collection of areas the vessel opens at at the tonnage lists' point in time.</p> <p>If a vessel opens at a specific port, this attribute will contain areas containing the port. For example, the continent, wide/narrow areas, country, etc.</p> <code>availability_port_type</code> <code>str</code> <p>Prediction source of the vessel's open port at the tonnage lists' point in time. See the <code>SourceType</code> class for possible values.</p> <code>availability_date_type</code> <code>str</code> <p>Prediction source of the vessel's open date at the tonnage lists' point in time. See the <code>SourceType</code> class for possible values.</p> <code>fixture_type</code> <code>str</code> <p>Fixture type. One of Scraped, Manual, Implied</p> <code>current_vessel_sub_type_id</code> <code>int</code> <p>Current vessel sub type Id</p> <code>current_vessel_sub_type</code> <code>str</code> <p>One of: -1: Unknown, 1: Dirty, 2: Clean</p> <code>willing_to_switch_current_vessel_sub_type</code> <code>bool</code> <p>bool nullable. If the vessel is willing to compete on a different vessel subclass category or not.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass Vessel:\n    \"\"\"Holds information for a vessel that's present in a `TonnageList`.\n\n    Contains both static and point-in-time vessel data. When converted to a\n    data frame, all point-in-time data is suffixed with `_point_in_time`. See\n    the `Column` class for the available data frame column names.\n\n    Attributes:\n        imo: The vessel's IMO number.\n        name: The vessel's name.\n        vessel_class: Name of the vessel class the vessel is categorized as.\n        ice_class: The vessel's ice class.\n        year_built: The year the vessel has been built.\n        deadweight: The vessel's deadweight.\n        length_overall: The vessel's length overall.\n        breadth_extreme: The vessel's breadth extreme.\n        market_deployment: Market deployment of the vessel at the tonnage\n            lists' point in time. See the `MarketDeployment` class for\n            available values.\n        push_type: Push type of the vessel at the tonnage lists' point in time.\n            See the `PushType` class for available values.\n        open_port_id: The vessel's open port id at the tonnage lists' point in\n            time.\n        open_port: The vessel's open port name at the tonnage lists' point in\n            time.\n        open_date: The vessel's open date at the tonnage lists' point in time.\n        operational_status: Operational status of the vessel at the tonnage\n            lists' point in time. See the `OperationalStatus` class for\n            available values.\n        commercial_operator_id: The vessel's commercial operator id\n            at the tonnage lists' point in time.\n        commercial_operator: The vessel's commercial operator at the tonnage\n            lists' point in time.\n        commercial_status: Commercial status of the vessel at the tonnage\n            lists' point in time. See the `CommercialStatus` class for\n            available values.\n        eta: Estimated time of arrival at the tonnage lists' point in time.\n        latest_ais: Timestamp of the vessel's latest AIS information at the\n            tonnage lists' point in time.\n        subclass: The vessel's subclass. See the `VesselSubclass` class for\n            available values.\n        willing_to_switch_subclass: When `True`, the vessel is willing to\n            switch its subclass.\n        open_prediction_accuracy: How accurate, in terms of location taxonomy,\n            is the vessel's open prediction at the tonnage lists' point in\n            time. See the `LocationTaxonomy` class for available values.\n        open_areas: A hierarchical collection of areas the vessel opens at at\n            the tonnage lists' point in time.\n\n            If a vessel opens at a specific port, this attribute\n            will contain areas containing the port. For example, the continent,\n            wide/narrow areas, country, etc.\n        availability_port_type: Prediction source of the vessel's open port at\n            the tonnage lists' point in time. See the `SourceType` class for\n            possible values.\n        availability_date_type: Prediction source of the vessel's open date at\n            the tonnage lists' point in time. See the `SourceType` class for\n            possible values.\n        fixture_type: Fixture type. One of Scraped, Manual, Implied\n        current_vessel_sub_type_id:  Current vessel sub type Id\n        current_vessel_sub_type:  One of: -1: Unknown, 1: Dirty, 2: Clean\n        willing_to_switch_current_vessel_sub_type: bool nullable. If the vessel\n            is willing to compete on a different vessel subclass\n            category or not.\n    \"\"\"\n\n    imo: int\n    name: str\n    vessel_class: str\n    ice_class: Optional[str]\n    year_built: int\n    deadweight: int\n    length_overall: float\n    breadth_extreme: int\n    market_deployment: str\n    push_type: str\n    open_port_id: int\n    open_port: str\n    open_date: Optional[datetime]\n    operational_status: str\n    commercial_operator_id: int\n    commercial_operator: str\n    commercial_status: str\n    eta: Optional[datetime]\n    latest_ais: Optional[datetime]\n    subclass: str\n    willing_to_switch_subclass: bool\n    open_prediction_accuracy: str\n    open_areas: Tuple[Area, ...]\n    availability_port_type: str\n    availability_date_type: str\n    fixture_type: str\n    current_vessel_sub_type_id: int\n    current_vessel_sub_type: str\n    willing_to_switch_current_vessel_sub_type: bool\n\n    def __post_init__(self) -&gt; None:  # noqa: D105\n        if self.open_areas is None:\n            object.__setattr__(self, \"open_areas\", tuple())\n\n    @property\n    def open_country(self) -&gt; Optional[str]:\n        \"\"\"The vessel's open country name.\n\n        Returns:\n            The name of the open country or `None` if an area with\n            `LocationTaxonomy.COUNTRY` was not present.\n        \"\"\"\n        return self.__area_name_by_taxonomy(LocationTaxonomy.COUNTRY)\n\n    @property\n    def open_narrow_area(self) -&gt; Optional[str]:\n        \"\"\"The vessel's narrow open area name.\n\n        Returns:\n            The name of the narrow open area or `None` if an area with\n            `LocationTaxonomy.NARROW_AREA` was not present.\n        \"\"\"\n        return self.__area_name_by_taxonomy(LocationTaxonomy.NARROW_AREA)\n\n    @property\n    def open_wide_area(self) -&gt; Optional[str]:\n        \"\"\"The vessel's wide open area name.\n\n        Returns:\n            The name of the wide open area or `None` if an area with\n            `LocationTaxonomy.WIDE_AREA` was not present.\n        \"\"\"\n        return self.__area_name_by_taxonomy(LocationTaxonomy.WIDE_AREA)\n\n    def __area_name_by_taxonomy(self, taxonomy: str) -&gt; Optional[str]:\n        for a in self.open_areas:\n            if a.location_taxonomy == taxonomy:\n                return a.name\n        return None\n\n    def _to_data_frame_row(self) -&gt; DataFrameRow:\n        return Column._create_row(\n            name=self.name,\n            vessel_class=self.vessel_class,\n            ice_class=self.ice_class,\n            year_built=self.year_built,\n            deadweight=self.deadweight,\n            length_overall=self.length_overall,\n            breadth_extreme=self.breadth_extreme,\n            subclass=self.subclass,\n            market_deployment=self.market_deployment,\n            push_type=self.push_type,\n            open_port_id=self.open_port_id,\n            open_port=self.open_port,\n            open_date=self.open_date,\n            operational_status=self.operational_status,\n            commercial_operator_id=self.commercial_operator_id,\n            commercial_operator=self.commercial_operator,\n            commercial_status=self.commercial_status,\n            eta=self.eta,\n            latest_ais=self.latest_ais,\n            open_prediction_accuracy=self.open_prediction_accuracy,\n            open_country=self.open_country,\n            open_narrow_area=self.open_narrow_area,\n            open_wide_area=self.open_wide_area,\n            availability_port_type=self.availability_port_type,\n            availability_date_type=self.availability_date_type,\n            fixture_type=self.fixture_type,\n            current_vessel_sub_type_id=self.current_vessel_sub_type_id,\n            current_vessel_sub_type=self.current_vessel_sub_type,\n            willing_to_switch_current_vessel_sub_type=self\n            .willing_to_switch_current_vessel_sub_type\n        )\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Vessel.open_country","title":"<code>open_country</code>  <code>property</code>","text":"<p>The vessel's open country name.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The name of the open country or <code>None</code> if an area with</p> <code>Optional[str]</code> <p><code>LocationTaxonomy.COUNTRY</code> was not present.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Vessel.open_narrow_area","title":"<code>open_narrow_area</code>  <code>property</code>","text":"<p>The vessel's narrow open area name.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The name of the narrow open area or <code>None</code> if an area with</p> <code>Optional[str]</code> <p><code>LocationTaxonomy.NARROW_AREA</code> was not present.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.Vessel.open_wide_area","title":"<code>open_wide_area</code>  <code>property</code>","text":"<p>The vessel's wide open area name.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The name of the wide open area or <code>None</code> if an area with</p> <code>Optional[str]</code> <p><code>LocationTaxonomy.WIDE_AREA</code> was not present.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.VesselClass","title":"<code>VesselClass</code>  <code>dataclass</code>","text":"<p>A group of vessels of similar characteristics, i.e. Aframax, Panamax, etc.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The vessel class ID.</p> <code>name</code> <code>str</code> <p>The vessel class name.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass VesselClass:\n    \"\"\"A group of vessels of similar characteristics, i.e. Aframax, Panamax, etc.\n\n    Attributes:\n        id: The vessel class ID.\n        name: The vessel class name.\n    \"\"\"\n\n    id: int\n    name: str\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.VesselClassFilter","title":"<code>VesselClassFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific vessel classes.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find vessel classes by name. When specified, vessel classes whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>@dataclass(eq=False)\nclass VesselClassFilter:\n    \"\"\"A filter used to find specific vessel classes.\n\n    Attributes:\n        name_like: Used to find vessel classes by name. When specified, vessel\n            classes whose names partially match (contain) the attribute's value\n            will be returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(\n        self, vessel_classes: Iterable[VesselClass]\n    ) -&gt; Iterable[VesselClass]:\n        return filter(self.__does_class_match, vessel_classes)\n\n    def __does_class_match(self, vessel_class: VesselClass) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, vessel_class.name\n        )\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.VesselFilter","title":"<code>VesselFilter</code>  <code>dataclass</code>","text":"<p>Used to filter vessels when retrieving tonnage lists.</p> <p>All attributes in this class are optional, i.e. no filtering will be performed on attributes whose value is None.</p> <p>Attributes that accept a list of values are used to perform an OR comparison. In other words, when a non-empty list of values is used, the tonnage lists will contain vessels that match on any of the specified values. Using an empty list will result in no filtering being performed.</p> <p><code>VesselFilter</code> is mutable in order to allow making adjustments to existing instances if query results are unsatisfactory.</p> <p>Attributes:</p> Name Type Description <code>push_types</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified push types. Use constants defined in the <code>PushType</code> class as values of this attribute.</p> <code>market_deployments</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified market deployment types. Use constants defined in the <code>MarketDeployment</code> class as values of this attribute.</p> <code>commercial_statuses</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified commercial statuses. Use constants defined in the <code>CommercialStatus</code> class for the values of this attribute.</p> <code>vessel_subclass</code> <code>Optional[str]</code> <p>Return vessels of the specified subclass. Use constants defined in the <code>VesselSubclass</code> class for the values of this attribute.</p> <code>add_willing_to_switch_subclass</code> <code>Optional[bool]</code> <p>When True, returns vessels that do not match the subclass but are willing to switch to it.</p> <code>latest_ais_since</code> <code>Optional[int]</code> <p>The maximum age, in days, of the vessel's AIS information at the time the tonnage list was captured.</p> <code>operational_statuses</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified operational statuses. Use constants defined in the <code>OperationalStatus</code> class for the values of this attribute.</p> <code>min_liquid_capacity</code> <code>Optional[int]</code> <p>The minimum liquid capacity, in cubic meters, the vessel should be able to hold.</p> <code>max_liquid_capacity</code> <code>Optional[int]</code> <p>The maximum liquid capacity, in cubic meters, the vessel should be able to hold.</p> <code>fixture_types</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified fixture types. Use constants defined in the <code>FixtureType</code> class for the values of this attribute.</p> <code>last_cargo_types</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified last cargo type IDs.</p> <code>past_port_visits</code> <code>Optional[List[int]]</code> <p>Return vessels with the specified past port visits.</p> <code>open_port_ids</code> <code>Optional[List[int]]</code> <p>Return vessels with the specified open port ids.</p> <code>canakkale_cancelling</code> <code>Optional[date]</code> <p>Return vessels with the specified Canakkale cancelling date.</p> <code>open_date</code> <code>Optional[date]</code> <p>Return vessels with the specified open date.</p> <code>ice_classes</code> <code>Optional[List[str]]</code> <p>Return vessels with the specified ice classes.</p> <code>min_cranes_ton_capacity</code> <code>Optional[int]</code> <p>Return vessels with the specified minimum cranes ton capacity.</p> <code>max_cranes_ton_capacity</code> <code>Optional[int]</code> <p>Return vessels with the specified maximum cranes ton capacity.</p> <code>min_length_overall</code> <code>Optional[int]</code> <p>Return vessels with the specified minimum length overall.</p> <code>max_length_overall</code> <code>Optional[int]</code> <p>Return vessels with the specified maximum length overall.</p> <code>min_breadth_extreme</code> <code>Optional[int]</code> <p>Return vessels with the specified minimum breadth extreme.</p> <code>max_breadth_extreme</code> <code>Optional[int]</code> <p>Return vessels with the specified maximum breadth extreme.</p> <code>openAreas</code> <code>Optional[int]</code> <p>Return vessels with the specified open area ids.</p> <code>openCountries</code> <code>Optional[int]</code> <p>Return vessels with the specified open country ids.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>@dataclass(eq=False)\nclass VesselFilter:\n    \"\"\"Used to filter vessels when retrieving tonnage lists.\n\n    All attributes in this class are optional, i.e. no filtering will be\n    performed on attributes whose value is None.\n\n    Attributes that accept a list of values are used to perform an *OR*\n    comparison. In other words, when a non-empty list of values is used, the\n    tonnage lists will contain vessels that match on **any** of the specified\n    values. Using an empty list will result in no filtering being performed.\n\n    `VesselFilter` is mutable in order to allow making adjustments to existing\n    instances if query results are unsatisfactory.\n\n    Attributes:\n        push_types: Return vessels with the specified push types. Use constants\n            defined in the `PushType` class as values of this\n            attribute.\n        market_deployments: Return vessels with the specified market deployment\n            types. Use constants defined in the `MarketDeployment`\n            class as values of this attribute.\n        commercial_statuses: Return vessels with the specified\n            commercial statuses. Use constants defined in the\n            `CommercialStatus` class for the values of this attribute.\n        vessel_subclass: Return vessels of the specified subclass.\n            Use constants defined in the `VesselSubclass` class for the values\n            of this attribute.\n        add_willing_to_switch_subclass: When True, returns vessels\n            that do not match the subclass but are willing to switch to it.\n        latest_ais_since: The maximum age, in days, of the vessel's\n            AIS information at the time the tonnage list was captured.\n        operational_statuses: Return vessels with the specified\n            operational statuses. Use constants defined in the\n            `OperationalStatus` class for the values of this attribute.\n        min_liquid_capacity: The minimum liquid capacity, in cubic\n            meters, the vessel should be able to hold.\n        max_liquid_capacity: The maximum liquid capacity, in cubic\n            meters, the vessel should be able to hold.\n        fixture_types: Return vessels with the specified\n            fixture types. Use constants defined in the `FixtureType` class for\n            the values of this attribute.\n        last_cargo_types: Return vessels with the specified last\n            cargo type IDs.\n        past_port_visits: Return vessels with the specified past\n            port visits.\n        open_port_ids: Return vessels with the specified open\n            port ids.\n        canakkale_cancelling: Return vessels with the specified\n            Canakkale cancelling date.\n        open_date: Return vessels with the specified open date.\n        ice_classes: Return vessels with the specified ice classes.\n        min_cranes_ton_capacity: Return vessels with the specified\n            minimum cranes ton capacity.\n        max_cranes_ton_capacity: Return vessels with the specified\n            maximum cranes ton capacity.\n        min_length_overall: Return vessels with the specified\n            minimum length overall.\n        max_length_overall: Return vessels with the specified\n            maximum length overall.\n        min_breadth_extreme: Return vessels with the specified\n            minimum breadth extreme.\n        max_breadth_extreme: Return vessels with the specified\n            maximum breadth extreme.\n        openAreas: Return vessels with the specified open area ids.\n        openCountries: Return vessels with the specified open\n            country ids.\n    \"\"\"\n\n    push_types: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    market_deployments: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    commercial_statuses: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    vessel_subclass: Optional[str] = VesselSubclass.ALL\n    add_willing_to_switch_subclass: Optional[bool] = False\n    latest_ais_since: Optional[int] = None\n    operational_statuses: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    min_liquid_capacity: Optional[int] = None\n    max_liquid_capacity: Optional[int] = None\n    fixture_types: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    past_port_visits: Optional[List[int]] = cast(\n        List[int], field(default_factory=list)\n    )\n    open_port_ids: Optional[List[int]] = cast(\n        List[int], field(default_factory=list)\n    )\n    canakkale_cancelling: Optional[date] = None\n    open_date: Optional[date] = None\n    ice_classes: Optional[List[str]] = cast(\n        List[str], field(default_factory=list)\n    )\n    min_cranes_ton_capacity: Optional[int] = None\n    max_cranes_ton_capacity: Optional[int] = None\n    min_length_overall: Optional[int] = None\n    max_length_overall: Optional[int] = None\n    min_breadth_extreme: Optional[int] = None\n    max_breadth_extreme: Optional[int] = None\n    open_area_ids: Optional[List[int]] = cast(\n        List[int], field(default_factory=list)\n    )\n    open_country_ids: Optional[List[int]] = cast(\n        List[int], field(default_factory=list)\n    )\n\n    def _to_query_string(self) -&gt; QueryString:\n        return {\n            \"pushType\": self.push_types,\n            \"commercialStatus\": self.commercial_statuses,\n            \"latestAisSince\": self.latest_ais_since,\n            \"vesselSubclass\": self.vessel_subclass,\n            \"addWillingToSwitchSubclass\": self.add_willing_to_switch_subclass,\n            \"marketDeployment\": self.market_deployments,\n            \"operationalStatus\": self.operational_statuses,\n            \"minLiquidCapacity\": self.min_liquid_capacity,\n            \"maxLiquidCapacity\": self.max_liquid_capacity,\n            \"fixtureType\": self.fixture_types,\n            \"pastPortVisit\": self.past_port_visits,\n            \"openPortId\": self.open_port_ids,\n            \"canakkaleCancelling\": format_iso_date(self.canakkale_cancelling),\n            \"openDate\": format_iso_date(self.open_date),\n            \"iceClass\": self.ice_classes,\n            \"cranesTonCapacityMin\": self.min_cranes_ton_capacity,\n            \"cranesTonCapacityMax\": self.max_cranes_ton_capacity,\n            \"lengthOverallMin\": self.min_length_overall,\n            \"lengthOverallMax\": self.max_length_overall,\n            \"breadthExtremeMin\": self.min_breadth_extreme,\n            \"breadthExtremeMax\": self.max_breadth_extreme,\n            \"openArea\": self.open_area_ids,\n            \"openCountry\": self.open_country_ids,\n        }\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.VesselSubclass","title":"<code>VesselSubclass</code>","text":"<p>Available vessel subclasses.</p> Source code in <code>signal_ocean/tonnage_list/models.py</code> <pre><code>class VesselSubclass(metaclass=IterableConstants):\n    \"\"\"Available vessel subclasses.\"\"\"\n\n    ALL = None\n    \"\"\"All vessel subclasses.\n\n    Refers to all vessels without any classification regarding the cargo type\n    they car carry.\n    \"\"\"\n\n    DIRTY = \"Dirty\"\n    \"\"\"Vessels carrying dirty types of oil.\n\n    Refers to all vessels that classify as carriers of dirty types of oil.\n    Applies only to tankers.\n    \"\"\"\n\n    CLEAN = \"Clean\"\n    \"\"\"Vessels carrying clean oil.\n\n    Refers to all vessels that classify as carriers of clean types of oil.\n    Applies only to tankers.\n    \"\"\"\n</code></pre>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.VesselSubclass.ALL","title":"<code>ALL = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All vessel subclasses.</p> <p>Refers to all vessels without any classification regarding the cargo type they car carry.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.VesselSubclass.CLEAN","title":"<code>CLEAN = 'Clean'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels carrying clean oil.</p> <p>Refers to all vessels that classify as carriers of clean types of oil. Applies only to tankers.</p>"},{"location":"tonnage_list/#signal_ocean.tonnage_list.VesselSubclass.DIRTY","title":"<code>DIRTY = 'Dirty'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vessels carrying dirty types of oil.</p> <p>Refers to all vessels that classify as carriers of dirty types of oil. Applies only to tankers.</p>"},{"location":"vessel_emissions/","title":"Package Documentation","text":"<p>Vessel Emissions API Package.</p> <p>Classes:</p> Name Description <code>VesselEmissionsAPI</code> <p>Represents Signal's Vessel Emissions API.</p> <code>EmissionsEstimation</code> <p>Represents Emissions Estimation for a single Voyage.</p> <code>Metrics</code> <p>Represents Emissions Metrics for a Vessel.</p> <code>VesselClassEmissions</code> <p>Represents Emissions Estimation</p> <code>VesselClassMetrics</code> <p>Represents Emissions Metrics</p>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.EmissionsEstimation","title":"<code>EmissionsEstimation</code>  <code>dataclass</code>","text":"<p>Contains info about the emissions estimation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Voyage ID</p> <code>imo</code> <code>int</code> <p>Vessel IMO</p> <code>vessel_name</code> <code>str</code> <p>Vessel Name</p> <code>voyage_number</code> <code>int</code> <p>Voyage Number</p> <code>vessel_type_id</code> <code>int</code> <p>Vessel type id</p> <code>vessel_type</code> <code>Optional[str]</code> <p>Vessel type</p> <code>vessel_class_id</code> <code>int</code> <p>Vessel class id</p> <code>vessel_class</code> <code>Optional[str]</code> <p>Vessel class</p> <code>start_date</code> <code>str</code> <p>Start date of the Voyage</p> <code>end_date</code> <code>str</code> <p>End date of the Voyage</p> <code>quantity</code> <code>Optional[float]</code> <p>Cargo quantity of the voyage</p> <code>deadweight</code> <code>int</code> <p>Vessel's deadweight</p> <code>transport_work_in_million_tonne_miles</code> <code>Optional[float]</code> <p>Transport</p> <code>transport_work_in_million_dwt_miles</code> <code>Optional[float]</code> <p>Transport work</p> <code>contains_eu_emissions</code> <code>Optional[bool]</code> <p>Declares whether</p> <code>emissions</code> <code>EmissionsBreakdown</code> <p>Emissions breakdown for the voyage</p> <code>consumptions</code> <code>Optional[ConsumptionsBreakdown]</code> <p>Consumptions breakdown for the voyage</p> <code>seagoing_speed_statistics</code> <code>Optional[SeagoingSpeedStatisticsBreakdown]</code> <p>Seagoing</p> <code>duration</code> <code>Optional[DurationBreakdown]</code> <p>Duration breakdown for the voyage</p> <code>distances</code> <code>Optional[DistancesBreakdown]</code> <p>Distance travelled breakdown for the voyage</p> <code>efficiency_metrics</code> <code>Optional[Metrics]</code> <p>Emissions Efficiency metrics for the voyage</p> <code>european_union_regulated</code> <code>Optional[EmissionsEssentialStatistics]</code> <p>European Union Related Emissions</p> Source code in <code>signal_ocean/vessel_emissions/models.py</code> <pre><code>@dataclass(frozen=True)\nclass EmissionsEstimation:\n    \"\"\"Contains info about the emissions estimation.\n\n    Attributes:\n        id: Voyage ID\n        imo: Vessel IMO\n        vessel_name: Vessel Name\n        voyage_number: Voyage Number\n        vessel_type_id: Vessel type id\n        vessel_type: Vessel type\n        vessel_class_id: Vessel class id\n        vessel_class: Vessel class\n        start_date: Start date of the Voyage\n        end_date: End date of the Voyage\n        quantity: Cargo quantity of the voyage\n        deadweight: Vessel's deadweight\n        transport_work_in_million_tonne_miles: Transport\n        work measured in millions tonnes of cargo carried\n        times the travelled distance in miles of the current voyage\n        transport_work_in_million_dwt_miles: Transport work\n        measured in millions tonnes when the cargo\n        curried equals the DWT times the travelled\n        distance in miles of the current voyage\n        contains_eu_emissions: Declares whether\n        voyage has European Union Related Emissions\n        emissions: Emissions breakdown for the voyage\n        consumptions: Consumptions breakdown for the voyage\n        seagoing_speed_statistics: Seagoing\n        Speed Statistics breakdown for the voyage\n        duration: Duration breakdown for the voyage\n        distances: Distance travelled breakdown for the voyage\n        efficiency_metrics: Emissions Efficiency metrics for the voyage\n        european_union_regulated: European Union Related Emissions\n\n    \"\"\"\n    id: str\n    imo: int\n    vessel_name: str\n    voyage_number: int\n    vessel_type_id: int\n    vessel_class_id: int\n    start_date: str\n    end_date: str\n    deadweight: int\n    emissions: EmissionsBreakdown\n    vessel_type: Optional[str] = None\n    vessel_class: Optional[str] = None\n    quantity: Optional[float] = None\n    transport_work_in_million_tonne_miles: Optional[float] = None\n    transport_work_in_million_dwt_miles: Optional[float] = None\n    contains_eu_emissions: Optional[bool] = None\n    consumptions: Optional[ConsumptionsBreakdown] = None\n    seagoing_speed_statistics: \\\n        Optional[SeagoingSpeedStatisticsBreakdown] = None\n    duration: Optional[DurationBreakdown] = None\n    distances: Optional[DistancesBreakdown] = None\n    efficiency_metrics: Optional[Metrics] = None\n    european_union_regulated: Optional[EmissionsEssentialStatistics] = None\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Override of the default __repr__ function.\n\n        Returns:\n            Object string representation omitting None attributes\n\n        \"\"\"\n        nodef_f_vals = (\n            (f.name, attrgetter(f.name)(self))\n            for f in dataclasses.fields(self)\n            if attrgetter(f.name)(self) != f.default\n        )\n\n        nodef_f_repr = \", \".join(f\"{name}={value}\"\n                                 for name, value\n                                 in nodef_f_vals)\n        return f\"{self.__class__.__name__}({nodef_f_repr})\"\n\n    def to_dict(self) -&gt; Dict[Any, Any]:\n        \"\"\"Cast EmissionsEstimation object to dict.\n\n        Returns:\n            Dict representation of EmissionsEstimation model\n\n        \"\"\"\n        return dataclasses.asdict(\n            self,\n            dict_factory=lambda x: {\n                _to_camel_case_with_special_keywords(k): v\n                for (k, v) in x if v is not None\n            })\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.EmissionsEstimation.__repr__","title":"<code>__repr__()</code>","text":"<p>Override of the default repr function.</p> <p>Returns:</p> Type Description <code>str</code> <p>Object string representation omitting None attributes</p> Source code in <code>signal_ocean/vessel_emissions/models.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Override of the default __repr__ function.\n\n    Returns:\n        Object string representation omitting None attributes\n\n    \"\"\"\n    nodef_f_vals = (\n        (f.name, attrgetter(f.name)(self))\n        for f in dataclasses.fields(self)\n        if attrgetter(f.name)(self) != f.default\n    )\n\n    nodef_f_repr = \", \".join(f\"{name}={value}\"\n                             for name, value\n                             in nodef_f_vals)\n    return f\"{self.__class__.__name__}({nodef_f_repr})\"\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.EmissionsEstimation.to_dict","title":"<code>to_dict()</code>","text":"<p>Cast EmissionsEstimation object to dict.</p> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dict representation of EmissionsEstimation model</p> Source code in <code>signal_ocean/vessel_emissions/models.py</code> <pre><code>def to_dict(self) -&gt; Dict[Any, Any]:\n    \"\"\"Cast EmissionsEstimation object to dict.\n\n    Returns:\n        Dict representation of EmissionsEstimation model\n\n    \"\"\"\n    return dataclasses.asdict(\n        self,\n        dict_factory=lambda x: {\n            _to_camel_case_with_special_keywords(k): v\n            for (k, v) in x if v is not None\n        })\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.Metrics","title":"<code>Metrics</code>  <code>dataclass</code>","text":"<p>Vessel Metrics estimation.</p> <p>Attributes:</p> Name Type Description <code>voyage_cii</code> <code>Optional[float]</code> <p>Carbon Intensity Indicator</p> <code>voyage_cii_unit</code> <code>Optional[str]</code> <p>The unit of the voyage</p> <code>voyage_cii_rating</code> <code>Optional[str]</code> <p>The rating of the vessel</p> <code>voyage_cii_target</code> <code>Optional[float]</code> <p>The alignment target for the</p> <code>voyage_cii_target_year</code> <code>Optional[int]</code> <p>The year that has taken</p> <code>capacity_eeoi</code> <code>Optional[float]</code> <p>The EEOI efficiency metric when</p> <code>capacity_eeoi_unit</code> <code>Optional[str]</code> <p>The unit of the Capacity</p> <code>capacity_eeoi_sea_cargo_charter_year_target</code> <code>Optional[float]</code> <code>capacity_eeoi_sea_cargo_charter_class</code> <code>Optional[str]</code> <code>capacity_eeoi_sea_cargo_charter_alignment_in_percentage</code> <code>Optional[float]</code> <code>eeoi</code> <code>Optional[float]</code> <p>The EEOI efficiency metrics calculated for the voyage</p> <code>eeoi_unit</code> <code>Optional[str]</code> <p>The unit of the EEOI efficiency metrics</p> <code>eeoi_sea_cargo_charter_year_target</code> <code>Optional[float]</code> <p>The alignment</p> <code>eeoi_sea_cargo_charter_class</code> <code>Optional[str]</code> <p>The Sea Cargo Charter</p> <code>eeoi_sea_cargo_charter_alignment_in_percentage</code> <code>Optional[float]</code> <code>kg_co2_per_tonne_cargo</code> <code>Optional[float]</code> <p>Kg of CO2 per tonne of cargo carried</p> <code>kg_co2_per_tonne_dwt</code> <code>Optional[float]</code> <p>Kg of CO2 per tonne of the vessel's deadweight</p> Source code in <code>signal_ocean/vessel_emissions/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Metrics:\n    \"\"\"Vessel Metrics estimation.\n\n    Attributes:\n        voyage_cii: Carbon Intensity Indicator\n        (VoyageCII)\n        efficiency metrics for the voyage\n        voyage_cii_unit: The unit of the voyage\n        Carbon Intensity Indicator (VoyageCII)\n        voyage_cii_rating: The rating of the vessel\n        based on the VoyageCII\n        voyage_cii_target: The alignment target for the\n        Voyage CII efficiency metric of the current year\n        voyage_cii_target_year: The year that has taken\n        into account for calculating the alignment target\n        for the VoyageCII efficiency metric\n        capacity_eeoi: The EEOI efficiency metric when\n        the quantity equals with the capacity of\n        the vessel (CapacityEEOI)\n        e.g. the deadweight of the vessel\n        capacity_eeoi_unit: The unit of the Capacity\n        EEOI efficiency metric\n        capacity_eeoi_sea_cargo_charter_year_target:\n        The alignment target for the Capacity EEOI\n        efficiency metric based on the Sea Cargo\n        Charter guidelines for the year of the voyage\n        capacity_eeoi_sea_cargo_charter_class:\n        The Sea Cargo Charter defined class\n        that the vessel belongs to based on it's size\n        capacity_eeoi_sea_cargo_charter_alignment_in_percentage:\n        The alignment delta in percentage, based on the acquired\n        Capacity EEOI and the given alignment target\n        from Sea Cargo Charter. Negative is aligned,\n        positive is misaligned\n        eeoi: The EEOI efficiency metrics calculated for the voyage\n        eeoi_unit: The unit of the EEOI efficiency metrics\n        eeoi_sea_cargo_charter_year_target: The alignment\n        target for the EEOI efficiency metric based on the Sea Cargo\n        Charter guidelines for the year of the voyage\n        eeoi_sea_cargo_charter_class: The Sea Cargo Charter\n        defined class that the vessel belongs to based on it's size\n        eeoi_sea_cargo_charter_alignment_in_percentage:\n        The alignment delta in percentage, based on the acquired\n        EOI and the given alignment target from Sea Cargo Charter.\n        Negative is aligned, positive is misaligned.\n        kg_co2_per_tonne_cargo: Kg of CO2 per tonne of cargo carried\n        kg_co2_per_tonne_dwt: Kg of CO2 per tonne of the vessel's deadweight\n\n\n    \"\"\"\n    voyage_cii: Optional[float] = None\n    voyage_cii_unit: Optional[str] = None\n    voyage_cii_rating: Optional[str] = None\n    voyage_cii_target: Optional[float] = None\n    voyage_cii_target_year: Optional[int] = None\n    capacity_eeoi: Optional[float] = None\n    capacity_eeoi_unit: Optional[str] = None\n    capacity_eeoi_sea_cargo_charter_year_target: \\\n        Optional[float] = None\n    capacity_eeoi_sea_cargo_charter_class: Optional[str] = None\n    capacity_eeoi_sea_cargo_charter_alignment_in_percentage: \\\n        Optional[float] = None\n    eeoi: Optional[float] = None\n    eeoi_unit: Optional[str] = None\n    eeoi_sea_cargo_charter_year_target: Optional[float] = None\n    eeoi_sea_cargo_charter_class: Optional[str] = None\n    eeoi_sea_cargo_charter_alignment_in_percentage: \\\n        Optional[float] = None\n    kg_co2_per_tonne_cargo: Optional[float] = None\n    kg_co2_per_tonne_dwt: Optional[float] = None\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselClassEmissions","title":"<code>VesselClassEmissions</code>  <code>dataclass</code>","text":"<p>Contains Vessel Class Emissions.</p> <p>Attributes:</p> Name Type Description <code>next_page_token</code> <code>str</code> <p>String. The key  to retrieve the next page</p> <code>data</code> <code>List[EmissionsEstimation]</code> <p>List of Vessel Emissions for available vessels of this class</p> Source code in <code>signal_ocean/vessel_emissions/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VesselClassEmissions:\n    \"\"\"Contains Vessel Class Emissions.\n\n    Attributes:\n        next_page_token: String. The key  to retrieve the next page\n        data: List of Vessel Emissions for available vessels of this class\n\n    \"\"\"\n    next_page_token: str\n    data: List[EmissionsEstimation]\n\n    def to_dict(self) -&gt; Dict[Any, Any]:\n        \"\"\"Cast VesselClassEmissions object to dict.\n\n        Returns:\n            Dict representation of VesselClassEmissions object\n\n        \"\"\"\n        return {\n            \"NextPageToken\": self.next_page_token,\n            \"Data\": [\n                vessel_emissions.to_dict()\n                for vessel_emissions in self.data\n            ]\n        }\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselClassEmissions.to_dict","title":"<code>to_dict()</code>","text":"<p>Cast VesselClassEmissions object to dict.</p> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dict representation of VesselClassEmissions object</p> Source code in <code>signal_ocean/vessel_emissions/models.py</code> <pre><code>def to_dict(self) -&gt; Dict[Any, Any]:\n    \"\"\"Cast VesselClassEmissions object to dict.\n\n    Returns:\n        Dict representation of VesselClassEmissions object\n\n    \"\"\"\n    return {\n        \"NextPageToken\": self.next_page_token,\n        \"Data\": [\n            vessel_emissions.to_dict()\n            for vessel_emissions in self.data\n        ]\n    }\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselClassMetrics","title":"<code>VesselClassMetrics</code>  <code>dataclass</code>","text":"<p>Contains Vessel Class Metrics.</p> <p>Attributes:</p> Name Type Description <code>next_page_token</code> <code>str</code> <p>String. The key that should be used</p> <code>data</code> <code>List[VesselMetrics]</code> <p>List of Vessel Metrics for available vessels of this class</p> Source code in <code>signal_ocean/vessel_emissions/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VesselClassMetrics:\n    \"\"\"Contains Vessel Class Metrics.\n\n    Attributes:\n        next_page_token: String. The key that should be used\n        as a parameter of the token to retrieve the next page\n        data: List of Vessel Metrics for available vessels of this class\n\n    \"\"\"\n    next_page_token: str\n    data: List[VesselMetrics]\n\n    def to_dict(self) -&gt; Dict[Any, Any]:\n        \"\"\"Cast VesselClassMetrics object to dict.\n\n        Returns:\n            Dict representation of VesselClassMetrics object\n\n        \"\"\"\n        return {\n            \"NextPageToken\": self.next_page_token,\n            \"Data\": [\n                vessel_metrics.to_dict()\n                for vessel_metrics in self.data\n            ]\n        }\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselClassMetrics.to_dict","title":"<code>to_dict()</code>","text":"<p>Cast VesselClassMetrics object to dict.</p> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dict representation of VesselClassMetrics object</p> Source code in <code>signal_ocean/vessel_emissions/models.py</code> <pre><code>def to_dict(self) -&gt; Dict[Any, Any]:\n    \"\"\"Cast VesselClassMetrics object to dict.\n\n    Returns:\n        Dict representation of VesselClassMetrics object\n\n    \"\"\"\n    return {\n        \"NextPageToken\": self.next_page_token,\n        \"Data\": [\n            vessel_metrics.to_dict()\n            for vessel_metrics in self.data\n        ]\n    }\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselEmissionsAPI","title":"<code>VesselEmissionsAPI</code>","text":"<p>Represents Signal's Vessel Emissions API.</p> Source code in <code>signal_ocean/vessel_emissions/vessel_emissions_api.py</code> <pre><code>class VesselEmissionsAPI:\n    \"\"\"Represents Signal's Vessel Emissions API.\"\"\"\n\n    relative_url = \"vessel-emissions-api/public/v2/\"\n    default_pit = str(date.today())\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes VesselEmissionsAPI.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        if connection is not None:\n            em_connection = copy.deepcopy(connection)\n            func_type = type(\n                em_connection._Connection__get_headers  # type: ignore\n            )\n            em_connection._Connection__get_headers = func_type(  # type: ignore\n                custom_headers, em_connection\n            )\n            self.__connection = em_connection\n        else:\n            connection = Connection()\n            func_type = type(\n                connection._Connection__get_headers  # type: ignore\n            )\n            connection._Connection__get_headers = func_type(  # type: ignore\n                custom_headers, connection\n            )\n            self.__connection = connection\n\n    def construct_url_parameters(\n            self,\n            quantity: Union[int, None] = None,\n            token: Optional[str] = None,\n            include_consumptions: bool = False,\n            include_efficiency_metrics: bool = False,\n            include_distances: bool = False,\n            include_durations: bool = False,\n            include_speed_statistics: bool = False,\n            include_eu_emissions: bool = False,\n            sulphur_content_hfo: Optional[Union[float, None]] = None,\n            sulphur_content_lfo: Optional[Union[float, None]] = None,\n            sulphur_content_mgo: Optional[Union[float, None]] = None,\n            sulphur_content_lng: Optional[Union[float, None]] = None\n    ) -&gt; Dict[Any, str]:\n        \"\"\"Construct the request parameters based on the user's input.\n\n        Args:\n        quantity: Cargo quantity of the voyage\n        token: Next page token\n        include_consumptions: Include consumption data in response\n        include_efficiency_metrics: Include efficiency metrics in response\n        include_distances: Include distances data in the response\n        include_durations: Include duration data in the response\n        include_speed_statistics: Include speed statistics data in response\n        include_eu_emissions: Include European Union related\n        emissions in response\n        sulphur_content_hfo: Sulphur Content of HFO fuel type\n        sulphur_content_lfo: Sulphur Content of LFO fuel type\n        sulphur_content_mgo: Sulphur Content of MGO fuel type\n        sulphur_content_lng: Sulphur Content of LNG fuel type\n\n        Returns:\n            The parameters dictionary of Request URL\n        \"\"\"\n        params = {}\n        if quantity is not None:\n            params['quantity'] = str(quantity)\n        if token is not None:\n            params['token'] = token\n        params['include_consumptions'] = str(include_consumptions)\n        params['include_efficiency_metrics'] = str(include_efficiency_metrics)\n        params['include_distances'] = str(include_distances)\n        params['include_durations'] = str(include_durations)\n        params['include_speed_statistics'] = str(include_speed_statistics)\n        params['include_eu_emissions'] = str(include_eu_emissions)\n        if sulphur_content_hfo is not None:\n            params['sulphur_content_hfo'] = str(sulphur_content_hfo)\n        if sulphur_content_lfo is not None:\n            params['sulphur_content_lfo'] = str(sulphur_content_lfo)\n        if sulphur_content_mgo is not None:\n            params['sulphur_content_mgo'] = str(sulphur_content_mgo)\n        if sulphur_content_lng is not None:\n            params['sulphur_content_lng'] = str(sulphur_content_lng)\n        return params\n\n    def get_emissions_by_imo_and_voyage_number(\n            self,\n            imo: int,\n            voyage_number: int,\n            quantity: Union[int, None] = None,\n            include_consumptions: bool = False,\n            include_efficiency_metrics: bool = False,\n            include_distances: bool = False,\n            include_durations: bool = False,\n            include_speed_statistics: bool = False,\n            include_eu_emissions: bool = False,\n            sulphur_content_hfo: Union[float, None] = None,\n            sulphur_content_lfo: Union[float, None] = None,\n            sulphur_content_mgo: Union[float, None] = None,\n            sulphur_content_lng: Union[float, None] = None\n    ) -&gt; Optional[EmissionsEstimation]:\n        \"\"\"Retrieves voyage emissions for a vessel by its IMO and Voyage Number.\n\n        Args:\n            imo: Vessel IMO to retrieve.\n            voyage_number: Voyage Number to retrieve.\n            quantity: User defined transported quantity for voyage.\n            include_consumptions: Include consumption data in the response.\n            include_efficiency_metrics: Include efficiency metrics in response.\n            include_distances: Include distances data in the response.\n            include_durations: Include duration data in the response.\n            include_speed_statistics: Include speed statistics in response.\n            include_eu_emissions: Include European Union related\n            emissions in response.\n            sulphur_content_hfo: Sulphur Content of HFO fuel type.\n            sulphur_content_lfo: Sulphur Content of LFO fuel type.\n            sulphur_content_mgo: Sulphur Content of MGO fuel type.\n            sulphur_content_lng: Sulphur Content of LNG fuel type.\n\n        Returns:\n            EmissionsEstimation if no vessel with\n            the specified IMO or Voyage Number has been found.\n        \"\"\"\n        params_dict = self.construct_url_parameters(\n            quantity=quantity,\n            include_consumptions=include_consumptions,\n            include_efficiency_metrics=include_efficiency_metrics,\n            include_distances=include_distances,\n            include_durations=include_durations,\n            include_speed_statistics=include_speed_statistics,\n            include_eu_emissions=include_eu_emissions,\n            sulphur_content_hfo=sulphur_content_hfo,\n            sulphur_content_lfo=sulphur_content_lfo,\n            sulphur_content_mgo=sulphur_content_mgo,\n            sulphur_content_lng=sulphur_content_lng)\n        query_url = make_url('emissions',\n                             'imo', imo,\n                             'voyage_number', voyage_number,\n                             **params_dict)\n        url = urljoin(VesselEmissionsAPI.relative_url, query_url)\n        return get_single(self.__connection, url, EmissionsEstimation)\n\n    def get_emissions_by_imo(\n            self,\n            imo: int,\n            include_consumptions: bool = False,\n            include_efficiency_metrics: bool = False,\n            include_distances: bool = False,\n            include_durations: bool = False,\n            include_speed_statistics: bool = False,\n            include_eu_emissions: bool = False,\n            sulphur_content_hfo: Union[float, None] = None,\n            sulphur_content_lfo: Union[float, None] = None,\n            sulphur_content_mgo: Union[float, None] = None,\n            sulphur_content_lng: Union[float, None] = None\n    ) -&gt; List[EmissionsEstimation]:\n        \"\"\"Retrieves a list of vessel emissions by its IMO.\n\n        Args:\n            imo: IMO of the vessel to retrieve emissions.\n            include_consumptions: Include consumption data in the response.\n            include_efficiency_metrics: Include efficiency metrics\n             data in the response.\n            include_distances: Include distances data in the response.\n            include_durations: Include duration data in the response.\n            include_speed_statistics: Include speed statistics\n             data in the response.\n            include_eu_emissions: Include European Union related\n             emissions data in the response.\n            sulphur_content_hfo: Sulphur Content of HFO fuel type.\n            sulphur_content_lfo: Sulphur Content of LFO fuel type.\n            sulphur_content_mgo: Sulphur Content of MGO fuel type.\n            sulphur_content_lng: Sulphur Content of LNG fuel type.\n\n        Returns:\n            A list of vessel emissions or None if no vessel\n             with the specified IMO has been found.\n        \"\"\"\n        params_dict = self.construct_url_parameters(\n            include_consumptions=include_consumptions,\n            include_efficiency_metrics=include_efficiency_metrics,\n            include_distances=include_distances,\n            include_durations=include_durations,\n            include_speed_statistics=include_speed_statistics,\n            include_eu_emissions=include_eu_emissions,\n            sulphur_content_hfo=sulphur_content_hfo,\n            sulphur_content_lfo=sulphur_content_lfo,\n            sulphur_content_mgo=sulphur_content_mgo,\n            sulphur_content_lng=sulphur_content_lng\n        )\n        query_url = make_url('emissions',\n                             'imo', imo,\n                             **params_dict)\n        url = urljoin(VesselEmissionsAPI.relative_url, query_url)\n        return [i for i in get_multiple(self.__connection,\n                                        url,\n                                        EmissionsEstimation)]\n\n    def get_metrics_by_imo(\n            self,\n            imo: int,\n            year: Union[int, None] = None\n    ) -&gt; List[VesselMetrics]:\n        \"\"\"Get vessel metrics.\n\n        Args:\n            imo: Vessel IMO to retrieve\n            year: The year for the annual metrics\n\n        Returns:\n            VesselMetrics for the requested IMO\n\n        \"\"\"\n        url = urljoin(VesselEmissionsAPI.relative_url,\n                      f\"emissions/metrics/imo/{imo}\")\n        if year is not None:\n            url = urljoin(url, f\"?year={year}\")\n        return [i for i in get_multiple(self.__connection,\n                                        url,\n                                        VesselMetrics)]\n\n    def get_emissions_by_vessel_class_id(\n            self,\n            vessel_class_id: int,\n            token: Union[str, None] = None,\n            include_consumptions: bool = False,\n            include_efficiency_metrics: bool = False,\n            include_distances: bool = False,\n            include_durations: bool = False,\n            include_speed_statistics: bool = False,\n            include_eu_emissions: bool = False\n    ) -&gt; Optional[VesselClassEmissions]:\n        \"\"\"Get emissions estimations for a vessel class (supports incremental updates).\n\n        Args:\n            vessel_class_id: The vessel class to retrieve\n            token: Next page token\n            include_consumptions: Include consumption data in the response.\n            include_efficiency_metrics: Include efficiency metrics\n             data in the response.\n            include_distances: Include distances data in the response.\n            include_durations: Include duration data in the response.\n            include_speed_statistics: Include speed statistics\n             data in the response.\n            include_eu_emissions: Include European Union related emissions\n             data in the response.\n\n        Returns:\n            List of emissions estimation for all\n             available voyages of a vessel class.\n\n        \"\"\"\n        params_dict = self.construct_url_parameters(\n            token=token,\n            include_consumptions=include_consumptions,\n            include_efficiency_metrics=include_efficiency_metrics,\n            include_distances=include_distances,\n            include_durations=include_durations,\n            include_speed_statistics=include_speed_statistics,\n            include_eu_emissions=include_eu_emissions\n        )\n        query_url = make_url('emissions',\n                             'class', vessel_class_id,\n                             **params_dict)\n\n        url = urljoin(VesselEmissionsAPI.relative_url, query_url)\n        return get_single(self.__connection,\n                          url,\n                          VesselClassEmissions)\n\n    def get_metrics_by_vessel_class_id(self,\n                                       vessel_class_id: int,\n                                       year: Union[int, None] = None,\n                                       token: Union[str, None] = None\n                                       ) -&gt; Optional[VesselClassMetrics]:\n        \"\"\"Get vessel class metrics.\n\n        Args:\n            vessel_class_id: The vessel class to retrieve\n            year: The year for the annual metrics\n            token: Next page token\n\n        Returns:\n            VesselClassMetrics for the requested Class\n\n        \"\"\"\n        if year is None and token is None:\n            query_url = \"\"\n        else:\n            query_url = \"?\"\n            if year is not None:\n                query_url += f\"year={year}\"\n                if token is not None:\n                    query_url += f\"&amp;token={token}\"\n            else:\n                if token is not None:\n                    query_url += f\"token={token}\"\n        query_url = urljoin(f\"emissions/metrics/class/\"\n                            f\"{vessel_class_id}\",\n                            query_url)\n        url = urljoin(VesselEmissionsAPI.relative_url, query_url)\n        return get_single(self.__connection, url, VesselClassMetrics)\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselEmissionsAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes VesselEmissionsAPI.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/vessel_emissions/vessel_emissions_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes VesselEmissionsAPI.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    if connection is not None:\n        em_connection = copy.deepcopy(connection)\n        func_type = type(\n            em_connection._Connection__get_headers  # type: ignore\n        )\n        em_connection._Connection__get_headers = func_type(  # type: ignore\n            custom_headers, em_connection\n        )\n        self.__connection = em_connection\n    else:\n        connection = Connection()\n        func_type = type(\n            connection._Connection__get_headers  # type: ignore\n        )\n        connection._Connection__get_headers = func_type(  # type: ignore\n            custom_headers, connection\n        )\n        self.__connection = connection\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselEmissionsAPI.construct_url_parameters","title":"<code>construct_url_parameters(quantity=None, token=None, include_consumptions=False, include_efficiency_metrics=False, include_distances=False, include_durations=False, include_speed_statistics=False, include_eu_emissions=False, sulphur_content_hfo=None, sulphur_content_lfo=None, sulphur_content_mgo=None, sulphur_content_lng=None)</code>","text":"<p>Construct the request parameters based on the user's input.</p> <p>Args: quantity: Cargo quantity of the voyage token: Next page token include_consumptions: Include consumption data in response include_efficiency_metrics: Include efficiency metrics in response include_distances: Include distances data in the response include_durations: Include duration data in the response include_speed_statistics: Include speed statistics data in response include_eu_emissions: Include European Union related emissions in response sulphur_content_hfo: Sulphur Content of HFO fuel type sulphur_content_lfo: Sulphur Content of LFO fuel type sulphur_content_mgo: Sulphur Content of MGO fuel type sulphur_content_lng: Sulphur Content of LNG fuel type</p> <p>Returns:</p> Type Description <code>Dict[Any, str]</code> <p>The parameters dictionary of Request URL</p> Source code in <code>signal_ocean/vessel_emissions/vessel_emissions_api.py</code> <pre><code>def construct_url_parameters(\n        self,\n        quantity: Union[int, None] = None,\n        token: Optional[str] = None,\n        include_consumptions: bool = False,\n        include_efficiency_metrics: bool = False,\n        include_distances: bool = False,\n        include_durations: bool = False,\n        include_speed_statistics: bool = False,\n        include_eu_emissions: bool = False,\n        sulphur_content_hfo: Optional[Union[float, None]] = None,\n        sulphur_content_lfo: Optional[Union[float, None]] = None,\n        sulphur_content_mgo: Optional[Union[float, None]] = None,\n        sulphur_content_lng: Optional[Union[float, None]] = None\n) -&gt; Dict[Any, str]:\n    \"\"\"Construct the request parameters based on the user's input.\n\n    Args:\n    quantity: Cargo quantity of the voyage\n    token: Next page token\n    include_consumptions: Include consumption data in response\n    include_efficiency_metrics: Include efficiency metrics in response\n    include_distances: Include distances data in the response\n    include_durations: Include duration data in the response\n    include_speed_statistics: Include speed statistics data in response\n    include_eu_emissions: Include European Union related\n    emissions in response\n    sulphur_content_hfo: Sulphur Content of HFO fuel type\n    sulphur_content_lfo: Sulphur Content of LFO fuel type\n    sulphur_content_mgo: Sulphur Content of MGO fuel type\n    sulphur_content_lng: Sulphur Content of LNG fuel type\n\n    Returns:\n        The parameters dictionary of Request URL\n    \"\"\"\n    params = {}\n    if quantity is not None:\n        params['quantity'] = str(quantity)\n    if token is not None:\n        params['token'] = token\n    params['include_consumptions'] = str(include_consumptions)\n    params['include_efficiency_metrics'] = str(include_efficiency_metrics)\n    params['include_distances'] = str(include_distances)\n    params['include_durations'] = str(include_durations)\n    params['include_speed_statistics'] = str(include_speed_statistics)\n    params['include_eu_emissions'] = str(include_eu_emissions)\n    if sulphur_content_hfo is not None:\n        params['sulphur_content_hfo'] = str(sulphur_content_hfo)\n    if sulphur_content_lfo is not None:\n        params['sulphur_content_lfo'] = str(sulphur_content_lfo)\n    if sulphur_content_mgo is not None:\n        params['sulphur_content_mgo'] = str(sulphur_content_mgo)\n    if sulphur_content_lng is not None:\n        params['sulphur_content_lng'] = str(sulphur_content_lng)\n    return params\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselEmissionsAPI.get_emissions_by_imo","title":"<code>get_emissions_by_imo(imo, include_consumptions=False, include_efficiency_metrics=False, include_distances=False, include_durations=False, include_speed_statistics=False, include_eu_emissions=False, sulphur_content_hfo=None, sulphur_content_lfo=None, sulphur_content_mgo=None, sulphur_content_lng=None)</code>","text":"<p>Retrieves a list of vessel emissions by its IMO.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>int</code> <p>IMO of the vessel to retrieve emissions.</p> required <code>include_consumptions</code> <code>bool</code> <p>Include consumption data in the response.</p> <code>False</code> <code>include_efficiency_metrics</code> <code>bool</code> <p>Include efficiency metrics data in the response.</p> <code>False</code> <code>include_distances</code> <code>bool</code> <p>Include distances data in the response.</p> <code>False</code> <code>include_durations</code> <code>bool</code> <p>Include duration data in the response.</p> <code>False</code> <code>include_speed_statistics</code> <code>bool</code> <p>Include speed statistics data in the response.</p> <code>False</code> <code>include_eu_emissions</code> <code>bool</code> <p>Include European Union related emissions data in the response.</p> <code>False</code> <code>sulphur_content_hfo</code> <code>Union[float, None]</code> <p>Sulphur Content of HFO fuel type.</p> <code>None</code> <code>sulphur_content_lfo</code> <code>Union[float, None]</code> <p>Sulphur Content of LFO fuel type.</p> <code>None</code> <code>sulphur_content_mgo</code> <code>Union[float, None]</code> <p>Sulphur Content of MGO fuel type.</p> <code>None</code> <code>sulphur_content_lng</code> <code>Union[float, None]</code> <p>Sulphur Content of LNG fuel type.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[EmissionsEstimation]</code> <p>A list of vessel emissions or None if no vessel with the specified IMO has been found.</p> Source code in <code>signal_ocean/vessel_emissions/vessel_emissions_api.py</code> <pre><code>def get_emissions_by_imo(\n        self,\n        imo: int,\n        include_consumptions: bool = False,\n        include_efficiency_metrics: bool = False,\n        include_distances: bool = False,\n        include_durations: bool = False,\n        include_speed_statistics: bool = False,\n        include_eu_emissions: bool = False,\n        sulphur_content_hfo: Union[float, None] = None,\n        sulphur_content_lfo: Union[float, None] = None,\n        sulphur_content_mgo: Union[float, None] = None,\n        sulphur_content_lng: Union[float, None] = None\n) -&gt; List[EmissionsEstimation]:\n    \"\"\"Retrieves a list of vessel emissions by its IMO.\n\n    Args:\n        imo: IMO of the vessel to retrieve emissions.\n        include_consumptions: Include consumption data in the response.\n        include_efficiency_metrics: Include efficiency metrics\n         data in the response.\n        include_distances: Include distances data in the response.\n        include_durations: Include duration data in the response.\n        include_speed_statistics: Include speed statistics\n         data in the response.\n        include_eu_emissions: Include European Union related\n         emissions data in the response.\n        sulphur_content_hfo: Sulphur Content of HFO fuel type.\n        sulphur_content_lfo: Sulphur Content of LFO fuel type.\n        sulphur_content_mgo: Sulphur Content of MGO fuel type.\n        sulphur_content_lng: Sulphur Content of LNG fuel type.\n\n    Returns:\n        A list of vessel emissions or None if no vessel\n         with the specified IMO has been found.\n    \"\"\"\n    params_dict = self.construct_url_parameters(\n        include_consumptions=include_consumptions,\n        include_efficiency_metrics=include_efficiency_metrics,\n        include_distances=include_distances,\n        include_durations=include_durations,\n        include_speed_statistics=include_speed_statistics,\n        include_eu_emissions=include_eu_emissions,\n        sulphur_content_hfo=sulphur_content_hfo,\n        sulphur_content_lfo=sulphur_content_lfo,\n        sulphur_content_mgo=sulphur_content_mgo,\n        sulphur_content_lng=sulphur_content_lng\n    )\n    query_url = make_url('emissions',\n                         'imo', imo,\n                         **params_dict)\n    url = urljoin(VesselEmissionsAPI.relative_url, query_url)\n    return [i for i in get_multiple(self.__connection,\n                                    url,\n                                    EmissionsEstimation)]\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselEmissionsAPI.get_emissions_by_imo_and_voyage_number","title":"<code>get_emissions_by_imo_and_voyage_number(imo, voyage_number, quantity=None, include_consumptions=False, include_efficiency_metrics=False, include_distances=False, include_durations=False, include_speed_statistics=False, include_eu_emissions=False, sulphur_content_hfo=None, sulphur_content_lfo=None, sulphur_content_mgo=None, sulphur_content_lng=None)</code>","text":"<p>Retrieves voyage emissions for a vessel by its IMO and Voyage Number.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>int</code> <p>Vessel IMO to retrieve.</p> required <code>voyage_number</code> <code>int</code> <p>Voyage Number to retrieve.</p> required <code>quantity</code> <code>Union[int, None]</code> <p>User defined transported quantity for voyage.</p> <code>None</code> <code>include_consumptions</code> <code>bool</code> <p>Include consumption data in the response.</p> <code>False</code> <code>include_efficiency_metrics</code> <code>bool</code> <p>Include efficiency metrics in response.</p> <code>False</code> <code>include_distances</code> <code>bool</code> <p>Include distances data in the response.</p> <code>False</code> <code>include_durations</code> <code>bool</code> <p>Include duration data in the response.</p> <code>False</code> <code>include_speed_statistics</code> <code>bool</code> <p>Include speed statistics in response.</p> <code>False</code> <code>include_eu_emissions</code> <code>bool</code> <p>Include European Union related</p> <code>False</code> <code>sulphur_content_hfo</code> <code>Union[float, None]</code> <p>Sulphur Content of HFO fuel type.</p> <code>None</code> <code>sulphur_content_lfo</code> <code>Union[float, None]</code> <p>Sulphur Content of LFO fuel type.</p> <code>None</code> <code>sulphur_content_mgo</code> <code>Union[float, None]</code> <p>Sulphur Content of MGO fuel type.</p> <code>None</code> <code>sulphur_content_lng</code> <code>Union[float, None]</code> <p>Sulphur Content of LNG fuel type.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[EmissionsEstimation]</code> <p>EmissionsEstimation if no vessel with</p> <code>Optional[EmissionsEstimation]</code> <p>the specified IMO or Voyage Number has been found.</p> Source code in <code>signal_ocean/vessel_emissions/vessel_emissions_api.py</code> <pre><code>def get_emissions_by_imo_and_voyage_number(\n        self,\n        imo: int,\n        voyage_number: int,\n        quantity: Union[int, None] = None,\n        include_consumptions: bool = False,\n        include_efficiency_metrics: bool = False,\n        include_distances: bool = False,\n        include_durations: bool = False,\n        include_speed_statistics: bool = False,\n        include_eu_emissions: bool = False,\n        sulphur_content_hfo: Union[float, None] = None,\n        sulphur_content_lfo: Union[float, None] = None,\n        sulphur_content_mgo: Union[float, None] = None,\n        sulphur_content_lng: Union[float, None] = None\n) -&gt; Optional[EmissionsEstimation]:\n    \"\"\"Retrieves voyage emissions for a vessel by its IMO and Voyage Number.\n\n    Args:\n        imo: Vessel IMO to retrieve.\n        voyage_number: Voyage Number to retrieve.\n        quantity: User defined transported quantity for voyage.\n        include_consumptions: Include consumption data in the response.\n        include_efficiency_metrics: Include efficiency metrics in response.\n        include_distances: Include distances data in the response.\n        include_durations: Include duration data in the response.\n        include_speed_statistics: Include speed statistics in response.\n        include_eu_emissions: Include European Union related\n        emissions in response.\n        sulphur_content_hfo: Sulphur Content of HFO fuel type.\n        sulphur_content_lfo: Sulphur Content of LFO fuel type.\n        sulphur_content_mgo: Sulphur Content of MGO fuel type.\n        sulphur_content_lng: Sulphur Content of LNG fuel type.\n\n    Returns:\n        EmissionsEstimation if no vessel with\n        the specified IMO or Voyage Number has been found.\n    \"\"\"\n    params_dict = self.construct_url_parameters(\n        quantity=quantity,\n        include_consumptions=include_consumptions,\n        include_efficiency_metrics=include_efficiency_metrics,\n        include_distances=include_distances,\n        include_durations=include_durations,\n        include_speed_statistics=include_speed_statistics,\n        include_eu_emissions=include_eu_emissions,\n        sulphur_content_hfo=sulphur_content_hfo,\n        sulphur_content_lfo=sulphur_content_lfo,\n        sulphur_content_mgo=sulphur_content_mgo,\n        sulphur_content_lng=sulphur_content_lng)\n    query_url = make_url('emissions',\n                         'imo', imo,\n                         'voyage_number', voyage_number,\n                         **params_dict)\n    url = urljoin(VesselEmissionsAPI.relative_url, query_url)\n    return get_single(self.__connection, url, EmissionsEstimation)\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselEmissionsAPI.get_emissions_by_vessel_class_id","title":"<code>get_emissions_by_vessel_class_id(vessel_class_id, token=None, include_consumptions=False, include_efficiency_metrics=False, include_distances=False, include_durations=False, include_speed_statistics=False, include_eu_emissions=False)</code>","text":"<p>Get emissions estimations for a vessel class (supports incremental updates).</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class_id</code> <code>int</code> <p>The vessel class to retrieve</p> required <code>token</code> <code>Union[str, None]</code> <p>Next page token</p> <code>None</code> <code>include_consumptions</code> <code>bool</code> <p>Include consumption data in the response.</p> <code>False</code> <code>include_efficiency_metrics</code> <code>bool</code> <p>Include efficiency metrics data in the response.</p> <code>False</code> <code>include_distances</code> <code>bool</code> <p>Include distances data in the response.</p> <code>False</code> <code>include_durations</code> <code>bool</code> <p>Include duration data in the response.</p> <code>False</code> <code>include_speed_statistics</code> <code>bool</code> <p>Include speed statistics data in the response.</p> <code>False</code> <code>include_eu_emissions</code> <code>bool</code> <p>Include European Union related emissions data in the response.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[VesselClassEmissions]</code> <p>List of emissions estimation for all available voyages of a vessel class.</p> Source code in <code>signal_ocean/vessel_emissions/vessel_emissions_api.py</code> <pre><code>def get_emissions_by_vessel_class_id(\n        self,\n        vessel_class_id: int,\n        token: Union[str, None] = None,\n        include_consumptions: bool = False,\n        include_efficiency_metrics: bool = False,\n        include_distances: bool = False,\n        include_durations: bool = False,\n        include_speed_statistics: bool = False,\n        include_eu_emissions: bool = False\n) -&gt; Optional[VesselClassEmissions]:\n    \"\"\"Get emissions estimations for a vessel class (supports incremental updates).\n\n    Args:\n        vessel_class_id: The vessel class to retrieve\n        token: Next page token\n        include_consumptions: Include consumption data in the response.\n        include_efficiency_metrics: Include efficiency metrics\n         data in the response.\n        include_distances: Include distances data in the response.\n        include_durations: Include duration data in the response.\n        include_speed_statistics: Include speed statistics\n         data in the response.\n        include_eu_emissions: Include European Union related emissions\n         data in the response.\n\n    Returns:\n        List of emissions estimation for all\n         available voyages of a vessel class.\n\n    \"\"\"\n    params_dict = self.construct_url_parameters(\n        token=token,\n        include_consumptions=include_consumptions,\n        include_efficiency_metrics=include_efficiency_metrics,\n        include_distances=include_distances,\n        include_durations=include_durations,\n        include_speed_statistics=include_speed_statistics,\n        include_eu_emissions=include_eu_emissions\n    )\n    query_url = make_url('emissions',\n                         'class', vessel_class_id,\n                         **params_dict)\n\n    url = urljoin(VesselEmissionsAPI.relative_url, query_url)\n    return get_single(self.__connection,\n                      url,\n                      VesselClassEmissions)\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselEmissionsAPI.get_metrics_by_imo","title":"<code>get_metrics_by_imo(imo, year=None)</code>","text":"<p>Get vessel metrics.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>int</code> <p>Vessel IMO to retrieve</p> required <code>year</code> <code>Union[int, None]</code> <p>The year for the annual metrics</p> <code>None</code> <p>Returns:</p> Type Description <code>List[VesselMetrics]</code> <p>VesselMetrics for the requested IMO</p> Source code in <code>signal_ocean/vessel_emissions/vessel_emissions_api.py</code> <pre><code>def get_metrics_by_imo(\n        self,\n        imo: int,\n        year: Union[int, None] = None\n) -&gt; List[VesselMetrics]:\n    \"\"\"Get vessel metrics.\n\n    Args:\n        imo: Vessel IMO to retrieve\n        year: The year for the annual metrics\n\n    Returns:\n        VesselMetrics for the requested IMO\n\n    \"\"\"\n    url = urljoin(VesselEmissionsAPI.relative_url,\n                  f\"emissions/metrics/imo/{imo}\")\n    if year is not None:\n        url = urljoin(url, f\"?year={year}\")\n    return [i for i in get_multiple(self.__connection,\n                                    url,\n                                    VesselMetrics)]\n</code></pre>"},{"location":"vessel_emissions/#signal_ocean.vessel_emissions.VesselEmissionsAPI.get_metrics_by_vessel_class_id","title":"<code>get_metrics_by_vessel_class_id(vessel_class_id, year=None, token=None)</code>","text":"<p>Get vessel class metrics.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_class_id</code> <code>int</code> <p>The vessel class to retrieve</p> required <code>year</code> <code>Union[int, None]</code> <p>The year for the annual metrics</p> <code>None</code> <code>token</code> <code>Union[str, None]</code> <p>Next page token</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[VesselClassMetrics]</code> <p>VesselClassMetrics for the requested Class</p> Source code in <code>signal_ocean/vessel_emissions/vessel_emissions_api.py</code> <pre><code>def get_metrics_by_vessel_class_id(self,\n                                   vessel_class_id: int,\n                                   year: Union[int, None] = None,\n                                   token: Union[str, None] = None\n                                   ) -&gt; Optional[VesselClassMetrics]:\n    \"\"\"Get vessel class metrics.\n\n    Args:\n        vessel_class_id: The vessel class to retrieve\n        year: The year for the annual metrics\n        token: Next page token\n\n    Returns:\n        VesselClassMetrics for the requested Class\n\n    \"\"\"\n    if year is None and token is None:\n        query_url = \"\"\n    else:\n        query_url = \"?\"\n        if year is not None:\n            query_url += f\"year={year}\"\n            if token is not None:\n                query_url += f\"&amp;token={token}\"\n        else:\n            if token is not None:\n                query_url += f\"token={token}\"\n    query_url = urljoin(f\"emissions/metrics/class/\"\n                        f\"{vessel_class_id}\",\n                        query_url)\n    url = urljoin(VesselEmissionsAPI.relative_url, query_url)\n    return get_single(self.__connection, url, VesselClassMetrics)\n</code></pre>"},{"location":"vessel_valuations/","title":"Package Documentation","text":"<p>Vessel Valuations API Package.</p> <p>Classes:</p> Name Description <code>VesselValuationsAPI</code> <p>Represents Signal's Vessel Valuations API.</p> <code>Valuation</code> <p>Valuation for a specific vessel.</p>"},{"location":"vessel_valuations/#signal_ocean.vessel_valuations.Valuation","title":"<code>Valuation</code>  <code>dataclass</code>","text":"<p>A valuation for a specific vessel.</p> <p>Attributes:</p> Name Type Description <code>imo</code> <code>int</code> <p>The IMO number of the vessel the valuation applies to.</p> <code>valuation_price</code> <code>float</code> <p>The price of the valuation.</p> <code>scrap_price</code> <code>float</code> <p>The estimated scrapped valuation of the vessel.</p> <code>updated_date</code> <code>str</code> <p>Date and time at which the valuation was updated.</p> Source code in <code>signal_ocean/vessel_valuations/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Valuation:\n    \"\"\"A valuation for a specific vessel.\n\n    Attributes:\n        imo: The IMO number of the vessel the valuation applies to.\n        valuation_price: The price of the valuation.\n        scrap_price: The estimated scrapped valuation of the vessel.\n        updated_date: Date and time at which the valuation was updated.\n    \"\"\"\n    imo: int\n    valuation_price: float\n    scrap_price: float\n    updated_date: str\n\n    def to_dict(self) -&gt; Dict[Any, Any]:\n        \"\"\"Cast Valuation object to dict.\n\n        Returns:\n            Dict representation of Valuation model\n\n        \"\"\"\n        return asdict(\n            self,\n            dict_factory=lambda x: {\n                _to_camel_case_custom(k): v\n                for (k, v) in x if v is not None\n            })\n</code></pre>"},{"location":"vessel_valuations/#signal_ocean.vessel_valuations.Valuation.to_dict","title":"<code>to_dict()</code>","text":"<p>Cast Valuation object to dict.</p> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dict representation of Valuation model</p> Source code in <code>signal_ocean/vessel_valuations/models.py</code> <pre><code>def to_dict(self) -&gt; Dict[Any, Any]:\n    \"\"\"Cast Valuation object to dict.\n\n    Returns:\n        Dict representation of Valuation model\n\n    \"\"\"\n    return asdict(\n        self,\n        dict_factory=lambda x: {\n            _to_camel_case_custom(k): v\n            for (k, v) in x if v is not None\n        })\n</code></pre>"},{"location":"vessel_valuations/#signal_ocean.vessel_valuations.VesselValuationsAPI","title":"<code>VesselValuationsAPI</code>","text":"<p>Represents Signal's Vessel Valuation API.</p> Source code in <code>signal_ocean/vessel_valuations/vessel_valuations_api.py</code> <pre><code>class VesselValuationsAPI:\n    \"\"\"Represents Signal's Vessel Valuation API.\"\"\"\n\n    relative_url = \"valuationsv2/api/v2/valuations\"\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes Vessels Valuations API.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        if connection is not None:\n            em_connection = copy.deepcopy(connection)\n            func_type = type(\n                em_connection._Connection__get_headers  # type: ignore\n            )\n            em_connection._Connection__get_headers = func_type(  # type: ignore\n                custom_headers, em_connection\n            )\n            self.__connection = em_connection\n        else:\n            connection = Connection()\n            func_type = type(\n                connection._Connection__get_headers  # type: ignore\n            )\n            connection._Connection__get_headers = func_type(  # type: ignore\n                custom_headers, connection\n            )\n            self.__connection = connection\n\n    def get_all_historical_valuations_by_imo(\n            self,\n            imo: int,\n            from_date: Optional[str] = None,\n            to_date: Optional[str] = None,\n    ) -&gt; Optional[List[HistoricalValuation]]:\n        \"\"\"Retrieves the latest valuation price (in $M) for a specific vessel.\n\n        Args:\n            imo: The IMO number of the vessel.\n            from_date: The first date of valuation (optional).\n            to_date: The last date of valuation (optional).\n\n        Returns:\n            A List of Historical Valuations for this vessel.\n        \"\"\"\n        params_dict = {}\n        if from_date is not None:\n            params_dict['FromDate'] = from_date\n        if to_date is not None:\n            params_dict['ToDate'] = to_date\n        query_url = make_url(VesselValuationsAPI.relative_url,\n                             imo,\n                             'historical',\n                             **params_dict)\n        historical_valuations = [\n            i for i in get_multiple(\n                self.__connection,\n                query_url,\n                HistoricalValuation\n            )\n        ]\n        return historical_valuations\n\n    def get_latest_valuation_by_imo(self, imo: int) -&gt; Optional[Valuation]:\n        \"\"\"Retrieves the latest valuation for a specific vessel.\n\n        Args:\n            imo: The IMO number of the vessel.\n\n        Returns:\n            A valuation or None if a vessel with the given IMO number does not\n            exist or has no valuation.\n        \"\"\"\n        url = make_url(VesselValuationsAPI.relative_url,\n                       imo,\n                       'latest')\n        valuation = get_single(self.__connection, url, Valuation)\n        return valuation\n\n    def get_latest_valuations_by_page(self,\n                                      page: Optional[int] = None,\n                                      page_size: Optional[int] = None,\n                                      changed_since: Optional[str] = None\n                                      ) -&gt; Optional[PageValuations]:\n        \"\"\"Retrieves all valuations for a specific vessel.\n\n        Args:\n            page:  The page number you are requesting.\n            page_size:  The maximum number of results per\n            page to be returned.\n            Range between 1 and 500, by default 100.\n            changed_since: The date since the\n            last time of update (optional).\n\n        Returns:\n            A tuple of valuations or None if a vessel with the given IMO number\n            does not exist.\n        \"\"\"\n        params_dict = {}\n        if page is not None:\n            params_dict['Page'] = str(page)\n        if page_size is not None:\n            params_dict['PageSize'] = str(page_size)\n        if changed_since is not None:\n            params_dict['ChangedSince'] = str(changed_since)\n        url = make_url(VesselValuationsAPI.relative_url,\n                       'latest',\n                       '',\n                       **params_dict)\n        return get_single(self.__connection, url, PageValuations)\n\n    def get_latest_valuations_for_list_of_vessels(\n            self,\n            imo_list: List[int]\n    ) -&gt; List[Optional[Valuation]]:\n        \"\"\"Retrieves the latest estimated valuations for a list of vessels.\n\n        Args:\n            imo_list: The list of IMO numbers of the vessels.\n\n        Returns:\n            A list of latest valuations\n            for the requested imo numbers.\n        \"\"\"\n        data = post_multiple(\n            connection=self.__connection,\n            relative_url=f\"{VesselValuationsAPI.relative_url}/latest\",\n            cls=Valuation,\n            query_string=imo_list  # type: ignore\n        )\n        return [i for i in data]\n</code></pre>"},{"location":"vessel_valuations/#signal_ocean.vessel_valuations.VesselValuationsAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes Vessels Valuations API.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/vessel_valuations/vessel_valuations_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes Vessels Valuations API.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    if connection is not None:\n        em_connection = copy.deepcopy(connection)\n        func_type = type(\n            em_connection._Connection__get_headers  # type: ignore\n        )\n        em_connection._Connection__get_headers = func_type(  # type: ignore\n            custom_headers, em_connection\n        )\n        self.__connection = em_connection\n    else:\n        connection = Connection()\n        func_type = type(\n            connection._Connection__get_headers  # type: ignore\n        )\n        connection._Connection__get_headers = func_type(  # type: ignore\n            custom_headers, connection\n        )\n        self.__connection = connection\n</code></pre>"},{"location":"vessel_valuations/#signal_ocean.vessel_valuations.VesselValuationsAPI.get_all_historical_valuations_by_imo","title":"<code>get_all_historical_valuations_by_imo(imo, from_date=None, to_date=None)</code>","text":"<p>Retrieves the latest valuation price (in $M) for a specific vessel.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>int</code> <p>The IMO number of the vessel.</p> required <code>from_date</code> <code>Optional[str]</code> <p>The first date of valuation (optional).</p> <code>None</code> <code>to_date</code> <code>Optional[str]</code> <p>The last date of valuation (optional).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[List[HistoricalValuation]]</code> <p>A List of Historical Valuations for this vessel.</p> Source code in <code>signal_ocean/vessel_valuations/vessel_valuations_api.py</code> <pre><code>def get_all_historical_valuations_by_imo(\n        self,\n        imo: int,\n        from_date: Optional[str] = None,\n        to_date: Optional[str] = None,\n) -&gt; Optional[List[HistoricalValuation]]:\n    \"\"\"Retrieves the latest valuation price (in $M) for a specific vessel.\n\n    Args:\n        imo: The IMO number of the vessel.\n        from_date: The first date of valuation (optional).\n        to_date: The last date of valuation (optional).\n\n    Returns:\n        A List of Historical Valuations for this vessel.\n    \"\"\"\n    params_dict = {}\n    if from_date is not None:\n        params_dict['FromDate'] = from_date\n    if to_date is not None:\n        params_dict['ToDate'] = to_date\n    query_url = make_url(VesselValuationsAPI.relative_url,\n                         imo,\n                         'historical',\n                         **params_dict)\n    historical_valuations = [\n        i for i in get_multiple(\n            self.__connection,\n            query_url,\n            HistoricalValuation\n        )\n    ]\n    return historical_valuations\n</code></pre>"},{"location":"vessel_valuations/#signal_ocean.vessel_valuations.VesselValuationsAPI.get_latest_valuation_by_imo","title":"<code>get_latest_valuation_by_imo(imo)</code>","text":"<p>Retrieves the latest valuation for a specific vessel.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>int</code> <p>The IMO number of the vessel.</p> required <p>Returns:</p> Type Description <code>Optional[Valuation]</code> <p>A valuation or None if a vessel with the given IMO number does not</p> <code>Optional[Valuation]</code> <p>exist or has no valuation.</p> Source code in <code>signal_ocean/vessel_valuations/vessel_valuations_api.py</code> <pre><code>def get_latest_valuation_by_imo(self, imo: int) -&gt; Optional[Valuation]:\n    \"\"\"Retrieves the latest valuation for a specific vessel.\n\n    Args:\n        imo: The IMO number of the vessel.\n\n    Returns:\n        A valuation or None if a vessel with the given IMO number does not\n        exist or has no valuation.\n    \"\"\"\n    url = make_url(VesselValuationsAPI.relative_url,\n                   imo,\n                   'latest')\n    valuation = get_single(self.__connection, url, Valuation)\n    return valuation\n</code></pre>"},{"location":"vessel_valuations/#signal_ocean.vessel_valuations.VesselValuationsAPI.get_latest_valuations_by_page","title":"<code>get_latest_valuations_by_page(page=None, page_size=None, changed_since=None)</code>","text":"<p>Retrieves all valuations for a specific vessel.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Optional[int]</code> <p>The page number you are requesting.</p> <code>None</code> <code>page_size</code> <code>Optional[int]</code> <p>The maximum number of results per</p> <code>None</code> <code>changed_since</code> <code>Optional[str]</code> <p>The date since the</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[PageValuations]</code> <p>A tuple of valuations or None if a vessel with the given IMO number</p> <code>Optional[PageValuations]</code> <p>does not exist.</p> Source code in <code>signal_ocean/vessel_valuations/vessel_valuations_api.py</code> <pre><code>def get_latest_valuations_by_page(self,\n                                  page: Optional[int] = None,\n                                  page_size: Optional[int] = None,\n                                  changed_since: Optional[str] = None\n                                  ) -&gt; Optional[PageValuations]:\n    \"\"\"Retrieves all valuations for a specific vessel.\n\n    Args:\n        page:  The page number you are requesting.\n        page_size:  The maximum number of results per\n        page to be returned.\n        Range between 1 and 500, by default 100.\n        changed_since: The date since the\n        last time of update (optional).\n\n    Returns:\n        A tuple of valuations or None if a vessel with the given IMO number\n        does not exist.\n    \"\"\"\n    params_dict = {}\n    if page is not None:\n        params_dict['Page'] = str(page)\n    if page_size is not None:\n        params_dict['PageSize'] = str(page_size)\n    if changed_since is not None:\n        params_dict['ChangedSince'] = str(changed_since)\n    url = make_url(VesselValuationsAPI.relative_url,\n                   'latest',\n                   '',\n                   **params_dict)\n    return get_single(self.__connection, url, PageValuations)\n</code></pre>"},{"location":"vessel_valuations/#signal_ocean.vessel_valuations.VesselValuationsAPI.get_latest_valuations_for_list_of_vessels","title":"<code>get_latest_valuations_for_list_of_vessels(imo_list)</code>","text":"<p>Retrieves the latest estimated valuations for a list of vessels.</p> <p>Parameters:</p> Name Type Description Default <code>imo_list</code> <code>List[int]</code> <p>The list of IMO numbers of the vessels.</p> required <p>Returns:</p> Type Description <code>List[Optional[Valuation]]</code> <p>A list of latest valuations</p> <code>List[Optional[Valuation]]</code> <p>for the requested imo numbers.</p> Source code in <code>signal_ocean/vessel_valuations/vessel_valuations_api.py</code> <pre><code>def get_latest_valuations_for_list_of_vessels(\n        self,\n        imo_list: List[int]\n) -&gt; List[Optional[Valuation]]:\n    \"\"\"Retrieves the latest estimated valuations for a list of vessels.\n\n    Args:\n        imo_list: The list of IMO numbers of the vessels.\n\n    Returns:\n        A list of latest valuations\n        for the requested imo numbers.\n    \"\"\"\n    data = post_multiple(\n        connection=self.__connection,\n        relative_url=f\"{VesselValuationsAPI.relative_url}/latest\",\n        cls=Valuation,\n        query_string=imo_list  # type: ignore\n    )\n    return [i for i in data]\n</code></pre>"},{"location":"vessels/","title":"Package Documentation","text":"<p>Vessels API Package.</p> <p>Classes:</p> Name Description <code>VesselsAPI</code> <p>Represents Signal's Vessels API.</p> <code>Vessel</code> <p>Represents a Vessel.</p> <code>VesselType</code> <p>Represents the type of the vessel.</p> <code>VesselClass</code> <p>Represents the class of the vessel.</p>"},{"location":"vessels/#signal_ocean.vessels.Vessel","title":"<code>Vessel</code>  <code>dataclass</code>","text":"<p>Contains all details of a vessel.</p> <p>Attributes:</p> Name Type Description <code>imo</code> <code>int</code> <p>A seven-digits number that uniquely identifies a ship and does not change when the ship's owner, country of registry or name of the vessel changes.</p> <code>vessel_type_id</code> <code>int</code> <p>Numeric ID corresponding to the different values of the VesselType field.  1 -&gt; Tanker, 3 -&gt; Dry, 4 -&gt; Containers, 5 -&gt; LNG(Liquified Natural gas), 6 -&gt; LPG(Liquified Petroleum Gas), -2 -&gt; NotSet, -1 -&gt; Unknown</p> <code>built_for_trade_id</code> <code>int</code> <p>Numeric ID corresponding to the different values of the BuiltForTrade field.  1 -&gt; Crude, 2 -&gt; Product, 3 -&gt; Chemical, -2 -&gt; NotSet, -1 -&gt; Unknown</p> <code>trade_id</code> <code>int</code> <p>Numeric ID that takes the same values as the BuiltForTradeID field.  1 -&gt; Crude, 2 -&gt; Product, 3 -&gt; Chemical, -2 -&gt; NotSet, -1 -&gt; Unknown</p> <code>vessel_class_id</code> <code>int</code> <p>60-&gt; VLGCLpg, 61-&gt; MidsizeLpg, 62-&gt; HandyLpg, 63-&gt; SmallLpg, 69-&gt; VLOC, 70-&gt; Capesize, 72-&gt; PostPanamaxDry, 74-&gt; PanamaxDry, 75-&gt; Supramax, 76-&gt; Handymax, 77-&gt; Handysize, 78-&gt; ULCV, 79-&gt; NewPanamaxContainer, 80-&gt; PostPanamaxContainer, 81-&gt; PanamaxContainer, 82-&gt; FeedermaxContainer, 83-&gt; FeederContainer, 84-&gt; VLCC, 85-&gt; Suezmax, 86-&gt; Aframax, 87-&gt; PanamaxTanker, 88-&gt; MR2, 89-&gt; MR1, 90-&gt; Small, 91-&gt; LNGLng, 92-&gt; SmallDry, 94-&gt; ULCC, 95-&gt; SmallContainer</p> <code>commercial_operator_id</code> <code>int</code> <p>Numeric ID corresponding to the maritime company that manages the vessel commercially.</p> <code>deadweight</code> <code>int</code> <p>Numeric, measured in tonnes [t], often shortened as DWT, denotes the total carrying capacity of the vessel including cargo, ballast water, stores, provisions, crew and so on.</p> <code>breadth_extreme</code> <code>int</code> <p>Numeric, measured in meters [m], denotes the width of a ship over the outside of all planking or plating at the widest frame.</p> <code>gross_rated_tonnage</code> <code>int</code> <p>Numeric, measured in register tons, often shortened as GRT, denotes the sum of all the closed and/or closable spaces.</p> <code>reduced_gross_tonnage</code> <code>int</code> <p>Numeric, measured in register tons, often shortened as RGT, denotes a measure applicable for open-top container ships and tankers with a double hull (ships equipped with segregated ballast tanks).This quantity can be used to compute various tonnage-based fees.</p> <code>net_rated_tonnage</code> <code>int</code> <p>Numeric, measured in register tons, often shortened as NRT, denotes the difference between the GRT and the sum of all spaces which are not used for the purpose for which the ship is built.</p> <code>draught</code> <code>float</code> <p>Numeric, measured in meters [m], denotes the distance between the ship\u2019s keel and the waterline of the vessel. As the instantaneous draught of a vessel is a function of the vessel's loading status, this vessel characteristics refers to the maximum draught of the vessel.</p> <code>length_overall</code> <code>float</code> <p>Numeric, measured in meters [m], denotes the vessel's maximum length between the extremes points, forward and aft.</p> <code>moulded_depth</code> <code>float</code> <p>Numeric, measured in meters [m], denotes the vertical distance between the moulded base line and the top of the beams of the uppermost continuous deck.</p> <code>year_built</code> <code>int</code> <p>Numeric, year format, the year the vessel was built.</p> <code>clean_dirty_willing</code> <code>bool</code> <p>Boolean, indicates whether a tanker vessel is \u2018willing\u2019 to compete in the market complementary to the one shown in Trade. For example an LR willing dirty will have Trade=Product and CleanDirtyWilling=true.</p> <code>main_engine_manufacturer_id</code> <code>int</code> <p>Numeric ID corresponding to the different values of the MainEngine field.  1-&gt; MAN B&amp;W, 2-&gt; Wartsila, 3-&gt; Mitsubishi.</p> <code>classification_register_id</code> <code>int</code> <p>The id of the classification register. Default value: -2.</p> <code>updated_date</code> <code>datetime</code> <p>Date, format YYYY-MM-DD HH:MM:SS, corresponding to the latest update.</p> <code>geared</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel has cranes installed for handling its cargo or not.</p> <code>interline_coating</code> <code>Optional[int]</code> <p>interline coating</p> <code>vessel_name</code> <code>Optional[str]</code> <p>The current vessel name corresponding to that IMO.</p> <code>call_sign</code> <code>Optional[str]</code> <p>Alphanumeric code that uniquely identifies a vessel and is used for radio communication with land based operators or stations and between the vessels.</p> <code>vessel_type</code> <code>Optional[str]</code> <p>Description of the type of the vessel, based on the carried cargo.  Main categories are Tankers, Dry (bulk carriers), Containers, LNG and LPG.</p> <code>built_for_trade</code> <code>Optional[str]</code> <p>Additional attribute to specify a Tanker vessel with finer granularity.  This classification is derived by the vessel characteristics only. It indicates the initial cargo the vessel was designed for, here called \"trade\". For example, an LR2 is a vessel of VesselClass Aframax and BuiltForTrade Clean.</p> <code>trade</code> <code>Optional[str]</code> <p>Time-dependent version of the attribute BuiltForTrade. It is specified by the last cargo carried by the vessel at the time of query. For example, an LR2 with fueloil as last cargo has BuiltForTrade = Crude and Trade = Product.</p> <code>vessel_class</code> <code>Optional[str]</code> <p>Name of the vessel class the vessel belongs to. Assignment of a vessel to a certain VesselClass is based on the VesselType and the value of its Deadweight (if Tanker or Dry), its LiquidCap (if LNG/LPG) or its TEU (if Containers).  For example, an Aframax is a Tanker vessel with Deadweight within the range 82kt - 125kt, while a Capesize is a Dry vessel with Deadweight within the range 120kt-220kt. LR2 are defined as Aframax, as only Deadweight is used to define vessel classes.</p> <code>flag_code</code> <code>Optional[str]</code> <p>ISO 3166-1 alpha-2 code representing the vessel's country of registration.</p> <code>flag</code> <code>Optional[str]</code> <p>The country where the vessel has been registered and whose law is subject to.</p> <code>commercial_operator</code> <code>Optional[str]</code> <p>Name of the maritime company that manages the vessel commercially.</p> <code>built_country_code</code> <code>Optional[str]</code> <p>Two letters code representing the country where the vessel was built.</p> <code>built_country_name</code> <code>Optional[str]</code> <p>String, the name of the country where the vessel was built.</p> <code>scrapped_date</code> <code>Optional[datetime]</code> <p>Date, with format YYYY-MM-DD, indicates when the vessel was scrapped. If the vessel is active, ScrappedDate is null.</p> <code>shipyard_built_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the geo location where the vessel was built, for example the specific shipyard.</p> <code>shipyard_built_name</code> <code>Optional[str]</code> <p>String, the name of the shipyard where the vessel was built, e.g. Hyundai Heavy Industries Co.</p> <code>ice_class</code> <code>Optional[str]</code> <p>Alphanumeric code that denotes the vessel's additional level of strengthening as well as other arrangements that make navigation through frozen seas possible. For example 1A, 1D, etc.</p> <code>teu</code> <code>Optional[int]</code> <p>Numeric, measured in TEU (Twenty-Foot Equivalent Unit), denotes a volumetric measure of a container's cargo carrying capacity. Used for Containers, that is vessels with VesselType=4.</p> <code>teu14</code> <code>Optional[int]</code> <p>Numeric, denotes the capacity of the vessel measured in twenty- foot equivalent units (TEU) loaded at 14 tons.</p> <code>reefers</code> <code>Optional[int]</code> <p>Numeric, denotes the capacity of the vessel measured in refrigerated twenty-foot equivalent units (TEU), i.e., the maximum number of refrigerated containers that could be carried.</p> <code>panama_canal_net_tonnage</code> <code>Optional[int]</code> <p>Numeric, measured in register tons, volumetric measure derived by the NRT (NetRatedTonnage) and modified for Panama Canal purposes. Often used to compute tonnage- based fees.</p> <code>cubic_size</code> <code>Optional[int]</code> <p>Numeric, measured in cubic meters [cbm] denotes the carrying capacity of Gas vessels (LNG, LPG). For tankers it is the volume of cargo tanks.</p> <code>scrubbers_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS, best estimate of the scrubbers installation date.</p> <code>summer_tpc</code> <code>Optional[float]</code> <p>Numeric, measured in [metric tonnes/cm], acronym of Summer Tonnes Per Centimeter, denotes the cargo in metric tonnes (10^3 kg) needed to further increase the vessel's salt water draught by one centimeter.</p> <code>lightship_tonnes</code> <code>Optional[int]</code> <p>The weight of the vessels without any cargo or bunkers. It is an important parameter to estimate the scrap value of the vessel as it represents the amount of steel that can be recycled.</p> <code>main_engine_manufacturer</code> <code>Optional[str]</code> <p>String denoting the brand of the vessel's main engine.</p> <code>delivery_date</code> <code>Optional[datetime]</code> <p>Date, with format YYYY-MM-DD, indicates when the vessel was delivered to the owner and commenced its first voyage.</p> <code>classification_register</code> <code>Optional[str]</code> <p>The name of the organization that issued the vessel's classification certificate. Default value: Not set.</p> <code>number_of_holds</code> <code>Optional[int]</code> <p>Numeric, the number of separate enclosed spaces within a ship designed for storing cargo.</p> <code>number_of_hatches</code> <code>Optional[int]</code> <p>Numeric, the number of cargo hatches on the vessel that cover the opening to the cargo hold to protect the cargo. Most cargo holds have a cargo hatch.</p> <code>number_of_grabs</code> <code>Optional[int]</code> <p>Numeric, the number of separate grabs a vessel is equipped with for handling and lifting the cargo.</p> <code>number_of_cranes</code> <code>Optional[int]</code> <p>Numeric, the number of separate cranes a vessel is equipped with for handling and lifting the cargo.</p> <code>number_of_bow_chain_stoppers</code> <code>Optional[int]</code> <p>Numeric denotes the number of bow chain stoppers the vessel is equipped with. Ships likely to trade to Single Point Moorings should be equipped with bow chain stoppers.</p> <code>grain_capacity</code> <code>Optional[int]</code> <p>This is the space available for a liquid-type cargo, like bulk grain, which can flow into every corner.</p> <code>bale_capacity</code> <code>Optional[int]</code> <p>This is the space available for solid cargo. Bale space is usually about 7\u201310% less than grain space.</p> <code>main_engine_kw</code> <code>Optional[int]</code> <p>This value indicates the main engine's power in KW</p> <code>main_engine_rpm</code> <code>Optional[int]</code> <p>This value indicates the main engine's revolutions per minute (RPM)</p> <code>air_draught</code> <code>Optional[float]</code> <p>This value indicates the distance from the top of a vessel's highest point to its waterline</p> <code>deck_teu</code> <code>Optional[int]</code> <p>This value indicates the number of containers that can be stacked on the deck of the vessel</p> <code>under_deck_teu</code> <code>Optional[int]</code> <p>This value indicates the number of containers that can be carried in the vessel's holds (\"under deck\")</p> <code>suez_canal_net_tonnage</code> <code>Optional[int]</code> <p>Numeric, measured in register tons, volumetric measure derived by the NRT (NetRatedTonnage) and modified for Suez Canal purposes. Often used to compute tonnage-based fees</p> <code>class_renewal_date</code> <code>Optional[datetime]</code> <p>This value indicates the latest date of the vessel's \u201cClass Renewal\u201d, which is the official survey that all seagoing vessels that travel international must do every 5 years</p> <code>mewis_duct</code> <code>Optional[datetime]</code> <p>The date the Becker Mewis Duct equipment was installed</p> <code>inert_gas_system</code> <code>Optional[str]</code> <p>Boolean, indicates whether a vessel has inert gas system, which is a system of preventing any explosion in the cargo tanks of a tanker</p> <code>imo_type_1</code> <code>Optional[str]</code> <p>The safest type of tanker, for most severe cargoes</p> <code>imo_type_2</code> <code>Optional[str]</code> <p>Can carry more polluting cargoes than ImoRating3</p> <code>imo_type_3</code> <code>Optional[str]</code> <p>Can carry cargoes that are not very polluting but need special containment(ex: edibles)</p> <code>stst_coating</code> <code>Optional[int]</code> <p>STSS coating</p> <code>epoxy_coating</code> <code>Optional[int]</code> <p>Epoxy coating</p> <code>zinc_coating</code> <code>Optional[int]</code> <p>Zinc coating</p> <code>marineline_coating</code> <code>Optional[int]</code> <p>Marineline coating</p> <code>crude_oil_washing</code> <code>Optional[str]</code> <p>Crude Oil Washing system</p> <code>beneficial_owner_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the beneficial owner of the vessel</p> <code>beneficial_owner</code> <code>Optional[str]</code> <p>Name of the beneficial owner of the vessel</p> <code>parallel_body_length</code> <code>Optional[float]</code> <p>The Parallel Body Length of the vessel</p> <code>heating_coils_fitted</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel is equipped with a heating coils system. Tanker vessels may be fitted with heating coils in order to maintain the required temperature of the cargo for pumping.</p> <code>cranes_max_outreach</code> <code>Optional[float]</code> <p>Numeric, in meters (m). The maximum outreach range across all the cranes that the vessel has. This range is measured as the distance from the boom tip to the crane hook.</p> <code>cranes_max_lifting_capacity</code> <code>Optional[float]</code> <p>Numeric in metric tons [MT]. It is the computed maximum SWL (Safe Working Load) across all non auxiliary cranes of the vessel.</p> <code>hold_details_as_str</code> <code>Optional[str]</code> <p>String, dimensions in meters (length x breadth x depth) of each single hold, collected in one single string with the format commonly used across market reports. Example: \"17.96 m x 17.6 m, 17.96 m x 20.24 m, 17.96 m x 20.24 m, 17.96 m x 20.24 m, 17.96 m x 20.24 m\".</p> <code>hatch_details_as_str</code> <code>Optional[str]</code> <p>String, dimensions in meters (length x breadth) of each single hatch, collected in one single string with the format commonly used across market reports.</p> <code>grab_details_as_str</code> <code>Optional[str]</code> <p>String, capacity range in cbm (minimum capacity - maximum capacity) and maximum lifting capacity in mt of each single grab, collected in one single string with the format commonly used across market reports. Example: \"4 x 12 CBM\".</p> <code>crane_details_as_str</code> <code>Optional[str]</code> <p>String, SWL (Safe Working Load) in mt for each crane, collected in one single string with the format commonly used across market reports. Example: \"4 x 30 MT\".</p> <code>bow_chain_stopper_details_as_str</code> <code>Optional[str]</code> <p>String, number of Bow Chain Stoppers with their maximum load capacity for each type of bow chain stopper in a string format. Example: <code>\"\"2 x 200 MT, 1 x 100 MT\"\"</code>.</p> <code>box_shaped_holds</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel has any hold with box shape.</p> <code>neo_panama_locks</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel is fitted to cross the Panama Canal through the new locks.</p> <code>australian_hold_ladder</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel has any Australian hold ladder on board. This system is a specific inclined ladder used to inspect the cargo.</p> <code>co2_fitted</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel has any CO2 fire suppression system.This system is used to fight fire in the cargo hold of a vessel.</p> <code>a60_bulkhead</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel has any bulkhead of class A, insulated with approved insulation and passed the standard fire test for 60 minutes. A bulkhead is a vertical partition to provide compartments or subdivisions.</p> <code>log_fitted</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel is fitted to carry logs.</p> <code>open_hatch</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the bulk carrier vessel is of the open hatch type. These vessels are designed to offer direct access to the hold through cargo hatches that extend the full width of the vessel. OHBC (Open Hatch Bulk Carriers) are often used to carry forest products, such as pre-slung timber and slugs.</p> <code>bwts</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel has any Ballast Water Treatment System. This system is designed to remove and destroy/inactive biological organisms (zooplankton, algae, bacteria) from ballast water.</p> <code>grabs_fitted</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel is fitted with grabs. Grabs are fitted on cranes to allow the handling of cargo.</p> <code>ghg</code> <code>Optional[str]</code> <p>String, denotes the vessel\u2019s GHG (Greenhouse Gas) Emissions Rating. Developed by RightShip, GHG compares a ship's design efficiency with peer vessels using a simple A\u2013G scale.</p> <code>order_book_status_id</code> <code>Optional[int]</code> <p>Int (1-8), denotes the OrderBook Status ID (1: UnconfirmedExistence, 2: ReportedOrder, 3: OnOrder, 4: CancelledOrder, 5: UnderConstruction, 6: Launched, 7: Live, 8: Dead)</p> <code>order_book_status</code> <code>Optional[str]</code> <p>String, denotes the OrderBook Status. Dead (Scrapped Date in the past), CancelledOrder (Cancelled Date in the past), Live (Delivery Date in the past), Launched (Launch Date in the past), UnderConstruction (Construction Start Date in the past), OnOrder (has a Construction Start Date), ReportedOrder (has an Order Date), UnconfirmedExistence.</p> <code>order_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD, the date the order of the vessel was placed.</p> <code>construction_start_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD, the date of the start of the construction.</p> <code>launch_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD, the date of the vessel launch into the water.</p> <code>scheduled_delivery_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD, the date of the scheduled delivery of the vessel.</p> <code>cancelled_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS, the date of the order.</p> <code>minimum_temperature</code> <code>Optional[float]</code> <p>Numeric, denotes the minimum temperature of cargo and tanks.</p> <code>maximum_pressure</code> <code>Optional[float]</code> <p>Numeric, measured in Bar, denotes the maximum tank pressure.</p> <code>ammonia</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel can carry ammonia.</p> <code>vcm</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel can carry vinyl chloride monomer.</p> <code>ethylene</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel can carry ethylene.</p> <code>ballast_parallel_body_length</code> <code>Optional[float]</code> <p>Numeric, denotes the length of the ship's hull that is parallel to the waterline when the ship is in its normal ballast condition. The normal ballast condition refers to the state of the vessel when it carries only ballast water (no cargo) to ensure stability and seaworthiness.</p> <code>empty_parallel_body_length</code> <code>Optional[float]</code> <p>Numeric, denotes the length of the ship's hull parallel to the baseline when the ship is completely empty, without any cargo or ballast water. This is essentially the ship's hull form at its lightest draft.</p> <code>stern_line</code> <code>Optional[bool]</code> <p>Boolean, denotes whether the vessel is equipped with a stern line at the rear end, which is used to secure the vessel to a dock, pier, or another ship during mooring operations. Stern lines are especially crucial during the process of berthing and unberthing, as they assist in guiding the stern while the ship pivots or moves sideways.</p> <code>yard_number</code> <code>Optional[str]</code> <p>String, the Yard Number refers to a unique identifier assigned to a vessel by the shipyard during its construction.</p> <code>design_model</code> <code>Optional[str]</code> <p>String, the Design Model refers to a specific class or series of ships designed and often standardized by a particular shipyard or shipbuilder. The design model encapsulates detailed specifications, layouts, and features that are common across all ships built to that particular design.</p> <code>bow_to_center_manifold</code> <code>Optional[float]</code> <p>Numeric, measured in meters [m], represents the distance from the bow (the front end) of the vessel to the center of the manifold. The manifold is the point on the ship where cargo hoses or arms are connected for the loading or unloading of liquid cargoes.</p> <code>water_line_to_manifold</code> <code>Optional[float]</code> <p>Numeric, measured in meters [m],  represents the vertical distance from the water line of the vessel to the center of the manifold. The manifold is the point on the ship where cargo hoses or arms are connected for the loading or unloading of liquid cargoes.</p> <code>deck_to_center_manifold</code> <code>Optional[float]</code> <p>Numeric, measured in meters [m],  refers to the vertical distance from the main deck of the vessel to the center of the cargo manifold. The manifold is the point on the ship where cargo hoses or arms are connected for the loading or unloading of liquid cargoes.</p> <code>rail_to_center_manifold</code> <code>Optional[float]</code> <p>Numeric, measured in meters [m],  represents the horizontal distance from the ship\u2019s rail (the protective barrier along the edge of the deck) to the center of the manifold. The manifold is the point on the ship where cargo hoses or arms are connected for the loading or unloading of liquid cargoes.</p> <code>bow_chain_stoppers_fitted</code> <code>Optional[bool]</code> <p>Boolean, indicates whether the vessel is equipped with bow chain stoppers. Ships likely to trade to Single Point Moorings should be equipped with bow chain stoppers.</p> <code>propulsion_type</code> <code>Optional[str]</code> <p>String (e.g., \"Dual Fuel\", \"Conventional Fuel\", or \"Steam Turbine\"), describes the vessel\u2019s main engine and how it moves. It indicates the type of propulsion system used, which affects fuel use, efficiency, and emissions.</p> <code>gas_containment_type</code> <code>Optional[str]</code> <p>String (e.g., \"Type A\", \"GTT Mk III\", or \"Kvaerner-Moss\"), describes how liquefied gas is stored on the vessel. It indicates the design of the tank system used for LNG or LPG, affecting safety, efficiency, and how much cargo the ship can carry.</p> <code>number_of_bow_thrusters</code> <code>Optional[int]</code> <p>Integer, indicates the number of bow thrusters installed on the vessel. Bow thrusters are lateral propulsion devices located at the bow (front) of the ship, used to assist with sideways maneuvering during docking and low-speed operations. A higher number generally provides greater maneuverability, especially on larger vessels.</p> Source code in <code>signal_ocean/vessels/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Vessel:\n    \"\"\"Contains all details of a vessel.\n\n    Attributes:\n        imo: A seven-digits number that uniquely identifies a ship and does\n            not change when the ship's owner, country of registry or name of\n            the vessel changes.\n        vessel_type_id: Numeric ID corresponding to the different values of\n            the VesselType field.  1 -&gt; Tanker, 3 -&gt; Dry, 4 -&gt; Containers,\n            5 -&gt; LNG(Liquified Natural gas), 6 -&gt; LPG(Liquified Petroleum\n            Gas), -2 -&gt; NotSet, -1 -&gt; Unknown\n        built_for_trade_id: Numeric ID corresponding to the different values\n            of the BuiltForTrade field.  1 -&gt; Crude, 2 -&gt; Product,\n            3 -&gt; Chemical, -2 -&gt; NotSet, -1 -&gt; Unknown\n        trade_id: Numeric ID that takes the same values as the BuiltForTradeID\n            field.  1 -&gt; Crude, 2 -&gt; Product, 3 -&gt; Chemical,\n            -2 -&gt; NotSet, -1 -&gt; Unknown\n        vessel_class_id: 60-&gt; VLGCLpg, 61-&gt; MidsizeLpg, 62-&gt; HandyLpg,\n            63-&gt; SmallLpg, 69-&gt; VLOC, 70-&gt; Capesize, 72-&gt; PostPanamaxDry,\n            74-&gt; PanamaxDry, 75-&gt; Supramax, 76-&gt; Handymax, 77-&gt; Handysize,\n            78-&gt; ULCV, 79-&gt; NewPanamaxContainer, 80-&gt; PostPanamaxContainer,\n            81-&gt; PanamaxContainer, 82-&gt; FeedermaxContainer,\n            83-&gt; FeederContainer, 84-&gt; VLCC, 85-&gt; Suezmax, 86-&gt; Aframax,\n            87-&gt; PanamaxTanker, 88-&gt; MR2, 89-&gt; MR1, 90-&gt; Small, 91-&gt; LNGLng,\n            92-&gt; SmallDry, 94-&gt; ULCC, 95-&gt; SmallContainer\n        commercial_operator_id: Numeric ID corresponding to the maritime\n            company that manages the vessel commercially.\n        deadweight: Numeric, measured in tonnes [t], often shortened as DWT,\n            denotes the total carrying capacity of the vessel including cargo,\n            ballast water, stores, provisions, crew and so on.\n        breadth_extreme: Numeric, measured in meters [m], denotes the width of\n            a ship over the outside of all planking or plating at the widest\n            frame.\n        gross_rated_tonnage: Numeric, measured in register tons, often\n            shortened as GRT, denotes the sum of all the closed and/or closable\n            spaces.\n        reduced_gross_tonnage: Numeric, measured in register tons, often\n            shortened as RGT, denotes a measure applicable for open-top\n            container ships and tankers with a double hull (ships equipped with\n            segregated ballast tanks).This quantity can be used to compute\n            various tonnage-based fees.\n        net_rated_tonnage: Numeric, measured in register tons, often shortened\n            as NRT, denotes the difference between the GRT and the sum of all\n            spaces which are not used for the purpose for which the ship is\n            built.\n        draught: Numeric, measured in meters [m], denotes the distance between\n            the ship\u2019s keel and the waterline of the vessel. As the\n            instantaneous draught of a vessel is a function of the vessel's\n            loading status, this vessel characteristics refers to the maximum\n            draught of the vessel.\n        length_overall: Numeric, measured in meters [m], denotes the vessel's\n            maximum length between the extremes points, forward and aft.\n        moulded_depth: Numeric, measured in meters [m], denotes the vertical\n            distance between the moulded base line and the top of the beams of\n            the uppermost continuous deck.\n        year_built: Numeric, year format, the year the vessel was built.\n        clean_dirty_willing: Boolean, indicates whether a tanker vessel is\n            \u2018willing\u2019 to compete in the market complementary to the one shown\n            in Trade. For example an LR willing dirty will have Trade=Product\n            and CleanDirtyWilling=true.\n        main_engine_manufacturer_id: Numeric ID corresponding to the different\n            values of the MainEngine field.  1-&gt; MAN B&amp;W, 2-&gt; Wartsila, 3-&gt;\n            Mitsubishi.\n        classification_register_id: The id of the classification register.\n            Default value: -2.\n        updated_date: Date, format YYYY-MM-DD HH:MM:SS, corresponding to the\n            latest update.\n        geared: Boolean, denotes whether the vessel has cranes installed for\n            handling its cargo or not.\n        interline_coating: interline coating\n        vessel_name: The current vessel name corresponding to that IMO.\n        call_sign: Alphanumeric code that uniquely identifies a vessel and is\n            used for radio communication with land based operators or stations\n            and between the vessels.\n        vessel_type: Description of the type of the vessel, based on the\n            carried cargo.  Main categories are Tankers, Dry (bulk carriers),\n            Containers, LNG and LPG.\n        built_for_trade: Additional attribute to specify a Tanker vessel with\n            finer granularity.  This classification is derived by the vessel\n            characteristics only. It indicates the initial cargo the vessel was\n            designed for, here called \"trade\". For example, an LR2 is a vessel\n            of VesselClass Aframax and BuiltForTrade Clean.\n        trade: Time-dependent version of the attribute BuiltForTrade. It is\n            specified by the last cargo carried by the vessel at the time of\n            query. For example, an LR2 with fueloil as last cargo has\n            BuiltForTrade = Crude and Trade = Product.\n        vessel_class: Name of the vessel class the vessel belongs to.\n            Assignment of a vessel to a certain VesselClass is based on the\n            VesselType and the value of its Deadweight (if Tanker or Dry), its\n            LiquidCap (if LNG/LPG) or its TEU (if Containers).  For example, an\n            Aframax is a Tanker vessel with Deadweight within the range 82kt -\n            125kt, while a Capesize is a Dry vessel with Deadweight within the\n            range 120kt-220kt. LR2 are defined as Aframax, as only Deadweight\n            is used to define vessel classes.\n        flag_code: ISO 3166-1 alpha-2 code representing the vessel's country of\n            registration.\n        flag: The country where the vessel has been registered and whose law is\n            subject to.\n        commercial_operator: Name of the maritime company that manages the\n            vessel commercially.\n        built_country_code: Two letters code representing the country where the\n            vessel was built.\n        built_country_name: String, the name of the country where the vessel\n            was built.\n        scrapped_date: Date, with format YYYY-MM-DD, indicates when the vessel\n            was scrapped. If the vessel is active, ScrappedDate is null.\n        shipyard_built_id: Numeric ID corresponding to the geo location where\n            the vessel was built, for example the specific shipyard.\n        shipyard_built_name: String, the name of the shipyard where the vessel\n            was built, e.g. Hyundai Heavy Industries Co.\n        ice_class: Alphanumeric code that denotes the vessel's additional level\n            of strengthening as well as other arrangements that make navigation\n            through frozen seas possible. For example 1A, 1D, etc.\n        teu: Numeric, measured in TEU (Twenty-Foot Equivalent Unit), denotes a\n            volumetric measure of a container's cargo carrying capacity. Used\n            for Containers, that is vessels with VesselType=4.\n        teu14: Numeric, denotes the capacity of the vessel measured in twenty-\n            foot equivalent units (TEU) loaded at 14 tons.\n        reefers: Numeric, denotes the capacity of the vessel measured in\n            refrigerated twenty-foot equivalent units (TEU), i.e., the maximum\n            number of refrigerated containers that could be carried.\n        panama_canal_net_tonnage: Numeric, measured in register tons,\n            volumetric measure derived by the NRT (NetRatedTonnage) and\n            modified for Panama Canal purposes. Often used to compute tonnage-\n            based fees.\n        cubic_size: Numeric, measured in cubic meters [cbm] denotes the\n            carrying capacity of Gas vessels (LNG, LPG). For tankers it is the\n            volume of cargo tanks.\n        scrubbers_date: Date, format YYYY-MM-DD HH:MM:SS, best estimate of the\n            scrubbers installation date.\n        summer_tpc: Numeric, measured in [metric tonnes/cm], acronym of Summer\n            Tonnes Per Centimeter, denotes the cargo in metric tonnes (10^3 kg)\n            needed to further increase the vessel's salt water draught by one\n            centimeter.\n        lightship_tonnes: The weight of the vessels without any cargo or\n            bunkers. It is an important parameter to estimate the scrap value\n            of the vessel as it represents the amount of steel that can be\n            recycled.\n        main_engine_manufacturer: String denoting the brand of the vessel's\n            main engine.\n        delivery_date: Date, with format YYYY-MM-DD, indicates when the vessel\n            was delivered to the owner and commenced its first voyage.\n        classification_register: The name of the organization that issued the\n            vessel's classification certificate. Default value: Not set.\n        number_of_holds: Numeric, the number of separate enclosed spaces within\n            a ship designed for storing cargo.\n        number_of_hatches: Numeric, the number of cargo hatches on the vessel\n            that cover the opening to the cargo hold to protect the cargo. Most\n            cargo holds have a cargo hatch.\n        number_of_grabs: Numeric, the number of separate grabs a vessel is\n            equipped with for handling and lifting the cargo.\n        number_of_cranes: Numeric, the number of separate cranes a vessel is\n            equipped with for handling and lifting the cargo.\n        number_of_bow_chain_stoppers: Numeric denotes the\n            number of bow chain stoppers the vessel is equipped\n            with. Ships likely to trade to Single Point\n            Moorings should be equipped with bow chain stoppers.\n        grain_capacity: This is the space available for a liquid-type cargo,\n            like bulk grain, which can flow into every corner.\n        bale_capacity: This is the space available for solid cargo. Bale space\n            is usually about 7\u201310% less than grain space.\n        main_engine_kw: This value indicates the main engine's power in KW\n        main_engine_rpm: This value indicates the main engine's revolutions\n            per minute (RPM)\n        air_draught: This value indicates the distance from the top of a\n            vessel's highest point to its waterline\n        deck_teu: This value indicates the number of containers that can be\n            stacked on the deck of the vessel\n        under_deck_teu: This value indicates the number of containers that can\n            be carried in the vessel's holds (\"under deck\")\n        suez_canal_net_tonnage: Numeric, measured in register tons, volumetric\n            measure derived by the NRT (NetRatedTonnage) and modified for Suez\n            Canal purposes. Often used to compute tonnage-based fees\n        class_renewal_date: This value indicates the latest date of the\n            vessel's \u201cClass Renewal\u201d, which is the official survey that all\n            seagoing vessels that travel international must do every 5 years\n        mewis_duct: The date the Becker Mewis Duct equipment was installed\n        inert_gas_system: Boolean, indicates whether a vessel has inert gas\n            system, which is a system of preventing any explosion in the cargo\n            tanks of a tanker\n        imo_type_1: The safest type of tanker, for most severe cargoes\n        imo_type_2: Can carry more polluting cargoes than ImoRating3\n        imo_type_3: Can carry cargoes that are not very polluting but need\n            special containment(ex: edibles)\n        stst_coating: STSS coating\n        epoxy_coating: Epoxy coating\n        zinc_coating: Zinc coating\n        marineline_coating: Marineline coating\n        crude_oil_washing: Crude Oil Washing system\n        beneficial_owner_id: Numeric ID corresponding to the beneficial owner\n            of the vessel\n        beneficial_owner: Name of the beneficial owner of the vessel\n        parallel_body_length: The Parallel Body Length of the vessel\n        heating_coils_fitted: Boolean, denotes whether the vessel is equipped\n            with a heating coils system. Tanker vessels may be fitted with\n            heating coils in order to maintain the required temperature of\n            the cargo for pumping.\n        cranes_max_outreach: Numeric, in meters (m). The maximum outreach\n            range across all the cranes that the vessel has. This range\n            is measured as the distance from the boom tip to the crane hook.\n        cranes_max_lifting_capacity: Numeric in metric tons [MT]. It is\n            the computed maximum SWL (Safe Working Load) across all non\n            auxiliary cranes of the vessel.\n        hold_details_as_str: String, dimensions in meters (length x\n            breadth x depth) of each single hold, collected in one single\n            string with the format commonly used across market reports.\n            Example: \"17.96 m x 17.6 m, 17.96 m x 20.24 m, 17.96 m x\n            20.24 m, 17.96 m x 20.24 m, 17.96 m x 20.24 m\".\n        hatch_details_as_str: String, dimensions in meters (length x\n            breadth) of each single hatch, collected in one single string\n            with the format commonly used across market reports.\n        grab_details_as_str: String, capacity range in cbm (minimum\n            capacity - maximum capacity) and maximum lifting capacity in\n            mt of each single grab, collected in one single string with\n            the format commonly used across market reports.\n            Example: \"4 x 12 CBM\".\n        crane_details_as_str: String, SWL (Safe Working Load) in mt for\n            each crane, collected in one single string with the format\n            commonly used across market reports. Example: \"4 x 30 MT\".\n        bow_chain_stopper_details_as_str: String, number of Bow\n            Chain Stoppers with their maximum load capacity for\n            each type of bow chain stopper in a string format.\n            Example: `\"\"2 x 200 MT, 1 x 100 MT\"\"`.\n        box_shaped_holds: Boolean, denotes whether the vessel has any hold\n            with box shape.\n        neo_panama_locks: Boolean, denotes whether the vessel is fitted to\n            cross the Panama Canal through the new locks.\n        australian_hold_ladder: Boolean, denotes whether the vessel has\n            any Australian hold ladder on board. This system is a specific\n            inclined ladder used to inspect the cargo.\n        co2_fitted: Boolean, denotes whether the vessel has any CO2 fire\n            suppression system.This system is used to fight fire in\n            the cargo hold of a vessel.\n        a60_bulkhead: Boolean, denotes whether the vessel has any\n            bulkhead of class A, insulated with approved insulation and\n            passed the standard fire test for 60 minutes. A bulkhead is\n            a vertical partition to provide compartments or subdivisions.\n        log_fitted: Boolean, denotes whether the vessel is fitted to\n            carry logs.\n        open_hatch: Boolean, denotes whether the bulk carrier vessel is\n            of the open hatch type. These vessels are designed to offer\n            direct access to the hold through cargo hatches that extend\n            the full width of the vessel. OHBC (Open Hatch Bulk Carriers)\n            are often used to carry forest products, such as pre-slung\n            timber and slugs.\n        bwts: Boolean, denotes whether the vessel has any Ballast Water\n            Treatment System. This system is designed to remove and\n            destroy/inactive biological organisms (zooplankton, algae,\n            bacteria) from ballast water.\n        grabs_fitted: Boolean, denotes whether the vessel is fitted with\n            grabs. Grabs are fitted on cranes to allow the handling of cargo.\n        ghg: String, denotes the vessel\u2019s GHG (Greenhouse Gas) Emissions\n            Rating. Developed by RightShip, GHG compares a ship's\n            design efficiency with peer vessels using a simple A\u2013G scale.\n        order_book_status_id: Int (1-8), denotes the OrderBook Status ID\n            (1: UnconfirmedExistence, 2: ReportedOrder, 3: OnOrder,\n            4: CancelledOrder, 5: UnderConstruction, 6: Launched,\n            7: Live, 8: Dead)\n        order_book_status: String, denotes the OrderBook Status. Dead\n            (Scrapped Date in the past), CancelledOrder (Cancelled Date in\n            the past), Live (Delivery Date in the past), Launched (Launch\n            Date in the past), UnderConstruction (Construction Start Date\n            in the past), OnOrder (has a Construction Start Date),\n            ReportedOrder (has an Order Date), UnconfirmedExistence.\n        order_date: Date, format YYYY-MM-DD, the date the order of the\n            vessel was placed.\n        construction_start_date: Date, format YYYY-MM-DD, the date of\n            the start of the construction.\n        launch_date: Date, format YYYY-MM-DD, the date of the vessel\n            launch into the water.\n        scheduled_delivery_date: Date, format YYYY-MM-DD, the date\n            of the scheduled delivery of the vessel.\n        cancelled_date: Date, format YYYY-MM-DD HH:MM:SS, the date\n            of the order.\n        minimum_temperature: Numeric, denotes the minimum temperature\n            of cargo and tanks.\n        maximum_pressure: Numeric, measured in Bar, denotes the\n            maximum tank pressure.\n        ammonia: Boolean, denotes whether the vessel can carry\n            ammonia.\n        vcm: Boolean, denotes whether the vessel can carry vinyl\n            chloride monomer.\n        ethylene: Boolean, denotes whether the vessel can carry\n            ethylene.\n        ballast_parallel_body_length: Numeric, denotes the length\n            of the ship's hull that is parallel to the waterline\n            when the ship is in its normal ballast condition.\n            The normal ballast condition refers to the state of\n            the vessel when it carries only ballast water (no\n            cargo) to ensure stability and seaworthiness.\n        empty_parallel_body_length: Numeric, denotes the length\n            of the ship's hull parallel to the baseline when\n            the ship is completely empty, without any cargo or\n            ballast water. This is essentially the ship's hull\n            form at its lightest draft.\n        stern_line: Boolean, denotes whether the vessel is\n            equipped with a stern line at the rear end, which\n            is used to secure the vessel to a dock, pier, or\n            another ship during mooring operations. Stern\n            lines are especially crucial during the process of\n            berthing and unberthing, as they assist in guiding\n            the stern while the ship pivots or moves sideways.\n        yard_number: String, the Yard Number refers to a\n            unique identifier assigned to a vessel by the\n            shipyard during its construction.\n        design_model: String, the Design Model refers to a\n            specific class or series of ships designed and\n            often standardized by a particular shipyard or\n            shipbuilder. The design model encapsulates\n            detailed specifications, layouts, and features\n            that are common across all ships built to that\n            particular design.\n        bow_to_center_manifold: Numeric, measured in meters\n            [m], represents the distance from the bow (the\n            front end) of the vessel to the center of the\n            manifold. The manifold is the point on the ship\n            where cargo hoses or arms are connected for the\n            loading or unloading of liquid cargoes.\n        water_line_to_manifold: Numeric, measured in meters\n            [m],  represents the vertical distance from the\n            water line of the vessel to the center of the\n            manifold. The manifold is the point on the ship\n            where cargo hoses or arms are connected for the\n            loading or unloading of liquid cargoes.\n        deck_to_center_manifold: Numeric, measured in meters\n            [m],  refers to the vertical distance from the\n            main deck of the vessel to the center of the cargo\n            manifold. The manifold is the point on the ship\n            where cargo hoses or arms are connected for the\n            loading or unloading of liquid cargoes.\n        rail_to_center_manifold: Numeric, measured in meters\n            [m],  represents the horizontal distance from the\n            ship\u2019s rail (the protective barrier along the edge\n            of the deck) to the center of the manifold. The\n            manifold is the point on the ship where cargo hoses\n            or arms are connected for the loading or unloading\n            of liquid cargoes.\n        bow_chain_stoppers_fitted: Boolean, indicates whether\n            the vessel is equipped with bow chain stoppers.\n            Ships likely to trade to Single Point Moorings\n            should be equipped with bow chain stoppers.\n        propulsion_type: String (e.g., \"Dual Fuel\",\n            \"Conventional Fuel\", or \"Steam Turbine\"),\n            describes the vessel\u2019s main engine and how it\n            moves. It indicates the type of propulsion system\n            used, which affects fuel use, efficiency, and\n            emissions.\n        gas_containment_type: String (e.g., \"Type A\",\n            \"GTT Mk III\", or \"Kvaerner-Moss\"), describes how\n            liquefied gas is stored on the vessel. It\n            indicates the design of the tank system used for\n            LNG or LPG, affecting safety, efficiency, and\n            how much cargo the ship can carry.\n        number_of_bow_thrusters: Integer, indicates the\n            number of bow thrusters installed on the vessel.\n            Bow thrusters are lateral propulsion devices\n            located at the bow (front) of the ship, used to\n            assist with sideways maneuvering during docking\n            and low-speed operations. A higher number\n            generally provides greater maneuverability,\n            especially on larger vessels.\n    \"\"\"\n\n    imo: int\n    vessel_type_id: int\n    built_for_trade_id: int\n    trade_id: int\n    vessel_class_id: int\n    commercial_operator_id: int\n    deadweight: int\n    breadth_extreme: int\n    gross_rated_tonnage: int\n    reduced_gross_tonnage: int\n    net_rated_tonnage: int\n    draught: float\n    length_overall: float\n    moulded_depth: float\n    year_built: int\n    clean_dirty_willing: bool\n    main_engine_manufacturer_id: int\n    classification_register_id: int\n    updated_date: datetime\n    geared: Optional[bool] = None\n    interline_coating: Optional[int] = None\n    vessel_name: Optional[str] = None\n    call_sign: Optional[str] = None\n    vessel_type: Optional[str] = None\n    built_for_trade: Optional[str] = None\n    trade: Optional[str] = None\n    vessel_class: Optional[str] = None\n    flag_code: Optional[str] = None\n    flag: Optional[str] = None\n    commercial_operator: Optional[str] = None\n    built_country_code: Optional[str] = None\n    built_country_name: Optional[str] = None\n    scrapped_date: Optional[datetime] = None\n    shipyard_built_id: Optional[int] = None\n    shipyard_built_name: Optional[str] = None\n    ice_class: Optional[str] = None\n    teu: Optional[int] = None\n    teu14: Optional[int] = None\n    reefers: Optional[int] = None\n    panama_canal_net_tonnage: Optional[int] = None\n    cubic_size: Optional[int] = None\n    scrubbers_date: Optional[datetime] = None\n    summer_tpc: Optional[float] = None\n    lightship_tonnes: Optional[int] = None\n    main_engine_manufacturer: Optional[str] = None\n    delivery_date: Optional[datetime] = None\n    classification_register: Optional[str] = None\n    number_of_holds: Optional[int] = None\n    number_of_hatches: Optional[int] = None\n    number_of_grabs: Optional[int] = None\n    number_of_cranes: Optional[int] = None\n    number_of_bow_chain_stoppers: Optional[int] = None\n    grain_capacity: Optional[int] = None\n    bale_capacity: Optional[int] = None\n    main_engine_kw: Optional[int] = None\n    main_engine_rpm: Optional[int] = None\n    air_draught: Optional[float] = None\n    deck_teu: Optional[int] = None\n    under_deck_teu: Optional[int] = None\n    suez_canal_net_tonnage: Optional[int] = None\n    class_renewal_date: Optional[datetime] = None\n    mewis_duct: Optional[datetime] = None\n    inert_gas_system: Optional[str] = None\n    imo_type_1: Optional[str] = None\n    imo_type_2: Optional[str] = None\n    imo_type_3: Optional[str] = None\n    stst_coating: Optional[int] = None\n    epoxy_coating: Optional[int] = None\n    zinc_coating: Optional[int] = None\n    marineline_coating: Optional[int] = None\n    crude_oil_washing: Optional[str] = None\n    beneficial_owner_id: Optional[int] = None\n    beneficial_owner: Optional[str] = None\n    parallel_body_length: Optional[float] = None\n    heating_coils_fitted: Optional[bool] = None\n    cranes_max_outreach: Optional[float] = None\n    cranes_max_lifting_capacity: Optional[float] = None\n    hold_details_as_str: Optional[str] = None\n    hatch_details_as_str: Optional[str] = None\n    grab_details_as_str: Optional[str] = None\n    crane_details_as_str: Optional[str] = None\n    bow_chain_stopper_details_as_str: Optional[str] = None\n    box_shaped_holds: Optional[bool] = None\n    neo_panama_locks: Optional[bool] = None\n    australian_hold_ladder: Optional[bool] = None\n    co2_fitted: Optional[bool] = None\n    a60_bulkhead: Optional[bool] = None\n    log_fitted: Optional[bool] = None\n    open_hatch: Optional[bool] = None\n    bwts: Optional[bool] = None\n    grabs_fitted: Optional[bool] = None\n    ghg: Optional[str] = None\n    order_book_status_id: Optional[int] = None\n    order_book_status: Optional[str] = None\n    order_date: Optional[datetime] = None\n    construction_start_date: Optional[datetime] = None\n    launch_date: Optional[datetime] = None\n    scheduled_delivery_date: Optional[datetime] = None\n    cancelled_date: Optional[datetime] = None\n    minimum_temperature: Optional[float] = None\n    maximum_pressure: Optional[float] = None\n    ammonia: Optional[bool] = None\n    vcm: Optional[bool] = None\n    ethylene: Optional[bool] = None\n    ballast_parallel_body_length: Optional[float] = None\n    empty_parallel_body_length: Optional[float] = None\n    stern_line: Optional[bool] = None\n    yard_number: Optional[str] = None\n    design_model: Optional[str] = None\n    bow_to_center_manifold: Optional[float] = None\n    water_line_to_manifold: Optional[float] = None\n    deck_to_center_manifold: Optional[float] = None\n    rail_to_center_manifold: Optional[float] = None\n    bow_chain_stoppers_fitted: Optional[bool] = None\n    sanctions_history: Optional[Tuple[VesselSanction, ...]] = None\n    propulsion_type: Optional[str] = None\n    gas_containment_type: Optional[str] = None\n    number_of_bow_thrusters: Optional[int] = None\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselClass","title":"<code>VesselClass</code>  <code>dataclass</code>","text":"<p>Vessel class characteristics.</p> <p>Detailed characteristics of each vessel class, including its defining measurement and the range that corresponds to this vessel class.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The vessel class id e.g. 81 (refers to Panamax), 86 (Aframax), 85 (Suezmax).</p> <code>vessel_type_id</code> <code>int</code> <p>Numeric ID corresponding to the different values of the VesselType field.  1-&gt; Tanker, 3-&gt; Dry, 4 -&gt; Containers, 5 -&gt;LNG(Liquified Natural gas) , 6-&gt; LPG(Liquified Petroleum Gas).</p> <code>from_size</code> <code>int</code> <p>The minimum value that corresponds to this vessel class (Deadweight/TEU/CubicSize).</p> <code>to_size</code> <code>int</code> <p>The maximum value that corresponds to this vessel class (Deadweight/TEU/CubicSize).</p> <code>name</code> <code>Optional[str]</code> <p>The vessel class e.g. Panamax, Aframax, Suezmax.</p> <code>vessel_type</code> <code>Optional[str]</code> <p>Description of the type of the vessel, based on the carried cargo. Main categories are Tankers, Dry (bulk carriers), Containers, LNG and LPG.</p> <code>defining_size</code> <code>Optional[str]</code> <p>The attribute(DeadWeight, TEU, CubicSize) that defines the size of the vesselClass.</p> <code>size</code> <code>Optional[str]</code> <p>The units of the DefiningSize attribute.  DeadWeight-&gt; kt(kilotons), TEU-&gt; TEU, CubicSize-&gt; cbm(cubic meters).</p> Source code in <code>signal_ocean/vessels/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VesselClass:\n    \"\"\"Vessel class characteristics.\n\n    Detailed characteristics of each vessel class, including its defining\n    measurement and the range that corresponds to this vessel class.\n\n    Attributes:\n        id: The vessel class id e.g. 81 (refers to Panamax), 86 (Aframax), 85\n            (Suezmax).\n        vessel_type_id: Numeric ID corresponding to the different values of the\n            VesselType field.  1-&gt; Tanker, 3-&gt; Dry, 4 -&gt; Containers, 5\n            -&gt;LNG(Liquified Natural gas) , 6-&gt; LPG(Liquified Petroleum Gas).\n        from_size: The minimum value that corresponds to this vessel class\n            (Deadweight/TEU/CubicSize).\n        to_size: The maximum value that corresponds to this vessel class\n            (Deadweight/TEU/CubicSize).\n        name: The vessel class e.g. Panamax, Aframax, Suezmax.\n        vessel_type: Description of the type of the vessel, based on the\n            carried cargo. Main categories are Tankers, Dry (bulk carriers),\n            Containers, LNG and LPG.\n        defining_size: The attribute(DeadWeight, TEU, CubicSize) that defines\n            the size of the vesselClass.\n        size: The units of the DefiningSize attribute.  DeadWeight-&gt;\n            kt(kilotons), TEU-&gt; TEU, CubicSize-&gt; cbm(cubic meters).\n    \"\"\"\n\n    id: int\n    vessel_type_id: int\n    from_size: int\n    to_size: int\n    name: Optional[str] = None\n    vessel_type: Optional[str] = None\n    defining_size: Optional[str] = None\n    size: Optional[str] = None\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselType","title":"<code>VesselType</code>  <code>dataclass</code>","text":"<p>A vessel type.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The vessel type id, e.g. 1 -&gt; Tanker, 3 -&gt; Dry, 4 -&gt; Containers, 5 -&gt; LNG (Liquified Natural gas), 6-&gt; LPG (Liquified Petroleum Gas).</p> <code>name</code> <code>str</code> <p>The vessel type name, e.g. Tanker, Dry, Containers, LNG (Liquified Natural gas), LPG (Liquified Petroleum Gas).</p> Source code in <code>signal_ocean/vessels/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VesselType:\n    \"\"\"A vessel type.\n\n    Attributes:\n        id: The vessel type id, e.g. 1 -&gt; Tanker, 3 -&gt; Dry, 4 -&gt; Containers,\n            5 -&gt; LNG (Liquified Natural gas),\n            6-&gt; LPG (Liquified Petroleum Gas).\n        name: The vessel type name, e.g. Tanker, Dry, Containers,\n            LNG (Liquified Natural gas), LPG (Liquified Petroleum Gas).\n    \"\"\"\n\n    id: int\n    name: str\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI","title":"<code>VesselsAPI</code>","text":"<p>Represents Signal's Vessels API.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>class VesselsAPI:\n    \"\"\"Represents Signal's Vessels API.\"\"\"\n\n    relative_url = \"vessels-api/v3/\"\n    default_pit = str(date.today())\n\n    rename_keys = {\"STSTCoating\": \"stst_coating\",\n                   \"BWTS\": \"bwts\",\n                   \"GHG\": \"ghg\",\n                   \"VCM\": \"vcm\",\n                   \"IMOType1\": \"imo_type_1\",\n                   \"IMOType2\": \"imo_type_2\",\n                   \"IMOType3\": \"imo_type_3\"}\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes VesselsAPI.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    def get_vessel_classes(self) -&gt; Tuple[VesselClass, ...]:\n        \"\"\"Retrieves all available vessel classes.\n\n        Returns:\n            A tuple of all available vessel classes.\n        \"\"\"\n        url = urljoin(VesselsAPI.relative_url, \"vesselClasses\")\n        return get_multiple(self.__connection, url, VesselClass)\n\n    def get_vessel_types(self) -&gt; Tuple[VesselType, ...]:\n        \"\"\"Retrieves all available vessel types.\n\n        Returns:\n            A tuple of all available vessel types.\n        \"\"\"\n        url = urljoin(VesselsAPI.relative_url, \"vesselTypes\")\n        return get_multiple(self.__connection, url, VesselType)\n\n    def get_vessel(self,\n                   imo: int,\n                   includeVesselSanctions: bool = False\n                   ) -&gt; Optional[Vessel]:\n        \"\"\"Retrieves a vessel by its IMO.\n\n        Args:\n            imo: IMO of the vessel to retrieve.\n\n        Returns:\n            A vessel or None if no vessel with the specified IMO has\n                been found.\n        \"\"\"\n        url = urljoin(VesselsAPI.relative_url,\n                      f\"vessels/{imo}\" +\n                      f\"?includeVesselSanctions={includeVesselSanctions}\"\n                      )\n        response = get_single(self.__connection,\n                              url,\n                              SingleVesselPagedResponse,\n                              rename_keys=VesselsAPI.rename_keys)\n        return response if response is None else response.data\n\n    def get_vessels(self,\n                    name: Optional[str] = None,\n                    includeVesselSanctions: bool = False\n                    ) -&gt; Tuple[Vessel, ...]:\n        \"\"\"Retrieves all available vessels.\n\n        Args:\n                name: String to filter and return only companies the name\n                        of which contains the provided string. If None, all\n                        companies are returned.\n\n        Returns:\n            A tuple of all available vessels.\n        \"\"\"\n        endpoint = (\n            (\"vessels\"\n             if name is None else\n             f\"vessels/searchByName/{name}\") +\n            f\"?includeVesselSanctions={includeVesselSanctions}\"\n        )\n        url = urljoin(VesselsAPI.relative_url, endpoint)\n\n        hasNextPage = True\n        nextPageToken: Optional[str] = \"\"\n        vessels: Tuple[Vessel, ...] = ()\n        while(hasNextPage):\n            specific_url = url + (nextPageToken\n                                  if nextPageToken == \"\"\n                                  else f\"&amp;token={nextPageToken}\")\n            response = get_single(self.__connection,\n                                  specific_url,\n                                  VesselPagedResponse,\n                                  rename_keys=VesselsAPI.rename_keys)\n            vessels = vessels + (response.data if response else ())\n            nextPageToken = response.next_page_token if response else None\n            hasNextPage = nextPageToken is not None\n\n        return vessels\n\n    def get_vessels_by_vessel_class(\n        self, vesselClass: int,  includeVesselSanctions: bool = False\n    ) -&gt; Optional[Tuple[Vessel, ...]]:\n        \"\"\"Retrieves all vessels of a specific vessel class.\n\n        Args:\n                vesselClass: Vessel Class of the vessels to retrieve.\n\n        Returns:\n            A tuple of all available vessels.\n        \"\"\"\n        endpoint = f\"vessels?vesselClass={vesselClass}\"\n        endpoint += f\"&amp;includeVesselSanctions={includeVesselSanctions}\"\n        url = urljoin(VesselsAPI.relative_url, endpoint)\n        vessels: Tuple[Vessel, ...] = ()\n        hasNextPage = True\n        nextPageToken: Optional[str] = \"\"\n        while(hasNextPage):\n            specific_url = url + (nextPageToken\n                                  if nextPageToken == \"\"\n                                  else f\"&amp;token={nextPageToken}\")\n            response = get_single(self.__connection,\n                                  specific_url,\n                                  VesselPagedResponse,\n                                  rename_keys=VesselsAPI.rename_keys)\n            vessels = vessels + (response.data if response else ())\n            nextPageToken = response.next_page_token if response else None\n            hasNextPage = nextPageToken is not None\n\n        return vessels if len(vessels) &gt; 0 else None\n\n    def get_vessels_name_history(\n            self, imo: Optional[int] = None\n    ) -&gt; Tuple[VesselFieldResponse, ...]:\n        \"\"\"Retrieves all vessel names changes.\n\n        Args:\n                imo: IMO of the vessel to retrieve.\n\n        Returns:\n            A tuple of all vessel names changes.\n        \"\"\"\n        return self.__get_history(FieldHistory.Name, imo)\n\n    def get_vessels_commOp_history(\n            self, imo: Optional[int] = None\n    ) -&gt; Tuple[VesselFieldResponse, ...]:\n        \"\"\"Retrieves all commOp changes.\n\n        Args:\n                imo: IMO of the vessel to retrieve.\n\n        Returns:\n            A tuple of all commOp changes.\n        \"\"\"\n        return self.__get_history(FieldHistory.CommOp, imo)\n\n    def get_vessels_flag_history(\n            self, imo: Optional[int] = None\n    ) -&gt; Tuple[VesselFieldResponse, ...]:\n        \"\"\"Retrieves all flag changes.\n\n        Args:\n                imo: IMO of the vessel to retrieve.\n\n        Returns:\n            A tuple of all flag changes.\n        \"\"\"\n        return self.__get_history(FieldHistory.Flag, imo)\n\n    def __get_history(\n            self,\n            field: FieldHistory,\n            imo: Optional[int] = None\n    ) -&gt; Tuple[VesselFieldResponse, ...]:\n        endpoint = \"vessels\"\n        if field == FieldHistory.Name:\n            if imo is None:\n                endpoint += \"/nameHistory\"\n            else:\n                endpoint += f\"/{imo}/history/names\"\n        elif field == FieldHistory.CommOp:\n            if imo is None:\n                endpoint += \"/commOpHistory\"\n            else:\n                endpoint += f\"/{imo}/history/commOps\"\n        elif field == FieldHistory.Flag:\n            if imo is None:\n                endpoint += \"/flagHistory\"\n            else:\n                endpoint += f\"/{imo}/history/flags\"\n\n        url = urljoin(VesselsAPI.relative_url, endpoint)\n\n        if imo is not None:\n            response = get_single(self.__connection,\n                                  url,\n                                  VesselHistoryPerIMOPagedResponse)\n            fieldResponse = VesselFieldResponse(imo=imo,\n                                                history=response.data\n                                                if response\n                                                else ())\n            historyResponse: Tuple[VesselFieldResponse, ...] = (\n                fieldResponse, )\n        else:\n            next_page_token: Optional[str] = \"\"\n            hasNextPage = True\n            historyResponse = ()\n            while(hasNextPage):\n                specific_url = url + (next_page_token\n                                      if next_page_token == \"\"\n                                      else f\"?token={next_page_token}\")\n                multipleHistoryResponse = get_single(\n                    self.__connection,\n                    specific_url,\n                    VesselHistoryPagedResponse)\n                historyResponse = historyResponse + (\n                    multipleHistoryResponse.data\n                    if multipleHistoryResponse\n                    else ())\n                if multipleHistoryResponse:\n                    next_page_token = multipleHistoryResponse.next_page_token\n                else:\n                    next_page_token = None\n                hasNextPage = next_page_token is not None\n        return historyResponse\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes VesselsAPI.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes VesselsAPI.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.get_vessel","title":"<code>get_vessel(imo, includeVesselSanctions=False)</code>","text":"<p>Retrieves a vessel by its IMO.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>int</code> <p>IMO of the vessel to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Vessel]</code> <p>A vessel or None if no vessel with the specified IMO has been found.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def get_vessel(self,\n               imo: int,\n               includeVesselSanctions: bool = False\n               ) -&gt; Optional[Vessel]:\n    \"\"\"Retrieves a vessel by its IMO.\n\n    Args:\n        imo: IMO of the vessel to retrieve.\n\n    Returns:\n        A vessel or None if no vessel with the specified IMO has\n            been found.\n    \"\"\"\n    url = urljoin(VesselsAPI.relative_url,\n                  f\"vessels/{imo}\" +\n                  f\"?includeVesselSanctions={includeVesselSanctions}\"\n                  )\n    response = get_single(self.__connection,\n                          url,\n                          SingleVesselPagedResponse,\n                          rename_keys=VesselsAPI.rename_keys)\n    return response if response is None else response.data\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.get_vessel_classes","title":"<code>get_vessel_classes()</code>","text":"<p>Retrieves all available vessel classes.</p> <p>Returns:</p> Type Description <code>Tuple[VesselClass, ...]</code> <p>A tuple of all available vessel classes.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def get_vessel_classes(self) -&gt; Tuple[VesselClass, ...]:\n    \"\"\"Retrieves all available vessel classes.\n\n    Returns:\n        A tuple of all available vessel classes.\n    \"\"\"\n    url = urljoin(VesselsAPI.relative_url, \"vesselClasses\")\n    return get_multiple(self.__connection, url, VesselClass)\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.get_vessel_types","title":"<code>get_vessel_types()</code>","text":"<p>Retrieves all available vessel types.</p> <p>Returns:</p> Type Description <code>Tuple[VesselType, ...]</code> <p>A tuple of all available vessel types.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def get_vessel_types(self) -&gt; Tuple[VesselType, ...]:\n    \"\"\"Retrieves all available vessel types.\n\n    Returns:\n        A tuple of all available vessel types.\n    \"\"\"\n    url = urljoin(VesselsAPI.relative_url, \"vesselTypes\")\n    return get_multiple(self.__connection, url, VesselType)\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.get_vessels","title":"<code>get_vessels(name=None, includeVesselSanctions=False)</code>","text":"<p>Retrieves all available vessels.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>String to filter and return only companies the name of which contains the provided string. If None, all companies are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Vessel, ...]</code> <p>A tuple of all available vessels.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def get_vessels(self,\n                name: Optional[str] = None,\n                includeVesselSanctions: bool = False\n                ) -&gt; Tuple[Vessel, ...]:\n    \"\"\"Retrieves all available vessels.\n\n    Args:\n            name: String to filter and return only companies the name\n                    of which contains the provided string. If None, all\n                    companies are returned.\n\n    Returns:\n        A tuple of all available vessels.\n    \"\"\"\n    endpoint = (\n        (\"vessels\"\n         if name is None else\n         f\"vessels/searchByName/{name}\") +\n        f\"?includeVesselSanctions={includeVesselSanctions}\"\n    )\n    url = urljoin(VesselsAPI.relative_url, endpoint)\n\n    hasNextPage = True\n    nextPageToken: Optional[str] = \"\"\n    vessels: Tuple[Vessel, ...] = ()\n    while(hasNextPage):\n        specific_url = url + (nextPageToken\n                              if nextPageToken == \"\"\n                              else f\"&amp;token={nextPageToken}\")\n        response = get_single(self.__connection,\n                              specific_url,\n                              VesselPagedResponse,\n                              rename_keys=VesselsAPI.rename_keys)\n        vessels = vessels + (response.data if response else ())\n        nextPageToken = response.next_page_token if response else None\n        hasNextPage = nextPageToken is not None\n\n    return vessels\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.get_vessels_by_vessel_class","title":"<code>get_vessels_by_vessel_class(vesselClass, includeVesselSanctions=False)</code>","text":"<p>Retrieves all vessels of a specific vessel class.</p> <p>Parameters:</p> Name Type Description Default <code>vesselClass</code> <code>int</code> <p>Vessel Class of the vessels to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Tuple[Vessel, ...]]</code> <p>A tuple of all available vessels.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def get_vessels_by_vessel_class(\n    self, vesselClass: int,  includeVesselSanctions: bool = False\n) -&gt; Optional[Tuple[Vessel, ...]]:\n    \"\"\"Retrieves all vessels of a specific vessel class.\n\n    Args:\n            vesselClass: Vessel Class of the vessels to retrieve.\n\n    Returns:\n        A tuple of all available vessels.\n    \"\"\"\n    endpoint = f\"vessels?vesselClass={vesselClass}\"\n    endpoint += f\"&amp;includeVesselSanctions={includeVesselSanctions}\"\n    url = urljoin(VesselsAPI.relative_url, endpoint)\n    vessels: Tuple[Vessel, ...] = ()\n    hasNextPage = True\n    nextPageToken: Optional[str] = \"\"\n    while(hasNextPage):\n        specific_url = url + (nextPageToken\n                              if nextPageToken == \"\"\n                              else f\"&amp;token={nextPageToken}\")\n        response = get_single(self.__connection,\n                              specific_url,\n                              VesselPagedResponse,\n                              rename_keys=VesselsAPI.rename_keys)\n        vessels = vessels + (response.data if response else ())\n        nextPageToken = response.next_page_token if response else None\n        hasNextPage = nextPageToken is not None\n\n    return vessels if len(vessels) &gt; 0 else None\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.get_vessels_commOp_history","title":"<code>get_vessels_commOp_history(imo=None)</code>","text":"<p>Retrieves all commOp changes.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>IMO of the vessel to retrieve.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VesselFieldResponse, ...]</code> <p>A tuple of all commOp changes.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def get_vessels_commOp_history(\n        self, imo: Optional[int] = None\n) -&gt; Tuple[VesselFieldResponse, ...]:\n    \"\"\"Retrieves all commOp changes.\n\n    Args:\n            imo: IMO of the vessel to retrieve.\n\n    Returns:\n        A tuple of all commOp changes.\n    \"\"\"\n    return self.__get_history(FieldHistory.CommOp, imo)\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.get_vessels_flag_history","title":"<code>get_vessels_flag_history(imo=None)</code>","text":"<p>Retrieves all flag changes.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>IMO of the vessel to retrieve.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VesselFieldResponse, ...]</code> <p>A tuple of all flag changes.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def get_vessels_flag_history(\n        self, imo: Optional[int] = None\n) -&gt; Tuple[VesselFieldResponse, ...]:\n    \"\"\"Retrieves all flag changes.\n\n    Args:\n            imo: IMO of the vessel to retrieve.\n\n    Returns:\n        A tuple of all flag changes.\n    \"\"\"\n    return self.__get_history(FieldHistory.Flag, imo)\n</code></pre>"},{"location":"vessels/#signal_ocean.vessels.VesselsAPI.get_vessels_name_history","title":"<code>get_vessels_name_history(imo=None)</code>","text":"<p>Retrieves all vessel names changes.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>IMO of the vessel to retrieve.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VesselFieldResponse, ...]</code> <p>A tuple of all vessel names changes.</p> Source code in <code>signal_ocean/vessels/vessels_api.py</code> <pre><code>def get_vessels_name_history(\n        self, imo: Optional[int] = None\n) -&gt; Tuple[VesselFieldResponse, ...]:\n    \"\"\"Retrieves all vessel names changes.\n\n    Args:\n            imo: IMO of the vessel to retrieve.\n\n    Returns:\n        A tuple of all vessel names changes.\n    \"\"\"\n    return self.__get_history(FieldHistory.Name, imo)\n</code></pre>"},{"location":"voyages/","title":"Package Documentation","text":"<p>Voyages API Package.</p> <p>Classes:</p> Name Description <code>VoyagesAPI</code> <p>Represents Signal's Voyages API.</p> <code>Voyage</code> <p>Represents a Voyage of a vessel.</p> <code>VoyageEvent</code> <p>Represents an Event associated with a Voyage.</p> <code>VoyageEventDetail</code> <p>Represents details about a VoyageEvent.</p> <code>VoyageGeo</code> <p>Represents a geo asset object associated with a voyage.</p> <code>VoyagesFlat</code> <p>Voyages with additional information in flat format.</p> <code>VoyagesIncremental</code> <p>Incremental voyages, including token for next request.</p> <code>VoyagesCondensed</code> <p>Voyages with additional information in condensed format.</p> <code>Vessel</code> <p>Vessel name and IMO</p> <code>VesselFilter</code> <p>Vessel Filter object</p> <code>VesselClass</code> <p>Vessel class</p> <code>VesselClassFilter</code> <p>Vessel class Filter object</p> <code>VesselType</code> <p>Vessel type object</p> <code>VesselTypeFilter</code> <p>Vessel type Filter object</p>"},{"location":"voyages/#signal_ocean.voyages.Vessel","title":"<code>Vessel</code>  <code>dataclass</code>","text":"<p>Vessels.</p> <p>Attributes:</p> Name Type Description <code>imo</code> <code>int</code> <p>The vessel imo.</p> <code>vessel_name</code> <code>str</code> <p>The vessel name.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass Vessel:\n    \"\"\"Vessels.\n\n    Attributes:\n        imo: The vessel imo.\n        vessel_name: The vessel name.\n    \"\"\"\n\n    imo: int\n    vessel_name: str\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VesselClass","title":"<code>VesselClass</code>  <code>dataclass</code>","text":"<p>A group of vessels of similar characteristics, i.e. Aframax, Panamax, etc.</p> <p>Attributes:</p> Name Type Description <code>vessel_class_id</code> <code>int</code> <p>The vessel class ID.</p> <code>vessel_class_name</code> <code>str</code> <p>The vessel class name.</p> <code>vessel_type_id</code> <code>int</code> <p>The vessel type ID.</p> <code>vessel_type</code> <code>str</code> <p>The vessel type</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass VesselClass:\n    \"\"\"A group of vessels of similar characteristics, i.e. Aframax, Panamax, etc.\n\n    Attributes:\n        vessel_class_id: The vessel class ID.\n        vessel_class_name: The vessel class name.\n        vessel_type_id: The vessel type ID.\n        vessel_type: The vessel type\n    \"\"\"\n\n    vessel_class_id: int\n    vessel_class_name: str\n    vessel_type_id: int\n    vessel_type: str\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VesselClassFilter","title":"<code>VesselClassFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific vessel classes.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find vessel classes by name. When specified, vessel classes whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(eq=False)\nclass VesselClassFilter:\n    \"\"\"A filter used to find specific vessel classes.\n\n    Attributes:\n        name_like: Used to find vessel classes by name. When specified, vessel\n            classes whose names partially match (contain) the attribute's value\n            will be returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(\n        self, vessel_classes: Iterable[VesselClass]\n    ) -&gt; Iterable[VesselClass]:\n        return filter(self.__does_class_match, vessel_classes)\n\n    def __does_class_match(self, vessel_class: VesselClass) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, vessel_class.vessel_class_name\n        )\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VesselFilter","title":"<code>VesselFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific vessels.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find vessel by name. When specified, vessel name whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(eq=False)\nclass VesselFilter:\n    \"\"\"A filter used to find specific vessels.\n\n    Attributes:\n        name_like: Used to find vessel by name. When specified, vessel\n            name whose names partially match (contain) the attribute's value\n            will be returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(self, vessels: Iterable[Vessel]) -&gt; Iterable[Vessel]:\n        return filter(self.__does_class_match, vessels)\n\n    def __does_class_match(self, vessel: Vessel) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, vessel.vessel_name\n        )\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VesselType","title":"<code>VesselType</code>  <code>dataclass</code>","text":"<p>Type of vessel used for transport.</p> <p>Attributes:</p> Name Type Description <code>vessel_type_id</code> <code>int</code> <p>The vessel type ID.</p> <code>vessel_type</code> <code>str</code> <p>The vessel type name.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(frozen=True, eq=False)\nclass VesselType:\n    \"\"\"Type of vessel used for transport.\n\n    Attributes:\n        vessel_type_id: The vessel type ID.\n        vessel_type: The vessel type name.\n    \"\"\"\n\n    vessel_type_id: int\n    vessel_type: str\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VesselTypeFilter","title":"<code>VesselTypeFilter</code>  <code>dataclass</code>","text":"<p>A filter used to find specific vessel types.</p> <p>Attributes:</p> Name Type Description <code>name_like</code> <code>Optional[str]</code> <p>Used to find vessel types by name. When specified, vessel types whose names partially match (contain) the attribute's value will be returned. Matching is case-insensitive.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(eq=False)\nclass VesselTypeFilter:\n    \"\"\"A filter used to find specific vessel types.\n\n    Attributes:\n        name_like: Used to find vessel types by name. When specified, vessel\n            types whose names partially match (contain) the attribute's value\n            will be returned. Matching is case-insensitive.\n    \"\"\"\n\n    name_like: Optional[str] = None\n\n    def _apply(\n        self, vessel_types: Iterable[VesselType]\n    ) -&gt; Iterable[VesselType]:\n        return filter(self.__does_type_match, vessel_types)\n\n    def __does_type_match(self, vessel_type: VesselType) -&gt; bool:\n        return not self.name_like or contains_caseless(\n            self.name_like, vessel_type.vessel_type\n        )\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.Voyage","title":"<code>Voyage</code>  <code>dataclass</code>","text":"<p>Contains information about a single voyage of a vessel.</p> <p>Attributes:</p> Name Type Description <code>imo</code> <code>Optional[int]</code> <p>A seven-digits number that uniquely identifies a ship and does not change when the ship's owner, country of registry or name of the vessel changes.</p> <code>voyage_number</code> <code>Optional[int]</code> <p>Numeric, a counter of the voyages for the same IMO.</p> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the different values of the VesselType field.  1-&gt; Tanker, 3-&gt; Dry, 4 -&gt; Containers, 5 -&gt;LNG (Liquified Natural gas) , 6-&gt; LPG (Liquified Petroleum Gas).</p> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the different vessel classes of a certain vessel type.</p> <code>vessel_status_id</code> <code>Optional[int]</code> <p>Numeric ID that takes the following values  1 -&gt; Voyage, 2 -&gt; Breaking, 3 -&gt; Domestic Trade, 4-&gt; FPSO, 5-&gt; FPSO Conversion, 6-&gt; Inactive, 7-&gt; Storage Vessel, 9-&gt; Conversion.</p> <code>deadweight</code> <code>Optional[int]</code> <p>Numeric, measured in tonnes [t], often shortened as DWT, denotes the total carrying capacity of the vessel including cargo, ballast water, stores, provisions, crew and so on.</p> <code>commercial_operator_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the maritime company that manages the vessel commercially.</p> <code>deleted</code> <code>Optional[bool]</code> <p>Boolean. This will be true if the voyage has been deleted from our database.</p> <code>events</code> <code>Optional[Tuple[VoyageEvent, ...]]</code> <p>The events that took place during the voyage.</p> <code>id</code> <code>Optional[str]</code> <p>String. Uniquely identifies the voyage.</p> <code>horizon_id</code> <code>Optional[int]</code> <p>Numeric ID that takes the following values Unknown (0), Historic (1), Historical (1), Current (2), Future (3)</p> <code>horizon</code> <code>Optional[str]</code> <p>String. It can take \"Historic\", \"Current\" or \"Future\" values, depending on whether the voyage event is in the past (StartDate and EndDate both in the past), is current (StartDate in the past and EndDate in the future) or future (both StartDate and EndDate in the future). Note: the notions of \"past\", \"current\" and \"future\" are not derived by the current date, but by the comparison between the voyage dates and the latest received AIS for that specific vessel.</p> <code>latest_received_ais</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The most recent AIS update for the vessel. It is used to define the horizon of a voyage and its events.</p> <code>vessel_name</code> <code>Optional[str]</code> <p>The vessel name corresponding to that IMO at the time of that voyage.</p> <code>pit_vessel_name</code> <code>Optional[str]</code> <p>String, The vessel name corresponding to that IMO at the time of that voyage (if different than VesselName)</p> <code>vessel_type</code> <code>Optional[str]</code> <p>Description of the type of the vessel, based on the carried cargo. Main categories are Tankers, Dry (bulk carriers), Containers, LNG and LPG.</p> <code>vessel_class</code> <code>Optional[str]</code> <p>Name of the vessel class the vessel belongs to. Assignment of a vessel to a certain VesselClass is based on the VesselType and the value of its Deadweight (if Tanker or Dry), its LiquidCap (if LNG/LPG) or its TEU (if Containers).   For example, an Aframax is a Tanker vessel with Deadweight within the range 82kt - 125kt, while a Capesize is a Dry vessel with Deadweight within the range 120kt-220kt. LR2 are defined as Aframax, as only Deadweight is used to define vessel classes.</p> <code>trade</code> <code>Optional[str]</code> <p>Additional attribute used to specify a Tanker vessel with finer granularity. It is derived by the last cargo carried by the vessel at the time of query.  For example, an LR2 with fueloil as last cargo has VesselClass=Aframax and Trade=Product.</p> <code>trade_id</code> <code>Optional[int]</code> <p>For Tankers only. Numeric ID that takes the following values 1 -&gt; Crude, 2 -&gt; Product, 3 -&gt; Chemical.</p> <code>vessel_status</code> <code>Optional[str]</code> <p>String identifying the status of a vessel. The active and most common status is the \"Voyage\" one, the one in which the vessel continuously sails and performs operations. The other statuses are used for specific purposes different than voyage.</p> <code>deadweight</code> <code>Optional[int]</code> <p>Numeric, measured in tonnes [t], often shortened as DWT, denotes the total carrying capacity of the vessel including cargo, ballast water, stores, provisions, crew and so on.</p> <code>year_built</code> <code>Optional[int]</code> <p>Numeric, year format, the year the vessel was built.</p> <code>commercial_operator</code> <code>Optional[str]</code> <p>Name of the maritime company that manages the vessel commercially.</p> <code>start_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The beginning of the specific voyage. The start of a voyage is set as the end of the previous voyage (if existing) or the first received AIS (for a new building). Voyages are consecutive and with no breaks in between, therefore a vessel is always in a voyage.</p> <code>first_load_arrival_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The time of arrival for the first load in the voyage. Indicates the transition from Ballast to Laden.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The end of the specific voyage. The end of a voyage is set as the sailing date (or completion date) from the port where the vessel discharged for the last time.</p> <code>charterer_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the company reported as charterer in at least one of the fixtures.</p> <code>charterer</code> <code>Optional[str]</code> <p>String, name of the company reported as charterer in at least one of the fixtures.</p> <code>rate</code> <code>Optional[float]</code> <p>Numeric, indicates the rate reported in at least one of the fixtures. If lump sum, the rate is reported in USD.</p> <code>rate_type</code> <code>Optional[str]</code> <p>String, indicates the type of rate reported in at least one of the fixtures. Main types are \"WS\" for World Scale or \"LS\" for Lump Sum.</p> <code>ballast_bonus</code> <code>Optional[float]</code> <p>.</p> <code>ballast_bonus_type</code> <code>Optional[str]</code> <p>.</p> <code>cargo_type_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the type of cargo the vessel carries in this voyage. For example 19-&gt; Crude Oil, 16-&gt;Fueloil, 9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil.</p> <code>cargo_type</code> <code>Optional[str]</code> <p>String, it corresponds to the estimated cargo type the vessel carries according to the specific voyage, AIS information, jetty the vessel may have visited or information coming from market reports.</p> <code>cargo_type_source_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the type of CargoSubType source. 0 -&gt; None, 2 -&gt; MarketInfo, 3 -&gt; Lineup, 8 -&gt; EstimatedLow, 9 -&gt; EstimatedMedium, 10 -&gt; EstimatedHigh, 20 -&gt; PrivateInfo.</p> <code>cargo_type_source</code> <code>Optional[str]</code> <p>String, it specifies the source of CargoType and CargoGroup. If market reports are available this filed takes value \"MarketInfo\". If no market reports are available for this voyage, the cargo is estimated based on AIS and visited jetties. Market info are considered more accurate and reliable, whenever available.</p> <code>cargo_sub_type_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the type of cargo the vessel carries in the given voyage at taxonomy level 0, for example 97-&gt; <code>High Sulphur Gasoil</code>. CargoSubTypes are a subcategory of CargoTypes and the most detailed level of information for the cargo that is onboard. In the case of the CargoType <code>Crude Oil</code>, CargoSubTypes represent specific grades, like <code>Basrah Light</code>.</p> <code>cargo_sub_type</code> <code>Optional[str]</code> <p>String, corresponds to the taxonomy 0 cargo type the vessel carries in the specific voyage. It is a product of all available information, including current and historical voyage information, geofencing and market data. CargoSubTypes are a subcategory of CargoTypes and the most detailed level of information for the cargo that is onboard. In the case of the CargoType Crude Oil, CargoSubTypes represent specific grades, like Basrah Light.</p> <code>cargo_sub_type_source_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the type of CargoSubType source. 0 -&gt; None, 2 -&gt; MarketInfo, 3 -&gt; Lineup, 8 -&gt; EstimatedLow, 9 -&gt; EstimatedMedium, 10 -&gt; EstimatedHigh, 20 -&gt; PrivateInfo.</p> <code>cargo_sub_type_source</code> <code>Optional[str]</code> <p>String, it specifies the source of CargoSubType. The source will be \"\"Lineup\"\" if the selection of CargoSubType is based on Lineup info, \"\"MarketInfo\"\" if the selection of CargoSubType is based on other market data like fixtures or tonnage lists, \"\"PrivateInfo\"\" if it is based on your private info and \"\"Estimated(Low/Medium/High, providing the different confidence levels of our estimation)\"\" if it is based on our proprietary sequential and hierarchical CargoTracking model that also uses current/historical voyage data as input, plus a specific cargo layer of our geofencing data structure.</p> <code>cargo_group_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the high-level cargo the vessel carries in this voyage, therefore called cargo group. For example 130000-&gt;Dirty, 120000-&gt; Clean.</p> <code>cargo_group</code> <code>Optional[str]</code> <p>String, it corresponds to the estimated high-level cargo the vessel carries in this voyage, according to AIS information and jetties the vessel may have visited or information coming from market reports.</p> <code>cargo_group_source_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the type of CargoGroup source. None (0), Estimated (1), MarketInfo (2), Lineup (3), EstimatedLow (8), EstimatedMedium (9), EstimatedHigh (10), PrivateMarketInfo (20)</p> <code>cargo_group_source</code> <code>Optional[str]</code> <p>String, it specifies the source of CargoGroup. The source will be \"Lineup\" if the selection of CargoGroup is based on Lineup info, \"MarketInfo\" if the selection of CargoGroup is based on other market data, \"PrivateInfo\" if it is based on private info and \"Estimated(Low/Medium/High, providing the different confidence levels of our estimation)\" if it is based on our proprietary sequential and hierarchical CargoTracking model that also uses current/historical voyage data as input, plus a specific cargo layer of our geofencing data structure.</p> <code>cargo_sub_group_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the type of cargo the vessel carries in the given voyage at taxonomy level 2. For example 132000-&gt; Crude. CargoSubGroups are a subcategory of CargoGroups and a parent category of CargoTypes, so the second-highest level of information after CargoGroups.</p> <code>cargo_sub_group</code> <code>Optional[str]</code> <p>String, corresponds to the taxonomy level 2 cargo type the vessel carries in the specific voyage. It is a product of all available information, including current and historical voyage information, geofencing and market data. CargoSubGroups are a subcategory of CargoGroups and a parent category of CargoTypes, so the second-highest level of information after CargoGroups.</p> <code>cargo_sub_group_source_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the type of CargoSubGroup source 0 -&gt; None, 2 -&gt; MarketInfo, 3 -&gt; Lineup, 8 -&gt; EstimatedLow, 9 -&gt; EstimatedMedium, 10 -&gt; EstimatedHigh, 20 -&gt; PrivateInfo.</p> <code>cargo_sub_group_source</code> <code>Optional[str]</code> <p>String, it specifies the source of CargoSubGroup. The source will be \"\"Lineup\"\" if the selection of CargoSubGroup is based on Lineup info, \"\"MarketInfo\"\" if the selection of CargoSubGroup is based on other market data, \"\"PrivateInfo\"\" if it is based on private info and \"\"Estimated(Low/Medium/High, providing the different confidence levels of our estimation)\"\" if it is based on our proprietary sequential and hierarchical CargoTracking model that also uses current/historical voyage data as input, plus a specific cargo layer of our geofencing data structure.</p> <code>quantity</code> <code>Optional[float]</code> <p>Numeric, measured in kilotonnes [kt]. It is the cargo quantity reported in at least one of the market reports.</p> <code>quantity_unit_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the Quantity unit 1 -&gt; MetricTonnes, 2 -&gt; CubicMeters.</p> <code>quantity_unit</code> <code>Optional[str]</code> <p>String corresponding to the unit type of the field Quantity (MetricTonnes for Tanker, LPG and Dry, CubicMeters for LNG).</p> <code>quantity_in_barrels</code> <code>Optional[int]</code> <p>Numeric, the quantity measured in barrels, applicable for Tanker vessels.</p> <code>quantity_source_id</code> <code>Optional[int]</code> <p>\"Numeric ID corresponding to the type of Quantity source 0 -&gt; None, 1 -&gt; Estimated, 2 -&gt; MarketInfo, 3 -&gt; Lineup, 20 -&gt; PrivateInfo.</p> <code>quantity_source</code> <code>Optional[str]</code> <p>String, it specifies the source of Quantity. If market     reports are available this field takes value \"MarketInfo\".     If no market reports are available     for this voyage, the quantity is estimated.     Market info is considered more accurate and reliable,     whenever available.</p> <code>cubic_source</code> <code>Optional[str]</code> <p>Numeric, measured in cubic meters [cbm] denotes the carrying capacity of Gas vessels (LNG, LPG). For tankers it is the volume of cargo tanks.</p> <code>laycan_from</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD indicates the earliest reported Laycan From (latest day of cancellation) across all fixtures.</p> <code>laycan_to</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD indicates the latest reported Laycan To (latest day of cancellation) across all fixtures.</p> <code>vessel_sanctioned_by</code> <code>Optional[str]</code> <p>String, includes overlapping sanctions from different organizations that were active during the voyage period. The organizations that sanctioned the vessel are listed as comma- separated values (e.g., \"OFAC, OFSI, UN\").</p> <code>fixture_status_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the different values of the FixtureStatus field.   0-&gt; OnSubs, 1-&gt; FullyFixed, 2 -&gt; Failed, 3 -&gt; Cancelled , 4-&gt; Available, 5-&gt; PossFixed, -2 -&gt; NotSet, -1 -&gt; Unknown.</p> <code>fixture_status</code> <code>Optional[str]</code> <p>String denoting the commercial status of a fixture if explicitly mentioned, like ffxd for fully fixed or subs for on subs.</p> <code>fixture_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. Details the date of the first fixture reporting the specific voyage.</p> <code>fixture_is_coa</code> <code>Optional[bool]</code> <p>Boolean. Value is true if \"COA\" (Contract of Affreightment) is explicitly reported in at least one of the fixtures relative to the specific voyage.</p> <code>fixture_is_hold</code> <code>Optional[bool]</code> <p>Boolean. Value is true if \"Hold\" is explicitly reported in at least one of the fixtures relative to the specific voyage.</p> <code>is_implied_by_ais</code> <code>Optional[bool]</code> <p>Boolean. This will be true if the voyage is implied from AIS.</p> <code>has_manual_entries</code> <code>Optional[bool]</code> <p>Boolean. True if the fused matched fixture on a voyage contains at least one (partial or full) fixture input by a user. It indicates that there is additional information input by a user in addition to what received through market reports only.</p> <code>ballast_distance</code> <code>Optional[float]</code> <p>Numeric. Travelled distance in nautical miles between the last discharge port of the previous voyage and the first load port of the current voyage. It is computed based on AIS data. It includes the whole period between the two port calls and non operational stops as well. Accuracy depends on AIS coverage.</p> <code>predicted_ballast_distance</code> <code>Optional[float]</code> <p>Numeric, Computed distance of the ballast leg based on our distance model, in nautical miles. For current voyage, when vessel is ballast, it is the remaining distance between the vessel position and the first load port. For historical legs PredictedBallastDistance is empty.</p> <code>laden_distance</code> <code>Optional[float]</code> <p>Numeric. Travelled distance in nautical miles between the first load port and the last discharge port of the same voyage. It is computed based on AIS data. Accuracy depends on AIS coverage.</p> <code>predicted_laden_distance</code> <code>Optional[float]</code> <p>Numeric, Computed distance of the laden leg based on our distance model, in nautical miles. For current voyage, when vessel is laden, it is the remaining distance between the vessel position and the last discharge port. For historical legs PredictedLadenDistance is empty.</p> <code>suez_crossing</code> <code>Optional[str]</code> <p>String, indicates whether the vessel crossed the Suez canal during the voyage. This field can take the following values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\", \"LadenPredicted\" or any combination of those. Each of this value indicates the leg in which the vessel crossed the Suez canal. This was done in order to distinguish the historical and the current/predicted passages.</p> <code>panama_crossing</code> <code>Optional[str]</code> <p>String, indicates whether the vessel crossed the Panama canal during the voyage. This field can take the following values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\", \"LadenPredicted\" or any combination of those. Each of this value indicates the leg in which the vessel crossed the Panama canal. This was done in order to distinguish the historical and the current/predicted passages.</p> <code>canakkale_crossing</code> <code>Optional[str]</code> <p>String, indicates whether the vessel crossed the Canakkale strait during the voyage. This field can take the following values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\", \"LadenPredicted\" or any combination of those. Each of this value indicates the leg in which the vessel crossed the Canakkale strait. This was done in order to distinguish the historical and the current/predicted passages.</p> <code>bosporus_crossing</code> <code>Optional[str]</code> <p>String, indicates whether the vessel crossed the Bosporus strait during the voyage. This field can take the following values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\", \"LadenPredicted\" or any combination of those. Each of this value indicates the leg in which the vessel crossed the Bosporus strait. This was done in order to distinguish the historical and the current/predicted passages.</p> <code>torres_strait_crossing</code> <code>Optional[str]</code> <p>Indicates whether the vessel crossed the Torres strait during the voyage. This field can take the following values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\", \"LadenPredicted\" or any combination of those. Each of this value indicates the leg in which the vessel crossed the Torres strait. This was done in order to distinguish the historical and the current/predicted passages.</p> <code>magellan_strait_crossing</code> <code>Optional[str]</code> <p>Indicates whether the vessel crossed the Magellan strait during the voyage. This field can take the following values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\", \"LadenPredicted\" or any combination of those. Each of this value indicates the leg in which the vessel crossed the Magellan strait. This was done in order to distinguish the historical and the current/predicted passages.</p> <code>great_belt_crossing</code> <code>Optional[str]</code> <p>Indicates whether the vessel crossed the Great Belt strait during the voyage. This field can take the following values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\", \"LadenPredicted\" or any combination of those. Each of this value indicates the leg in which the vessel crossed the Great Belt strait. This was done in order to distinguish the historical and the current/predicted passages.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Voyage:\n    \"\"\"Contains information about a single voyage of a vessel.\n\n    Attributes:\n        imo: A seven-digits number that uniquely identifies a ship and does not\n            change when the ship's owner, country of registry or name of the\n            vessel changes.\n        voyage_number: Numeric, a counter of the voyages for the same IMO.\n        vessel_type_id: Numeric ID corresponding to the different values of the\n            VesselType field.  1-&gt; Tanker, 3-&gt; Dry, 4 -&gt; Containers, 5 -&gt;LNG\n            (Liquified Natural gas) , 6-&gt; LPG (Liquified Petroleum Gas).\n        vessel_class_id: Numeric ID corresponding to the different vessel\n            classes of a certain vessel type.\n        vessel_status_id: Numeric ID that takes the following values  1 -&gt;\n            Voyage, 2 -&gt; Breaking, 3 -&gt; Domestic Trade, 4-&gt; FPSO, 5-&gt; FPSO\n            Conversion, 6-&gt; Inactive, 7-&gt; Storage Vessel, 9-&gt; Conversion.\n        deadweight: Numeric, measured in tonnes [t], often shortened as DWT,\n            denotes the total carrying capacity of the vessel including cargo,\n            ballast water, stores, provisions, crew and so on.\n        commercial_operator_id: Numeric ID corresponding to the maritime\n            company that manages the vessel commercially.\n        deleted: Boolean. This will be true if the voyage has been deleted from\n            our database.\n        events: The events that took place during the voyage.\n        id: String. Uniquely identifies the voyage.\n        horizon_id: Numeric ID that takes the following values Unknown (0),\n            Historic (1), Historical (1), Current (2), Future (3)\n        horizon: String. It can take \"Historic\", \"Current\" or \"Future\" values,\n            depending on whether the voyage event is in the past (StartDate and\n            EndDate both in the past), is current (StartDate in the past and\n            EndDate in the future) or future (both StartDate and EndDate in the\n            future). Note: the notions of \"past\", \"current\" and \"future\" are\n            not derived by the current date, but by the comparison between the\n            voyage dates and the latest received AIS for that specific vessel.\n        latest_received_ais: Date, format YYYY-MM-DD HH:MM:SS. The most recent\n            AIS update for the vessel. It is used to define the horizon of a\n            voyage and its events.\n        vessel_name: The vessel name corresponding to that IMO at the time of\n            that voyage.\n        pit_vessel_name: String, The vessel name corresponding to that IMO at\n            the time of that voyage (if different than VesselName)\n        vessel_type: Description of the type of the vessel, based on the\n            carried cargo. Main categories are Tankers, Dry (bulk carriers),\n            Containers, LNG and LPG.\n        vessel_class: Name of the vessel class the vessel belongs to.\n            Assignment of a vessel to a certain VesselClass is based on the\n            VesselType and the value of its Deadweight (if Tanker or Dry), its\n            LiquidCap (if LNG/LPG) or its TEU (if Containers).   For example,\n            an Aframax is a Tanker vessel with Deadweight within the range 82kt\n            - 125kt, while a Capesize is a Dry vessel with Deadweight within\n            the range 120kt-220kt. LR2 are defined as Aframax, as only\n            Deadweight is used to define vessel classes.\n        trade: Additional attribute used to specify a Tanker vessel with finer\n            granularity. It is derived by the last cargo carried by the vessel\n            at the time of query.  For example, an LR2 with fueloil as last\n            cargo has VesselClass=Aframax and Trade=Product.\n        trade_id: For Tankers only. Numeric ID that takes the following values\n            1 -&gt; Crude, 2 -&gt; Product, 3 -&gt; Chemical.\n        vessel_status: String identifying the status of a vessel. The active\n            and most common status is the \"Voyage\" one, the one in which the\n            vessel continuously sails and performs operations. The other\n            statuses are used for specific purposes different than voyage.\n        deadweight: Numeric, measured in tonnes [t], often shortened as DWT,\n            denotes the total carrying capacity of the vessel including cargo,\n            ballast water, stores, provisions, crew and so on.\n        year_built: Numeric, year format, the year the vessel was built.\n        commercial_operator: Name of the maritime company that manages the\n            vessel commercially.\n        start_date: Date, format YYYY-MM-DD HH:MM:SS. The beginning of the\n            specific voyage. The start of a voyage is set as the end of the\n            previous voyage (if existing) or the first received AIS (for a new\n            building). Voyages are consecutive and with no breaks in between,\n            therefore a vessel is always in a voyage.\n        first_load_arrival_date: Date, format YYYY-MM-DD HH:MM:SS. The time\n            of arrival for the first load in the voyage. Indicates the\n            transition from Ballast to Laden.\n        end_date: Date, format YYYY-MM-DD HH:MM:SS. The end of the specific\n            voyage. The end of a voyage is set as the sailing date (or\n            completion date) from the port where the vessel discharged for the\n            last time.\n        charterer_id: Numeric ID corresponding to the company reported as\n            charterer in at least one of the fixtures.\n        charterer: String, name of the company reported as charterer in at\n            least one of the fixtures.\n        rate: Numeric, indicates the rate reported in at least one of the\n            fixtures. If lump sum, the rate is reported in USD.\n        rate_type: String, indicates the type of rate reported in at least one\n            of the fixtures. Main types are \"WS\" for World Scale or \"LS\" for\n            Lump Sum.\n        ballast_bonus: .\n        ballast_bonus_type: .\n        cargo_type_id: Numeric ID corresponding to the type of cargo the vessel\n            carries in this voyage. For example 19-&gt; Crude Oil, 16-&gt;Fueloil,\n            9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil.\n        cargo_type: String, it corresponds to the estimated cargo type the\n            vessel carries according to the specific voyage, AIS information,\n            jetty the vessel may have visited or information coming from market\n            reports.\n        cargo_type_source_id: Numeric ID corresponding to the type of\n            CargoSubType source. 0 -&gt; None, 2 -&gt; MarketInfo, 3 -&gt; Lineup,\n            8 -&gt; EstimatedLow, 9 -&gt; EstimatedMedium,\n            10 -&gt; EstimatedHigh, 20 -&gt; PrivateInfo.\n        cargo_type_source: String, it specifies the source of CargoType and\n            CargoGroup. If market reports are available this filed takes value\n            \"MarketInfo\". If no market reports are available for this voyage,\n            the cargo is estimated based on AIS and visited jetties. Market\n            info are considered more accurate and reliable, whenever available.\n        cargo_sub_type_id: Numeric ID corresponding to the type of cargo the\n            vessel carries in the given voyage at taxonomy level 0, for example\n            97-&gt; `High Sulphur Gasoil`. CargoSubTypes are a subcategory of\n            CargoTypes and the most detailed level of information for the cargo\n            that is onboard. In the case of the CargoType `Crude Oil`,\n            CargoSubTypes represent specific grades, like `Basrah Light`.\n        cargo_sub_type: String, corresponds to the taxonomy 0 cargo type the\n            vessel carries in the specific voyage. It is a product of all\n            available information, including current and historical voyage\n            information, geofencing and market data. CargoSubTypes are a\n            subcategory of CargoTypes and the most detailed level of\n            information for the cargo that is onboard. In the case of the\n            CargoType Crude Oil, CargoSubTypes represent specific grades,\n            like Basrah Light.\n        cargo_sub_type_source_id: Numeric ID corresponding to the type of\n            CargoSubType source. 0 -&gt; None, 2 -&gt; MarketInfo, 3 -&gt; Lineup,\n            8 -&gt; EstimatedLow, 9 -&gt; EstimatedMedium, 10 -&gt; EstimatedHigh,\n            20 -&gt; PrivateInfo.\n        cargo_sub_type_source: String, it specifies the source of\n            CargoSubType. The source will be \"\"Lineup\"\" if the selection of\n            CargoSubType is based on Lineup info, \"\"MarketInfo\"\" if the\n            selection of CargoSubType is based on other market data like\n            fixtures or tonnage lists, \"\"PrivateInfo\"\" if it is based on your\n            private info and \"\"Estimated(Low/Medium/High, providing the\n            different confidence levels of our estimation)\"\" if it is based\n            on our proprietary sequential and hierarchical CargoTracking\n            model that also uses current/historical voyage data as input,\n            plus a specific cargo layer of our geofencing data structure.\n        cargo_group_id: Numeric ID corresponding to the high-level cargo the\n            vessel carries in this voyage, therefore called cargo group. For\n            example 130000-&gt;Dirty, 120000-&gt; Clean.\n        cargo_group: String, it corresponds to the estimated high-level cargo\n            the vessel carries in this voyage, according to AIS information and\n            jetties the vessel may have visited or information coming from\n            market reports.\n        cargo_group_source_id: Numeric ID corresponding to the type of\n            CargoGroup source. None (0), Estimated (1), MarketInfo (2),\n            Lineup (3), EstimatedLow (8), EstimatedMedium (9),\n            EstimatedHigh (10), PrivateMarketInfo (20)\n        cargo_group_source: String, it specifies the source of CargoGroup.\n            The source will be \"Lineup\" if the selection of CargoGroup is based\n            on Lineup info, \"MarketInfo\" if the selection of CargoGroup is\n            based on other market data, \"PrivateInfo\" if it is based on private\n            info and \"Estimated(Low/Medium/High, providing the different\n            confidence levels of our estimation)\" if it is based on our\n            proprietary sequential and hierarchical CargoTracking model that\n            also uses current/historical voyage data as input, plus a specific\n            cargo layer of our geofencing data structure.\n        cargo_sub_group_id: Numeric ID corresponding to the type of cargo the\n            vessel carries in the given voyage at taxonomy level 2. For example\n            132000-&gt; Crude. CargoSubGroups are a subcategory of CargoGroups and\n            a parent category of CargoTypes, so the second-highest level\n            of information after CargoGroups.\n        cargo_sub_group: String, corresponds to the taxonomy level 2 cargo\n            type the vessel carries in the specific voyage. It is a product of\n            all available information, including current and historical voyage\n            information, geofencing and market data. CargoSubGroups are a\n            subcategory of CargoGroups and a parent category of CargoTypes,\n            so the second-highest level of information after CargoGroups.\n        cargo_sub_group_source_id: Numeric ID corresponding to the type of\n            CargoSubGroup source 0 -&gt; None, 2 -&gt; MarketInfo, 3 -&gt; Lineup,\n            8 -&gt; EstimatedLow, 9 -&gt; EstimatedMedium, 10 -&gt; EstimatedHigh,\n            20 -&gt; PrivateInfo.\n        cargo_sub_group_source: String, it specifies the source of\n            CargoSubGroup. The source will be \"\"Lineup\"\" if the selection\n            of CargoSubGroup is based on Lineup info, \"\"MarketInfo\"\" if the\n            selection of CargoSubGroup is based on other market data,\n            \"\"PrivateInfo\"\" if it is based on private info and\n            \"\"Estimated(Low/Medium/High, providing the different confidence\n            levels of our estimation)\"\" if it is based on our proprietary\n            sequential and hierarchical CargoTracking model that also uses\n            current/historical voyage data as input, plus a specific cargo\n            layer of our geofencing data structure.\n        quantity: Numeric, measured in kilotonnes [kt]. It is the cargo\n            quantity reported in at least one of the market reports.\n        quantity_unit_id: Numeric ID corresponding to the Quantity unit\n            1 -&gt; MetricTonnes, 2 -&gt; CubicMeters.\n        quantity_unit: String corresponding to the unit type of the field\n            Quantity (MetricTonnes for Tanker, LPG and Dry, CubicMeters\n            for LNG).\n        quantity_in_barrels: Numeric, the quantity measured in barrels,\n            applicable for Tanker vessels.\n        quantity_source_id: \"Numeric ID corresponding to the type of\n            Quantity source 0 -&gt; None, 1 -&gt; Estimated, 2 -&gt; MarketInfo,\n            3 -&gt; Lineup, 20 -&gt; PrivateInfo.\n        quantity_source: String, it specifies the source of Quantity. If market\n                reports are available this field takes value \"MarketInfo\".\n                If no market reports are available\n                for this voyage, the quantity is estimated.\n                Market info is considered more accurate and reliable,\n                whenever available.\n        cubic_source: Numeric, measured in cubic meters [cbm] denotes the\n            carrying capacity of Gas vessels (LNG, LPG). For tankers it is the\n            volume of cargo tanks.\n        laycan_from: Date, format YYYY-MM-DD indicates the earliest reported\n            Laycan From (latest day of cancellation) across all fixtures.\n        laycan_to: Date, format YYYY-MM-DD indicates the latest reported Laycan\n            To (latest day of cancellation) across all fixtures.\n        vessel_sanctioned_by: String, includes overlapping sanctions from\n            different organizations that were active during the voyage period.\n            The organizations that sanctioned the vessel are listed as comma-\n            separated values (e.g., \"OFAC, OFSI, UN\").\n        fixture_status_id: Numeric ID corresponding to the different values of\n            the FixtureStatus field.   0-&gt; OnSubs, 1-&gt; FullyFixed, 2 -&gt; Failed,\n            3 -&gt; Cancelled , 4-&gt; Available, 5-&gt; PossFixed,\n            -2 -&gt; NotSet, -1 -&gt; Unknown.\n        fixture_status: String denoting the commercial status of a fixture if\n            explicitly mentioned, like ffxd for fully fixed or subs for on\n            subs.\n        fixture_date: Date, format YYYY-MM-DD HH:MM:SS. Details the date of the\n            first fixture reporting the specific voyage.\n        fixture_is_coa: Boolean. Value is true if \"COA\" (Contract of\n            Affreightment) is explicitly reported in at least one of the\n            fixtures relative to the specific voyage.\n        fixture_is_hold: Boolean. Value is true if \"Hold\" is explicitly\n            reported in at least one of the fixtures relative to the specific\n            voyage.\n        is_implied_by_ais: Boolean. This will be true if the voyage is implied\n            from AIS.\n        has_manual_entries: Boolean. True if the fused matched fixture on a\n            voyage contains at least one (partial or full) fixture input by a\n            user. It indicates that there is additional information input by a\n            user in addition to what received through market reports only.\n        ballast_distance: Numeric. Travelled distance in nautical miles between\n            the last discharge port of the previous voyage and the first load\n            port of the current voyage. It is computed based on AIS data.\n            It includes the whole period between the two port calls and non\n            operational stops as well. Accuracy depends on AIS coverage.\n        predicted_ballast_distance: Numeric, Computed distance of the ballast\n            leg based on our distance model, in nautical miles. For current\n            voyage, when vessel is ballast, it is the remaining distance\n            between the vessel position and the first load port. For\n            historical legs PredictedBallastDistance is empty.\n        laden_distance: Numeric. Travelled distance in nautical miles between\n            the first load port and the last discharge port of the same voyage.\n            It is computed based on AIS data. Accuracy depends on AIS coverage.\n        predicted_laden_distance: Numeric, Computed distance of the laden leg\n            based on our distance model, in nautical miles. For current voyage,\n            when vessel is laden, it is the remaining distance between the\n            vessel position and the last discharge port. For historical legs\n            PredictedLadenDistance is empty.\n        suez_crossing: String, indicates whether the vessel crossed the Suez\n            canal during the voyage. This field can take the following values:\n            \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\",\n            \"LadenPredicted\" or any combination of those. Each of this value\n            indicates the leg in which the vessel crossed the Suez canal.\n            This was done in order to distinguish the historical and the\n            current/predicted passages.\n        panama_crossing: String, indicates whether the vessel crossed the\n            Panama canal during the voyage. This field can take the following\n            values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\",\n            \"LadenPredicted\" or any combination of those. Each of this value\n            indicates the leg in which the vessel crossed the Panama canal.\n            This was done in order to distinguish the historical and the\n            current/predicted passages.\n        canakkale_crossing: String, indicates whether the vessel crossed the\n            Canakkale strait during the voyage. This field can take the\n            following values: \"BallastHistorical\", \"LadenHistorical\",\n            \"BallastPredicted\", \"LadenPredicted\" or any combination of those.\n            Each of this value indicates the leg in which the vessel crossed\n            the Canakkale strait. This was done in order to distinguish the\n            historical and the current/predicted passages.\n        bosporus_crossing: String, indicates whether the vessel crossed the\n            Bosporus strait during the voyage. This field can take the\n            following values: \"BallastHistorical\", \"LadenHistorical\",\n            \"BallastPredicted\", \"LadenPredicted\" or any combination of those.\n            Each of this value indicates the leg in which the vessel crossed\n            the Bosporus strait. This was done in order to distinguish the\n            historical and the current/predicted passages.\n        torres_strait_crossing: Indicates whether the vessel crossed the Torres\n            strait during the voyage. This field can take the following values:\n            \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\",\n            \"LadenPredicted\" or any combination of those. Each of this value\n            indicates the leg in which the vessel crossed the Torres strait.\n            This was done in order to distinguish the historical and the\n            current/predicted passages.\n        magellan_strait_crossing: Indicates whether the vessel crossed the\n            Magellan strait during the voyage. This field can take the\n            following values: \"BallastHistorical\", \"LadenHistorical\",\n            \"BallastPredicted\", \"LadenPredicted\" or any combination of those.\n            Each of this value indicates the leg in which the vessel crossed\n            the Magellan strait. This was done in order to distinguish the\n            historical and the current/predicted passages.\n        great_belt_crossing: Indicates whether the vessel crossed the Great\n            Belt strait during the voyage. This field can take the following\n            values: \"BallastHistorical\", \"LadenHistorical\", \"BallastPredicted\",\n            \"LadenPredicted\" or any combination of those. Each of this value\n            indicates the leg in which the vessel crossed the Great Belt\n            strait. This was done in order to distinguish the historical and\n            the current/predicted passages.\n    \"\"\"\n\n    imo: Optional[int] = None\n    voyage_number: Optional[int] = None\n    vessel_type_id: Optional[int] = None\n    vessel_class_id: Optional[int] = None\n    vessel_status_id: Optional[int] = None\n    commercial_operator_id: Optional[int] = None\n    deleted: Optional[bool] = False\n    events: Optional[Tuple[VoyageEvent, ...]] = None\n    id: Optional[str] = None\n    horizon_id: Optional[int] = None\n    horizon: Optional[str] = None\n    latest_received_ais: Optional[datetime] = None\n    vessel_name: Optional[str] = None\n    pit_vessel_name: Optional[str] = None\n    vessel_type: Optional[str] = None\n    vessel_class: Optional[str] = None\n    trade: Optional[str] = None\n    trade_id: Optional[int] = None\n    vessel_status: Optional[str] = None\n    deadweight: Optional[int] = None\n    year_built: Optional[int] = None\n    commercial_operator: Optional[str] = None\n    start_date: Optional[datetime] = None\n    first_load_arrival_date: Optional[datetime] = None\n    end_date: Optional[datetime] = None\n    charterer_id: Optional[int] = None\n    charterer: Optional[str] = None\n    rate: Optional[float] = None\n    rate_type: Optional[str] = None\n    ballast_bonus: Optional[float] = None\n    ballast_bonus_type: Optional[str] = None\n    cargo_type_id: Optional[int] = None\n    cargo_type: Optional[str] = None\n    cargo_type_source_id: Optional[int] = None\n    cargo_type_source: Optional[str] = None\n    cargo_sub_type_id: Optional[int] = None\n    cargo_sub_type: Optional[str] = None\n    cargo_sub_type_source_id: Optional[int] = None\n    cargo_sub_type_source: Optional[str] = None\n    cargo_group_id: Optional[int] = None\n    cargo_group: Optional[str] = None\n    cargo_group_source_id: Optional[int] = None\n    cargo_group_source: Optional[str] = None\n    cargo_sub_group_id: Optional[int] = None\n    cargo_sub_group: Optional[str] = None\n    cargo_sub_group_source_id: Optional[int] = None\n    cargo_sub_group_source: Optional[str] = None\n    quantity: Optional[float] = None\n    quantity_unit_id: Optional[int] = None\n    quantity_unit: Optional[str] = None\n    quantity_in_barrels: Optional[int] = None\n    quantity_source_id: Optional[int] = None\n    quantity_source: Optional[str] = None\n    cubic_size: Optional[int] = None\n    laycan_from: Optional[datetime] = None\n    laycan_to: Optional[datetime] = None\n    vessel_sanctioned_by: Optional[str] = None\n    fixture_status_id: Optional[int] = None\n    fixture_status: Optional[str] = None\n    fixture_date: Optional[datetime] = None\n    fixture_is_coa: Optional[bool] = None\n    fixture_is_hold: Optional[bool] = None\n    is_implied_by_ais: Optional[bool] = None\n    has_manual_entries: Optional[bool] = None\n    ballast_distance: Optional[float] = None\n    predicted_ballast_distance: Optional[float] = None\n    laden_distance: Optional[float] = None\n    predicted_laden_distance: Optional[float] = None\n    suez_crossing: Optional[str] = None\n    panama_crossing: Optional[str] = None\n    canakkale_crossing: Optional[str] = None\n    bosporus_crossing: Optional[str] = None\n    torres_strait_crossing: Optional[str] = None\n    magellan_strait_crossing: Optional[str] = None\n    great_belt_crossing: Optional[str] = None\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyageCondensed","title":"<code>VoyageCondensed</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Voyage</code></p> <p>Contains information about a single voyage of a vessel.</p> <p>Attributes:</p> Name Type Description <code>starting_port_name</code> <code>Optional[str]</code> <p>String, name of the port in where the voyage started from.</p> <code>starting_port_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the port where the voyage started from. The start of a voyage is set as the end of the previous voyage (if existing) or the first received AIS (for a new building). Voyages are consecutive and with no breaks in between, therefore a vessel is always in a voyage.</p> <code>starting_port_unlocode</code> <code>Optional[str]</code> <p>String. The official code corresponding to the port where the voyage started from.</p> <code>starting_country_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the country where the voyage started from.</p> <code>starting_country_name</code> <code>Optional[str]</code> <p>String, name of the country where the voyage started from.</p> <code>starting_area_id_level0</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the level 0 area where the voyage started from. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest.</p> <code>starting_area_name_level0</code> <code>Optional[str]</code> <p>String, name of the area where the voyage started from. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest. Examples of level 0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".</p> <code>first_load_port_name</code> <code>Optional[str]</code> <p>String, name of the port where the vessel performed the first loading port call of a voyage.</p> <code>first_load_port_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the port where the vessel performed the first loading port call of a voyage.</p> <code>first_load_port_unlocode</code> <code>Optional[str]</code> <p>String. The official code corresponding to the port where the vessel performed the first loading port call of a voyage.</p> <code>first_load_arrival_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The beginning of the first loading port call, including waiting time. The arrival date of a port call is calculated based on the first AIS point within the event. If the vessel waits in an anchorage area for days, this waiting time is captured as the difference between the FirstLoadArrivalDate and the FirstLoadStartTimeOfOperation.</p> <code>first_load_start_time_of_operation</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. Timestamp indicating the beginning of the first loading operation. This is the timestamp of the first AIS point received when the vessel is within a jetty or while performing a ship-to-ship operation.</p> <code>first_load_sailing_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The end of the first loading port call. The sailing date of an event is calculated based on the last AIS point within the event. In the case of missing AIS data, the sailing date is derived based on the next reported location of the vessel after the event and the time without reported AIS information.</p> <code>first_load_country_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the country where the vessel performed the first loading port call.</p> <code>first_load_country_name</code> <code>Optional[str]</code> <p>String, name of the country where the vessel performed the first loading port call.</p> <code>first_load_area_id_level0</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the level 0 area where the vessel performed the first loading operation of the voyage. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest.</p> <code>first_load_area_name_level0</code> <code>Optional[str]</code> <p>String, name of the area where the vessel performed the first loading operation of the voyage. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest. Examples of level 0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".</p> <code>last_discharge_port_name</code> <code>Optional[str]</code> <p>String, name of the port where the vessel performed the last discharging port call of a voyage.</p> <code>last_discharge_port_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the port where the vessel performed the last discharging port call of a voyage.</p> <code>last_discharge_port_unlocode</code> <code>Optional[str]</code> <p>String. The official code corresponding to the port where the vessel performed the last discharging port call of a voyage.</p> <code>last_discharge_arrival_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The beginning of the last discharging port call, including waiting time. The arrival date of a port call is calculated based on the first AIS point within the event. If the vessel waits in an anchorage area for days, this waiting time is captured as the difference between the LastDischargeArrivalDate and the LastDischargeStartTimeOfOperation.</p> <code>last_discharge_start_time_of_operation</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. Timestamp indicating the beginning of the last discharging operation. This is the timestamp of the first AIS point received when the vessel is within a jetty or while performing a ship-to-ship operation.</p> <code>last_discharge_sailing_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. Timestamp indicating the beginning of the first loading operation. This is the timestamp of the first AIS point received when the vessel is within a jetty or while performing a ship-to-ship operation.</p> <code>last_discharge_country_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the country where the vessel performed the last discharging port call.</p> <code>last_discharge_country_name</code> <code>Optional[str]</code> <p>String, name of the country where the vessel performed the last discharging port call.</p> <code>last_discharge_area_id_level0</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the level 0 area where the vessel performed the last discharging operation of the voyage. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest.</p> <code>last_discharge_area_name_level0</code> <code>Optional[str]</code> <p>String, name of the area where the vessel performed the last discharging operation of the voyage. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest. Examples of level 0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".</p> <code>repairs_ind</code> <code>Optional[bool]</code> <p>Boolean. True if the voyage contains any port call operation performed in a dry dock or shipyard.</p> <code>storage_ind</code> <code>Optional[bool]</code> <p>Boolean. True if the vessel acted as storage in the specific voyage.</p> <code>sts_load_ind</code> <code>Optional[bool]</code> <p>Boolean. True if at least one loading operation has been performed by transferring cargo from another vessel through a ship-to-ship operation.</p> <code>sts_discharge_ind</code> <code>Optional[bool]</code> <p>Boolean. True if at least one discharging operation has been performed by transferring cargo from another vessel through a ship-to-ship operation.</p> <code>local_trade_ind</code> <code>Optional[bool]</code> <p>Boolean. True if the vessel has loaded and discharged in the same country.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VoyageCondensed(Voyage):\n    \"\"\"Contains information about a single voyage of a vessel.\n\n    Attributes:\n            starting_port_name: String, name of the port in where the voyage\n                    started from.\n            starting_port_id: Numeric ID corresponding to the port where the\n                    voyage started from. The start of a voyage is set as the\n                    end of the previous voyage (if existing) or the first\n                    received AIS (for a new building). Voyages are\n                    consecutive and with no breaks in between, therefore a\n                    vessel is always in a voyage.\n            starting_port_unlocode: String. The official code corresponding to\n                    the port where the voyage started from.\n            starting_country_id: Numeric ID corresponding to the country\n                    where the voyage started from.\n            starting_country_name: String, name of the country where the\n                    voyage started from.\n            starting_area_id_level0: Numeric ID corresponding to the level 0\n                    area where the voyage started from. Level 0 areas offer a\n                    detailed breakdown of the globe to the areas of maritime\n                    interest.\n            starting_area_name_level0: String, name of the area where the\n                    voyage started from. Level 0 areas offer a detailed\n                    breakdown of the globe to the areas of maritime interest.\n                    Examples of level 0 areas include \"Arabian Gulf\",\n                    \"US Gulf\" and \"East Mediterranean\".\n            first_load_port_name: String, name of the port where the vessel\n                    performed the first loading port call of a voyage.\n            first_load_port_id: Numeric ID corresponding to the port where\n                    the vessel performed the first loading port call of a\n                    voyage.\n            first_load_port_unlocode: String. The official code corresponding\n                    to the port where the vessel performed the first loading\n                    port call of a voyage.\n            first_load_arrival_date: Date, format YYYY-MM-DD HH:MM:SS. The\n                    beginning of the first loading port call, including\n                    waiting time. The arrival date of a port call is\n                    calculated based on the first AIS point within the\n                    event. If the vessel waits in an anchorage area for days,\n                    this waiting time is captured as the difference between\n                    the FirstLoadArrivalDate and the\n                    FirstLoadStartTimeOfOperation.\n            first_load_start_time_of_operation: Date, format\n                    YYYY-MM-DD HH:MM:SS. Timestamp indicating the beginning of\n                    the first loading operation. This is the timestamp of the\n                    first AIS point received when the vessel is within a jetty\n                    or while performing a ship-to-ship operation.\n            first_load_sailing_date: Date, format YYYY-MM-DD HH:MM:SS. The end\n                    of the first loading port call. The sailing date of an\n                    event is calculated based on the last AIS point within the\n                    event. In the case of missing AIS data, the sailing date\n                    is derived based on the next reported location of the\n                    vessel after the event and the time without reported AIS\n                    information.\n            first_load_country_id: Numeric ID corresponding to the country\n                    where the vessel performed the first loading port call.\n            first_load_country_name: String, name of the country where the\n                    vessel performed the first loading port call.\n            first_load_area_id_level0: Numeric ID corresponding to the level 0\n                    area where the vessel performed the first loading\n                    operation of the voyage. Level 0 areas offer a detailed\n                    breakdown of the globe to the areas of maritime interest.\n            first_load_area_name_level0: String, name of the area where the\n                    vessel performed the first loading operation of the\n                    voyage. Level 0 areas offer a detailed breakdown of the\n                    globe to the areas of maritime interest. Examples of level\n                    0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East\n                    Mediterranean\".\n            last_discharge_port_name: String, name of the port where the\n                    vessel performed the last discharging port call of a\n                    voyage.\n            last_discharge_port_id: Numeric ID corresponding to the port where\n                    the vessel performed the last discharging port call of a\n                    voyage.\n            last_discharge_port_unlocode: String. The official code\n                    corresponding to the port where the vessel performed the\n                    last discharging port call of a voyage.\n            last_discharge_arrival_date: Date, format YYYY-MM-DD HH:MM:SS. The\n                    beginning of the last discharging port call, including\n                    waiting time. The arrival date of a port call is\n                    calculated based on the first AIS point within the event.\n                    If the vessel waits in an anchorage area for days, this\n                    waiting time is captured as the difference between the\n                    LastDischargeArrivalDate and the\n                    LastDischargeStartTimeOfOperation.\n            last_discharge_start_time_of_operation: Date, format\n                    YYYY-MM-DD HH:MM:SS. Timestamp indicating the beginning of\n                    the last discharging operation. This is the timestamp of\n                    the first AIS point received when the vessel is within a\n                    jetty or while performing a ship-to-ship operation.\n            last_discharge_sailing_date: Date, format YYYY-MM-DD HH:MM:SS.\n                    Timestamp indicating the beginning of the first loading\n                    operation. This is the timestamp of the first AIS point\n                    received when the vessel is within a jetty or while\n                    performing a ship-to-ship operation.\n            last_discharge_country_id: Numeric ID corresponding to the country\n                    where the vessel performed the last discharging port call.\n            last_discharge_country_name: String, name of the country where the\n                    vessel performed the last discharging port call.\n            last_discharge_area_id_level0: Numeric ID corresponding to the\n                    level 0 area where the vessel performed the last\n                    discharging operation of the voyage. Level 0 areas offer\n                    a detailed breakdown of the globe to the areas of maritime\n                    interest.\n            last_discharge_area_name_level0: String, name of the area where\n                    the vessel performed the last discharging operation of the\n                    voyage. Level 0 areas offer a detailed breakdown of the\n                    globe to the areas of maritime interest. Examples of level\n                    0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East\n                    Mediterranean\".\n            repairs_ind: Boolean. True if the voyage contains any port call\n                    operation performed in a dry dock or shipyard.\n            storage_ind: Boolean. True if the vessel acted as storage in the\n                    specific voyage.\n            sts_load_ind: Boolean. True if at least one loading operation has\n                    been performed by transferring cargo from another vessel\n                    through a ship-to-ship operation.\n            sts_discharge_ind: Boolean. True if at least one discharging\n                    operation has been performed by transferring cargo from\n                    another vessel through a ship-to-ship operation.\n            local_trade_ind: Boolean. True if the vessel has loaded and\n                    discharged in the same country.\n    \"\"\"\n\n    starting_port_name: Optional[str] = None\n    starting_port_id: Optional[int] = None\n    starting_port_unlocode: Optional[str] = None\n    starting_country_id: Optional[int] = None\n    starting_country_name: Optional[str] = None\n    starting_area_id_level0: Optional[int] = None\n    starting_area_name_level0: Optional[str] = None\n    first_load_port_name: Optional[str] = None\n    first_load_port_id: Optional[int] = None\n    first_load_port_unlocode: Optional[str] = None\n    first_load_arrival_date: Optional[datetime] = None\n    first_load_start_time_of_operation: Optional[datetime] = None\n    first_load_sailing_date: Optional[datetime] = None\n    first_load_country_id: Optional[int] = None\n    first_load_country_name: Optional[str] = None\n    first_load_area_id_level0: Optional[int] = None\n    first_load_area_name_level0: Optional[str] = None\n    last_discharge_port_name: Optional[str] = None\n    last_discharge_port_id: Optional[int] = None\n    last_discharge_port_unlocode: Optional[str] = None\n    last_discharge_arrival_date: Optional[datetime] = None\n    last_discharge_start_time_of_operation: Optional[datetime] = None\n    last_discharge_sailing_date: Optional[datetime] = None\n    last_discharge_country_id: Optional[int] = None\n    last_discharge_country_name: Optional[str] = None\n    last_discharge_area_id_level0: Optional[int] = None\n    last_discharge_area_name_level0: Optional[str] = None\n    repairs_ind: Optional[bool] = None\n    storage_ind: Optional[bool] = None\n    sts_load_ind: Optional[bool] = None\n    sts_discharge_ind: Optional[bool] = None\n    local_trade_ind: Optional[bool] = None\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyageEvent","title":"<code>VoyageEvent</code>  <code>dataclass</code>","text":"<p>An event associated with a voyage of a vessel.</p> <p>Voyage events describe the start of the voyage, a stop or a port call that took place during this voyage.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>String. Uniquely identifies the event.</p> <code>port_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the port in which the event took place. A port may be associated with multiple geo assets representing different terminals and anchorages within this port.</p> <code>voyage_id</code> <code>Optional[str]</code> <p>String. Uniquely identifies the voyage that this event relates to.</p> <code>event_type_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to event type. Stop (0), PortCall (1), VoyageStart (2)</p> <code>event_type</code> <code>Optional[str]</code> <p>String. It can take values \"Stop\", \"Portcall\" or \"VoyageStart\".</p> <code>event_horizon_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to event horizon. Historical (0), Current (1), Future (2)</p> <code>event_horizon</code> <code>Optional[str]</code> <p>String. It can take \"Historical\", \"Current\" or \"Future\" values, depending on whether the event is in the past with reference point the latest AIS point of the vessel (ArrivalDate and SailingDate both in the past), is current (ArrivalDate in the past and SailingDate in the future) or future (both ArrivalDate and SailingDate in the future).</p> <code>purpose</code> <code>Optional[str]</code> <p>String. It will be \"Stop\" if EventType=\"Stop\" and \"Start\" if EventType=\"VoyageStart\". If the event is a portcall, that is an operational stop, this field specifies the type of operation, like \"Load\", \"Discharge\" or \"Dry dock\".</p> <code>event_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The timestamp of the specific event, for instantaneous events e.g. VoyageStart</p> <code>arrival_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The beginning of the specific event. The arrival date of an event is calculated based on the first AIS point within the event. In the case of missing AIS data, the arrival date is derived based on the last reported location of the vessel before the event and the time without reported AIS information. If an event is associated with multiple event details, the arrival date of the event reports the arrival date of the first event detail associated with this event.</p> <code>sailing_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The end of the specific event. The sailing date of an event is calculated based on the last AIS point within the event. In the case of missing AIS data, the sailing date is derived based on the next reported location of the vessel after the event and the time without reported AIS information. If an event is associated with multiple event details, the sailing date of the event reports the sailing date of the final event detail associated with this event.</p> <code>latitude</code> <code>Optional[float]</code> <p>Numeric, decimal value representing the latitude of the location where the event took place.</p> <code>longitude</code> <code>Optional[float]</code> <p>Numeric, decimal value representing the longitude of the location where the event took place.</p> <code>geo_asset_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the geo asset in which the event took place. Geo assets represent maritime facilities such as terminals, anchorages and lightering zones. Multiple geo assets are grouped under the same port.</p> <code>geo_asset_name</code> <code>Optional[str]</code> <p>Name of the GeoAsset in which the event took place. Geo assets represent maritime facilities such as terminals, anchorages and lightering zones. Multiple geo assets are grouped under the same port.</p> <code>port_name</code> <code>Optional[str]</code> <p>Name of the port in which the event took place. A port may be associated with multiple geo assets representing different terminals and anchorages within this port.</p> <code>port_unlocode</code> <code>Optional[str]</code> <p>String. The official code corresponding to the port in which the event took place.</p> <code>country_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the country in which the event took place.</p> <code>country</code> <code>Optional[str]</code> <p>Name of the country in which the event took place.</p> <code>area_idlevel0</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the level 0 area in which the event took place. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest. Examples of level 0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".</p> <code>area_name_level0</code> <code>Optional[str]</code> <p>Name of the area in which the event took place. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest. Examples of level 0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".</p> <code>area_idlevel1</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the area in which the event took place. Level 1 areas consist of one or multiple level 0 areas. For example, level 1 area \"Mediterranean\" groups together the level 0 areas \"West Mediterranean\", \"Central Mediterranean\" and \"East Mediterranean\".</p> <code>area_name_level1</code> <code>Optional[str]</code> <p>Name of the area in which the event took place. Level 1 areas consist of one or multiple level 0 areas. For example, level 1 area \"Mediterranean\" groups together the level 0 areas \"West Mediterranean\", \"Central Mediterranean\" and \"East Mediterranean\".</p> <code>area_idlevel2</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the area in which the event took place. Level 2 areas consist of one or multiple level 1 areas. For example, level 2 area \"Mediterranean/UK Continent\" groups together the \"Mediterranean\" and \"UK Continent\" level 1 areas.</p> <code>area_name_level2</code> <code>Optional[str]</code> <p>Name of the area in which the event took place. Level 2 areas consist of one or multiple level 1 areas. For example, level 2 area \"Mediterranean/UK Continent\" groups together the \"Mediterranean\" and \"UK Continent\" level 1 areas.</p> <code>area_idlevel3</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the area in which the event took place. Level 3 areas the highest area grouping in our taxonomy. Examples of such areas are \"Pacific America\" or \"Africa\". These group together level 2 areas. For instance, \"Pacific America\" groups together the level 2 areas \"West Coast North America\", \"West Coast Mexico\", \"West Coast Central America\" and \"West Coast South America\".</p> <code>area_name_level3</code> <code>Optional[str]</code> <p>Name of the area in which the event took place. Level 3 areas the highest area grouping in our taxonomy. Examples of such areas are \"Pacific America\" or \"Africa\". These group together level 2 areas. For instance, \"Pacific America\" groups together the level 2 areas \"West Coast North America\", \"West Coast Mexico\", \"West Coast Central America\" and \"West Coast South America\".</p> <code>low_ais_density</code> <code>Optional[bool]</code> <p>Boolean, indicating whether there is no tracked AIS data for a duration higher that the time required for an operation.</p> <code>quantity</code> <code>Optional[float]</code> <p>Numeric, measured in tonnes [t] for Tanker, LPG and Dry and in cubic meters for LNG. It is the cargo quantity reported in at least one of the market reports or estimated by Signal models.</p> <code>quantity_unit_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the Quantity unit 1 -&gt; MetricTonnes, 2 -&gt; CubicMeters.</p> <code>quantity_unit</code> <code>Optional[str]</code> <p>String corresponding to the unit type of the field Quantity (MetricTonnes for Tanker, LPG and Dry, CubicMeters for LNG).</p> <code>quantity_in_barrels</code> <code>Optional[int]</code> <p>Numeric, the quantity measured in barrels, applicable for Tanker vessels.</p> <code>event_details</code> <code>Optional[Tuple[VoyageEventDetail, ...]]</code> <p>Specific details regarding the voyage events, e.g. a ship-to-ship operation or a jetty stay.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VoyageEvent:\n    \"\"\"An event associated with a voyage of a vessel.\n\n    Voyage events describe the start of the voyage, a stop or a port call that\n    took place during this voyage.\n\n    Attributes:\n        id: String. Uniquely identifies the event.\n        port_id: Numeric ID corresponding to the port in which the event took\n            place. A port may be associated with multiple geo assets\n            representing different terminals and anchorages within this port.\n        voyage_id: String. Uniquely identifies the voyage that this event\n            relates to.\n        event_type_id: Numeric ID corresponding to event type. Stop (0),\n            PortCall (1), VoyageStart (2)\n        event_type: String. It can take values \"Stop\", \"Portcall\" or\n            \"VoyageStart\".\n        event_horizon_id: Numeric ID corresponding to event horizon.\n            Historical (0), Current (1), Future (2)\n        event_horizon: String. It can take \"Historical\", \"Current\" or \"Future\"\n            values, depending on whether the event is in the past with\n            reference point the latest AIS point of the vessel (ArrivalDate\n            and SailingDate both in the past), is current (ArrivalDate in the\n            past and SailingDate in the future) or future (both ArrivalDate\n            and SailingDate in the future).\n        purpose: String. It will be \"Stop\" if EventType=\"Stop\" and \"Start\" if\n            EventType=\"VoyageStart\". If the event is a portcall, that is an\n            operational stop, this field specifies the type of operation, like\n            \"Load\", \"Discharge\" or \"Dry dock\".\n        event_date: Date, format YYYY-MM-DD HH:MM:SS. The timestamp of the\n            specific event, for instantaneous events e.g. VoyageStart\n        arrival_date: Date, format YYYY-MM-DD HH:MM:SS. The beginning of the\n            specific event. The arrival date of an event is calculated based on\n            the first AIS point within the event. In the case of missing AIS\n            data, the arrival date is derived based on the last reported\n            location of the vessel before the event and the time without\n            reported AIS information. If an event is associated with multiple\n            event details, the arrival date of the event reports the arrival\n            date of the first event detail associated with this event.\n        sailing_date: Date, format YYYY-MM-DD HH:MM:SS. The end of the specific\n            event. The sailing date of an event is calculated based on the last\n            AIS point within the event. In the case of missing AIS data, the\n            sailing date is derived based on the next reported location of the\n            vessel after the event and the time without reported AIS\n            information. If an event is associated with multiple event details,\n            the sailing date of the event reports the sailing date of the final\n            event detail associated with this event.\n        latitude: Numeric, decimal value representing the latitude of the\n            location where the event took place.\n        longitude: Numeric, decimal value representing the longitude of the\n            location where the event took place.\n        geo_asset_id: Numeric ID corresponding to the geo asset in which the\n            event took place. Geo assets represent maritime facilities such as\n            terminals, anchorages and lightering zones. Multiple geo assets are\n            grouped under the same port.\n        geo_asset_name: Name of the GeoAsset in which the event took place. Geo\n            assets represent maritime facilities such as terminals, anchorages\n            and lightering zones. Multiple geo assets are grouped under the\n            same port.\n        port_name: Name of the port in which the event took place. A port may\n            be associated with multiple geo assets representing different\n            terminals and anchorages within this port.\n        port_unlocode: String. The official code corresponding to the port in\n            which the event took place.\n        country_id: Numeric ID corresponding to the country in which the event\n            took place.\n        country: Name of the country in which the event took place.\n        area_idlevel0: Numeric ID corresponding to the level 0 area in which\n            the event took place. Level 0 areas offer a detailed breakdown of\n            the globe to the areas of maritime interest. Examples of level 0\n            areas include \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".\n        area_name_level0: Name of the area in which the event took place. Level\n            0 areas offer a detailed breakdown of the globe to the areas of\n            maritime interest. Examples of level 0 areas include \"Arabian\n            Gulf\", \"US Gulf\" and \"East Mediterranean\".\n        area_idlevel1: Numeric ID corresponding to the area in which the event\n            took place. Level 1 areas consist of one or multiple level 0 areas.\n            For example, level 1 area \"Mediterranean\" groups together the level\n            0 areas \"West Mediterranean\", \"Central Mediterranean\" and \"East\n            Mediterranean\".\n        area_name_level1: Name of the area in which the event took place. Level\n            1 areas consist of one or multiple level 0 areas. For example,\n            level 1 area \"Mediterranean\" groups together the level 0 areas\n            \"West Mediterranean\", \"Central Mediterranean\" and \"East\n            Mediterranean\".\n        area_idlevel2: Numeric ID corresponding to the area in which the event\n            took place. Level 2 areas consist of one or multiple level 1 areas.\n            For example, level 2 area \"Mediterranean/UK Continent\" groups\n            together the \"Mediterranean\" and \"UK Continent\" level 1 areas.\n        area_name_level2: Name of the area in which the event took place. Level\n            2 areas consist of one or multiple level 1 areas. For example,\n            level 2 area \"Mediterranean/UK Continent\" groups together the\n            \"Mediterranean\" and \"UK Continent\" level 1 areas.\n        area_idlevel3: Numeric ID corresponding to the area in which the event\n            took place. Level 3 areas the highest area grouping in our\n            taxonomy. Examples of such areas are \"Pacific America\" or \"Africa\".\n            These group together level 2 areas. For instance, \"Pacific America\"\n            groups together the level 2 areas \"West Coast North America\", \"West\n            Coast Mexico\", \"West Coast Central America\" and \"West Coast South\n            America\".\n        area_name_level3: Name of the area in which the event took place. Level\n            3 areas the highest area grouping in our taxonomy. Examples of such\n            areas are \"Pacific America\" or \"Africa\". These group together level\n            2 areas. For instance, \"Pacific America\" groups together the level\n            2 areas \"West Coast North America\", \"West Coast Mexico\", \"West\n            Coast Central America\" and \"West Coast South America\".\n        low_ais_density: Boolean, indicating whether there is no tracked AIS\n            data for a duration higher that the time required for an operation.\n        quantity: Numeric, measured in tonnes [t] for Tanker, LPG and Dry and\n            in cubic meters for LNG. It is the cargo quantity reported in at\n            least one of the market reports or estimated by Signal models.\n        quantity_unit_id: Numeric ID corresponding to the Quantity unit\n            1 -&gt; MetricTonnes, 2 -&gt; CubicMeters.\n        quantity_unit: String corresponding to the unit type of the field\n            Quantity (MetricTonnes for Tanker, LPG and Dry, CubicMeters\n            for LNG).\n        quantity_in_barrels: Numeric, the quantity measured in barrels,\n            applicable for Tanker vessels.\n        event_details: Specific details regarding the voyage events, e.g. a\n            ship-to-ship operation or a jetty stay.\n    \"\"\"\n\n    id: Optional[str] = None\n    voyage_id: Optional[str] = None\n    event_type_id: Optional[int] = None\n    event_type: Optional[str] = None\n    event_horizon_id: Optional[int] = None\n    event_horizon: Optional[str] = None\n    purpose: Optional[str] = None\n    event_date: Optional[datetime] = None\n    arrival_date: Optional[datetime] = None\n    sailing_date: Optional[datetime] = None\n    latitude: Optional[float] = None\n    longitude: Optional[float] = None\n    geo_asset_id: Optional[int] = None\n    geo_asset_name: Optional[str] = None\n    port_id: Optional[int] = None\n    port_name: Optional[str] = None\n    port_unlocode: Optional[str] = None\n    country_id: Optional[int] = None\n    country: Optional[str] = None\n    area_idlevel0: Optional[int] = None\n    area_name_level0: Optional[str] = None\n    area_idlevel1: Optional[int] = None\n    area_name_level1: Optional[str] = None\n    area_idlevel2: Optional[int] = None\n    area_name_level2: Optional[str] = None\n    area_idlevel3: Optional[int] = None\n    area_name_level3: Optional[str] = None\n    low_ais_density: Optional[bool] = None\n    quantity: Optional[float] = None\n    quantity_unit_id: Optional[int] = None\n    quantity_unit: Optional[str] = None\n    quantity_in_barrels: Optional[int] = None\n    event_details: Optional[Tuple[VoyageEventDetail, ...]] = None\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyageEventDetail","title":"<code>VoyageEventDetail</code>  <code>dataclass</code>","text":"<p>Detailed information about a voyage events.</p> <p>Voyage event details provides information a such as a jetty stay or ship-to-ship operation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>String. Uniquely identifies the event detail.</p> <code>event_id</code> <code>Optional[str]</code> <p>String. Uniquely identifies the event that this event detail relates to.</p> <code>event_detail_type</code> <code>Optional[str]</code> <p>String, denotes the type of the event detail. For instance, \"StS\" indicates that the event is a ship-to-ship operation, while \"Jetty\" describes that the event took place in a jetty.</p> <code>arrival_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The beginning of the specific event. The arrival date of an event is calculated based on the first AIS point within the event. In the case of missing AIS data, the arrival date is derived based on the last reported location of the vessel before the event and the time without reported AIS information.</p> <code>sailing_date</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. The end of the specific event. The sailing date of an event is calculated based on the last AIS point within the event. In the case of missing AIS data, the sailing date is derived based on the next reported location of the vessel after the event and the time without reported AIS information.</p> <code>start_time_of_operation</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. Timestamp indicating the beginning of the operation described by the event detail. This is the timestamp of the first AIS point the vessel is tracked within a jetty or that is captured performing a ship-to- ship operation.</p> <code>end_time_of_operation</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD HH:MM:SS. Timestamp indicating the end of the operation described by the event detail. This is the timestamp of the final AIS point the vessel is tracked within a jetty or that is captured performing a ship-to-ship operation.</p> <code>sts_id</code> <code>Optional[str]</code> <p>String, A unique identifier assigned to each ship-to-ship event. Will be identical for both participating vessels.</p> <code>geo_asset_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the geo asset in which the event took place. Geo assets represent maritime facilities such as terminals, anchorages and lightering zones. Multiple geo assets are grouped under the same port.</p> <code>geo_asset_name</code> <code>Optional[str]</code> <p>Name of the GeoAsset in which the event took place. Geo assets represent maritime facilities such as terminals, anchorages and lightering zones. Multiple geo assets are grouped under the same port.</p> <code>latitude</code> <code>Optional[float]</code> <p>Numeric, decimal value representing the latitude of the location where the event took place. The location of the vessel is identified from AIS data within the duration of the event or, in the case of missing AIS data, from the location of the GeoAsset in which the event took place. If the event represents an operation in a jetty or a STS operation, the latitude reports the location of the first AIS within the jetty or STS operation.</p> <code>longitude</code> <code>Optional[float]</code> <p>Numeric, decimal value representing the longitude of the location where the event took place. The location of the vessel is identified from AIS data within the duration of the event or, in the case of missing AIS data, from the location of the GeoAsset in which the event took place. If the event represents an operation in a jetty or a STS operation, the longitude reports the location of the first AIS within the jetty or STS operation.</p> <code>other_vessel_imo</code> <code>Optional[int]</code> <p>Numeric, Containing the IMO of the second vessel in case of ship-to-ship operation.</p> <code>other_vessel_name</code> <code>Optional[str]</code> <p>String, Containing the name of the second vessel in case of ship-to-ship operation.</p> <code>floating_storage_start_date</code> <code>Optional[datetime]</code> <p>The start date of the time period the vessel is acting as a floating storage. A floating storage is a vessel that is not moving or operating while having cargo on board, often for trading reasons.</p> <code>floating_storage_duration</code> <code>Optional[int]</code> <p>The duration of the time period the vessel is acting as a floating storage. A floating storage is a vessel that is not moving or operating while having cargo on board, often for trading reasons.</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VoyageEventDetail:\n    \"\"\"Detailed information about a voyage events.\n\n    Voyage event details provides information a such as a jetty stay\n    or ship-to-ship operation.\n\n    Attributes:\n        id: String. Uniquely identifies the event detail.\n        event_id: String. Uniquely identifies the event that this event detail\n            relates to.\n        event_detail_type: String, denotes the type of the event detail. For\n            instance, \"StS\" indicates that the event is a ship-to-ship\n            operation, while \"Jetty\" describes that the event took place in a\n            jetty.\n        arrival_date: Date, format YYYY-MM-DD HH:MM:SS. The beginning of the\n            specific event. The arrival date of an event is calculated based on\n            the first AIS point within the event. In the case of missing AIS\n            data, the arrival date is derived based on the last reported\n            location of the vessel before the event and the time without\n            reported AIS information.\n        sailing_date: Date, format YYYY-MM-DD HH:MM:SS. The end of the specific\n            event. The sailing date of an event is calculated based on the last\n            AIS point within the event. In the case of missing AIS data, the\n            sailing date is derived based on the next reported location of the\n            vessel after the event and the time without reported AIS\n            information.\n        start_time_of_operation: Date, format YYYY-MM-DD HH:MM:SS. Timestamp\n            indicating the beginning of the operation described by the event\n            detail. This is the timestamp of the first AIS point the vessel is\n            tracked within a jetty or that is captured performing a ship-to-\n            ship operation.\n        end_time_of_operation: Date, format YYYY-MM-DD HH:MM:SS. Timestamp\n            indicating the end of the operation described by the event detail.\n            This is the timestamp of the final AIS point the vessel is tracked\n            within a jetty or that is captured performing a ship-to-ship\n            operation.\n        sts_id: String, A unique identifier assigned to each ship-to-ship\n            event. Will be identical for both participating vessels.\n        geo_asset_id: Numeric ID corresponding to the geo asset in which the\n            event took place. Geo assets represent maritime facilities such as\n            terminals, anchorages and lightering zones. Multiple geo assets are\n            grouped under the same port.\n        geo_asset_name: Name of the GeoAsset in which the event took place. Geo\n            assets represent maritime facilities such as terminals, anchorages\n            and lightering zones. Multiple geo assets are grouped under the\n            same port.\n        latitude: Numeric, decimal value representing the latitude of the\n            location where the event took place. The location of the vessel is\n            identified from AIS data within the duration of the event or, in\n            the case of missing AIS data, from the location of the GeoAsset in\n            which the event took place. If the event represents an operation in\n            a jetty or a STS operation, the latitude reports the location of\n            the first AIS within the jetty or STS operation.\n        longitude: Numeric, decimal value representing the longitude of the\n            location where the event took place. The location of the vessel is\n            identified from AIS data within the duration of the event or, in\n            the case of missing AIS data, from the location of the GeoAsset in\n            which the event took place. If the event represents an operation in\n            a jetty or a STS operation, the longitude reports the location of\n            the first AIS within the jetty or STS operation.\n        other_vessel_imo: Numeric, Containing the IMO of the second vessel in\n            case of ship-to-ship operation.\n        other_vessel_name: String, Containing the name of the second vessel in\n            case of ship-to-ship operation.\n        floating_storage_start_date: The start date of the time period the\n            vessel is acting as a floating storage. A floating storage is a\n            vessel that is not moving or operating while having cargo on board,\n            often for trading reasons.\n        floating_storage_duration: The duration of the time period the vessel\n            is acting as a floating storage. A floating storage is a vessel\n            that is not moving or operating while having cargo on board, often\n            for trading reasons.\n    \"\"\"\n\n    id: Optional[str] = None\n    event_id: Optional[str] = None\n    event_detail_type: Optional[str] = None\n    arrival_date: Optional[datetime] = None\n    sailing_date: Optional[datetime] = None\n    start_time_of_operation: Optional[datetime] = None\n    end_time_of_operation: Optional[datetime] = None\n    sts_id: Optional[str] = None\n    geo_asset_id: Optional[int] = None\n    geo_asset_name: Optional[str] = None\n    latitude: Optional[float] = None\n    longitude: Optional[float] = None\n    other_vessel_imo: Optional[int] = None\n    other_vessel_name: Optional[str] = None\n    floating_storage_start_date: Optional[datetime] = None\n    floating_storage_duration: Optional[int] = None\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyageGeo","title":"<code>VoyageGeo</code>  <code>dataclass</code>","text":"<p>Information about a geo asset object associated with a voyage.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[int]</code> <p>Numeric ID of the geo asset. Geo assets represent maritime facilities such as terminals, anchorages and lightering zones. Multiple geo assets are grouped under the same port.</p> <code>name</code> <code>Optional[str]</code> <p>Name of the geo asset. Geo assets represent maritime facilities such as terminals, anchorages and lightering zones. Multiple geo assets are grouped under the same port.</p> <code>port_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the port. A port may be associated with multiple geo assets representing different terminals and anchorages within this port.</p> <code>port_unlocode</code> <code>Optional[str]</code> <p>The official code corresponding to the port.</p> <code>port_name</code> <code>Optional[str]</code> <p>Name of the port. A port may be associated with multiple geo assets representing different terminals and anchorages within this port.</p> <code>country_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the country of the geo asset.</p> <code>country</code> <code>Optional[str]</code> <p>Name of the country of the geo asset.</p> <code>area_idlevel0</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the level 0 area of the geo asset. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest. Examples of level 0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".</p> <code>area_name_level0</code> <code>Optional[str]</code> <p>Name of the level 0 area of the geo asset. Level 0 areas offer a detailed breakdown of the globe to the areas of maritime interest. Examples of level 0 areas include \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".</p> <code>area_idlevel1</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the level 1 area of the geo asset. Level 1 areas consist of one or multiple level 0 areas. For example, level 1 area \"Mediterranean\" groups together the level 0 areas \"West Mediterranean\", \"Central Mediterranean\" and \"East Mediterranean\".</p> <code>area_name_level1</code> <code>Optional[str]</code> <p>Name of the level 1 area of the geo asset. Level 1 areas consist of one or multiple level 0 areas. For example, level 1 area \"Mediterranean\" groups together the level 0 areas \"West Mediterranean\", \"Central Mediterranean\" and \"East Mediterranean\".</p> <code>area_idlevel2</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the level 2 area of the geo asset. Level 2 areas consist of one or multiple level 1 areas. For example, level 2 area \"Mediterranean/UK Continent\" groups together the \"Mediterranean\" and \"UK Continent\" level 1 areas.</p> <code>area_name_level2</code> <code>Optional[str]</code> <p>Name of the level 2 area of the geo asset. Level 2 areas consist of one or multiple level 1 areas. For example, level 2 area \"Mediterranean/UK Continent\" groups together the \"Mediterranean\" and \"UK Continent\" level 1 areas.</p> <code>area_idlevel3</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the level 3 area of the geo asset. Level 3 areas the highest area grouping in our taxonomy. Examples of such areas are \"Pacific America\" or \"Africa\". These group together level 2 areas. For instance, \"Pacific America\" groups together the level 2 areas \"West Coast North America\", \"West Coast Mexico\", \"West Coast Central America\" and \"West Coast South America\".</p> <code>area_name_level3</code> <code>Optional[str]</code> <p>Name of the level 3 area of the geo asset. Level 3 areas the highest area grouping in our taxonomy. Examples of such areas are \"Pacific America\" or \"Africa\". These group together level 2 areas. For instance, \"Pacific America\" groups together the level 2 areas \"West Coast North America\", \"West Coast Mexico\", \"West Coast Central America\" and \"West Coast South America\".</p> Source code in <code>signal_ocean/voyages/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VoyageGeo:\n    \"\"\"Information about a geo asset object associated with a voyage.\n\n    Attributes:\n        id: Numeric ID of the geo asset. Geo assets represent maritime\n            facilities such as terminals, anchorages and lightering zones.\n            Multiple geo assets are grouped under the same port.\n        name: Name of the geo asset. Geo assets represent maritime facilities\n            such as terminals, anchorages and lightering zones. Multiple geo\n            assets are grouped under the same port.\n        port_id: Numeric ID corresponding to the port. A port may be\n            associated with multiple geo assets representing different\n            terminals and anchorages within this port.\n        port_unlocode: The official code corresponding to the port.\n        port_name: Name of the port. A port may be associated with multiple\n            geo assets representing different terminals and anchorages within\n            this port.\n        country_id: Numeric ID corresponding to the country of the geo asset.\n        country: Name of the country of the geo asset.\n        area_idlevel0: Numeric ID corresponding to the level 0 area of the geo\n            asset. Level 0 areas offer a detailed breakdown of the globe to\n            the areas of maritime interest. Examples of level 0 areas include\n            \"Arabian Gulf\", \"US Gulf\" and \"East Mediterranean\".\n        area_name_level0: Name of the level 0 area of the geo asset. Level 0\n            areas offer a detailed breakdown of the globe to the areas of\n            maritime interest. Examples of level 0 areas include \"Arabian\n            Gulf\", \"US Gulf\" and \"East Mediterranean\".\n        area_idlevel1: Numeric ID corresponding to the level 1 area of the geo\n            asset. Level 1 areas consist of one or multiple level 0 areas. For\n            example, level 1 area \"Mediterranean\" groups together the level 0\n            areas \"West Mediterranean\", \"Central Mediterranean\" and \"East\n            Mediterranean\".\n        area_name_level1: Name of the level 1 area of the geo asset. Level 1\n            areas consist of one or multiple level 0 areas. For example, level\n            1 area \"Mediterranean\" groups together the level 0 areas \"West\n            Mediterranean\", \"Central Mediterranean\" and \"East Mediterranean\".\n        area_idlevel2: Numeric ID corresponding to the level 2 area of the geo\n            asset. Level 2 areas consist of one or multiple level 1 areas. For\n            example, level 2 area \"Mediterranean/UK Continent\" groups together\n            the \"Mediterranean\" and \"UK Continent\" level 1 areas.\n        area_name_level2: Name of the level 2 area of the geo asset. Level 2\n            areas consist of one or multiple level 1 areas. For example, level\n            2 area \"Mediterranean/UK Continent\" groups together the\n            \"Mediterranean\" and \"UK Continent\" level 1 areas.\n        area_idlevel3: Numeric ID corresponding to the level 3 area of the geo\n            asset. Level 3 areas the highest area grouping in our taxonomy.\n            Examples of such areas are \"Pacific America\" or \"Africa\". These\n            group together level 2 areas. For instance, \"Pacific America\"\n            groups together the level 2 areas \"West Coast North America\",\n            \"West Coast Mexico\", \"West Coast Central America\" and \"West Coast\n            South America\".\n        area_name_level3: Name of the level 3 area of the geo asset. Level 3\n            areas the highest area grouping in our taxonomy. Examples of such\n            areas are \"Pacific America\" or \"Africa\". These group together\n            level 2 areas. For instance, \"Pacific America\" groups together the\n            level 2 areas \"West Coast North America\", \"West Coast Mexico\",\n            \"West Coast Central America\" and \"West Coast South America\".\n    \"\"\"\n\n    id: Optional[int] = None\n    name: Optional[str] = None\n    port_id: Optional[int] = None\n    port_unlocode: Optional[str] = None\n    port_name: Optional[str] = None\n    country_id: Optional[int] = None\n    country: Optional[str] = None\n    area_idlevel0: Optional[int] = None\n    area_name_level0: Optional[str] = None\n    area_idlevel1: Optional[int] = None\n    area_name_level1: Optional[str] = None\n    area_idlevel2: Optional[int] = None\n    area_name_level2: Optional[str] = None\n    area_idlevel3: Optional[int] = None\n    area_name_level3: Optional[str] = None\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI","title":"<code>VoyagesAPI</code>","text":"<p>Represents Signal's Voyages API.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>class VoyagesAPI:\n    \"\"\"Represents Signal's Voyages API.\"\"\"\n\n    relative_url = \"voyages-api/v4/\"\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes VoyagesAPI.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    @staticmethod\n    def _get_endpoint(\n        imo: Optional[List[int]] = None,\n        voyage_keys: Optional[List[str]] = None,\n        event_type: Optional[int] = None,\n        event_horizons: Optional[List[int]] = None,\n        event_purpose: Optional[List[str]] = None,\n        vessel_class_id: Optional[List[int]] = None,\n        port_ids: Optional[List[int]] = None,\n        vessel_type_id: Optional[int] = None,\n        voyage_date_from: Optional[date] = None,\n        voyage_date_to: Optional[date] = None,\n        voyage_number_from: Optional[int] = None,\n        voyage_number_to: Optional[int] = None,\n        start_date_from: Optional[date] = None,\n        start_date_to: Optional[date] = None,\n        first_load_arrival_date_from: Optional[date] = None,\n        first_load_arrival_date_to: Optional[date] = None,\n        end_date_from: Optional[date] = None,\n        end_date_to: Optional[date] = None,\n        market_info_rate_from: Optional[date] = None,\n        market_info_rate_to: Optional[date] = None,\n        market_info_rate_type: Optional[date] = None,\n        commercial_operator_id: Optional[int] = None,\n        charterer_id: Optional[int] = None,\n        voyage_horizon: Optional[List[str]] = None,\n        token: Optional[str] = None,\n        hide_event_details: Optional[bool] = None,\n        hide_events: Optional[bool] = None,\n        hide_market_info: Optional[bool] = None,\n        nested: Optional[bool] = True,\n        condensed: Optional[bool] = False,\n        incremental: Optional[bool] = False,\n    ) -&gt; str:\n        \"\"\"Constructs the VoyagesData v4 endpoint.\n\n        Args:\n            endpoint_params: VoyagesData v4 endpoint parameters dictionary.\n            Part of get_voyages method arguments.\n            Part of get_voyages_incremental arguments.\n\n        Returns:\n            The constructed endpoint to call to retrieve the requested \\\n            voyages for the provided arguments.\n        \"\"\"\n        # Special Handling for event purposes and VoyageHorizons\n        endpoint_params = locals()\n        if condensed:\n            format_type = \"condensed\"\n        elif nested:\n            format_type = \"nested\"\n        else:\n            format_type = \"flat\"\n        endpoint = \"voyages/\" + \\\n            format_type + \\\n            f'{\"/incremental?\" if incremental else \"?\"}'\n\n        del endpoint_params[\"nested\"]\n        del endpoint_params[\"condensed\"]\n        del endpoint_params[\"incremental\"]\n        params = urlencode(\n            {\n                _to_camel_case(key): value\n                for key, value in endpoint_params.items()\n                if value is not None and value is not []\n            }, doseq=True\n        )\n        endpoint += params\n        return urljoin(VoyagesAPI.relative_url, endpoint)\n\n    def _get_voyages_pages(\n        self, endpoint: str, token: Optional[str] = None\n    ) -&gt; Tuple[Voyages, Optional[NextRequestToken]]:\n        \"\"\"Get voyages paged data.\n\n        Args:\n            endpoint: The endpoint to call.\n            token: Next request token for incremental voyages.\n\n        Make consecutive requests until no next page token is returned, gather\n        and return data.\n\n        Returns:\n            Voyages data gathered from the returned pages as a tupple.\n            The next request token, to be used for incremental updates.\n        \"\"\"\n        results: List[Voyage] = []\n        next_page_token = token\n        while True:\n            params = (\n                {\"token\": next_page_token}\n                if next_page_token is not None\n                else None\n            )\n            response = get_single(\n                self.__connection,\n                endpoint,\n                VoyagesPagedResponse,\n                query_string=params,\n            )\n            if response is not None and response.data is not None:\n                results.extend(response.data)\n            next_page_token = (\n                response.next_page_token if response is not None else None\n            )\n\n            if next_page_token is None:\n                break\n\n        next_request_token = (\n            response.next_request_token if response is not None else None\n        )\n        return tuple(results), next_request_token\n\n    def _get_voyages_flat_pages(\n        self, endpoint: str, token: Optional[str] = None\n    ) -&gt; Tuple[VoyagesFlat, Optional[NextRequestToken]]:\n        \"\"\"Get voyages flat paged data.\n\n        Args:\n            endpoint: The endpoint to call.\n            token: Next request token for incremental voyages.\n\n        Make consecutive requests until no next page token is returned, gather\n        and return data.\n\n        Returns:\n            Voyages flat data gathered from the returned pages as a tupple.\n            The next request token, to be used for incremental updates.\n        \"\"\"\n        voyages: List[Voyage] = []\n        events: List[VoyageEvent] = []\n        event_details: List[VoyageEventDetail] = []\n        geos: List[VoyageGeo] = []\n        next_page_token = token\n        while True:\n            params = (\n                {\"token\": next_page_token}\n                if next_page_token is not None\n                else None\n            )\n\n            response = get_single(\n                self.__connection,\n                endpoint,\n                VoyagesFlatPagedResponse,\n                query_string=params,\n            )\n\n            if response is not None and response.data is not None:\n                voyages.extend(response.data.voyages or [])\n                events.extend(response.data.events or [])\n                event_details.extend(response.data.event_details or [])\n                geos.extend(response.data.geos or [])\n\n            next_page_token = (\n                response.next_page_token if response is not None else None\n            )\n\n            if next_page_token is None:\n                break\n\n        # Remove duplicate geos entries because of the multiple paging\n        geos = list({geo.id: geo for geo in geos}.values())\n\n        result = VoyagesFlat(\n            voyages=tuple(voyages),\n            events=tuple(events),\n            event_details=tuple(event_details),\n            geos=tuple(geos),\n        )\n\n        next_request_token = (\n            response.next_request_token if response is not None else None\n        )\n\n        return result, next_request_token\n\n    def _get_voyages_condensed_pages(\n        self, endpoint: str, token: Optional[str] = None\n    ) -&gt; Tuple[VoyagesCondensed, Optional[NextRequestToken]]:\n        \"\"\"Get voyages condensed paged data.\n\n        Args:\n            endpoint: The endpoint to call.\n            token: Next request token for incremental voyages.\n\n        Make consecutive requests until no next page token is returned, gather\n        and return data.\n\n        Returns:\n            Voyages condensed data gathered from the returned pages as a\n            tupple. The next request token, for incremental updates.\n        \"\"\"\n        results: List[VoyageCondensed] = []\n        next_page_token = token\n        while True:\n            params = (\n                {\"token\": next_page_token}\n                if next_page_token is not None\n                else None\n            )\n            response = get_single(\n                self.__connection,\n                endpoint,\n                VoyagesCondensedPagedResponse,\n                query_string=params,\n            )\n            if response is not None and response.data is not None:\n                results.extend(response.data)\n            next_page_token = (\n                response.next_page_token if response is not None else None\n            )\n\n            if next_page_token is None:\n                break\n\n        next_request_token = (\n            response.next_request_token if response is not None else None\n        )\n        return tuple(results), next_request_token\n\n    def get_voyages(\n        self,\n        imo: Optional[int] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_type_id: Optional[int] = None,\n        date_from: Optional[date] = None,\n    ) -&gt; Voyages:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imo: Return only voyages for the provided vessel IMO. If None,\n                voyages for all vessels are returned.\n            vessel_class_id: Return only voyages for the provided vessel\n                class. If None, voyages for all vessels are returned. If\n                imo is specified, then vessel_class_id is ignored.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, voyages for all vessels are returned. If either imo\n                or vessel_class_id is specified, then vessel_type_id is\n                ignored.\n            date_from: Return voyages after provided date. If imo is\n                specified, then date_from is ignored.\n\n        Returns:\n            Voyages data as a tupple.\n        \"\"\"\n        if vessel_class_id is not None:\n            vcids = [vessel_class_id]\n        else:\n            vcids = []\n\n        if imo is not None:\n            imos = [imo]\n        else:\n            imos = []\n\n        endpoint = self._get_endpoint(\n            imo=imos,\n            vessel_class_id=vcids,\n            vessel_type_id=vessel_type_id,\n            start_date_from=date_from\n        )\n        results, _ = self._get_voyages_pages(endpoint)\n        return results\n\n    def get_voyages_flat(\n        self,\n        imo: Optional[int] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_type_id: Optional[int] = None,\n        date_from: Optional[date] = None,\n    ) -&gt; Optional[VoyagesFlat]:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imo: Return only voyages for the provided vessel IMO. If None\n                voyages for all vessels are returned.\n            vessel_class_id: Return only voyages for the provided vessel\n                class. If None, voyages for all vessels are returned. If imo\n                is specified, then vessel_class_id is ignored.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, voyages for all vessels are returned. If either imo\n                or vessel_class_id is specified, then vessel_type_id is\n                ignored.\n            date_from: Return voyages after provided date. If imo is\n                specified, then date_from is treated as None.\n\n        Returns:\n            A VoyagesFlat object containing lists of voyages, voyage events, \\\n            voyage event details and voyage geos otherwise.\n        \"\"\"\n        if vessel_class_id is not None:\n            vcids = [vessel_class_id]\n        else:\n            vcids = []\n\n        if imo is not None:\n            imos = [imo]\n        else:\n            imos = []\n\n        endpoint = self._get_endpoint(\n            imo=imos,\n            vessel_class_id=vcids,\n            vessel_type_id=vessel_type_id,\n            start_date_from=date_from,\n            nested=False\n        )\n        results, _ = self._get_voyages_flat_pages(endpoint)\n        return results\n\n    def get_voyages_condensed(\n        self,\n        imo: Optional[int] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_type_id: Optional[int] = None,\n        date_from: Optional[date] = None,\n    ) -&gt; VoyagesCondensed:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imo: Return only voyages for the provided vessel IMO. If None\n                voyages for all vessels are returned.\n            vessel_class_id: Return only voyages for the provided vessel\n                class. If None, voyages for all vessels are returned. If imo\n                is specified, then vessel_class_id is ignored.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, voyages for all vessels are returned. If either imo\n                or vessel_class_id is specified, then vessel_type_id is\n                ignored.\n            date_from: Return voyages after provided date. If imo is\n                specified, then date_from is treated as None.\n\n        Returns:\n            A VoyagesCondensed object containing lists of voyages.\n        \"\"\"\n        if vessel_class_id is not None:\n            vcids = [vessel_class_id]\n        else:\n            vcids = []\n\n        if imo is not None:\n            imos = [imo]\n        else:\n            imos = []\n        endpoint = self._get_endpoint(\n            imo=imos,\n            vessel_class_id=vcids,\n            vessel_type_id=vessel_type_id,\n            start_date_from=date_from,\n            nested=False,\n            condensed=True\n        )\n        results, _ = self._get_voyages_condensed_pages(endpoint)\n        return results\n\n    def get_incremental_voyages(\n        self,\n        imo: Optional[int] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_type_id: Optional[int] = None,\n        date_from: Optional[date] = None,\n        incremental_token: Optional[str] = None,\n    ) -&gt; Tuple[Voyages, Optional[NextRequestToken]]:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imo: Return only voyages for the provided vessel IMO. If None,\n                then voyages for all vessels are returned.\n            vessel_class_id: Return only voyages for the provided vessel\n                class. If None, then voyages for all vessels are returned. If\n                imo is specified, then vessel_class_id is ignored.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, then voyages for all vessels are returned. If either\n                imo or vessel_class_id is specified, then vessel_type_id is\n                ignored.\n            date_from: Return voyages after provided date. If imo is\n                specified, then date_from is treated as None.\n            incremental_token: Token returned from the previous incremental\n                call. If this is the first call, then it can be omitted.\n\n        Returns:\n            A tuple containing the returned voyages, including any deleted \\\n            voyages, and the token for the next incremental request.\n        \"\"\"\n        if vessel_class_id is not None:\n            vcids = [vessel_class_id]\n        else:\n            vcids = []\n\n        if imo is not None:\n            imos = [imo]\n        else:\n            imos = []\n        endpoint = self._get_endpoint(\n            imo=imos,\n            vessel_class_id=vcids,\n            vessel_type_id=vessel_type_id,\n            voyage_date_from=date_from,\n            nested=True,\n            incremental=True\n        )\n        results = self._get_voyages_pages(endpoint, token=incremental_token)\n        return results\n\n    def get_incremental_voyages_flat(\n        self,\n        imo: Optional[int] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_type_id: Optional[int] = None,\n        date_from: Optional[date] = None,\n        incremental_token: Optional[str] = None,\n    ) -&gt; Tuple[VoyagesFlat, Optional[NextRequestToken]]:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imo: Return only voyages for the provided vessel IMO. If None,\n                then voyages for all vessels are returned.\n            vessel_class_id: Return only voyages for the provided vessel\n                class. If None, voyages for all vessels are returned. If imo\n                is specified, then vessel_class_id is ignored.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, voyages for all vessels are returned. If either imo\n                or vessel_class_id is specified, then vessel_type_id is\n                ignored.\n            date_from: Return  after the provided date. If imo is\n                specified, then datevoyages_from is treated as None.\n            incremental_token: Token returned from the previous incremental\n                call. If this is the first call, then it can be omitted.\n\n        Returns:\n            A tuple containing the returned voyages in flat format, \\\n            including any deleted voyages, and the token for the next \\\n            incremental request.\n        \"\"\"\n        if vessel_class_id is not None:\n            vcids = [vessel_class_id]\n        else:\n            vcids = []\n\n        if imo is not None:\n            imos = [imo]\n        else:\n            imos = []\n        endpoint = self._get_endpoint(\n            imo=imos,\n            vessel_class_id=vcids,\n            vessel_type_id=vessel_type_id,\n            voyage_date_from=date_from,\n            nested=False,\n            incremental=True\n        )\n        results = self._get_voyages_flat_pages(\n            endpoint, token=incremental_token\n        )\n        return results\n\n    def get_incremental_voyages_condensed(\n        self,\n        imo: Optional[int] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_type_id: Optional[int] = None,\n        date_from: Optional[date] = None,\n        incremental_token: Optional[str] = None,\n    ) -&gt; Tuple[VoyagesCondensed, Optional[NextRequestToken]]:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imo: Return only voyages for the provided vessel IMO. If None,\n                then voyages for all vessels are returned.\n            vessel_class_id: Return only voyages for the provided vessel class.\n                If None, then voyages for all vessels are returned. If imo is\n                specified, then vessel_class_id is ignored.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, then voyages for all vessels are returned. If either\n                imo or vessel_class_id is specified, then vessel_type_id is\n                ignored.\n            date_from: Return voyages after provided date. If imo is\n                specified, then date_from is treated as None.\n            incremental_token: Token returned from the previous incremental\n                call. If this is the first call, then it can be omitted.\n\n        Returns:\n            A tuple containing the returned voyages in condensed format, \\\n            including any deleted voyages, and the token for the next \\\n            incremental request.\n        \"\"\"\n        if vessel_class_id is not None:\n            vcids = [vessel_class_id]\n        else:\n            vcids = []\n\n        if imo is not None:\n            imos = [imo]\n        else:\n            imos = []\n        endpoint = self._get_endpoint(\n            imo=imos,\n            vessel_class_id=vcids,\n            vessel_type_id=vessel_type_id,\n            voyage_date_from=date_from,\n            nested=False,\n            incremental=True,\n            condensed=True\n        )\n        results = self._get_voyages_condensed_pages(\n            endpoint, token=incremental_token\n        )\n        return results\n\n    def get_voyages_by_advanced_search(\n        self,\n        imos: Optional[List[int]] = None,\n        voyage_keys: Optional[List[str]] = None,\n        event_type: Optional[int] = None,\n        event_horizon: Optional[int] = None,\n        event_horizons: Optional[List[int]] = None,\n        event_purpose: Optional[str] = None,\n        event_purposes: Optional[List[str]] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_class_ids: Optional[List[int]] = None,\n        port_id: Optional[int] = None,\n        port_ids: Optional[List[int]] = None,\n        vessel_type_id: Optional[int] = None,\n        start_date_from: Optional[date] = None,\n        start_date_to: Optional[date] = None,\n        first_load_arrival_date_from: Optional[date] = None,\n        first_load_arrival_date_to: Optional[date] = None,\n        end_date_from: Optional[date] = None,\n        end_date_to: Optional[date] = None,\n        market_info_rate_from: Optional[date] = None,\n        market_info_rate_to: Optional[date] = None,\n        market_info_rate_type: Optional[date] = None,\n        commercial_operator_id: Optional[int] = None,\n        charterer_id: Optional[int] = None,\n        voyage_horizon: Optional[str] = None,\n        voyage_horizons: Optional[List[str]] = None,\n        token: Optional[str] = None,\n        hide_event_details: Optional[bool] = None,\n        hide_events: Optional[bool] = None,\n        hide_market_info: Optional[bool] = None,\n    ) -&gt; Voyages:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imos: If a list of imos is provided then only voyages of these\n                imos will be returned\n            voyage_keys: If provided only the voyages with the requested\n                keys will be returned\n            event_type: If an EventType is provided, then only voyages that\n                include at least one event of this type will be returned.\n            event_horizon: If an EventHorizon is provided, then only voyages\n                of this event horizon will be returned.\n            event_horizons: If a list of EventHorizons is provided then only\n                voyages that include at least one event of those types\n                will be returned\n            event_purpose: If an EventPurpose is provided, then only voyages\n                that include at least one event of this purpose will be\n                returned.\n            event_purposes: If a list of EventPurposes is provided then only\n                voyages that include at least one event of this type\n                will be returned\n            vessel_class_id: Return only voyages for the provided vessel\n                class. If None, then voyages for all vessels are returned.\n            vessel_class_ids: If provided only voyages of those vessel classes\n                will be returned.\n            port_id: If PortId is provided then only voyages that contains at\n                least one event at this port will be returned.\n            port_ids: If a list of ports is provided then only voyages that\n                contains at least one event at those ports will be returned.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, then voyages for all vessels are returned.\n            start_date_from: Return voyages after the provided voyage start\n                date.\n            start_date_to: Return voyages up to the provided voyage end date.\n            first_load_arrival_date_from: Return voyages with a first load\n                arrival date after the provided date.\n            first_load_arrival_date_to: Return voyages with a first load\n                arrival date up to the provided date.\n            end_date_from: Return voyages with an end date after the provided\n                date.\n            end_date_to: Return voyages with an end date up to the provided\n                date.\n            market_info_rate_from: If provided, then only voyages that have\n                market data and with rate greater than this will be returned.\n            market_info_rate_to: If provided, then only voyages that have\n                market data and with a lower rate will be returned.\n            market_info_rate_type: If provided, then only voyages that have\n                market data and with the same rate type will be returned.\n            commercial_operator_id: If provided, then only voyages that have\n                this commercial operator will be returned.\n            charterer_id: If provided, then only voyages that have this\n                charterer will be returned.\n            voyage_horizon: If a VoyageHorizon is provided, then only voyages\n                of that type will be returned.\n            voyage_horizons: If a list of VoyageHorizon is provided then\n                only voyages of that type will be returned.\n            token: Token returned from the previous incremental call. If this\n                is the first call, then it can be omitted.\n            hide_event_details: If True, then event details will be excluded.\n            hide_events: If True, then events will be excluded.\n            hide_market_info: If True, then market information will be\n                excluded.\n\n        Returns:\n            Voyages data as a tupple.\n        \"\"\"\n        if event_horizon is not None:\n            if event_horizons is None:\n                event_horizons = []\n            event_horizons.append(event_horizon)\n\n        if event_purpose is not None:\n            if event_purposes is None:\n                event_purposes = []\n            event_purposes.append(event_purpose)\n\n        if vessel_class_id is not None:\n            if vessel_class_ids is None:\n                vessel_class_ids = []\n            vessel_class_ids.append(vessel_class_id)\n\n        if port_id is not None:\n            if port_ids is None:\n                port_ids = []\n            port_ids.append(port_id)\n\n        if voyage_horizon is not None:\n            if voyage_horizons is None:\n                voyage_horizons = []\n            voyage_horizons.append(voyage_horizon)\n        endpoint = self._get_endpoint(\n            imo=imos,\n            voyage_keys=voyage_keys,\n            event_type=event_type,\n            event_horizons=event_horizons,\n            event_purpose=event_purposes,\n            vessel_class_id=vessel_class_ids,\n            port_ids=port_ids,\n            vessel_type_id=vessel_type_id,\n            start_date_from=start_date_from,\n            start_date_to=start_date_to,\n            first_load_arrival_date_from=first_load_arrival_date_from,\n            first_load_arrival_date_to=first_load_arrival_date_to,\n            end_date_from=end_date_from,\n            end_date_to=end_date_to,\n            market_info_rate_from=market_info_rate_from,\n            market_info_rate_to=market_info_rate_to,\n            market_info_rate_type=market_info_rate_type,\n            commercial_operator_id=commercial_operator_id,\n            charterer_id=charterer_id,\n            voyage_horizon=voyage_horizons,\n            token=token,\n            hide_event_details=hide_event_details,\n            hide_events=hide_events,\n            hide_market_info=hide_market_info,\n        )\n        results, _ = self._get_voyages_pages(endpoint)\n        return results\n\n    def get_voyages_flat_by_advanced_search(\n        self,\n        imos: Optional[List[int]] = None,\n        voyage_keys: Optional[List[str]] = None,\n        event_type: Optional[int] = None,\n        event_horizon: Optional[int] = None,\n        event_horizons: Optional[List[int]] = None,\n        event_purpose: Optional[str] = None,\n        event_purposes: Optional[List[str]] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_class_ids: Optional[List[int]] = None,\n        port_id: Optional[int] = None,\n        port_ids: Optional[List[int]] = None,\n        vessel_type_id: Optional[int] = None,\n        start_date_from: Optional[date] = None,\n        start_date_to: Optional[date] = None,\n        first_load_arrival_date_from: Optional[date] = None,\n        first_load_arrival_date_to: Optional[date] = None,\n        end_date_from: Optional[date] = None,\n        end_date_to: Optional[date] = None,\n        market_info_rate_from: Optional[date] = None,\n        market_info_rate_to: Optional[date] = None,\n        market_info_rate_type: Optional[date] = None,\n        commercial_operator_id: Optional[int] = None,\n        charterer_id: Optional[int] = None,\n        voyage_horizon: Optional[str] = None,\n        voyage_horizons: Optional[List[str]] = None,\n        token: Optional[str] = None,\n        hide_event_details: Optional[bool] = None,\n        hide_events: Optional[bool] = None,\n        hide_market_info: Optional[bool] = None,\n    ) -&gt; VoyagesFlat:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imos: If a list of imos is provided then only voyages of these\n                imos will be returned\n            voyage_keys: If provided only the voyages with the requested\n                keys will be returned\n            event_type: If an EventType is provided, then only voyages that\n                include at least one event of this type will be returned.\n            event_horizon: If an EventHorizon is provided, then only voyages\n                of this event horizon will be returned.\n            event_horizons: If a list of EventHorizons is provided then only\n                voyages that include at least one event of those types\n                will be returned\n            event_purpose: If an EventPurpose is provided, then only voyages\n                that include at least one event of this purpose will be\n                returned.\n            event_purposes: If a list of EventPurposes is provided then only\n                voyages that include at least one event of this type\n                will be returned\n            vessel_class_id: Return only voyages for the provided vessel\n                class. If None, then voyages for all vessels are returned.\n            vessel_class_ids: If provided only voyages of those vessel classes\n                will be returned.\n            port_id: If PortId is provided then only voyages that contains at\n                least one event at this port will be returned.\n            port_ids: If a list of ports is provided then only voyages that\n                contains at least one event at those ports will be returned.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, then voyages for all vessels are returned.\n            start_date_from: Return voyages after the provided voyage start\n                date.\n            start_date_to: Return voyages up to the provided voyage end date.\n            first_load_arrival_date_from: Return voyages with a first load\n                arrival date after the provided date.\n            first_load_arrival_date_to: Return voyages with a first load\n                arrival date up to the provided date.\n            end_date_from: Return voyages with an end date after the provided\n                date.\n            end_date_to: Return voyages with an end date up to the provided\n                date.\n            market_info_rate_from: If provided, then only voyages that have\n                market data and with rate greater than this will be returned.\n            market_info_rate_to: If provided, then only voyages that have\n                market data and with a lower rate will be returned.\n            market_info_rate_type: If provided, then only voyages that have\n                market data and with the same rate type will be returned.\n            commercial_operator_id: If provided, then only voyages that have\n                this commercial operator will be returned.\n            charterer_id: If provided, then only voyages that have this\n                charterer will be returned.\n            voyage_horizon: If a VoyageHorizon is provided, then only voyages\n                of that type will be returned.\n            voyage_horizons: If a list of VoyageHorizon is provided then\n                only voyages of that type will be returned.\n            token: Token returned from the previous incremental call. If this\n                is the first call, then it can be omitted.\n            hide_event_details: If True, then event details will be excluded.\n            hide_events: If True, then events will be excluded.\n            hide_market_info: If True, then market information will be\n                excluded.\n\n        Returns:\n            Voyages data in flat format as a tupple.\n        \"\"\"\n        if event_horizon is not None:\n            if event_horizons is None:\n                event_horizons = []\n            event_horizons.append(event_horizon)\n\n        if event_purpose is not None:\n            if event_purposes is None:\n                event_purposes = []\n            event_purposes.append(event_purpose)\n\n        if vessel_class_id is not None:\n            if vessel_class_ids is None:\n                vessel_class_ids = []\n            vessel_class_ids.append(vessel_class_id)\n\n        if port_id is not None:\n            if port_ids is None:\n                port_ids = []\n            port_ids.append(port_id)\n\n        if voyage_horizon is not None:\n            if voyage_horizons is None:\n                voyage_horizons = []\n            voyage_horizons.append(voyage_horizon)\n        endpoint = self._get_endpoint(\n            imo=imos,\n            voyage_keys=voyage_keys,\n            event_type=event_type,\n            event_horizons=event_horizons,\n            event_purpose=event_purposes,\n            vessel_class_id=vessel_class_ids,\n            port_ids=port_ids,\n            vessel_type_id=vessel_type_id,\n            voyage_date_from=start_date_from,\n            voyage_date_to=start_date_to,\n            start_date_from=start_date_from,\n            start_date_to=start_date_to,\n            first_load_arrival_date_from=first_load_arrival_date_from,\n            first_load_arrival_date_to=first_load_arrival_date_to,\n            end_date_from=end_date_from,\n            end_date_to=end_date_to,\n            market_info_rate_from=market_info_rate_from,\n            market_info_rate_to=market_info_rate_to,\n            market_info_rate_type=market_info_rate_type,\n            commercial_operator_id=commercial_operator_id,\n            charterer_id=charterer_id,\n            voyage_horizon=voyage_horizons,\n            token=token,\n            hide_event_details=hide_event_details,\n            hide_events=hide_events,\n            hide_market_info=hide_market_info,\n            nested=False\n        )\n        results, _ = self._get_voyages_flat_pages(endpoint)\n        return results\n\n    def get_voyages_condensed_by_advanced_search(\n        self,\n        imos: Optional[List[int]] = None,\n        voyage_keys: Optional[List[str]] = None,\n        event_type: Optional[int] = None,\n        event_horizon: Optional[int] = None,\n        event_horizons: Optional[List[int]] = None,\n        event_purpose: Optional[str] = None,\n        event_purposes: Optional[List[str]] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_class_ids: Optional[List[int]] = None,\n        port_id: Optional[int] = None,\n        port_ids: Optional[List[int]] = None,\n        vessel_type_id: Optional[int] = None,\n        start_date_from: Optional[date] = None,\n        start_date_to: Optional[date] = None,\n        first_load_arrival_date_from: Optional[date] = None,\n        first_load_arrival_date_to: Optional[date] = None,\n        end_date_from: Optional[date] = None,\n        end_date_to: Optional[date] = None,\n        market_info_rate_from: Optional[date] = None,\n        market_info_rate_to: Optional[date] = None,\n        market_info_rate_type: Optional[date] = None,\n        commercial_operator_id: Optional[int] = None,\n        charterer_id: Optional[int] = None,\n        voyage_horizon: Optional[str] = None,\n        voyage_horizons: Optional[List[str]] = None,\n        token: Optional[str] = None,\n        hide_event_details: Optional[bool] = None,\n        hide_events: Optional[bool] = None,\n        hide_market_info: Optional[bool] = None,\n    ) -&gt; VoyagesCondensed:\n        \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n        Args:\n            imos: If a list of imos is provided then only voyages of these\n                imos will be returned\n            voyage_keys: If provided only the voyages with the requested\n                keys will be returned\n            event_type: If an EventType is provided, then only voyages that\n                include at least one event of this type will be returned.\n            event_horizon: If an EventHorizon is provided, then only voyages\n                of this event horizon will be returned.\n            event_horizons: If a list of EventHorizons is provided then only\n                voyages that include at least one event of those types\n                will be returned\n            event_purpose: If an EventPurpose is provided, then only voyages\n                that include at least one event of this purpose will be\n                returned.\n            event_purposes: If a list of EventPurposes is provided then only\n                voyages that include at least one event of this type\n                will be returned\n            vessel_class_id: Return only voyages for the provided vessel\n                class. If None, then voyages for all vessels are returned.\n            vessel_class_ids: If provided only voyages of those vessel classes\n                will be returned.\n            port_id: If PortId is provided then only voyages that contains at\n                least one event at this port will be returned.\n            port_ids: If a list of ports is provided then only voyages that\n                contains at least one event at those ports will be returned.\n            vessel_type_id: Return only voyages for the provided vessel type.\n                If None, then voyages for all vessels are returned.\n            start_date_from: Return voyages after the provided voyage start\n                date.\n            start_date_to: Return voyages up to the provided voyage end date.\n            first_load_arrival_date_from: Return voyages with a first load\n                arrival date after the provided date.\n            first_load_arrival_date_to: Return voyages with a first load\n                arrival date up to the provided date.\n            end_date_from: Return voyages with an end date after the provided\n                date.\n            end_date_to: Return voyages with an end date up to the provided\n                date.\n            market_info_rate_from: If provided, then only voyages that have\n                market data and with rate greater than this will be returned.\n            market_info_rate_to: If provided, then only voyages that have\n                market data and with a lower rate will be returned.\n            market_info_rate_type: If provided, then only voyages that have\n                market data and with the same rate type will be returned.\n            commercial_operator_id: If provided, then only voyages that have\n                this commercial operator will be returned.\n            charterer_id: If provided, then only voyages that have this\n                charterer will be returned.\n            voyage_horizon: If a VoyageHorizon is provided, then only voyages\n                of that type will be returned.\n            voyage_horizons: If a list of VoyageHorizon is provided then\n                only voyages of that type will be returned.\n            token: Token returned from the previous incremental call. If this\n                is the first call, then it can be omitted.\n            hide_event_details: If True, then event details will be excluded.\n            hide_events: If True, then events will be excluded.\n            hide_market_info: If True, then market information will be\n                excluded.\n\n        Returns:\n            Voyages data in condensed format as a tupple.\n        \"\"\"\n        if event_horizon is not None:\n            if event_horizons is None:\n                event_horizons = []\n            event_horizons.append(event_horizon)\n\n        if event_purpose is not None:\n            if event_purposes is None:\n                event_purposes = []\n            event_purposes.append(event_purpose)\n\n        if vessel_class_id is not None:\n            if vessel_class_ids is None:\n                vessel_class_ids = []\n            vessel_class_ids.append(vessel_class_id)\n\n        if port_id is not None:\n            if port_ids is None:\n                port_ids = []\n            port_ids.append(port_id)\n\n        if voyage_horizon is not None:\n            if voyage_horizons is None:\n                voyage_horizons = []\n            voyage_horizons.append(voyage_horizon)\n        endpoint = self._get_endpoint(\n            imo=imos,\n            voyage_keys=voyage_keys,\n            event_type=event_type,\n            event_horizons=event_horizons,\n            event_purpose=event_purposes,\n            vessel_class_id=vessel_class_ids,\n            port_ids=port_ids,\n            vessel_type_id=vessel_type_id,\n            voyage_date_from=start_date_from,\n            voyage_date_to=start_date_to,\n            start_date_from=start_date_from,\n            start_date_to=start_date_to,\n            first_load_arrival_date_from=first_load_arrival_date_from,\n            first_load_arrival_date_to=first_load_arrival_date_to,\n            end_date_from=end_date_from,\n            end_date_to=end_date_to,\n            market_info_rate_from=market_info_rate_from,\n            market_info_rate_to=market_info_rate_to,\n            market_info_rate_type=market_info_rate_type,\n            commercial_operator_id=commercial_operator_id,\n            charterer_id=charterer_id,\n            voyage_horizon=voyage_horizons,\n            token=token,\n            hide_event_details=hide_event_details,\n            hide_events=hide_events,\n            hide_market_info=hide_market_info,\n            nested=False,\n            condensed=True\n        )\n        results, _ = self._get_voyages_condensed_pages(endpoint)\n        return results\n\n    def get_vessel_classes(\n        self, class_filter: Optional[VesselClassFilter] = None\n    ) -&gt; Tuple[VesselClass, ...]:\n        \"\"\"Retrieves available vessel classes.\n\n        Args:\n            class_filter: A filter used to find specific vessel classes. If\n                not specified, returns all available vessel classes.\n\n        Returns:\n            A tuple of available vessel classes that match the filter.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"voyages-api/v4/filters/availableVesselClasses\"\n        )\n        response.raise_for_status()\n\n        classes = (parse_model(c, VesselClass) for c in response.json())\n        class_filter = class_filter or VesselClassFilter()\n\n        return tuple(class_filter._apply(classes))\n\n    def get_vessel_types(\n        self, type_filter: Optional[VesselTypeFilter] = None\n    ) -&gt; Tuple[VesselType, ...]:\n        \"\"\"Retrieves available vessel types.\n\n        Args:\n            type_filter: A filter used to find specific vessel types. If not\n                specified, returns all available vessel types.\n\n        Returns:\n            A tuple of available vessel types that match the filter.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"voyages-api/v4/filters/availableVesselTypes\"\n        )\n        response.raise_for_status()\n\n        types = (parse_model(c, VesselType) for c in response.json())\n        type_filter = type_filter or VesselTypeFilter()\n\n        return tuple(type_filter._apply(types))\n\n    def get_imos(\n        self, vessel_filter: Optional[VesselFilter] = None\n    ) -&gt; Tuple[Vessel, ...]:\n        \"\"\"Retrieves available vessel types.\n\n        Args:\n            vessel_filter: A filter used to find specific vessel . If not\n                specified, returns all available vessels .\n\n        Returns:\n            A tuple of available vessels that match the filter.\n        \"\"\"\n        response = self.__connection._make_get_request(\n            \"voyages-api/v4/filters/availableVessels\"\n        )\n        response.raise_for_status()\n\n        vessels = (parse_model(c, Vessel) for c in response.json())\n        vessel_filter = vessel_filter or VesselFilter()\n\n        return tuple(vessel_filter._apply(vessels))\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes VoyagesAPI.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes VoyagesAPI.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_imos","title":"<code>get_imos(vessel_filter=None)</code>","text":"<p>Retrieves available vessel types.</p> <p>Parameters:</p> Name Type Description Default <code>vessel_filter</code> <code>Optional[VesselFilter]</code> <p>A filter used to find specific vessel . If not specified, returns all available vessels .</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Vessel, ...]</code> <p>A tuple of available vessels that match the filter.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_imos(\n    self, vessel_filter: Optional[VesselFilter] = None\n) -&gt; Tuple[Vessel, ...]:\n    \"\"\"Retrieves available vessel types.\n\n    Args:\n        vessel_filter: A filter used to find specific vessel . If not\n            specified, returns all available vessels .\n\n    Returns:\n        A tuple of available vessels that match the filter.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"voyages-api/v4/filters/availableVessels\"\n    )\n    response.raise_for_status()\n\n    vessels = (parse_model(c, Vessel) for c in response.json())\n    vessel_filter = vessel_filter or VesselFilter()\n\n    return tuple(vessel_filter._apply(vessels))\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_incremental_voyages","title":"<code>get_incremental_voyages(imo=None, vessel_class_id=None, vessel_type_id=None, date_from=None, incremental_token=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel IMO. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, then voyages for all vessels are returned. If imo is specified, then vessel_class_id is ignored.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, then voyages for all vessels are returned. If either imo or vessel_class_id is specified, then vessel_type_id is ignored.</p> <code>None</code> <code>date_from</code> <code>Optional[date]</code> <p>Return voyages after provided date. If imo is specified, then date_from is treated as None.</p> <code>None</code> <code>incremental_token</code> <code>Optional[str]</code> <p>Token returned from the previous incremental call. If this is the first call, then it can be omitted.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Voyages, Optional[NextRequestToken]]</code> <p>A tuple containing the returned voyages, including any deleted             voyages, and the token for the next incremental request.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_incremental_voyages(\n    self,\n    imo: Optional[int] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_type_id: Optional[int] = None,\n    date_from: Optional[date] = None,\n    incremental_token: Optional[str] = None,\n) -&gt; Tuple[Voyages, Optional[NextRequestToken]]:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imo: Return only voyages for the provided vessel IMO. If None,\n            then voyages for all vessels are returned.\n        vessel_class_id: Return only voyages for the provided vessel\n            class. If None, then voyages for all vessels are returned. If\n            imo is specified, then vessel_class_id is ignored.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, then voyages for all vessels are returned. If either\n            imo or vessel_class_id is specified, then vessel_type_id is\n            ignored.\n        date_from: Return voyages after provided date. If imo is\n            specified, then date_from is treated as None.\n        incremental_token: Token returned from the previous incremental\n            call. If this is the first call, then it can be omitted.\n\n    Returns:\n        A tuple containing the returned voyages, including any deleted \\\n        voyages, and the token for the next incremental request.\n    \"\"\"\n    if vessel_class_id is not None:\n        vcids = [vessel_class_id]\n    else:\n        vcids = []\n\n    if imo is not None:\n        imos = [imo]\n    else:\n        imos = []\n    endpoint = self._get_endpoint(\n        imo=imos,\n        vessel_class_id=vcids,\n        vessel_type_id=vessel_type_id,\n        voyage_date_from=date_from,\n        nested=True,\n        incremental=True\n    )\n    results = self._get_voyages_pages(endpoint, token=incremental_token)\n    return results\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_incremental_voyages_condensed","title":"<code>get_incremental_voyages_condensed(imo=None, vessel_class_id=None, vessel_type_id=None, date_from=None, incremental_token=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel IMO. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, then voyages for all vessels are returned. If imo is specified, then vessel_class_id is ignored.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, then voyages for all vessels are returned. If either imo or vessel_class_id is specified, then vessel_type_id is ignored.</p> <code>None</code> <code>date_from</code> <code>Optional[date]</code> <p>Return voyages after provided date. If imo is specified, then date_from is treated as None.</p> <code>None</code> <code>incremental_token</code> <code>Optional[str]</code> <p>Token returned from the previous incremental call. If this is the first call, then it can be omitted.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VoyagesCondensed, Optional[NextRequestToken]]</code> <p>A tuple containing the returned voyages in condensed format,             including any deleted voyages, and the token for the next             incremental request.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_incremental_voyages_condensed(\n    self,\n    imo: Optional[int] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_type_id: Optional[int] = None,\n    date_from: Optional[date] = None,\n    incremental_token: Optional[str] = None,\n) -&gt; Tuple[VoyagesCondensed, Optional[NextRequestToken]]:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imo: Return only voyages for the provided vessel IMO. If None,\n            then voyages for all vessels are returned.\n        vessel_class_id: Return only voyages for the provided vessel class.\n            If None, then voyages for all vessels are returned. If imo is\n            specified, then vessel_class_id is ignored.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, then voyages for all vessels are returned. If either\n            imo or vessel_class_id is specified, then vessel_type_id is\n            ignored.\n        date_from: Return voyages after provided date. If imo is\n            specified, then date_from is treated as None.\n        incremental_token: Token returned from the previous incremental\n            call. If this is the first call, then it can be omitted.\n\n    Returns:\n        A tuple containing the returned voyages in condensed format, \\\n        including any deleted voyages, and the token for the next \\\n        incremental request.\n    \"\"\"\n    if vessel_class_id is not None:\n        vcids = [vessel_class_id]\n    else:\n        vcids = []\n\n    if imo is not None:\n        imos = [imo]\n    else:\n        imos = []\n    endpoint = self._get_endpoint(\n        imo=imos,\n        vessel_class_id=vcids,\n        vessel_type_id=vessel_type_id,\n        voyage_date_from=date_from,\n        nested=False,\n        incremental=True,\n        condensed=True\n    )\n    results = self._get_voyages_condensed_pages(\n        endpoint, token=incremental_token\n    )\n    return results\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_incremental_voyages_flat","title":"<code>get_incremental_voyages_flat(imo=None, vessel_class_id=None, vessel_type_id=None, date_from=None, incremental_token=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel IMO. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, voyages for all vessels are returned. If imo is specified, then vessel_class_id is ignored.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, voyages for all vessels are returned. If either imo or vessel_class_id is specified, then vessel_type_id is ignored.</p> <code>None</code> <code>date_from</code> <code>Optional[date]</code> <p>Return  after the provided date. If imo is specified, then datevoyages_from is treated as None.</p> <code>None</code> <code>incremental_token</code> <code>Optional[str]</code> <p>Token returned from the previous incremental call. If this is the first call, then it can be omitted.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VoyagesFlat, Optional[NextRequestToken]]</code> <p>A tuple containing the returned voyages in flat format,             including any deleted voyages, and the token for the next             incremental request.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_incremental_voyages_flat(\n    self,\n    imo: Optional[int] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_type_id: Optional[int] = None,\n    date_from: Optional[date] = None,\n    incremental_token: Optional[str] = None,\n) -&gt; Tuple[VoyagesFlat, Optional[NextRequestToken]]:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imo: Return only voyages for the provided vessel IMO. If None,\n            then voyages for all vessels are returned.\n        vessel_class_id: Return only voyages for the provided vessel\n            class. If None, voyages for all vessels are returned. If imo\n            is specified, then vessel_class_id is ignored.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, voyages for all vessels are returned. If either imo\n            or vessel_class_id is specified, then vessel_type_id is\n            ignored.\n        date_from: Return  after the provided date. If imo is\n            specified, then datevoyages_from is treated as None.\n        incremental_token: Token returned from the previous incremental\n            call. If this is the first call, then it can be omitted.\n\n    Returns:\n        A tuple containing the returned voyages in flat format, \\\n        including any deleted voyages, and the token for the next \\\n        incremental request.\n    \"\"\"\n    if vessel_class_id is not None:\n        vcids = [vessel_class_id]\n    else:\n        vcids = []\n\n    if imo is not None:\n        imos = [imo]\n    else:\n        imos = []\n    endpoint = self._get_endpoint(\n        imo=imos,\n        vessel_class_id=vcids,\n        vessel_type_id=vessel_type_id,\n        voyage_date_from=date_from,\n        nested=False,\n        incremental=True\n    )\n    results = self._get_voyages_flat_pages(\n        endpoint, token=incremental_token\n    )\n    return results\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_vessel_classes","title":"<code>get_vessel_classes(class_filter=None)</code>","text":"<p>Retrieves available vessel classes.</p> <p>Parameters:</p> Name Type Description Default <code>class_filter</code> <code>Optional[VesselClassFilter]</code> <p>A filter used to find specific vessel classes. If not specified, returns all available vessel classes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VesselClass, ...]</code> <p>A tuple of available vessel classes that match the filter.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_vessel_classes(\n    self, class_filter: Optional[VesselClassFilter] = None\n) -&gt; Tuple[VesselClass, ...]:\n    \"\"\"Retrieves available vessel classes.\n\n    Args:\n        class_filter: A filter used to find specific vessel classes. If\n            not specified, returns all available vessel classes.\n\n    Returns:\n        A tuple of available vessel classes that match the filter.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"voyages-api/v4/filters/availableVesselClasses\"\n    )\n    response.raise_for_status()\n\n    classes = (parse_model(c, VesselClass) for c in response.json())\n    class_filter = class_filter or VesselClassFilter()\n\n    return tuple(class_filter._apply(classes))\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_vessel_types","title":"<code>get_vessel_types(type_filter=None)</code>","text":"<p>Retrieves available vessel types.</p> <p>Parameters:</p> Name Type Description Default <code>type_filter</code> <code>Optional[VesselTypeFilter]</code> <p>A filter used to find specific vessel types. If not specified, returns all available vessel types.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[VesselType, ...]</code> <p>A tuple of available vessel types that match the filter.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_vessel_types(\n    self, type_filter: Optional[VesselTypeFilter] = None\n) -&gt; Tuple[VesselType, ...]:\n    \"\"\"Retrieves available vessel types.\n\n    Args:\n        type_filter: A filter used to find specific vessel types. If not\n            specified, returns all available vessel types.\n\n    Returns:\n        A tuple of available vessel types that match the filter.\n    \"\"\"\n    response = self.__connection._make_get_request(\n        \"voyages-api/v4/filters/availableVesselTypes\"\n    )\n    response.raise_for_status()\n\n    types = (parse_model(c, VesselType) for c in response.json())\n    type_filter = type_filter or VesselTypeFilter()\n\n    return tuple(type_filter._apply(types))\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_voyages","title":"<code>get_voyages(imo=None, vessel_class_id=None, vessel_type_id=None, date_from=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel IMO. If None, voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, voyages for all vessels are returned. If imo is specified, then vessel_class_id is ignored.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, voyages for all vessels are returned. If either imo or vessel_class_id is specified, then vessel_type_id is ignored.</p> <code>None</code> <code>date_from</code> <code>Optional[date]</code> <p>Return voyages after provided date. If imo is specified, then date_from is ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>Voyages</code> <p>Voyages data as a tupple.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_voyages(\n    self,\n    imo: Optional[int] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_type_id: Optional[int] = None,\n    date_from: Optional[date] = None,\n) -&gt; Voyages:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imo: Return only voyages for the provided vessel IMO. If None,\n            voyages for all vessels are returned.\n        vessel_class_id: Return only voyages for the provided vessel\n            class. If None, voyages for all vessels are returned. If\n            imo is specified, then vessel_class_id is ignored.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, voyages for all vessels are returned. If either imo\n            or vessel_class_id is specified, then vessel_type_id is\n            ignored.\n        date_from: Return voyages after provided date. If imo is\n            specified, then date_from is ignored.\n\n    Returns:\n        Voyages data as a tupple.\n    \"\"\"\n    if vessel_class_id is not None:\n        vcids = [vessel_class_id]\n    else:\n        vcids = []\n\n    if imo is not None:\n        imos = [imo]\n    else:\n        imos = []\n\n    endpoint = self._get_endpoint(\n        imo=imos,\n        vessel_class_id=vcids,\n        vessel_type_id=vessel_type_id,\n        start_date_from=date_from\n    )\n    results, _ = self._get_voyages_pages(endpoint)\n    return results\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_voyages_by_advanced_search","title":"<code>get_voyages_by_advanced_search(imos=None, voyage_keys=None, event_type=None, event_horizon=None, event_horizons=None, event_purpose=None, event_purposes=None, vessel_class_id=None, vessel_class_ids=None, port_id=None, port_ids=None, vessel_type_id=None, start_date_from=None, start_date_to=None, first_load_arrival_date_from=None, first_load_arrival_date_to=None, end_date_from=None, end_date_to=None, market_info_rate_from=None, market_info_rate_to=None, market_info_rate_type=None, commercial_operator_id=None, charterer_id=None, voyage_horizon=None, voyage_horizons=None, token=None, hide_event_details=None, hide_events=None, hide_market_info=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imos</code> <code>Optional[List[int]]</code> <p>If a list of imos is provided then only voyages of these imos will be returned</p> <code>None</code> <code>voyage_keys</code> <code>Optional[List[str]]</code> <p>If provided only the voyages with the requested keys will be returned</p> <code>None</code> <code>event_type</code> <code>Optional[int]</code> <p>If an EventType is provided, then only voyages that include at least one event of this type will be returned.</p> <code>None</code> <code>event_horizon</code> <code>Optional[int]</code> <p>If an EventHorizon is provided, then only voyages of this event horizon will be returned.</p> <code>None</code> <code>event_horizons</code> <code>Optional[List[int]]</code> <p>If a list of EventHorizons is provided then only voyages that include at least one event of those types will be returned</p> <code>None</code> <code>event_purpose</code> <code>Optional[str]</code> <p>If an EventPurpose is provided, then only voyages that include at least one event of this purpose will be returned.</p> <code>None</code> <code>event_purposes</code> <code>Optional[List[str]]</code> <p>If a list of EventPurposes is provided then only voyages that include at least one event of this type will be returned</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_ids</code> <code>Optional[List[int]]</code> <p>If provided only voyages of those vessel classes will be returned.</p> <code>None</code> <code>port_id</code> <code>Optional[int]</code> <p>If PortId is provided then only voyages that contains at least one event at this port will be returned.</p> <code>None</code> <code>port_ids</code> <code>Optional[List[int]]</code> <p>If a list of ports is provided then only voyages that contains at least one event at those ports will be returned.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>start_date_from</code> <code>Optional[date]</code> <p>Return voyages after the provided voyage start date.</p> <code>None</code> <code>start_date_to</code> <code>Optional[date]</code> <p>Return voyages up to the provided voyage end date.</p> <code>None</code> <code>first_load_arrival_date_from</code> <code>Optional[date]</code> <p>Return voyages with a first load arrival date after the provided date.</p> <code>None</code> <code>first_load_arrival_date_to</code> <code>Optional[date]</code> <p>Return voyages with a first load arrival date up to the provided date.</p> <code>None</code> <code>end_date_from</code> <code>Optional[date]</code> <p>Return voyages with an end date after the provided date.</p> <code>None</code> <code>end_date_to</code> <code>Optional[date]</code> <p>Return voyages with an end date up to the provided date.</p> <code>None</code> <code>market_info_rate_from</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with rate greater than this will be returned.</p> <code>None</code> <code>market_info_rate_to</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with a lower rate will be returned.</p> <code>None</code> <code>market_info_rate_type</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with the same rate type will be returned.</p> <code>None</code> <code>commercial_operator_id</code> <code>Optional[int]</code> <p>If provided, then only voyages that have this commercial operator will be returned.</p> <code>None</code> <code>charterer_id</code> <code>Optional[int]</code> <p>If provided, then only voyages that have this charterer will be returned.</p> <code>None</code> <code>voyage_horizon</code> <code>Optional[str]</code> <p>If a VoyageHorizon is provided, then only voyages of that type will be returned.</p> <code>None</code> <code>voyage_horizons</code> <code>Optional[List[str]]</code> <p>If a list of VoyageHorizon is provided then only voyages of that type will be returned.</p> <code>None</code> <code>token</code> <code>Optional[str]</code> <p>Token returned from the previous incremental call. If this is the first call, then it can be omitted.</p> <code>None</code> <code>hide_event_details</code> <code>Optional[bool]</code> <p>If True, then event details will be excluded.</p> <code>None</code> <code>hide_events</code> <code>Optional[bool]</code> <p>If True, then events will be excluded.</p> <code>None</code> <code>hide_market_info</code> <code>Optional[bool]</code> <p>If True, then market information will be excluded.</p> <code>None</code> <p>Returns:</p> Type Description <code>Voyages</code> <p>Voyages data as a tupple.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_voyages_by_advanced_search(\n    self,\n    imos: Optional[List[int]] = None,\n    voyage_keys: Optional[List[str]] = None,\n    event_type: Optional[int] = None,\n    event_horizon: Optional[int] = None,\n    event_horizons: Optional[List[int]] = None,\n    event_purpose: Optional[str] = None,\n    event_purposes: Optional[List[str]] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_class_ids: Optional[List[int]] = None,\n    port_id: Optional[int] = None,\n    port_ids: Optional[List[int]] = None,\n    vessel_type_id: Optional[int] = None,\n    start_date_from: Optional[date] = None,\n    start_date_to: Optional[date] = None,\n    first_load_arrival_date_from: Optional[date] = None,\n    first_load_arrival_date_to: Optional[date] = None,\n    end_date_from: Optional[date] = None,\n    end_date_to: Optional[date] = None,\n    market_info_rate_from: Optional[date] = None,\n    market_info_rate_to: Optional[date] = None,\n    market_info_rate_type: Optional[date] = None,\n    commercial_operator_id: Optional[int] = None,\n    charterer_id: Optional[int] = None,\n    voyage_horizon: Optional[str] = None,\n    voyage_horizons: Optional[List[str]] = None,\n    token: Optional[str] = None,\n    hide_event_details: Optional[bool] = None,\n    hide_events: Optional[bool] = None,\n    hide_market_info: Optional[bool] = None,\n) -&gt; Voyages:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imos: If a list of imos is provided then only voyages of these\n            imos will be returned\n        voyage_keys: If provided only the voyages with the requested\n            keys will be returned\n        event_type: If an EventType is provided, then only voyages that\n            include at least one event of this type will be returned.\n        event_horizon: If an EventHorizon is provided, then only voyages\n            of this event horizon will be returned.\n        event_horizons: If a list of EventHorizons is provided then only\n            voyages that include at least one event of those types\n            will be returned\n        event_purpose: If an EventPurpose is provided, then only voyages\n            that include at least one event of this purpose will be\n            returned.\n        event_purposes: If a list of EventPurposes is provided then only\n            voyages that include at least one event of this type\n            will be returned\n        vessel_class_id: Return only voyages for the provided vessel\n            class. If None, then voyages for all vessels are returned.\n        vessel_class_ids: If provided only voyages of those vessel classes\n            will be returned.\n        port_id: If PortId is provided then only voyages that contains at\n            least one event at this port will be returned.\n        port_ids: If a list of ports is provided then only voyages that\n            contains at least one event at those ports will be returned.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, then voyages for all vessels are returned.\n        start_date_from: Return voyages after the provided voyage start\n            date.\n        start_date_to: Return voyages up to the provided voyage end date.\n        first_load_arrival_date_from: Return voyages with a first load\n            arrival date after the provided date.\n        first_load_arrival_date_to: Return voyages with a first load\n            arrival date up to the provided date.\n        end_date_from: Return voyages with an end date after the provided\n            date.\n        end_date_to: Return voyages with an end date up to the provided\n            date.\n        market_info_rate_from: If provided, then only voyages that have\n            market data and with rate greater than this will be returned.\n        market_info_rate_to: If provided, then only voyages that have\n            market data and with a lower rate will be returned.\n        market_info_rate_type: If provided, then only voyages that have\n            market data and with the same rate type will be returned.\n        commercial_operator_id: If provided, then only voyages that have\n            this commercial operator will be returned.\n        charterer_id: If provided, then only voyages that have this\n            charterer will be returned.\n        voyage_horizon: If a VoyageHorizon is provided, then only voyages\n            of that type will be returned.\n        voyage_horizons: If a list of VoyageHorizon is provided then\n            only voyages of that type will be returned.\n        token: Token returned from the previous incremental call. If this\n            is the first call, then it can be omitted.\n        hide_event_details: If True, then event details will be excluded.\n        hide_events: If True, then events will be excluded.\n        hide_market_info: If True, then market information will be\n            excluded.\n\n    Returns:\n        Voyages data as a tupple.\n    \"\"\"\n    if event_horizon is not None:\n        if event_horizons is None:\n            event_horizons = []\n        event_horizons.append(event_horizon)\n\n    if event_purpose is not None:\n        if event_purposes is None:\n            event_purposes = []\n        event_purposes.append(event_purpose)\n\n    if vessel_class_id is not None:\n        if vessel_class_ids is None:\n            vessel_class_ids = []\n        vessel_class_ids.append(vessel_class_id)\n\n    if port_id is not None:\n        if port_ids is None:\n            port_ids = []\n        port_ids.append(port_id)\n\n    if voyage_horizon is not None:\n        if voyage_horizons is None:\n            voyage_horizons = []\n        voyage_horizons.append(voyage_horizon)\n    endpoint = self._get_endpoint(\n        imo=imos,\n        voyage_keys=voyage_keys,\n        event_type=event_type,\n        event_horizons=event_horizons,\n        event_purpose=event_purposes,\n        vessel_class_id=vessel_class_ids,\n        port_ids=port_ids,\n        vessel_type_id=vessel_type_id,\n        start_date_from=start_date_from,\n        start_date_to=start_date_to,\n        first_load_arrival_date_from=first_load_arrival_date_from,\n        first_load_arrival_date_to=first_load_arrival_date_to,\n        end_date_from=end_date_from,\n        end_date_to=end_date_to,\n        market_info_rate_from=market_info_rate_from,\n        market_info_rate_to=market_info_rate_to,\n        market_info_rate_type=market_info_rate_type,\n        commercial_operator_id=commercial_operator_id,\n        charterer_id=charterer_id,\n        voyage_horizon=voyage_horizons,\n        token=token,\n        hide_event_details=hide_event_details,\n        hide_events=hide_events,\n        hide_market_info=hide_market_info,\n    )\n    results, _ = self._get_voyages_pages(endpoint)\n    return results\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_voyages_condensed","title":"<code>get_voyages_condensed(imo=None, vessel_class_id=None, vessel_type_id=None, date_from=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel IMO. If None voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, voyages for all vessels are returned. If imo is specified, then vessel_class_id is ignored.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, voyages for all vessels are returned. If either imo or vessel_class_id is specified, then vessel_type_id is ignored.</p> <code>None</code> <code>date_from</code> <code>Optional[date]</code> <p>Return voyages after provided date. If imo is specified, then date_from is treated as None.</p> <code>None</code> <p>Returns:</p> Type Description <code>VoyagesCondensed</code> <p>A VoyagesCondensed object containing lists of voyages.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_voyages_condensed(\n    self,\n    imo: Optional[int] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_type_id: Optional[int] = None,\n    date_from: Optional[date] = None,\n) -&gt; VoyagesCondensed:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imo: Return only voyages for the provided vessel IMO. If None\n            voyages for all vessels are returned.\n        vessel_class_id: Return only voyages for the provided vessel\n            class. If None, voyages for all vessels are returned. If imo\n            is specified, then vessel_class_id is ignored.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, voyages for all vessels are returned. If either imo\n            or vessel_class_id is specified, then vessel_type_id is\n            ignored.\n        date_from: Return voyages after provided date. If imo is\n            specified, then date_from is treated as None.\n\n    Returns:\n        A VoyagesCondensed object containing lists of voyages.\n    \"\"\"\n    if vessel_class_id is not None:\n        vcids = [vessel_class_id]\n    else:\n        vcids = []\n\n    if imo is not None:\n        imos = [imo]\n    else:\n        imos = []\n    endpoint = self._get_endpoint(\n        imo=imos,\n        vessel_class_id=vcids,\n        vessel_type_id=vessel_type_id,\n        start_date_from=date_from,\n        nested=False,\n        condensed=True\n    )\n    results, _ = self._get_voyages_condensed_pages(endpoint)\n    return results\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_voyages_condensed_by_advanced_search","title":"<code>get_voyages_condensed_by_advanced_search(imos=None, voyage_keys=None, event_type=None, event_horizon=None, event_horizons=None, event_purpose=None, event_purposes=None, vessel_class_id=None, vessel_class_ids=None, port_id=None, port_ids=None, vessel_type_id=None, start_date_from=None, start_date_to=None, first_load_arrival_date_from=None, first_load_arrival_date_to=None, end_date_from=None, end_date_to=None, market_info_rate_from=None, market_info_rate_to=None, market_info_rate_type=None, commercial_operator_id=None, charterer_id=None, voyage_horizon=None, voyage_horizons=None, token=None, hide_event_details=None, hide_events=None, hide_market_info=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imos</code> <code>Optional[List[int]]</code> <p>If a list of imos is provided then only voyages of these imos will be returned</p> <code>None</code> <code>voyage_keys</code> <code>Optional[List[str]]</code> <p>If provided only the voyages with the requested keys will be returned</p> <code>None</code> <code>event_type</code> <code>Optional[int]</code> <p>If an EventType is provided, then only voyages that include at least one event of this type will be returned.</p> <code>None</code> <code>event_horizon</code> <code>Optional[int]</code> <p>If an EventHorizon is provided, then only voyages of this event horizon will be returned.</p> <code>None</code> <code>event_horizons</code> <code>Optional[List[int]]</code> <p>If a list of EventHorizons is provided then only voyages that include at least one event of those types will be returned</p> <code>None</code> <code>event_purpose</code> <code>Optional[str]</code> <p>If an EventPurpose is provided, then only voyages that include at least one event of this purpose will be returned.</p> <code>None</code> <code>event_purposes</code> <code>Optional[List[str]]</code> <p>If a list of EventPurposes is provided then only voyages that include at least one event of this type will be returned</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_ids</code> <code>Optional[List[int]]</code> <p>If provided only voyages of those vessel classes will be returned.</p> <code>None</code> <code>port_id</code> <code>Optional[int]</code> <p>If PortId is provided then only voyages that contains at least one event at this port will be returned.</p> <code>None</code> <code>port_ids</code> <code>Optional[List[int]]</code> <p>If a list of ports is provided then only voyages that contains at least one event at those ports will be returned.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>start_date_from</code> <code>Optional[date]</code> <p>Return voyages after the provided voyage start date.</p> <code>None</code> <code>start_date_to</code> <code>Optional[date]</code> <p>Return voyages up to the provided voyage end date.</p> <code>None</code> <code>first_load_arrival_date_from</code> <code>Optional[date]</code> <p>Return voyages with a first load arrival date after the provided date.</p> <code>None</code> <code>first_load_arrival_date_to</code> <code>Optional[date]</code> <p>Return voyages with a first load arrival date up to the provided date.</p> <code>None</code> <code>end_date_from</code> <code>Optional[date]</code> <p>Return voyages with an end date after the provided date.</p> <code>None</code> <code>end_date_to</code> <code>Optional[date]</code> <p>Return voyages with an end date up to the provided date.</p> <code>None</code> <code>market_info_rate_from</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with rate greater than this will be returned.</p> <code>None</code> <code>market_info_rate_to</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with a lower rate will be returned.</p> <code>None</code> <code>market_info_rate_type</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with the same rate type will be returned.</p> <code>None</code> <code>commercial_operator_id</code> <code>Optional[int]</code> <p>If provided, then only voyages that have this commercial operator will be returned.</p> <code>None</code> <code>charterer_id</code> <code>Optional[int]</code> <p>If provided, then only voyages that have this charterer will be returned.</p> <code>None</code> <code>voyage_horizon</code> <code>Optional[str]</code> <p>If a VoyageHorizon is provided, then only voyages of that type will be returned.</p> <code>None</code> <code>voyage_horizons</code> <code>Optional[List[str]]</code> <p>If a list of VoyageHorizon is provided then only voyages of that type will be returned.</p> <code>None</code> <code>token</code> <code>Optional[str]</code> <p>Token returned from the previous incremental call. If this is the first call, then it can be omitted.</p> <code>None</code> <code>hide_event_details</code> <code>Optional[bool]</code> <p>If True, then event details will be excluded.</p> <code>None</code> <code>hide_events</code> <code>Optional[bool]</code> <p>If True, then events will be excluded.</p> <code>None</code> <code>hide_market_info</code> <code>Optional[bool]</code> <p>If True, then market information will be excluded.</p> <code>None</code> <p>Returns:</p> Type Description <code>VoyagesCondensed</code> <p>Voyages data in condensed format as a tupple.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_voyages_condensed_by_advanced_search(\n    self,\n    imos: Optional[List[int]] = None,\n    voyage_keys: Optional[List[str]] = None,\n    event_type: Optional[int] = None,\n    event_horizon: Optional[int] = None,\n    event_horizons: Optional[List[int]] = None,\n    event_purpose: Optional[str] = None,\n    event_purposes: Optional[List[str]] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_class_ids: Optional[List[int]] = None,\n    port_id: Optional[int] = None,\n    port_ids: Optional[List[int]] = None,\n    vessel_type_id: Optional[int] = None,\n    start_date_from: Optional[date] = None,\n    start_date_to: Optional[date] = None,\n    first_load_arrival_date_from: Optional[date] = None,\n    first_load_arrival_date_to: Optional[date] = None,\n    end_date_from: Optional[date] = None,\n    end_date_to: Optional[date] = None,\n    market_info_rate_from: Optional[date] = None,\n    market_info_rate_to: Optional[date] = None,\n    market_info_rate_type: Optional[date] = None,\n    commercial_operator_id: Optional[int] = None,\n    charterer_id: Optional[int] = None,\n    voyage_horizon: Optional[str] = None,\n    voyage_horizons: Optional[List[str]] = None,\n    token: Optional[str] = None,\n    hide_event_details: Optional[bool] = None,\n    hide_events: Optional[bool] = None,\n    hide_market_info: Optional[bool] = None,\n) -&gt; VoyagesCondensed:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imos: If a list of imos is provided then only voyages of these\n            imos will be returned\n        voyage_keys: If provided only the voyages with the requested\n            keys will be returned\n        event_type: If an EventType is provided, then only voyages that\n            include at least one event of this type will be returned.\n        event_horizon: If an EventHorizon is provided, then only voyages\n            of this event horizon will be returned.\n        event_horizons: If a list of EventHorizons is provided then only\n            voyages that include at least one event of those types\n            will be returned\n        event_purpose: If an EventPurpose is provided, then only voyages\n            that include at least one event of this purpose will be\n            returned.\n        event_purposes: If a list of EventPurposes is provided then only\n            voyages that include at least one event of this type\n            will be returned\n        vessel_class_id: Return only voyages for the provided vessel\n            class. If None, then voyages for all vessels are returned.\n        vessel_class_ids: If provided only voyages of those vessel classes\n            will be returned.\n        port_id: If PortId is provided then only voyages that contains at\n            least one event at this port will be returned.\n        port_ids: If a list of ports is provided then only voyages that\n            contains at least one event at those ports will be returned.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, then voyages for all vessels are returned.\n        start_date_from: Return voyages after the provided voyage start\n            date.\n        start_date_to: Return voyages up to the provided voyage end date.\n        first_load_arrival_date_from: Return voyages with a first load\n            arrival date after the provided date.\n        first_load_arrival_date_to: Return voyages with a first load\n            arrival date up to the provided date.\n        end_date_from: Return voyages with an end date after the provided\n            date.\n        end_date_to: Return voyages with an end date up to the provided\n            date.\n        market_info_rate_from: If provided, then only voyages that have\n            market data and with rate greater than this will be returned.\n        market_info_rate_to: If provided, then only voyages that have\n            market data and with a lower rate will be returned.\n        market_info_rate_type: If provided, then only voyages that have\n            market data and with the same rate type will be returned.\n        commercial_operator_id: If provided, then only voyages that have\n            this commercial operator will be returned.\n        charterer_id: If provided, then only voyages that have this\n            charterer will be returned.\n        voyage_horizon: If a VoyageHorizon is provided, then only voyages\n            of that type will be returned.\n        voyage_horizons: If a list of VoyageHorizon is provided then\n            only voyages of that type will be returned.\n        token: Token returned from the previous incremental call. If this\n            is the first call, then it can be omitted.\n        hide_event_details: If True, then event details will be excluded.\n        hide_events: If True, then events will be excluded.\n        hide_market_info: If True, then market information will be\n            excluded.\n\n    Returns:\n        Voyages data in condensed format as a tupple.\n    \"\"\"\n    if event_horizon is not None:\n        if event_horizons is None:\n            event_horizons = []\n        event_horizons.append(event_horizon)\n\n    if event_purpose is not None:\n        if event_purposes is None:\n            event_purposes = []\n        event_purposes.append(event_purpose)\n\n    if vessel_class_id is not None:\n        if vessel_class_ids is None:\n            vessel_class_ids = []\n        vessel_class_ids.append(vessel_class_id)\n\n    if port_id is not None:\n        if port_ids is None:\n            port_ids = []\n        port_ids.append(port_id)\n\n    if voyage_horizon is not None:\n        if voyage_horizons is None:\n            voyage_horizons = []\n        voyage_horizons.append(voyage_horizon)\n    endpoint = self._get_endpoint(\n        imo=imos,\n        voyage_keys=voyage_keys,\n        event_type=event_type,\n        event_horizons=event_horizons,\n        event_purpose=event_purposes,\n        vessel_class_id=vessel_class_ids,\n        port_ids=port_ids,\n        vessel_type_id=vessel_type_id,\n        voyage_date_from=start_date_from,\n        voyage_date_to=start_date_to,\n        start_date_from=start_date_from,\n        start_date_to=start_date_to,\n        first_load_arrival_date_from=first_load_arrival_date_from,\n        first_load_arrival_date_to=first_load_arrival_date_to,\n        end_date_from=end_date_from,\n        end_date_to=end_date_to,\n        market_info_rate_from=market_info_rate_from,\n        market_info_rate_to=market_info_rate_to,\n        market_info_rate_type=market_info_rate_type,\n        commercial_operator_id=commercial_operator_id,\n        charterer_id=charterer_id,\n        voyage_horizon=voyage_horizons,\n        token=token,\n        hide_event_details=hide_event_details,\n        hide_events=hide_events,\n        hide_market_info=hide_market_info,\n        nested=False,\n        condensed=True\n    )\n    results, _ = self._get_voyages_condensed_pages(endpoint)\n    return results\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_voyages_flat","title":"<code>get_voyages_flat(imo=None, vessel_class_id=None, vessel_type_id=None, date_from=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel IMO. If None voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, voyages for all vessels are returned. If imo is specified, then vessel_class_id is ignored.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, voyages for all vessels are returned. If either imo or vessel_class_id is specified, then vessel_type_id is ignored.</p> <code>None</code> <code>date_from</code> <code>Optional[date]</code> <p>Return voyages after provided date. If imo is specified, then date_from is treated as None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[VoyagesFlat]</code> <p>A VoyagesFlat object containing lists of voyages, voyage events,             voyage event details and voyage geos otherwise.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_voyages_flat(\n    self,\n    imo: Optional[int] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_type_id: Optional[int] = None,\n    date_from: Optional[date] = None,\n) -&gt; Optional[VoyagesFlat]:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imo: Return only voyages for the provided vessel IMO. If None\n            voyages for all vessels are returned.\n        vessel_class_id: Return only voyages for the provided vessel\n            class. If None, voyages for all vessels are returned. If imo\n            is specified, then vessel_class_id is ignored.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, voyages for all vessels are returned. If either imo\n            or vessel_class_id is specified, then vessel_type_id is\n            ignored.\n        date_from: Return voyages after provided date. If imo is\n            specified, then date_from is treated as None.\n\n    Returns:\n        A VoyagesFlat object containing lists of voyages, voyage events, \\\n        voyage event details and voyage geos otherwise.\n    \"\"\"\n    if vessel_class_id is not None:\n        vcids = [vessel_class_id]\n    else:\n        vcids = []\n\n    if imo is not None:\n        imos = [imo]\n    else:\n        imos = []\n\n    endpoint = self._get_endpoint(\n        imo=imos,\n        vessel_class_id=vcids,\n        vessel_type_id=vessel_type_id,\n        start_date_from=date_from,\n        nested=False\n    )\n    results, _ = self._get_voyages_flat_pages(endpoint)\n    return results\n</code></pre>"},{"location":"voyages/#signal_ocean.voyages.VoyagesAPI.get_voyages_flat_by_advanced_search","title":"<code>get_voyages_flat_by_advanced_search(imos=None, voyage_keys=None, event_type=None, event_horizon=None, event_horizons=None, event_purpose=None, event_purposes=None, vessel_class_id=None, vessel_class_ids=None, port_id=None, port_ids=None, vessel_type_id=None, start_date_from=None, start_date_to=None, first_load_arrival_date_from=None, first_load_arrival_date_to=None, end_date_from=None, end_date_to=None, market_info_rate_from=None, market_info_rate_to=None, market_info_rate_type=None, commercial_operator_id=None, charterer_id=None, voyage_horizon=None, voyage_horizons=None, token=None, hide_event_details=None, hide_events=None, hide_market_info=None)</code>","text":"<p>Retrieves all voyages filtered with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imos</code> <code>Optional[List[int]]</code> <p>If a list of imos is provided then only voyages of these imos will be returned</p> <code>None</code> <code>voyage_keys</code> <code>Optional[List[str]]</code> <p>If provided only the voyages with the requested keys will be returned</p> <code>None</code> <code>event_type</code> <code>Optional[int]</code> <p>If an EventType is provided, then only voyages that include at least one event of this type will be returned.</p> <code>None</code> <code>event_horizon</code> <code>Optional[int]</code> <p>If an EventHorizon is provided, then only voyages of this event horizon will be returned.</p> <code>None</code> <code>event_horizons</code> <code>Optional[List[int]]</code> <p>If a list of EventHorizons is provided then only voyages that include at least one event of those types will be returned</p> <code>None</code> <code>event_purpose</code> <code>Optional[str]</code> <p>If an EventPurpose is provided, then only voyages that include at least one event of this purpose will be returned.</p> <code>None</code> <code>event_purposes</code> <code>Optional[List[str]]</code> <p>If a list of EventPurposes is provided then only voyages that include at least one event of this type will be returned</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel class. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>vessel_class_ids</code> <code>Optional[List[int]]</code> <p>If provided only voyages of those vessel classes will be returned.</p> <code>None</code> <code>port_id</code> <code>Optional[int]</code> <p>If PortId is provided then only voyages that contains at least one event at this port will be returned.</p> <code>None</code> <code>port_ids</code> <code>Optional[List[int]]</code> <p>If a list of ports is provided then only voyages that contains at least one event at those ports will be returned.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel type. If None, then voyages for all vessels are returned.</p> <code>None</code> <code>start_date_from</code> <code>Optional[date]</code> <p>Return voyages after the provided voyage start date.</p> <code>None</code> <code>start_date_to</code> <code>Optional[date]</code> <p>Return voyages up to the provided voyage end date.</p> <code>None</code> <code>first_load_arrival_date_from</code> <code>Optional[date]</code> <p>Return voyages with a first load arrival date after the provided date.</p> <code>None</code> <code>first_load_arrival_date_to</code> <code>Optional[date]</code> <p>Return voyages with a first load arrival date up to the provided date.</p> <code>None</code> <code>end_date_from</code> <code>Optional[date]</code> <p>Return voyages with an end date after the provided date.</p> <code>None</code> <code>end_date_to</code> <code>Optional[date]</code> <p>Return voyages with an end date up to the provided date.</p> <code>None</code> <code>market_info_rate_from</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with rate greater than this will be returned.</p> <code>None</code> <code>market_info_rate_to</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with a lower rate will be returned.</p> <code>None</code> <code>market_info_rate_type</code> <code>Optional[date]</code> <p>If provided, then only voyages that have market data and with the same rate type will be returned.</p> <code>None</code> <code>commercial_operator_id</code> <code>Optional[int]</code> <p>If provided, then only voyages that have this commercial operator will be returned.</p> <code>None</code> <code>charterer_id</code> <code>Optional[int]</code> <p>If provided, then only voyages that have this charterer will be returned.</p> <code>None</code> <code>voyage_horizon</code> <code>Optional[str]</code> <p>If a VoyageHorizon is provided, then only voyages of that type will be returned.</p> <code>None</code> <code>voyage_horizons</code> <code>Optional[List[str]]</code> <p>If a list of VoyageHorizon is provided then only voyages of that type will be returned.</p> <code>None</code> <code>token</code> <code>Optional[str]</code> <p>Token returned from the previous incremental call. If this is the first call, then it can be omitted.</p> <code>None</code> <code>hide_event_details</code> <code>Optional[bool]</code> <p>If True, then event details will be excluded.</p> <code>None</code> <code>hide_events</code> <code>Optional[bool]</code> <p>If True, then events will be excluded.</p> <code>None</code> <code>hide_market_info</code> <code>Optional[bool]</code> <p>If True, then market information will be excluded.</p> <code>None</code> <p>Returns:</p> Type Description <code>VoyagesFlat</code> <p>Voyages data in flat format as a tupple.</p> Source code in <code>signal_ocean/voyages/voyages_api.py</code> <pre><code>def get_voyages_flat_by_advanced_search(\n    self,\n    imos: Optional[List[int]] = None,\n    voyage_keys: Optional[List[str]] = None,\n    event_type: Optional[int] = None,\n    event_horizon: Optional[int] = None,\n    event_horizons: Optional[List[int]] = None,\n    event_purpose: Optional[str] = None,\n    event_purposes: Optional[List[str]] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_class_ids: Optional[List[int]] = None,\n    port_id: Optional[int] = None,\n    port_ids: Optional[List[int]] = None,\n    vessel_type_id: Optional[int] = None,\n    start_date_from: Optional[date] = None,\n    start_date_to: Optional[date] = None,\n    first_load_arrival_date_from: Optional[date] = None,\n    first_load_arrival_date_to: Optional[date] = None,\n    end_date_from: Optional[date] = None,\n    end_date_to: Optional[date] = None,\n    market_info_rate_from: Optional[date] = None,\n    market_info_rate_to: Optional[date] = None,\n    market_info_rate_type: Optional[date] = None,\n    commercial_operator_id: Optional[int] = None,\n    charterer_id: Optional[int] = None,\n    voyage_horizon: Optional[str] = None,\n    voyage_horizons: Optional[List[str]] = None,\n    token: Optional[str] = None,\n    hide_event_details: Optional[bool] = None,\n    hide_events: Optional[bool] = None,\n    hide_market_info: Optional[bool] = None,\n) -&gt; VoyagesFlat:\n    \"\"\"Retrieves all voyages filtered with the provided parameters.\n\n    Args:\n        imos: If a list of imos is provided then only voyages of these\n            imos will be returned\n        voyage_keys: If provided only the voyages with the requested\n            keys will be returned\n        event_type: If an EventType is provided, then only voyages that\n            include at least one event of this type will be returned.\n        event_horizon: If an EventHorizon is provided, then only voyages\n            of this event horizon will be returned.\n        event_horizons: If a list of EventHorizons is provided then only\n            voyages that include at least one event of those types\n            will be returned\n        event_purpose: If an EventPurpose is provided, then only voyages\n            that include at least one event of this purpose will be\n            returned.\n        event_purposes: If a list of EventPurposes is provided then only\n            voyages that include at least one event of this type\n            will be returned\n        vessel_class_id: Return only voyages for the provided vessel\n            class. If None, then voyages for all vessels are returned.\n        vessel_class_ids: If provided only voyages of those vessel classes\n            will be returned.\n        port_id: If PortId is provided then only voyages that contains at\n            least one event at this port will be returned.\n        port_ids: If a list of ports is provided then only voyages that\n            contains at least one event at those ports will be returned.\n        vessel_type_id: Return only voyages for the provided vessel type.\n            If None, then voyages for all vessels are returned.\n        start_date_from: Return voyages after the provided voyage start\n            date.\n        start_date_to: Return voyages up to the provided voyage end date.\n        first_load_arrival_date_from: Return voyages with a first load\n            arrival date after the provided date.\n        first_load_arrival_date_to: Return voyages with a first load\n            arrival date up to the provided date.\n        end_date_from: Return voyages with an end date after the provided\n            date.\n        end_date_to: Return voyages with an end date up to the provided\n            date.\n        market_info_rate_from: If provided, then only voyages that have\n            market data and with rate greater than this will be returned.\n        market_info_rate_to: If provided, then only voyages that have\n            market data and with a lower rate will be returned.\n        market_info_rate_type: If provided, then only voyages that have\n            market data and with the same rate type will be returned.\n        commercial_operator_id: If provided, then only voyages that have\n            this commercial operator will be returned.\n        charterer_id: If provided, then only voyages that have this\n            charterer will be returned.\n        voyage_horizon: If a VoyageHorizon is provided, then only voyages\n            of that type will be returned.\n        voyage_horizons: If a list of VoyageHorizon is provided then\n            only voyages of that type will be returned.\n        token: Token returned from the previous incremental call. If this\n            is the first call, then it can be omitted.\n        hide_event_details: If True, then event details will be excluded.\n        hide_events: If True, then events will be excluded.\n        hide_market_info: If True, then market information will be\n            excluded.\n\n    Returns:\n        Voyages data in flat format as a tupple.\n    \"\"\"\n    if event_horizon is not None:\n        if event_horizons is None:\n            event_horizons = []\n        event_horizons.append(event_horizon)\n\n    if event_purpose is not None:\n        if event_purposes is None:\n            event_purposes = []\n        event_purposes.append(event_purpose)\n\n    if vessel_class_id is not None:\n        if vessel_class_ids is None:\n            vessel_class_ids = []\n        vessel_class_ids.append(vessel_class_id)\n\n    if port_id is not None:\n        if port_ids is None:\n            port_ids = []\n        port_ids.append(port_id)\n\n    if voyage_horizon is not None:\n        if voyage_horizons is None:\n            voyage_horizons = []\n        voyage_horizons.append(voyage_horizon)\n    endpoint = self._get_endpoint(\n        imo=imos,\n        voyage_keys=voyage_keys,\n        event_type=event_type,\n        event_horizons=event_horizons,\n        event_purpose=event_purposes,\n        vessel_class_id=vessel_class_ids,\n        port_ids=port_ids,\n        vessel_type_id=vessel_type_id,\n        voyage_date_from=start_date_from,\n        voyage_date_to=start_date_to,\n        start_date_from=start_date_from,\n        start_date_to=start_date_to,\n        first_load_arrival_date_from=first_load_arrival_date_from,\n        first_load_arrival_date_to=first_load_arrival_date_to,\n        end_date_from=end_date_from,\n        end_date_to=end_date_to,\n        market_info_rate_from=market_info_rate_from,\n        market_info_rate_to=market_info_rate_to,\n        market_info_rate_type=market_info_rate_type,\n        commercial_operator_id=commercial_operator_id,\n        charterer_id=charterer_id,\n        voyage_horizon=voyage_horizons,\n        token=token,\n        hide_event_details=hide_event_details,\n        hide_events=hide_events,\n        hide_market_info=hide_market_info,\n        nested=False\n    )\n    results, _ = self._get_voyages_flat_pages(endpoint)\n    return results\n</code></pre>"},{"location":"voyages_market_data/","title":"Package Documentation","text":"<p>Voyages API Package.</p> <p>Classes:</p> Name Description <code>VoyagesMarketDataAPI</code> <p>Represents Signal's VoyagesMarketData API.</p> <code>MatchedFixture</code> <p>Represents the matched fixture of a voyage.</p> <code>Fixture</code> <p>Represents a single fixture.</p> <code>VoyagesMarketData</code> <p>Holds all information on a single voyage</p>"},{"location":"voyages_market_data/#signal_ocean.voyages_market_data.Fixture","title":"<code>Fixture</code>  <code>dataclass</code>","text":"<p>Fixture information.</p> <p>Attributes:</p> Name Type Description <code>next_page_token</code> <p>String. The key that should be used as a parameter of the token to retrieve the next page.</p> <code>is_matched</code> <code>Optional[bool]</code> <p>Boolean. This will be true if the market data item is matched to the corresponding voyage.</p> <code>is_load_matched</code> <code>Optional[bool]</code> <p>Boolean. This will be true if the load of the market data item is matched to the corresponding voyage.</p> <code>is_discharge_matched</code> <code>Optional[bool]</code> <p>Boolean. This will be true if the load of the market data item is matched to the corresponding voyage.</p> <code>fixture_status_id</code> <code>Optional[int]</code> <p>0-&gt; OnSubs, 1-&gt; FullyFixed, 2-&gt; Failed, 3-&gt; Cancelled, 4-&gt; Available, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>fixture_status</code> <code>Optional[str]</code> <p>String, based on the status of the market data item. Potential values are OnSubs, FullyFixed, Failed, Cancelled, Available</p> Source code in <code>signal_ocean/voyages_market_data/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Fixture:\n    \"\"\"Fixture information.\n\n    Attributes:\n        next_page_token: String. The key that should be used as a parameter\n            of the token to retrieve the next page.\n        is_matched: Boolean. This will be true if the market data item is\n            matched to the corresponding voyage.\n        is_load_matched: Boolean. This will be true if the load of the market\n            data item is matched to the corresponding voyage.\n        is_discharge_matched: Boolean. This will be true if the load of the\n            market data item is matched to the corresponding voyage.\n        fixture_status_id: 0-&gt; OnSubs, 1-&gt; FullyFixed, 2-&gt; Failed,\n            3-&gt; Cancelled, 4-&gt; Available, -2-&gt; NotSet, -1-&gt; Unknown\n        fixture_status: String, based on the status of the market data item.\n            Potential values are OnSubs, FullyFixed, Failed, Cancelled,\n            Available\n    \"\"\"\n\n    fixture_id: Optional[int] = None\n    is_matched: Optional[bool] = None\n    is_load_matched: Optional[bool] = None\n    is_discharge_matched: Optional[bool] = None\n    fixture_status_id: Optional[int] = None\n    fixture_status: Optional[str] = None\n</code></pre>"},{"location":"voyages_market_data/#signal_ocean.voyages_market_data.MatchedFixture","title":"<code>MatchedFixture</code>  <code>dataclass</code>","text":"<p>Contains information about a single fixture.</p> <p>Attributes:</p> Name Type Description <code>fixture_status_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the different values of the FixtureStatus field. 0-&gt; OnSubs, 1-&gt; FullyFixed, 2-&gt; Failed, 3-&gt; Cancelled , 4-&gt; Available, 5-&gt; PossFixed, -2-&gt; NotSet, -1-&gt; Unknown.</p> <code>fixture_status</code> <code>Optional[str]</code> <p>String denoting the commercial status of a fixture if explicitly mentioned, like ffxd for fully fixed or subs for on subs.</p> <code>charter_type_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the different values of the ChartererType field. 0-&gt; Voyage, 1-&gt; Time charter</p> <code>charter_type</code> <code>Optional[str]</code> <p>String denoting the type of the charter</p> <code>charterer_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the company reported as charterer in at least one of the fixtures.</p> <code>charterer</code> <code>Optional[str]</code> <p>String, name of the company reported as charterer in at least one of the fixtures.</p> <code>laycan_from</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD indicates the earliest reported Laycan From (latest day of cancellation) across all fixtures.</p> <code>laycan_to</code> <code>Optional[datetime]</code> <p>Date, format YYYY-MM-DD indicates the latest reported Laycan To (latest day of cancellation) across all fixtures.</p> <code>load_geo_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the id of the load geo asset</p> <code>load_name</code> <code>Optional[str]</code> <p>String, name of the load geo asset</p> <code>load_taxonomy_id</code> <code>Optional[int]</code> <p>1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>load_taxonomy</code> <code>Optional[str]</code> <p>String, the taxonomy of the load geo asset</p> <code>load_geo_id2</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the id of the load geo asset</p> <code>load_name</code> <code>Optional[str]</code> <p>String, name of the load geo asset</p> <code>load_name2</code> <code>Optional[str]</code> <p>String, the taxonomy of the second load geo asset</p> <code>load_taxonomy_id2</code> <code>Optional[int]</code> <p>1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>load_taxonomy2</code> <code>Optional[str]</code> <p>String, the taxonomy of the load geo asset</p> <code>discharge_geo_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the id of the discharge geo asset</p> <code>discharge_name</code> <code>Optional[str]</code> <p>String, name of the discharge geo asset</p> <code>discharge_taxonomy_id</code> <code>Optional[int]</code> <p>1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>discharge_taxonomy</code> <code>Optional[str]</code> <p>String, the taxonomy of the discharge geo asset</p> <code>discharge_geo_id2</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the id of the discharge geo</p> <code>discharge_name2</code> <code>Optional[str]</code> <p>String, name of the discharge geo asset</p> <code>discharge_taxonomy_id2</code> <code>Optional[int]</code> <p>1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>discharge_taxonomy2</code> <code>Optional[str]</code> <p>String, the taxonomy of the discharge geo asset</p> <code>cargo_type_id</code> <code>Optional[int]</code> <p>numeric ID corresponding to the type of cargo the vessel carries in this voyage. For example 19-&gt; Crude Oil, 16-&gt;Fueloil, 9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil</p> <code>cargo_type</code> <code>Optional[str]</code> <p>String, it corresponds to the estimated cargo type the vessel carries according to the specific voyage, AIS information, jetty the vessel may have visited or information coming from market reports.</p> <code>cargo_group_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the high-level cargo the vessel carries in this voyage, therefore called cargo group. For example 130000-&gt;Dirty, 120000-&gt; Clean</p> <code>cargo_group</code> <code>Optional[str]</code> <p>String, it corresponds to the estimated high-level cargo the vessel carries in this voyage, according to AIS information and jetties the vessel may have visited or information coming from market reports.</p> <code>quantity</code> <code>Optional[int]</code> <p>Numeric, measured in kilotonnes [kt]. It is the cargo quantity reported in at least one of the market reports.</p> <code>quantity_buffer</code> <code>Optional[int]</code> <p>Buffer on the agreed quantity.</p> <code>rate</code> <code>Optional[int]</code> <p>Numeric, indicates the rate reported in at least one of the fixtures. If lump sum, the rate is reported in USD.</p> <code>rate_type</code> <code>Optional[str]</code> <p>String, indicates the type of rate reported in at least one of the fixtures. Main types are \"WS\" for World Scale, \"LS\" for Lump Sum, \"TCE\" ($/day) for Time Charter Equivalent.</p> <code>ballast_bonus_value</code> <code>Optional[int]</code> <p>Numeric, indicates the incentive or compensation paid to the ship owner for delivering the ship to the agreed delivery place. Derived from market info whenever available.</p> <code>ballast_bonus_type</code> <code>Optional[str]</code> <p>String, indicates the currency of the ballast bonus, \"$\"(dollars).</p> <code>delivery_geo_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the id of the delivery geo asset</p> <code>delivery_name</code> <code>Optional[str]</code> <p>String, name of the delivery geo asset</p> <code>delivery_taxonomy_id</code> <code>Optional[int]</code> <p>1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>delivery_taxonomy</code> <code>Optional[str]</code> <p>String, the taxonomy of the delivery geo asset</p> <code>delivery_date_from</code> <code>Optional[datetime]</code> <p>The start date of the delivery</p> <code>delivery_date_to</code> <code>Optional[datetime]</code> <p>The end date of the delivery</p> <code>redelivery_from_geo_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the id of the redelivery from geo</p> <code>redelivery_from_name</code> <code>Optional[str]</code> <p>String, name of the  redelivery from geo asset</p> <code>redelivery_from_taxonomy_id</code> <code>Optional[int]</code> <p>1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>redelivery_from_taxonomy</code> <code>Optional[str]</code> <p>String, the taxonomy of the redelivery from geo asset</p> <code>redelivery_to_geo_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the id of the redelivery to geo asset</p> <code>redelivery_to_name</code> <code>Optional[str]</code> <p>String, name of the  redelivery to geo asset</p> <code>redelivery_to_taxonomy_id</code> <code>Optional[int]</code> <p>1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>redelivery_to_taxonomy</code> <code>Optional[str]</code> <p>String, the taxonomy of the redelivery to geo asset</p> <code>user_entries</code> <code>Optional[int]</code> <p>The number of the user entries for the voyage</p> <code>full_fixtures</code> <code>Optional[int]</code> <p>The number of full fixtures for the voyage</p> <code>partial_fixtures</code> <code>Optional[int]</code> <p>The number of partial fixtures for the voyage</p> <code>is_coa</code> <code>Optional[bool]</code> <p>Boolean. Value is true if \"COA\" (Contract of Affreightment) is explicitly reported in at least one of the fixtures relative to the specific voyage</p> <code>is_owners_option</code> <code>Optional[bool]</code> <p>Boolean, indicating if owners option is agreed</p> <code>is_hold</code> <code>Optional[bool]</code> <p>Boolean. Value is true if \"Hold\" is explicitly reported in at least one of the fixtures relative to the specific voyage</p> <code>is_fio</code> <code>Optional[bool]</code> <p>Boolean, is free in and out. If true, charterer pays for loading and unloading</p> <code>sources</code> <code>Optional[Tuple[str, ...]]</code> <p>A list of the sources</p> Source code in <code>signal_ocean/voyages_market_data/models.py</code> <pre><code>@dataclass(frozen=True)\nclass MatchedFixture:\n    \"\"\"Contains information about a single fixture.\n\n    Attributes:\n        fixture_status_id: Numeric ID corresponding to the different values of\n            the FixtureStatus field. 0-&gt; OnSubs, 1-&gt; FullyFixed,\n            2-&gt; Failed, 3-&gt; Cancelled , 4-&gt; Available, 5-&gt; PossFixed,\n            -2-&gt; NotSet, -1-&gt; Unknown.\n        fixture_status: String denoting the commercial status of a fixture if\n            explicitly mentioned, like ffxd for fully fixed or subs for on\n            subs.\n        charter_type_id: Numeric ID corresponding to the different values of\n            the ChartererType field. 0-&gt; Voyage, 1-&gt; Time charter\n        charter_type: String denoting the type of the charter\n        charterer_id: Numeric ID corresponding to the company reported as\n            charterer in at least one of the fixtures.\n        charterer: String, name of the company reported as charterer in at\n            least one of the fixtures.\n        laycan_from: Date, format YYYY-MM-DD indicates the earliest reported\n            Laycan From (latest day of cancellation) across all fixtures.\n        laycan_to: Date, format YYYY-MM-DD indicates the latest reported\n            Laycan To (latest day of cancellation) across all fixtures.\n        load_geo_id: Numeric ID corresponding to the id of the load geo asset\n        load_name: String, name of the load geo asset\n        load_taxonomy_id: 1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0,\n            5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet,\n            -1-&gt; Unknown\n        load_taxonomy: String, the taxonomy of the load geo asset\n        load_geo_id2:  Numeric ID corresponding to the id of the load geo\n            asset\n        load_name: String, name of the load geo asset\n        load_name2: String, the taxonomy of the second load geo asset\n        load_taxonomy_id2: 1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country, 4-&gt; Level0,\n            5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid, -2-&gt; NotSet,\n            -1-&gt; Unknown\n        load_taxonomy2: String, the taxonomy of the load geo asset\n        discharge_geo_id: Numeric ID corresponding to the id of the discharge\n            geo asset\n        discharge_name: String, name of the discharge geo asset\n        discharge_taxonomy_id: 1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country,\n            4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid,\n            -2-&gt; NotSet, -1-&gt; Unknown\n        discharge_taxonomy: String, the taxonomy of the discharge geo asset\n        discharge_geo_id2: Numeric ID corresponding to the id of the discharge\n            geo\n        discharge_name2: String, name of the discharge geo asset\n        discharge_taxonomy_id2: 1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country,\n            4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid,\n            -2-&gt; NotSet, -1-&gt; Unknown\n        discharge_taxonomy2: String, the taxonomy of the discharge geo asset\n        cargo_type_id: numeric ID corresponding to the type of cargo the\n            vessel carries in this voyage. For example 19-&gt; Crude Oil,\n            16-&gt;Fueloil, 9-&gt; Naphtha, 135-&gt; Unleaded Motor Spirit, 12-&gt; Gasoil\n        cargo_type: String, it corresponds to the estimated cargo type the\n            vessel carries according to the specific voyage, AIS information,\n            jetty the vessel may have visited or information coming from\n            market reports.\n        cargo_group_id: Numeric ID corresponding to the high-level cargo the\n            vessel carries in this voyage, therefore called cargo group.\n            For example 130000-&gt;Dirty, 120000-&gt; Clean\n        cargo_group: String, it corresponds to the estimated high-level cargo\n            the vessel carries in this voyage, according to AIS information\n            and jetties the vessel may have visited or information coming from\n            market reports.\n        quantity: Numeric, measured in kilotonnes [kt]. It is the cargo\n            quantity reported in at least one of the market reports.\n        quantity_buffer: Buffer on the agreed quantity.\n        rate: Numeric, indicates the rate reported in at least one of the\n            fixtures. If lump sum, the rate is reported in USD.\n        rate_type: String, indicates the type of rate reported in at least\n            one of the fixtures. Main types are \"WS\" for World Scale, \"LS\"\n            for Lump Sum, \"TCE\" ($/day) for Time Charter Equivalent.\n        ballast_bonus_value: Numeric, indicates the incentive or compensation\n            paid to the ship owner for delivering the ship to the agreed\n            delivery place. Derived from market info whenever available.\n        ballast_bonus_type: String, indicates the currency of the ballast\n            bonus, \"$\"(dollars).\n        delivery_geo_id: Numeric ID corresponding to the id of the delivery\n            geo asset\n        delivery_name: String, name of the delivery geo asset\n        delivery_taxonomy_id: 1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country,\n            4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid,\n            -2-&gt; NotSet, -1-&gt; Unknown\n        delivery_taxonomy: String, the taxonomy of the delivery geo asset\n        delivery_date_from: The start date of the delivery\n        delivery_date_to: The end date of the delivery\n        redelivery_from_geo_id: Numeric ID corresponding to the id of the\n            redelivery from geo\n        redelivery_from_name: String, name of the  redelivery from geo asset\n        redelivery_from_taxonomy_id: 1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country,\n            4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid,\n            -2-&gt; NotSet, -1-&gt; Unknown\n        redelivery_from_taxonomy: String, the taxonomy of the redelivery from\n            geo asset\n        redelivery_to_geo_id: Numeric ID corresponding to the id of the\n            redelivery to geo asset\n        redelivery_to_name: String, name of the  redelivery to geo asset\n        redelivery_to_taxonomy_id: 1-&gt; GeoAsset, 2-&gt;  Port, 3-&gt; Country,\n            4-&gt; Level0, 5-&gt; Level1, 6-&gt; Level2, 7-&gt; Level3, -3-&gt; Invalid,\n            -2-&gt; NotSet, -1-&gt; Unknown\n        redelivery_to_taxonomy: String, the taxonomy of the redelivery to geo\n            asset\n        user_entries: The number of the user entries for the voyage\n        full_fixtures: The number of full fixtures for the voyage\n        partial_fixtures: The number of partial fixtures for the voyage\n        is_coa: Boolean. Value is true if \"COA\" (Contract of Affreightment)\n            is explicitly reported in at least one of the fixtures relative\n            to the specific voyage\n        is_owners_option: Boolean, indicating if owners option is agreed\n        is_hold: Boolean. Value is true if \"Hold\" is explicitly reported in\n            at least one of the fixtures relative to the specific voyage\n        is_fio: Boolean, is free in and out. If true, charterer pays for\n            loading and unloading\n        sources: A list of the sources\n\n    \"\"\"\n\n    fixture_status_id: Optional[int] = None\n    fixture_status: Optional[str] = None\n    charter_type_id: Optional[int] = None\n    charter_type: Optional[str] = None\n    fixture_date: Optional[datetime] = None\n    charterer_id: Optional[int] = None\n    charterer: Optional[str] = None\n    laycan_from: Optional[datetime] = None\n    laycan_to: Optional[datetime] = None\n    load_geo_id: Optional[int] = None\n    load_name: Optional[str] = None\n    load_taxonomy_id: Optional[int] = None\n    load_taxonomy: Optional[str] = None\n    load_geo_id2: Optional[int] = None\n    load_name2: Optional[str] = None\n    load_taxonomy_id2: Optional[int] = None\n    load_taxonomy2: Optional[str] = None\n    discharge_geo_id: Optional[int] = None\n    discharge_name: Optional[str] = None\n    discharge_taxonomy_id: Optional[int] = None\n    discharge_taxonomy: Optional[str] = None\n    discharge_geo_id2: Optional[int] = None\n    discharge_name2: Optional[str] = None\n    discharge_taxonomy_id2: Optional[int] = None\n    discharge_taxonomy2: Optional[str] = None\n    cargo_type_id: Optional[int] = None\n    cargo_type: Optional[str] = None\n    cargo_group_id: Optional[int] = None\n    cargo_group: Optional[str] = None\n    quantity: Optional[int] = None\n    quantity_buffer: Optional[int] = None\n    rate: Optional[int] = None\n    rate_type: Optional[str] = None\n    ballast_bonus_value: Optional[int] = None\n    ballast_bonus_type: Optional[str] = None\n    delivery_geo_id: Optional[int] = None\n    delivery_name: Optional[str] = None\n    delivery_taxonomy_id: Optional[int] = None\n    delivery_taxonomy: Optional[str] = None\n    delivery_date_from: Optional[datetime] = None\n    delivery_date_to: Optional[datetime] = None\n    redelivery_from_geo_id: Optional[int] = None\n    redelivery_from_name: Optional[str] = None\n    redelivery_from_taxonomy_id: Optional[int] = None\n    redelivery_from_taxonomy: Optional[str] = None\n    redelivery_to_geo_id: Optional[int] = None\n    redelivery_to_name: Optional[str] = None\n    redelivery_to_taxonomy_id: Optional[int] = None\n    redelivery_to_taxonomy: Optional[str] = None\n    user_entries: Optional[int] = None\n    full_fixtures: Optional[int] = None\n    partial_fixtures: Optional[int] = None\n    is_coa: Optional[bool] = None\n    is_owners_option: Optional[bool] = None\n    is_hold: Optional[bool] = None\n    is_fio: Optional[bool] = None\n    sources: Optional[Tuple[str, ...]] = None\n</code></pre>"},{"location":"voyages_market_data/#signal_ocean.voyages_market_data.VoyagesMarketData","title":"<code>VoyagesMarketData</code>  <code>dataclass</code>","text":"<p>Contains information about a single fixture.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>String. Uniquely identifies the market data result.</p> <code>voyage_id</code> <code>Optional[str]</code> <p>String. Uniquely identifies the voyage.</p> <code>imo</code> <code>Optional[int]</code> <p>A seven-digits number that uniquely identifies a ship and does not change when the ship's owner, country of registry or name of the vessel changes.</p> <code>voyage_number</code> <code>Optional[int]</code> <p>Numeric, a counter of the voyages for the same IMO.</p> <code>vessel_name</code> <code>Optional[str]</code> <p>The vessel name corresponding to that IMO at the time of that voyage.</p> <code>vessel_type_id</code> <code>Optional[int]</code> <p>0-&gt; Empty, 1-&gt; Tanker, 3-&gt; Dry, 4-&gt; Container, 5-&gt; Lng, 6-&gt; Lpg, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>vessel_type</code> <code>Optional[str]</code> <p>Description of the type of the vessel, based on the carried cargo. Main categories are Tankers, Dry (bulk carriers), Containers, LNG and LPG.</p> <code>vessel_class_id</code> <code>Optional[int]</code> <p>60-&gt; VLGCLpg, 61-&gt; MidsizeLpg, 62-&gt; HandyLpg, 63-&gt; SmallLpg, 69-&gt; VLOC, 70-&gt; Capesize, 72-&gt; PostPanamaxDry, 74-&gt; PanamaxDry, 75-&gt; Supramax, 76-&gt; Handymax, 77-&gt; Handysize, 78-&gt; ULCV, 79-&gt; NewPanamaxContainer, 80-&gt; PostPanamaxContainer, 81-&gt; PanamaxContainer, 82-&gt; FeedermaxContainer, 83-&gt; FeederContainer, 84-&gt; VLCC, 85-&gt; Suezmax, 86-&gt; Aframax, 87-&gt; PanamaxTanker, 88-&gt; MR2, 89-&gt; MR1, 90-&gt; Small, 91-&gt; LNGLng, 92-&gt; SmallDry, 94-&gt; ULCC, 95-&gt; SmallContainer</p> <code>vessel_class</code> <code>Optional[str]</code> <p>Name of the vessel class the vessel belongs to. Assignment of a vessel to a certain VesselClass is based on the VesselType and the value of its Deadweight (if Tanker or Dry), its LiquidCap (if LNG/LPG) or its TEU (if Containers). For example, an Aframax is a Tanker vessel with Deadweight within the range 82kt - 125kt, while a Capesize is a Dry vessel with Deadweight within the range 120kt-220kt. LR2 are defined as Aframax, as only Deadweight is used to define vessel classes.</p> <code>trade_id</code> <code>Optional[int]</code> <p>1-&gt; Crude, 2-&gt; Product, 3-&gt; Chemical, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>trade</code> <code>Optional[str]</code> <p>Additional attribute used to specify a Tanker vessel with finer granularity. It is derived by the last cargo carried by the vessel at the time of query. For example, an LR2 with fueloil as last cargo has VesselClass=Aframax and Trade=Product.</p> <code>commercial_operator_id</code> <code>Optional[int]</code> <p>Numeric ID corresponding to the maritime company that manages the vessel commercially.</p> <code>commercial_operator</code> <code>Optional[str]</code> <p>Name of the maritime company that manages the vessel commercially.</p> <code>deadweight</code> <code>Optional[int]</code> <p>Numeric, measured in tonnes [t], often shortened as DWT, denotes the total carrying capacity of the vessel including cargo, ballast water, stores, provisions, crew and so on.</p> <code>year_built</code> <code>Optional[int]</code> <p>Numeric, year format, the year the vessel was built.</p> <code>matched_fixture</code> <code>Optional[MatchedFixture]</code> <p>Nested object containing additional information on the matched fixture.</p> <code>fixtures</code> <code>Optional[Tuple[Fixture, ...]]</code> <p>Nested object containing information on fixtures for a given IMO and voyage.</p> Source code in <code>signal_ocean/voyages_market_data/models.py</code> <pre><code>@dataclass(frozen=True)\nclass VoyagesMarketData:\n    \"\"\"Contains information about a single fixture.\n\n    Attributes:\n        id: String. Uniquely identifies the market data result.\n        voyage_id: String. Uniquely identifies the voyage.\n        imo: A seven-digits number that uniquely identifies a ship and does\n            not change when the ship's owner, country of registry or name of\n            the vessel changes.\n        voyage_number: Numeric, a counter of the voyages for the same IMO.\n        vessel_name: The vessel name corresponding to that IMO at the time\n            of that voyage.\n        vessel_type_id: 0-&gt; Empty, 1-&gt; Tanker, 3-&gt; Dry, 4-&gt; Container,\n            5-&gt; Lng, 6-&gt; Lpg, -2-&gt; NotSet, -1-&gt; Unknown\n        vessel_type: Description of the type of the vessel, based on the\n            carried cargo. Main categories are Tankers, Dry (bulk carriers),\n            Containers, LNG and LPG.\n        vessel_class_id: 60-&gt; VLGCLpg, 61-&gt; MidsizeLpg, 62-&gt; HandyLpg,\n            63-&gt; SmallLpg, 69-&gt; VLOC, 70-&gt; Capesize, 72-&gt; PostPanamaxDry,\n            74-&gt; PanamaxDry, 75-&gt; Supramax, 76-&gt; Handymax, 77-&gt; Handysize,\n            78-&gt; ULCV, 79-&gt; NewPanamaxContainer, 80-&gt; PostPanamaxContainer,\n            81-&gt; PanamaxContainer, 82-&gt; FeedermaxContainer,\n            83-&gt; FeederContainer, 84-&gt; VLCC, 85-&gt; Suezmax, 86-&gt; Aframax,\n            87-&gt; PanamaxTanker, 88-&gt; MR2, 89-&gt; MR1, 90-&gt; Small, 91-&gt; LNGLng,\n            92-&gt; SmallDry, 94-&gt; ULCC, 95-&gt; SmallContainer\n        vessel_class: Name of the vessel class the vessel belongs to.\n            Assignment of a vessel to a certain VesselClass is based on the\n            VesselType and the value of its Deadweight (if Tanker or Dry),\n            its LiquidCap (if LNG/LPG) or its TEU (if Containers). For\n            example, an Aframax is a Tanker vessel with Deadweight within the\n            range 82kt - 125kt, while a Capesize is a Dry vessel with\n            Deadweight within the range 120kt-220kt. LR2 are defined as\n            Aframax, as only Deadweight is used to define vessel classes.\n        trade_id: 1-&gt; Crude, 2-&gt; Product, 3-&gt; Chemical, -2-&gt; NotSet,\n            -1-&gt; Unknown\n        trade: Additional attribute used to specify a Tanker vessel with finer\n            granularity. It is derived by the last cargo carried by the vessel\n            at the time of query. For example, an LR2 with fueloil as last\n            cargo has VesselClass=Aframax and Trade=Product.\n        commercial_operator_id: Numeric ID corresponding to the maritime\n            company that manages the vessel commercially.\n        commercial_operator: Name of the maritime company that manages the\n            vessel commercially.\n        deadweight: Numeric, measured in tonnes [t], often shortened as DWT,\n            denotes the total carrying capacity of the vessel including cargo,\n            ballast water, stores, provisions, crew and so on.\n        year_built: Numeric, year format, the year the vessel was built.\n        matched_fixture: Nested object containing additional information on\n            the matched fixture.\n        fixtures: Nested object containing information on fixtures for a given\n            IMO and voyage.\n\n\n    \"\"\"\n\n    id: Optional[str] = None\n    voyage_id: Optional[str] = None\n    imo: Optional[int] = None\n    voyage_number: Optional[int] = None\n    vessel_name: Optional[str] = None\n    vessel_type_id: Optional[int] = None\n    vessel_type: Optional[str] = None\n    vessel_class_id: Optional[int] = None\n    vessel_class: Optional[str] = None\n    trade_id: Optional[int] = None\n    trade: Optional[str] = None\n    commercial_operator_id: Optional[int] = None\n    commercial_operator: Optional[str] = None\n    deadweight: Optional[int] = None\n    year_built: Optional[int] = None\n    matched_fixture: Optional[MatchedFixture] = None\n    fixtures: Optional[Tuple[Fixture, ...]] = None\n</code></pre>"},{"location":"voyages_market_data/#signal_ocean.voyages_market_data.VoyagesMarketDataAPI","title":"<code>VoyagesMarketDataAPI</code>","text":"<p>Represents Signal's VoyagesMarketData API.</p> Source code in <code>signal_ocean/voyages_market_data/voyages_market_data_api.py</code> <pre><code>class VoyagesMarketDataAPI:\n    \"\"\"Represents Signal's VoyagesMarketData API.\"\"\"\n\n    relative_url = \"voyages-market-data-api/v1/\"\n    advanced_url = \"voyages-market-data-api/v1/marketData/search/advanced\"\n\n    def __init__(self, connection: Optional[Connection] = None):\n        \"\"\"Initializes VoyagesMarketDataAPI.\n\n        Args:\n            connection: API connection configuration. If not provided, the\n                default connection method is used.\n        \"\"\"\n        self.__connection = connection or Connection()\n\n    @staticmethod\n    def _get_endpoint(\n        imo: Optional[int] = None,\n        voyage_id: Optional[int] = None,\n        voyage_number: Optional[int] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_type_id: Optional[int] = None,\n        incremental: Optional[date] = None,\n        include_vessel_details: Optional[bool] = None,\n        include_fixtures: Optional[bool] = None,\n        include_matched_fixture: Optional[bool] = None,\n        include_labels: Optional[bool] = None,\n        filter_by_matched_fixture: Optional[bool] = None\n    ) -&gt; str:\n        \"\"\"Retrieves the endpoint to call to construct the request.\n\n        Args:\n            imo: Return only voyages for the provided vessel IMO. If None\n                voyages for all vessels are returned.\n            voyage_id: If provided only market data with the requested voyage\n                ID will be returned.\n            voyage_number: If provided only market data with the requested\n                voyageNumber will be returned.\n            vessel_class_id: If provided only market data with the requested\n                vesselClassId will be returned.\n            vessel_type_id: If provided only market data with the requested\n                vesselTypeId will be returned. Potential values are 0-&gt; Empty,\n                1-&gt; Tanker, 3-&gt; Dry, 4-&gt; Container, 5-&gt; Lng, 6-&gt; Lpg,\n                -2-&gt; NotSet, -1-&gt; Unknown\n            incremental:  Return voyages incrementally, including voyages that\n                may have been retrieved in previous calls and are now deleted.\n            include_vessel_details: If set to true the following fields will\n                be included in the response. VesselName, Deadweight,\n                YearBuilt, VesselClass, VesselType, Trade, CommercialOperator\n            include_fixtures: If True, information on fixtures will be\n                included in the response.\n            include_matched_fixture: If True, information on the matched\n                fixture will be included in the response.\n            include_labels: If set to true the following fields will be\n                included in the response. Charterer, LoadName, LoadTaxonomy,\n                LoadName2, LoadTaxonomy2, DischargeName, DischargeTaxonomy,\n                DischargeName2, DischargeTaxonomy2, CargoType, CargoGroup,\n                CargoGroupID, DeliveryName, DeliveryTaxonomy,\n                RedeliveryFromName, RedeliveryFromTaxonomy, RedeliveryToName,\n                RedeliveryToTaxonomy\n            filter_by_matched_fixture: If set to true, only results with a\n                matched fixture will be included in the response.\n\n        Returns:\n            The endpoint to call to retrieve the requested voyage market \\\n            data for the provided arguments.\n        \"\"\"\n        endpoint_params = {}\n\n        for key, value in locals().items():\n            if key in {'include_vessel_details', 'include_fixtures',\n                       'include_matched_fixture', 'include_labels',\n                       'filter_by_matched_fixture'}:\n                endpoint_params[key] = value\n\n        endpoint = \"marketData\"\n\n        if imo is not None:\n            endpoint += f\"/imo/{imo}\"\n            if voyage_number is not None:\n                endpoint += f\"/voyage/{voyage_number}\"\n        elif voyage_id is not None:\n            endpoint += f\"/type/{voyage_id}\"\n        elif vessel_class_id is not None:\n            endpoint += f\"/class/{vessel_class_id}\"\n        elif vessel_type_id is not None:\n            endpoint += f\"/type/{vessel_type_id}\"\n        else:\n            raise NotImplementedError(\n                \"please provide at least one of the following arguments: \"\n                \"imo, voyage_number, voyage_id, vessel_class_id, \"\n                \"vessel_type_id\")\n\n        if imo is None and incremental is not None:\n            endpoint += f\"/incremental/{incremental}\"\n\n        endpoint += \"?\"\n\n        params = urlencode(\n            {\n                _to_camel_case(key): value\n                for key, value in endpoint_params.items()\n                if value is not None\n            }\n        )\n        endpoint += params\n\n        return urljoin(VoyagesMarketDataAPI.relative_url, endpoint)\n\n    def _get_voyage_market_data_pages(\n        self, endpoint: str, token: Optional[str] = None\n    ) -&gt; Tuple[VoyagesMarketDataMultiple, Optional[NextRequestToken]]:\n        \"\"\"Retrieves data filtered for the provided parameters.\n\n        Args:\n            endpoint: The endpoint to call.\n            token: Next request token for incremental voyage market data.\n                Make consecutive requests until no next page token is\n                returned, gather and return data.\n\n        Returns:\n            Voyage market data gathered from the returned pages.\n            The next request token, to be used for incremental updates.\n        \"\"\"\n        results: List[VoyagesMarketData] = []\n        next_page_token = token\n        while True:\n            params = (\n                {\"token\": next_page_token}\n                if next_page_token is not None\n                else None\n            )\n            response = get_single(\n                self.__connection,\n                endpoint,\n                VoyagesMarketDataPagedResponse,\n                query_string=params,\n            )\n            if response is not None and response.data is not None:\n                results.extend(response.data)\n            next_page_token = (\n                response.next_page_token if response is not None else None\n            )\n\n            if next_page_token is None:\n                break\n\n        next_request_token = (\n            response.next_request_token if response is not None else None\n        )\n        return tuple(results), next_request_token\n\n    def get_voyage_market_data(\n        self,\n        imo: Optional[int] = None,\n        voyage_id: Optional[int] = None,\n        voyage_number: Optional[int] = None,\n        vessel_class_id: Optional[int] = None,\n        vessel_type_id: Optional[int] = None,\n        incremental: Optional[date] = None,\n        include_vessel_details: Optional[bool] = None,\n        include_fixtures: Optional[bool] = None,\n        include_matched_fixture: Optional[bool] = None,\n        include_labels: Optional[bool] = None,\n        filter_by_matched_fixture: Optional[bool] = None\n    ) -&gt; VoyagesMarketDataMultiple:\n        \"\"\"Retrieves market data filtered for the provided parameters.\n\n        Args:\n            imo: Return only voyages for the provided vessel IMO. If None\n                voyages for all vessels are returned.\n            voyage_id: If provided only market data with the requested voyage\n                ID will be returned.\n            voyage_number: If provided only market data with the requested\n                voyageNumber will be returned.\n            vessel_class_id: If provided only market data with the requested\n                vesselClassId will be returned.\n            vessel_type_id: If provided only market data with the requested\n                vesselTypeId will be returned. Potential values are 0-&gt; Empty,\n                1-&gt; Tanker, 3-&gt; Dry, 4-&gt; Container, 5-&gt; Lng, 6-&gt; Lpg,\n                -2-&gt; NotSet, -1-&gt; Unknown\n            incremental:  Return voyages incrementally, including voyages that\n                may have been retrieved in previous calls and are now deleted.\n            include_vessel_details: If set to true the following fields will\n                be included in the response. VesselName, Deadweight,\n                YearBuilt, VesselClass, VesselType, Trade, CommercialOperator\n            include_fixtures: If True, information on fixtures will be\n                included in the response.\n            include_matched_fixture: If True, information on the matched\n                fixture will be included in the response.\n            include_labels: If set to true the following fields will be\n                included in the response. Charterer, LoadName, LoadTaxonomy,\n                LoadName2, LoadTaxonomy2, DischargeName, DischargeTaxonomy,\n                DischargeName2, DischargeTaxonomy2, CargoType, CargoGroup,\n                CargoGroupID, DeliveryName, DeliveryTaxonomy,\n                RedeliveryFromName, RedeliveryFromTaxonomy, RedeliveryToName,\n                RedeliveryToTaxonomy.\n            filter_by_matched_fixture: If set to true, only results with a\n                matched fixture will be included in the response.\n\n        Returns:\n            A tuple containing the returned voyage market data.\n        \"\"\"\n        endpoint = self._get_endpoint(\n                        imo, voyage_id, voyage_number, vessel_class_id,\n                        vessel_type_id, incremental, include_vessel_details,\n                        include_fixtures, include_matched_fixture,\n                        include_labels, filter_by_matched_fixture\n        )\n\n        if imo is not None:\n            results = get_multiple(self.__connection, endpoint,\n                                   VoyagesMarketData, data_key_label='Data')\n        else:\n            results, _ = self._get_voyage_market_data_pages(endpoint)\n\n        return results\n\n    def get_voyage_market_data_advanced(\n        self,\n        imos: Optional[List[int]] = None,\n        voyage_ids: Optional[List[str]] = None,\n        vessel_class_ids: Optional[List[int]] = None,\n        trade_id: Optional[int] = None,\n        include_vessel_details: Optional[bool] = None,\n        include_fixtures: Optional[bool] = None,\n        include_lineups: Optional[bool] = None,\n        include_positions: Optional[bool] = None,\n        include_matched_fixture: Optional[bool] = None,\n        filter_by_matched_fixture: Optional[bool] = None,\n        fixture_date_from: Optional[date] = None,\n        fixture_date_to: Optional[date] = None,\n        laycan_date_from: Optional[date] = None,\n        laycan_date_to: Optional[date] = None,\n        include_labels: Optional[bool] = None,\n        charterer_ids_include: Optional[List[int]] = None,\n        charterer_ids_exclude: Optional[List[int]] = None,\n        cargo_type_ids_include: Optional[List[int]] = None,\n        cargo_type_ids_exclude: Optional[List[int]] = None,\n        sources_include: Optional[List[str]] = None,\n        sources_exclude: Optional[List[str]] = None\n    ) -&gt; VoyagesMarketDataMultiple:\n        \"\"\"Retrieves matched voyage market data for the provided parameters.\n\n        Args:\n            imos: Return only voyages for the provided vessel IMOs. If None\n                voyages for all vessels are returned.\n            voyage_ids: If provided only market data with the requested voyage\n                IDs will be returned.\n            vessel_class_ids: If provided only market data with the requested\n                vesselClassIds will be returned.\n            trade_id: If provided only market data for the requested trade id\n                will be returned.\n            include_vessel_details: If True the following fields will be\n                included in the response. VesselName, Deadweight, YearBuilt,\n                VesselClass, VesselType, Trade, CommercialOperator\n            include_fixtures: If True, information on fixtures will be\n                included in the response.\n            include_lineups: If True, information on fixtures will be included\n                in the response.\n            include_positions: If True, information on positions will be\n                included in the response.\n            include_matched_fixture: If True, information on the matched\n                fixture will be included in the response.\n            filter_by_matched_fixture: If set to true, only results with a\n                matched fixture will be included in the response.\n            fixture_date_from: Date format 'YYYY-MM-DD', if included market\n                data with a fixture date after the given date will be\n                returned.\n            fixture_date_to: Date format 'YYYY-MM-DD', if included market data\n                with a fixture date prior to the given date will be returned.\n            laycan_date_from: Date format 'YYYY-MM-DD', if included market\n                data with a laycan date after the given date will be returned.\n            laycan_date_to: Date format 'YYYY-MM-DD', if included market data\n                with a laycan date prior to the given date will be returned.\n            include_labels: If set to true the following fields will be\n                included in the response. Charterer, LoadName, LoadTaxonomy,\n                LoadName2, LoadTaxonomy2, DischargeName, DischargeTaxonomy,\n                DischargeName2, DischargeTaxonomy2, CargoType, CargoGroup,\n                CargoGroupID, DeliveryName, DeliveryTaxonomy,\n                RedeliveryFromName, RedeliveryFromTaxonomy, RedeliveryToName,\n                RedeliveryToTaxonomy.\n            charterer_ids_include: If provided, charterers with the given ids\n                will be included.\n            charterer_ids_exclude: If provided, charterers with the given ids\n                will be excluded.\n            cargo_type_ids_include: If provided, market data for the give\n                cargo type ids will be included.\n            cargo_type_ids_exclude: If provided, market data for the give\n                cargo type ids will be excluded.\n            sources_include: If provided, market data from the give sources\n                will be included.\n            sources_exclude: If provided, market data from the give sources\n                will be excluded.\n\n        Returns:\n            A tuple containing the returned voyage market data.\n        \"\"\"\n        data_body: Dict[str, Any] = {}\n\n        rename_keys = {'imos': 'IMOs',\n                       'voyage_ids': 'VoyageIDs',\n                       'vessel_class_ids': 'VesselClassIDs',\n                       'trade_id': 'TradeID',\n                       'charterer_ids_include': 'ChartererIDsInclude',\n                       'charterer_ids_exclude': 'ChartererIDsExclude',\n                       'cargo_type_ids_include': 'CargoTypeIDsInclude',\n                       'cargo_type_ids_exclude': 'CargoTypeIDsExclude'}\n\n        for key, value in locals().items():\n            if key != 'self':\n                if value:\n                    cc_key = _to_camel_case(key, rename_keys=rename_keys)\n                    data_body[cc_key] = value\n\n        del data_body['DataBody']\n        del data_body['RenameKeys']\n\n        endpoint = VoyagesMarketDataAPI.advanced_url\n\n        results: List[VoyagesMarketData] = []\n        next_page_token = None\n\n        while True:\n            if next_page_token is not None:\n                endpoint = VoyagesMarketDataAPI.advanced_url + \\\n                           f\"?token={next_page_token}\"\n            response = post_single(self.__connection,\n                                   endpoint,\n                                   VoyagesMarketDataPagedResponse,\n                                   query_string=data_body)\n            if response is not None and response.data is not None:\n                results.extend(response.data)\n            next_page_token = (\n                response.next_page_token if response is not None else None\n            )\n            if next_page_token is None:\n                break\n\n        next_request_token = (\n            response.next_request_token if response is not None else None\n        )\n\n        return tuple(results)\n</code></pre>"},{"location":"voyages_market_data/#signal_ocean.voyages_market_data.VoyagesMarketDataAPI.__init__","title":"<code>__init__(connection=None)</code>","text":"<p>Initializes VoyagesMarketDataAPI.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[Connection]</code> <p>API connection configuration. If not provided, the default connection method is used.</p> <code>None</code> Source code in <code>signal_ocean/voyages_market_data/voyages_market_data_api.py</code> <pre><code>def __init__(self, connection: Optional[Connection] = None):\n    \"\"\"Initializes VoyagesMarketDataAPI.\n\n    Args:\n        connection: API connection configuration. If not provided, the\n            default connection method is used.\n    \"\"\"\n    self.__connection = connection or Connection()\n</code></pre>"},{"location":"voyages_market_data/#signal_ocean.voyages_market_data.VoyagesMarketDataAPI.get_voyage_market_data","title":"<code>get_voyage_market_data(imo=None, voyage_id=None, voyage_number=None, vessel_class_id=None, vessel_type_id=None, incremental=None, include_vessel_details=None, include_fixtures=None, include_matched_fixture=None, include_labels=None, filter_by_matched_fixture=None)</code>","text":"<p>Retrieves market data filtered for the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imo</code> <code>Optional[int]</code> <p>Return only voyages for the provided vessel IMO. If None voyages for all vessels are returned.</p> <code>None</code> <code>voyage_id</code> <code>Optional[int]</code> <p>If provided only market data with the requested voyage ID will be returned.</p> <code>None</code> <code>voyage_number</code> <code>Optional[int]</code> <p>If provided only market data with the requested voyageNumber will be returned.</p> <code>None</code> <code>vessel_class_id</code> <code>Optional[int]</code> <p>If provided only market data with the requested vesselClassId will be returned.</p> <code>None</code> <code>vessel_type_id</code> <code>Optional[int]</code> <p>If provided only market data with the requested vesselTypeId will be returned. Potential values are 0-&gt; Empty, 1-&gt; Tanker, 3-&gt; Dry, 4-&gt; Container, 5-&gt; Lng, 6-&gt; Lpg, -2-&gt; NotSet, -1-&gt; Unknown</p> <code>None</code> <code>incremental</code> <code>Optional[date]</code> <p>Return voyages incrementally, including voyages that may have been retrieved in previous calls and are now deleted.</p> <code>None</code> <code>include_vessel_details</code> <code>Optional[bool]</code> <p>If set to true the following fields will be included in the response. VesselName, Deadweight, YearBuilt, VesselClass, VesselType, Trade, CommercialOperator</p> <code>None</code> <code>include_fixtures</code> <code>Optional[bool]</code> <p>If True, information on fixtures will be included in the response.</p> <code>None</code> <code>include_matched_fixture</code> <code>Optional[bool]</code> <p>If True, information on the matched fixture will be included in the response.</p> <code>None</code> <code>include_labels</code> <code>Optional[bool]</code> <p>If set to true the following fields will be included in the response. Charterer, LoadName, LoadTaxonomy, LoadName2, LoadTaxonomy2, DischargeName, DischargeTaxonomy, DischargeName2, DischargeTaxonomy2, CargoType, CargoGroup, CargoGroupID, DeliveryName, DeliveryTaxonomy, RedeliveryFromName, RedeliveryFromTaxonomy, RedeliveryToName, RedeliveryToTaxonomy.</p> <code>None</code> <code>filter_by_matched_fixture</code> <code>Optional[bool]</code> <p>If set to true, only results with a matched fixture will be included in the response.</p> <code>None</code> <p>Returns:</p> Type Description <code>VoyagesMarketDataMultiple</code> <p>A tuple containing the returned voyage market data.</p> Source code in <code>signal_ocean/voyages_market_data/voyages_market_data_api.py</code> <pre><code>def get_voyage_market_data(\n    self,\n    imo: Optional[int] = None,\n    voyage_id: Optional[int] = None,\n    voyage_number: Optional[int] = None,\n    vessel_class_id: Optional[int] = None,\n    vessel_type_id: Optional[int] = None,\n    incremental: Optional[date] = None,\n    include_vessel_details: Optional[bool] = None,\n    include_fixtures: Optional[bool] = None,\n    include_matched_fixture: Optional[bool] = None,\n    include_labels: Optional[bool] = None,\n    filter_by_matched_fixture: Optional[bool] = None\n) -&gt; VoyagesMarketDataMultiple:\n    \"\"\"Retrieves market data filtered for the provided parameters.\n\n    Args:\n        imo: Return only voyages for the provided vessel IMO. If None\n            voyages for all vessels are returned.\n        voyage_id: If provided only market data with the requested voyage\n            ID will be returned.\n        voyage_number: If provided only market data with the requested\n            voyageNumber will be returned.\n        vessel_class_id: If provided only market data with the requested\n            vesselClassId will be returned.\n        vessel_type_id: If provided only market data with the requested\n            vesselTypeId will be returned. Potential values are 0-&gt; Empty,\n            1-&gt; Tanker, 3-&gt; Dry, 4-&gt; Container, 5-&gt; Lng, 6-&gt; Lpg,\n            -2-&gt; NotSet, -1-&gt; Unknown\n        incremental:  Return voyages incrementally, including voyages that\n            may have been retrieved in previous calls and are now deleted.\n        include_vessel_details: If set to true the following fields will\n            be included in the response. VesselName, Deadweight,\n            YearBuilt, VesselClass, VesselType, Trade, CommercialOperator\n        include_fixtures: If True, information on fixtures will be\n            included in the response.\n        include_matched_fixture: If True, information on the matched\n            fixture will be included in the response.\n        include_labels: If set to true the following fields will be\n            included in the response. Charterer, LoadName, LoadTaxonomy,\n            LoadName2, LoadTaxonomy2, DischargeName, DischargeTaxonomy,\n            DischargeName2, DischargeTaxonomy2, CargoType, CargoGroup,\n            CargoGroupID, DeliveryName, DeliveryTaxonomy,\n            RedeliveryFromName, RedeliveryFromTaxonomy, RedeliveryToName,\n            RedeliveryToTaxonomy.\n        filter_by_matched_fixture: If set to true, only results with a\n            matched fixture will be included in the response.\n\n    Returns:\n        A tuple containing the returned voyage market data.\n    \"\"\"\n    endpoint = self._get_endpoint(\n                    imo, voyage_id, voyage_number, vessel_class_id,\n                    vessel_type_id, incremental, include_vessel_details,\n                    include_fixtures, include_matched_fixture,\n                    include_labels, filter_by_matched_fixture\n    )\n\n    if imo is not None:\n        results = get_multiple(self.__connection, endpoint,\n                               VoyagesMarketData, data_key_label='Data')\n    else:\n        results, _ = self._get_voyage_market_data_pages(endpoint)\n\n    return results\n</code></pre>"},{"location":"voyages_market_data/#signal_ocean.voyages_market_data.VoyagesMarketDataAPI.get_voyage_market_data_advanced","title":"<code>get_voyage_market_data_advanced(imos=None, voyage_ids=None, vessel_class_ids=None, trade_id=None, include_vessel_details=None, include_fixtures=None, include_lineups=None, include_positions=None, include_matched_fixture=None, filter_by_matched_fixture=None, fixture_date_from=None, fixture_date_to=None, laycan_date_from=None, laycan_date_to=None, include_labels=None, charterer_ids_include=None, charterer_ids_exclude=None, cargo_type_ids_include=None, cargo_type_ids_exclude=None, sources_include=None, sources_exclude=None)</code>","text":"<p>Retrieves matched voyage market data for the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>imos</code> <code>Optional[List[int]]</code> <p>Return only voyages for the provided vessel IMOs. If None voyages for all vessels are returned.</p> <code>None</code> <code>voyage_ids</code> <code>Optional[List[str]]</code> <p>If provided only market data with the requested voyage IDs will be returned.</p> <code>None</code> <code>vessel_class_ids</code> <code>Optional[List[int]]</code> <p>If provided only market data with the requested vesselClassIds will be returned.</p> <code>None</code> <code>trade_id</code> <code>Optional[int]</code> <p>If provided only market data for the requested trade id will be returned.</p> <code>None</code> <code>include_vessel_details</code> <code>Optional[bool]</code> <p>If True the following fields will be included in the response. VesselName, Deadweight, YearBuilt, VesselClass, VesselType, Trade, CommercialOperator</p> <code>None</code> <code>include_fixtures</code> <code>Optional[bool]</code> <p>If True, information on fixtures will be included in the response.</p> <code>None</code> <code>include_lineups</code> <code>Optional[bool]</code> <p>If True, information on fixtures will be included in the response.</p> <code>None</code> <code>include_positions</code> <code>Optional[bool]</code> <p>If True, information on positions will be included in the response.</p> <code>None</code> <code>include_matched_fixture</code> <code>Optional[bool]</code> <p>If True, information on the matched fixture will be included in the response.</p> <code>None</code> <code>filter_by_matched_fixture</code> <code>Optional[bool]</code> <p>If set to true, only results with a matched fixture will be included in the response.</p> <code>None</code> <code>fixture_date_from</code> <code>Optional[date]</code> <p>Date format 'YYYY-MM-DD', if included market data with a fixture date after the given date will be returned.</p> <code>None</code> <code>fixture_date_to</code> <code>Optional[date]</code> <p>Date format 'YYYY-MM-DD', if included market data with a fixture date prior to the given date will be returned.</p> <code>None</code> <code>laycan_date_from</code> <code>Optional[date]</code> <p>Date format 'YYYY-MM-DD', if included market data with a laycan date after the given date will be returned.</p> <code>None</code> <code>laycan_date_to</code> <code>Optional[date]</code> <p>Date format 'YYYY-MM-DD', if included market data with a laycan date prior to the given date will be returned.</p> <code>None</code> <code>include_labels</code> <code>Optional[bool]</code> <p>If set to true the following fields will be included in the response. Charterer, LoadName, LoadTaxonomy, LoadName2, LoadTaxonomy2, DischargeName, DischargeTaxonomy, DischargeName2, DischargeTaxonomy2, CargoType, CargoGroup, CargoGroupID, DeliveryName, DeliveryTaxonomy, RedeliveryFromName, RedeliveryFromTaxonomy, RedeliveryToName, RedeliveryToTaxonomy.</p> <code>None</code> <code>charterer_ids_include</code> <code>Optional[List[int]]</code> <p>If provided, charterers with the given ids will be included.</p> <code>None</code> <code>charterer_ids_exclude</code> <code>Optional[List[int]]</code> <p>If provided, charterers with the given ids will be excluded.</p> <code>None</code> <code>cargo_type_ids_include</code> <code>Optional[List[int]]</code> <p>If provided, market data for the give cargo type ids will be included.</p> <code>None</code> <code>cargo_type_ids_exclude</code> <code>Optional[List[int]]</code> <p>If provided, market data for the give cargo type ids will be excluded.</p> <code>None</code> <code>sources_include</code> <code>Optional[List[str]]</code> <p>If provided, market data from the give sources will be included.</p> <code>None</code> <code>sources_exclude</code> <code>Optional[List[str]]</code> <p>If provided, market data from the give sources will be excluded.</p> <code>None</code> <p>Returns:</p> Type Description <code>VoyagesMarketDataMultiple</code> <p>A tuple containing the returned voyage market data.</p> Source code in <code>signal_ocean/voyages_market_data/voyages_market_data_api.py</code> <pre><code>def get_voyage_market_data_advanced(\n    self,\n    imos: Optional[List[int]] = None,\n    voyage_ids: Optional[List[str]] = None,\n    vessel_class_ids: Optional[List[int]] = None,\n    trade_id: Optional[int] = None,\n    include_vessel_details: Optional[bool] = None,\n    include_fixtures: Optional[bool] = None,\n    include_lineups: Optional[bool] = None,\n    include_positions: Optional[bool] = None,\n    include_matched_fixture: Optional[bool] = None,\n    filter_by_matched_fixture: Optional[bool] = None,\n    fixture_date_from: Optional[date] = None,\n    fixture_date_to: Optional[date] = None,\n    laycan_date_from: Optional[date] = None,\n    laycan_date_to: Optional[date] = None,\n    include_labels: Optional[bool] = None,\n    charterer_ids_include: Optional[List[int]] = None,\n    charterer_ids_exclude: Optional[List[int]] = None,\n    cargo_type_ids_include: Optional[List[int]] = None,\n    cargo_type_ids_exclude: Optional[List[int]] = None,\n    sources_include: Optional[List[str]] = None,\n    sources_exclude: Optional[List[str]] = None\n) -&gt; VoyagesMarketDataMultiple:\n    \"\"\"Retrieves matched voyage market data for the provided parameters.\n\n    Args:\n        imos: Return only voyages for the provided vessel IMOs. If None\n            voyages for all vessels are returned.\n        voyage_ids: If provided only market data with the requested voyage\n            IDs will be returned.\n        vessel_class_ids: If provided only market data with the requested\n            vesselClassIds will be returned.\n        trade_id: If provided only market data for the requested trade id\n            will be returned.\n        include_vessel_details: If True the following fields will be\n            included in the response. VesselName, Deadweight, YearBuilt,\n            VesselClass, VesselType, Trade, CommercialOperator\n        include_fixtures: If True, information on fixtures will be\n            included in the response.\n        include_lineups: If True, information on fixtures will be included\n            in the response.\n        include_positions: If True, information on positions will be\n            included in the response.\n        include_matched_fixture: If True, information on the matched\n            fixture will be included in the response.\n        filter_by_matched_fixture: If set to true, only results with a\n            matched fixture will be included in the response.\n        fixture_date_from: Date format 'YYYY-MM-DD', if included market\n            data with a fixture date after the given date will be\n            returned.\n        fixture_date_to: Date format 'YYYY-MM-DD', if included market data\n            with a fixture date prior to the given date will be returned.\n        laycan_date_from: Date format 'YYYY-MM-DD', if included market\n            data with a laycan date after the given date will be returned.\n        laycan_date_to: Date format 'YYYY-MM-DD', if included market data\n            with a laycan date prior to the given date will be returned.\n        include_labels: If set to true the following fields will be\n            included in the response. Charterer, LoadName, LoadTaxonomy,\n            LoadName2, LoadTaxonomy2, DischargeName, DischargeTaxonomy,\n            DischargeName2, DischargeTaxonomy2, CargoType, CargoGroup,\n            CargoGroupID, DeliveryName, DeliveryTaxonomy,\n            RedeliveryFromName, RedeliveryFromTaxonomy, RedeliveryToName,\n            RedeliveryToTaxonomy.\n        charterer_ids_include: If provided, charterers with the given ids\n            will be included.\n        charterer_ids_exclude: If provided, charterers with the given ids\n            will be excluded.\n        cargo_type_ids_include: If provided, market data for the give\n            cargo type ids will be included.\n        cargo_type_ids_exclude: If provided, market data for the give\n            cargo type ids will be excluded.\n        sources_include: If provided, market data from the give sources\n            will be included.\n        sources_exclude: If provided, market data from the give sources\n            will be excluded.\n\n    Returns:\n        A tuple containing the returned voyage market data.\n    \"\"\"\n    data_body: Dict[str, Any] = {}\n\n    rename_keys = {'imos': 'IMOs',\n                   'voyage_ids': 'VoyageIDs',\n                   'vessel_class_ids': 'VesselClassIDs',\n                   'trade_id': 'TradeID',\n                   'charterer_ids_include': 'ChartererIDsInclude',\n                   'charterer_ids_exclude': 'ChartererIDsExclude',\n                   'cargo_type_ids_include': 'CargoTypeIDsInclude',\n                   'cargo_type_ids_exclude': 'CargoTypeIDsExclude'}\n\n    for key, value in locals().items():\n        if key != 'self':\n            if value:\n                cc_key = _to_camel_case(key, rename_keys=rename_keys)\n                data_body[cc_key] = value\n\n    del data_body['DataBody']\n    del data_body['RenameKeys']\n\n    endpoint = VoyagesMarketDataAPI.advanced_url\n\n    results: List[VoyagesMarketData] = []\n    next_page_token = None\n\n    while True:\n        if next_page_token is not None:\n            endpoint = VoyagesMarketDataAPI.advanced_url + \\\n                       f\"?token={next_page_token}\"\n        response = post_single(self.__connection,\n                               endpoint,\n                               VoyagesMarketDataPagedResponse,\n                               query_string=data_body)\n        if response is not None and response.data is not None:\n            results.extend(response.data)\n        next_page_token = (\n            response.next_page_token if response is not None else None\n        )\n        if next_page_token is None:\n            break\n\n    next_request_token = (\n        response.next_request_token if response is not None else None\n    )\n\n    return tuple(results)\n</code></pre>"},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/","title":"MR2 ARA Supply Versus Market Rates","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <pre>Requirement already satisfied: signal-ocean in /usr/local/lib/python3.10/dist-packages (13.0.0)\nRequirement already satisfied: requests&lt;3,&gt;=2.23.0 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (2.32.3)\nRequirement already satisfied: python-dateutil&lt;3,&gt;=2.8.1 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (2.8.2)\nRequirement already satisfied: pandas&lt;3,&gt;=2 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (2.2.2)\nRequirement already satisfied: numpy&gt;=1.18.5 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (1.26.4)\nRequirement already satisfied: strictly-typed-pandas==0.1.4 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (0.1.4)\nRequirement already satisfied: typeguard&lt;3.0.0,&gt;=2.13.3 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (2.13.3)\nRequirement already satisfied: pandas-stubs in /usr/local/lib/python3.10/dist-packages (from strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2.2.2.240909)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.10/dist-packages (from pandas&lt;3,&gt;=2-&gt;signal-ocean) (2024.2)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.10/dist-packages (from pandas&lt;3,&gt;=2-&gt;signal-ocean) (2024.2)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.10/dist-packages (from python-dateutil&lt;3,&gt;=2.8.1-&gt;signal-ocean) (1.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /usr/local/lib/python3.10/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.4.0)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.10/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.2.3)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2024.8.30)\nRequirement already satisfied: types-pytz&gt;=2022.1.1 in /usr/local/lib/python3.10/dist-packages (from pandas-stubs-&gt;strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2024.2.0.20241003)\n</pre> <p>Import required dependencies:</p> In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom datetime import date, timedelta\nfrom signal_ocean import Connection\nfrom signal_ocean.market_rates import MarketRatesAPI, CargoId\nfrom signal_ocean.tonnage_list import (\n    TonnageListAPI,\n    VesselClassFilter,\n    PortFilter,\n    VesselFilter,\n    PushType,\n    MarketDeployment,\n    CommercialStatus,\n    VesselSubclass,\n    IndexLevel,\n    DateRange,\n)\n</pre> import pandas as pd import matplotlib.pyplot as plt  from datetime import date, timedelta from signal_ocean import Connection from signal_ocean.market_rates import MarketRatesAPI, CargoId from signal_ocean.tonnage_list import (     TonnageListAPI,     VesselClassFilter,     PortFilter,     VesselFilter,     PushType,     MarketDeployment,     CommercialStatus,     VesselSubclass,     IndexLevel,     DateRange, )  In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = \"\"  # Replace with your subscription key\nvessel_class_filter = VesselClassFilter(name_like=\"MR2\") # Focus on the MR2 segment\nload_port_filter = PortFilter(name_like=\"Rotterdam\") # As a basis port for the Tonnage List Rotterdam is chosen\ndays_back = 365 # Last year info\nlaycan_end_in_days = 7 # Laycan day window\n\nvessel_filter = VesselFilter(\n    vessel_subclass=VesselSubclass.CLEAN, # Focusing on Clean carrying MR2s i.e. LR2\n    latest_ais_since=5) # Filtering out vessels missing recent AIS info\n'''\nmarket_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT], # Only Relevant for Tankers\npush_types=[PushType.PUSHED_POSS, PushType.PUSHED], # Signal Ocean Platform UI filter: Pushed State\ncommercial_statuses= [CommercialStatus.ON_SUBS] #[CommercialStatus.AVAILABLE, CommercialStatus.ON_SUBS, CommercialStatus.FAILED, CommercialStatus.CANCELLED], # Signal Ocean Platform UI filter: Availability State\noperational_statuses=[OperationalStatus.BALLAST_UNFIXED] #, OperationalStatus.BALLAST_FIXED], ## Signal Ocean Platform UI filter: Voyage State\n'''\n\n\nroute_description = \"MR2 - Cont/USAC\" # Route Abbreviation for Market Rates retrieval later\n\ntoday = date.today()\nstart_date = today - timedelta(days=days_back) # set start date for the Chart window\nend_date = today - timedelta(1) # set  end date for the Chart window\n</pre> signal_ocean_api_key = \"\"  # Replace with your subscription key vessel_class_filter = VesselClassFilter(name_like=\"MR2\") # Focus on the MR2 segment load_port_filter = PortFilter(name_like=\"Rotterdam\") # As a basis port for the Tonnage List Rotterdam is chosen days_back = 365 # Last year info laycan_end_in_days = 7 # Laycan day window  vessel_filter = VesselFilter(     vessel_subclass=VesselSubclass.CLEAN, # Focusing on Clean carrying MR2s i.e. LR2     latest_ais_since=5) # Filtering out vessels missing recent AIS info ''' market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT], # Only Relevant for Tankers push_types=[PushType.PUSHED_POSS, PushType.PUSHED], # Signal Ocean Platform UI filter: Pushed State commercial_statuses= [CommercialStatus.ON_SUBS] #[CommercialStatus.AVAILABLE, CommercialStatus.ON_SUBS, CommercialStatus.FAILED, CommercialStatus.CANCELLED], # Signal Ocean Platform UI filter: Availability State operational_statuses=[OperationalStatus.BALLAST_UNFIXED] #, OperationalStatus.BALLAST_FIXED], ## Signal Ocean Platform UI filter: Voyage State '''   route_description = \"MR2 - Cont/USAC\" # Route Abbreviation for Market Rates retrieval later  today = date.today() start_date = today - timedelta(days=days_back) # set start date for the Chart window end_date = today - timedelta(1) # set  end date for the Chart window  <p>Get your personal Signal Ocean API subscription key (acquired here) and use it to create a <code>Connection</code>:</p> In\u00a0[\u00a0]: Copied! <pre>connection = Connection(signal_ocean_api_key)\n</pre> connection = Connection(signal_ocean_api_key) <p>Create instances of APIs used throughout this notebook:</p> In\u00a0[\u00a0]: Copied! <pre>tonnage_list_api = TonnageListAPI(connection)\nmarket_rate_api = MarketRatesAPI(connection)\n</pre> tonnage_list_api = TonnageListAPI(connection) market_rate_api = MarketRatesAPI(connection) <p>For more information, see the Tonnage List and  Market Rates API sections.</p> In\u00a0[\u00a0]: Copied! <pre>load_port = tonnage_list_api.get_ports(load_port_filter)[0] # Retrieve load port ID\nload_port\n</pre> load_port = tonnage_list_api.get_ports(load_port_filter)[0] # Retrieve load port ID load_port Out[\u00a0]: <pre>Port(id=3689, name='Rotterdam')</pre> In\u00a0[\u00a0]: Copied! <pre>vessel_class = tonnage_list_api.get_vessel_classes(vessel_class_filter)[0] # Retrieve vessel class object\nload_port = tonnage_list_api.get_ports(load_port_filter)[0] # Retrieve load port object\n\nhtl = tonnage_list_api.get_historical_tonnage_list(\n    loading_port = load_port,                       # load port of the requested Tonnage List\n    vessel_class = vessel_class,                    # vessel class of interest\n    laycan_end_in_days = laycan_end_in_days,        # laycan period\n    date_range = DateRange(start_date, end_date),   # a range for which are the tonnage lists of interest\n    vessel_filter = vessel_filter,                  # which vessels should be included in the response\n)\n\nhtl_for_supply_trend = htl.to_data_frame()\nhtl_for_supply_trend\n</pre> vessel_class = tonnage_list_api.get_vessel_classes(vessel_class_filter)[0] # Retrieve vessel class object load_port = tonnage_list_api.get_ports(load_port_filter)[0] # Retrieve load port object  htl = tonnage_list_api.get_historical_tonnage_list(     loading_port = load_port,                       # load port of the requested Tonnage List     vessel_class = vessel_class,                    # vessel class of interest     laycan_end_in_days = laycan_end_in_days,        # laycan period     date_range = DateRange(start_date, end_date),   # a range for which are the tonnage lists of interest     vessel_filter = vessel_filter,                  # which vessels should be included in the response )  htl_for_supply_trend = htl.to_data_frame() htl_for_supply_trend  Out[\u00a0]: name vessel_class ice_class year_built deadweight length_overall breadth_extreme subclass market_deployment_point_in_time push_type_point_in_time ... open_prediction_accuracy_point_in_time open_country_point_in_time open_narrow_area_point_in_time open_wide_area_point_in_time availability_port_type_point_in_time availability_date_type_point_in_time fixture_type_point_in_time current_vessel_sub_type_id_point_in_time current_vessel_sub_type_point_in_time willing_to_switch_current_vessel_sub_type_point_in_time date imo 2024-12-15 12:00:00+00:00 9447744 NH Erle MR2 NaN 2010 49999 183.30 32 Clean Spot Pushed ... Narrow Area Netherlands Continent UK Continent Source Source NaN 2 Clean False 9882396 Solar Katherine MR2 1A 2020 49990 183.00 32 Clean Relet Pushed ... Narrow Area Netherlands Continent UK Continent Source Source NaN 2 Clean False 9718870 Silver Heba MR2 NaN 2016 49897 183.06 32 Clean Relet Pushed ... Narrow Area Netherlands Continent UK Continent Source Source NaN 2 Clean False 9308132 Unite MR2 NaN 2006 50322 189.02 32 Clean Spot Not Pushed ... Narrow Area Belgium Continent UK Continent Source Source NaN 2 Clean False 9364588 Jane MR2 NaN 2008 51505 183.00 32 Clean Spot Not Pushed ... Narrow Area Netherlands Continent UK Continent Source Source NaN 2 Clean False ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2024-12-16 12:00:00+00:00 9789257 Atlantic Falcon MR2 NaN 2018 49951 183.06 32 Clean Spot Pushed ... Port Poland Baltic Sea Low Baltic Source Source NaN 2 Clean False 9315068 Star Osprey MR2 NaN 2007 51213 183.00 32 Clean Spot Pushed ... Port Belgium Continent UK Continent Source Source NaN 2 Clean False 9708760 Shenandoah Trader MR2 NaN 2015 50124 183.00 32 Clean Contract Not Pushed ... Narrow Area Italy Central Mediterranean Mediterranean Source Source NaN 2 Clean False 9345659 Papillon MR2 NaN 2007 47302 182.50 32 Clean Spot Pushed ... Narrow Area Mauritania Africa Atlantic Coast West Africa Source Source NaN 2 Clean False 9344007 Hardrada MR2 NaN 2007 45983 179.88 32 Clean Spot Not Pushed ... Port Russian Federation Baltic Sea Upper Baltic Source Prediction NaN 2 Clean False <p>28237 rows \u00d7 29 columns</p> <p>We'll need a helper function to find our desired route for the market rates:</p> In\u00a0[\u00a0]: Copied! <pre>def return_selected_route(vessel_class, route_description):\n    vessel_routes = market_rate_api.get_routes(vessel_class_id=vessel_class.id)\n    for i, _ in enumerate(vessel_routes):\n        if vessel_routes[i].description == route_description:\n            break\n    return vessel_routes[i]\n</pre> def return_selected_route(vessel_class, route_description):     vessel_routes = market_rate_api.get_routes(vessel_class_id=vessel_class.id)     for i, _ in enumerate(vessel_routes):         if vessel_routes[i].description == route_description:             break     return vessel_routes[i]  <p>Which we can use to find the route object returned from the Market Rates API:</p> In\u00a0[\u00a0]: Copied! <pre>market_rate_route = return_selected_route(vessel_class, route_description)\nmarket_rate_route\n</pre> market_rate_route = return_selected_route(vessel_class, route_description) market_rate_route Out[\u00a0]: <pre>Route(id='R27', description='MR2 - Cont/USAC', unit='WS', vessel_class_id=88, cargo_id=1, load_port_id=3688, discharge_port_id=3864, load_area_id=24758, discharge_area_id=24747, load_port_2_id=None, discharge_port_2_id=None, load_area_2_id=None, discharge_area_2_id=None, deprecated_to=None, deprecated_since=None)</pre> <p>And use it to query for market rates:</p> In\u00a0[\u00a0]: Copied! <pre>market_rates = market_rate_api.get_market_rates(\n    start_date = start_date,                          # Date from which we want the market rates for the specific route\n    route_id = market_rate_route.id,                  # The ID of the route of interest\n    vessel_class_id = vessel_class.id,                # The ID of the specific vessel class that we want the rates for\n    end_date = end_date,                              # Last day of the time window that we want the rates for\n    cargo_id = CargoId(market_rate_route.cargo_id)    # Cargo type that we want to concentrate to\n)\n\nmarket_rates = pd.DataFrame([vars(vr) for vr in market_rates])\nmarket_rates[\"rate_date\"] = pd.to_datetime(market_rates[\"rate_date\"])\nmarket_rates.set_index(\"rate_date\", inplace=True)\nmarket_rates\n</pre> market_rates = market_rate_api.get_market_rates(     start_date = start_date,                          # Date from which we want the market rates for the specific route     route_id = market_rate_route.id,                  # The ID of the route of interest     vessel_class_id = vessel_class.id,                # The ID of the specific vessel class that we want the rates for     end_date = end_date,                              # Last day of the time window that we want the rates for     cargo_id = CargoId(market_rate_route.cargo_id)    # Cargo type that we want to concentrate to )  market_rates = pd.DataFrame([vars(vr) for vr in market_rates]) market_rates[\"rate_date\"] = pd.to_datetime(market_rates[\"rate_date\"]) market_rates.set_index(\"rate_date\", inplace=True) market_rates  Out[\u00a0]: route_id rate_value unit vessel_class_id deprecated_to rate_date 2023-12-17 R27 195.0 WS 88 None 2023-12-18 R27 195.0 WS 88 None 2023-12-19 R27 180.0 WS 88 None 2023-12-20 R27 175.0 WS 88 None 2023-12-21 R27 180.0 WS 88 None ... ... ... ... ... ... 2024-12-12 R27 145.0 WS 88 None 2024-12-13 R27 140.0 WS 88 None 2024-12-14 R27 140.0 WS 88 None 2024-12-15 R27 140.0 WS 88 None 2024-12-16 R27 135.0 WS 88 None <p>366 rows \u00d7 5 columns</p> In\u00a0[\u00a0]: Copied! <pre>def plot_drawing():\n  fig, axs = plt.subplots(figsize=(15, 6))\n\n  supply_trend = htl_for_supply_trend.groupby(IndexLevel.DATE, sort=True).size()\n  supply_trend.index = supply_trend.index.strftime(\"%d %b %y\")\n\n  # Left axis (Supply plot)\n  supply_plot = supply_trend.plot(ax=axs, x=\"date\", color=\"#3086EF\", marker=\"o\")\n  supply_plot.set_ylabel(\n      \"Vessel count\", color=plt.gca().lines[-1].get_color(), fontsize=14\n  )\n  supply_plot.set_ylim(ymin=0)\n\n  # Right axis (Market rate plot)\n  market_rates.index = market_rates.index.strftime(\"%d %b %y\")\n  mr_plot = market_rates.plot(\n      ax=axs, y=\"rate_value\", secondary_y=True, color=\"#F06C6E\", marker=\"d\"\n  )\n  mr_plot.set_ylabel(\n      \"Market Rates (WS)\", color=plt.gca().lines[-1].get_color(), fontsize=14\n  )\n\n  axs.set_xlim(0, len(supply_trend) - 1)\n  axs.set_xlabel(\"\")\n  axs.get_legend().remove()\n</pre> def plot_drawing():   fig, axs = plt.subplots(figsize=(15, 6))    supply_trend = htl_for_supply_trend.groupby(IndexLevel.DATE, sort=True).size()   supply_trend.index = supply_trend.index.strftime(\"%d %b %y\")    # Left axis (Supply plot)   supply_plot = supply_trend.plot(ax=axs, x=\"date\", color=\"#3086EF\", marker=\"o\")   supply_plot.set_ylabel(       \"Vessel count\", color=plt.gca().lines[-1].get_color(), fontsize=14   )   supply_plot.set_ylim(ymin=0)    # Right axis (Market rate plot)   market_rates.index = market_rates.index.strftime(\"%d %b %y\")   mr_plot = market_rates.plot(       ax=axs, y=\"rate_value\", secondary_y=True, color=\"#F06C6E\", marker=\"d\"   )   mr_plot.set_ylabel(       \"Market Rates (WS)\", color=plt.gca().lines[-1].get_color(), fontsize=14   )    axs.set_xlim(0, len(supply_trend) - 1)   axs.set_xlabel(\"\")   axs.get_legend().remove()  In\u00a0[\u00a0]: Copied! <pre>plot_drawing()\n</pre> plot_drawing()"},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#mr2-ara-supply-versus-market-rates","title":"MR2 ARA Supply Versus Market Rates\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":"<p>APIs Used : Tonnage List API, Market Rates API</p> <p>Description :</p> <p>In this Notebook the main goal is to construct and display the vessel count per day for MR2 tankers with respect to ARA area.</p> <p>The script walks though the installation of the signal ocean SDK and import of the required dependencies used for the processing of the data.</p> <p>Also the parameters <code>vessel_class_filter, load_port_filter, days_back, laycan_end_in_days, vessel_filter, route_description, start_date, end_date</code> are initialized, in order to be used to achieve the desired output.</p> <p>Next the Tonnage List API and the Market Rates API are called to fetch the corresponding data to our query based on the parameters set.</p> <p>Lastly, we display the chart of the data that we retrieved and present them as time series.</p> <p>Output : Time-Series Graph displaying the historic supply of MR2 Vessels in ARA region versus the corresponding Market Rates for the past year.</p>"},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#setup","title":"Setup\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#parametrization","title":"Parametrization\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#main-codeblock","title":"Main CodeBlock\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#fetch-the-historical-tonnage-list","title":"Fetch the historical tonnage list\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#get-daily-market-rates-for-the-route-of-interest","title":"Get daily market rates for the route of interest\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#plot-the-daily-supply-trend-with-market-rates","title":"Plot the daily supply trend with market rates\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/MR2_ARA_Supply_versus_Market_Rates/#output","title":"Output\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/","title":"Supply trend with market rates","text":"In\u00a0[28]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <pre>Requirement already satisfied: signal-ocean in c:\\users\\kimon\\workspace\\signalsdk (2.0.0)\nRequirement already satisfied: requests&lt;3,&gt;=2.23.0 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from signal-ocean) (2.28.1)\nRequirement already satisfied: python-dateutil&lt;3,&gt;=2.8.1 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from signal-ocean) (2.8.2)\nRequirement already satisfied: pandas&lt;2,&gt;=1.0.3 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from signal-ocean) (1.3.0)\nRequirement already satisfied: numpy&gt;=1.18.5 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from signal-ocean) (1.23.5)\nRequirement already satisfied: strictly-typed-pandas==0.1.4 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from signal-ocean) (0.1.4)\nRequirement already satisfied: typeguard&gt;=2.13.3 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from signal-ocean) (2.13.3)\nRequirement already satisfied: pandas-stubs in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from strictly-typed-pandas==0.1.4-&gt;signal-ocean) (1.4.3.220718)\nRequirement already satisfied: pytz&gt;=2017.3 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from pandas&lt;2,&gt;=1.0.3-&gt;signal-ocean) (2020.1)\nRequirement already satisfied: six&gt;=1.5 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from python-dateutil&lt;3,&gt;=2.8.1-&gt;signal-ocean) (1.15.0)\nRequirement already satisfied: charset-normalizer&lt;3,&gt;=2 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.1.1)\nRequirement already satisfied: certifi&gt;=2017.4.17 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2020.4.5.1)\nRequirement already satisfied: urllib3&lt;1.27,&gt;=1.21.1 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (1.25.9)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.9)\nRequirement already satisfied: types-pytz&gt;=2022.1.1 in c:\\users\\kimon\\workspace\\signalsdk\\venv2\\lib\\site-packages (from pandas-stubs-&gt;strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2022.1.2)\n\n[notice] A new release of pip available: 22.2 -&gt; 22.3.1\n[notice] To update, run: python.exe -m pip install --upgrade pip\n</pre> <p>Import required dependencies:</p> In\u00a0[38]: Copied! <pre>from datetime import date, timedelta\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nfrom signal_ocean.market_rates import MarketRatesAPI, CargoId\nfrom signal_ocean.tonnage_list import (\n    TonnageListAPI,\n    VesselClassFilter,\n    PortFilter,\n    VesselFilter,\n    PushType,\n    MarketDeployment,\n    CommercialStatus,\n    VesselSubclass,\n    IndexLevel,\n    DateRange,\n)\n</pre> from datetime import date, timedelta  import pandas as pd import matplotlib.pyplot as plt  from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI from signal_ocean.market_rates import MarketRatesAPI, CargoId from signal_ocean.tonnage_list import (     TonnageListAPI,     VesselClassFilter,     PortFilter,     VesselFilter,     PushType,     MarketDeployment,     CommercialStatus,     VesselSubclass,     IndexLevel,     DateRange, )  <p>Get your personal Signal Ocean API subscription key (acquired here) and use it to create a <code>Connection</code>:</p> In\u00a0[39]: Copied! <pre>signal_ocean_api_key = \"\"  # replace with your subscription key\nconnection = Connection(signal_ocean_api_key)\n</pre> signal_ocean_api_key = \"\"  # replace with your subscription key connection = Connection(signal_ocean_api_key) <p>Create instances of APIs used throughout this notebook:</p> In\u00a0[40]: Copied! <pre>voyage_api = VoyagesAPI(connection)\ntonnage_list_api = TonnageListAPI(connection)\nmarket_rate_api = MarketRatesAPI(connection)\n</pre> voyage_api = VoyagesAPI(connection) tonnage_list_api = TonnageListAPI(connection) market_rate_api = MarketRatesAPI(connection) <p>In order to plot a supply trend with the predicted market rates, we need to specify the following parameters for our queries:</p> <ol> <li><code>vessel_class</code> - the class of queried vessels.</li> <li><code>load_port</code> - the loading port.</li> <li><code>days_back</code> - the number of days the supply trend should reach back, starting from the current date.</li> <li><code>laycan_end_in_days</code> - the maximum estimated time of arrival for available vessels to reach the loading port.</li> <li><code>push_type</code> - the vessels' push status, if available from the emails in your account.</li> <li><code>market_deployment</code> - the vessels' market deployment.</li> <li><code>commercial_status</code> - commercial status of the vessels at each point in time.</li> <li><code>vessel_subclass</code> - the type of oil product the vessel is classified to carry.</li> <li><code>ais_since</code> - how many days since the vessel has transmitted its AIS data.</li> <li><code>route_description</code> - the route of interest with available market rates.</li> </ol> In\u00a0[41]: Copied! <pre>vessel_class_filter = VesselClassFilter(name_like=\"Aframax\")\nload_port_filter = PortFilter(name_like=\"Ceyhan\")\ndays_back = 90\nlaycan_end_in_days = 10\n\nvessel_filter = VesselFilter(\n    push_types=[PushType.PUSHED_POSS, PushType.PUSHED],\n    market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],\n    commercial_statuses=[\n        CommercialStatus.AVAILABLE,\n        CommercialStatus.ON_SUBS,\n        CommercialStatus.FAILED,\n        CommercialStatus.CANCELLED,\n    ],\n    vessel_subclass=VesselSubclass.DIRTY,\n    latest_ais_since=5,\n)\n\nroute_description = \"Afra - Med/Med\"\n\ntoday = date.today()\nstart_date = today - timedelta(days=days_back)\nend_date = today\n</pre> vessel_class_filter = VesselClassFilter(name_like=\"Aframax\") load_port_filter = PortFilter(name_like=\"Ceyhan\") days_back = 90 laycan_end_in_days = 10  vessel_filter = VesselFilter(     push_types=[PushType.PUSHED_POSS, PushType.PUSHED],     market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],     commercial_statuses=[         CommercialStatus.AVAILABLE,         CommercialStatus.ON_SUBS,         CommercialStatus.FAILED,         CommercialStatus.CANCELLED,     ],     vessel_subclass=VesselSubclass.DIRTY,     latest_ais_since=5, )  route_description = \"Afra - Med/Med\"  today = date.today() start_date = today - timedelta(days=days_back) end_date = today  <p>For more information, see the Tonnage List and  Market Rate API sections.</p> In\u00a0[42]: Copied! <pre>vessel_class = tonnage_list_api.get_vessel_classes(vessel_class_filter)[0]\nload_port = tonnage_list_api.get_ports(load_port_filter)[0]\n\nhtl = tonnage_list_api.get_historical_tonnage_list(\n    load_port,\n    vessel_class,\n    laycan_end_in_days,\n    DateRange(start_date, end_date),\n    vessel_filter,\n)\n\nhtl_for_supply_trend = htl.to_data_frame()\nhtl_for_supply_trend\n</pre> vessel_class = tonnage_list_api.get_vessel_classes(vessel_class_filter)[0] load_port = tonnage_list_api.get_ports(load_port_filter)[0]  htl = tonnage_list_api.get_historical_tonnage_list(     load_port,     vessel_class,     laycan_end_in_days,     DateRange(start_date, end_date),     vessel_filter, )  htl_for_supply_trend = htl.to_data_frame() htl_for_supply_trend  Out[42]: name vessel_class ice_class year_built deadweight length_overall breadth_extreme subclass market_deployment_point_in_time push_type_point_in_time ... open_prediction_accuracy_point_in_time open_country_point_in_time open_narrow_area_point_in_time open_wide_area_point_in_time availability_port_type_point_in_time availability_date_type_point_in_time fixture_type_point_in_time current_vessel_sub_type_id_point_in_time current_vessel_sub_type_point_in_time willing_to_switch_current_vessel_sub_type_point_in_time date imo 2023-09-06 12:00:00+00:00 9262924 Linda I Aframax NaN 2002 109189 241.00 42 Dirty Relet Pushed ... Narrow Area Russian Federation Black Sea Black Sea / Sea Of Marmara Source Source NaN 1 Source False 9293155 Wonder Vega Aframax NaN 2005 106062 244.00 42 Dirty Spot Pushed ... Narrow Area Greece East Mediterranean Mediterranean Source Source NaN 1 Source False 9407457 Matilda Aframax NaN 2009 112935 249.96 44 Dirty Spot Pushed ... Narrow Area Turkey Sea of Marmara Black Sea / Sea Of Marmara Source Source Scraped 1 Source False 9308443 Royall Aframax 1D 2006 110531 244.50 42 Dirty Relet Pushed ... Port Egypt Red Sea Red Sea Source Source Scraped 1 Source False 9276573 Minerva Eleonora Aframax 1C 2004 103622 244.00 42 Dirty Spot Pushed ... Narrow Area Egypt Red Sea Red Sea Source Source NaN 1 Source False ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2023-06-09 12:00:00+00:00 9334739 Olib Aframax 1C 2009 108932 246.00 48 Dirty Spot Pushed ... Narrow Area Spain Iberian Atlantic Coast UK Continent Source Source Scraped 1 Source False 9285835 Sea Fidelity Aframax NaN 2005 115341 249.87 44 Dirty Spot Pushed POSS ... Port Italy Central Mediterranean Mediterranean Source Prediction NaN 1 Prediction False 9261619 Sea Luck III Aframax NaN 2003 105869 243.96 43 Dirty Spot Pushed ... Narrow Area Saudi Arabia Red Sea Red Sea Prediction Prediction NaN 1 Prediction False 9329409 Kriti Samaria Aframax NaN 2007 105865 241.03 42 Dirty Relet Pushed ... Port Italy Central Mediterranean Mediterranean Source Prediction NaN 1 Prediction False 9645401 Affinity V Aframax NaN 2016 114070 252.00 45 Dirty Spot Pushed POSS ... Port Italy Central Mediterranean Mediterranean Source Prediction NaN 1 Prediction False <p>3029 rows \u00d7 29 columns</p> In\u00a0[43]: Copied! <pre>def return_selected_route(vessel_class, route_description):\n    vessel_routes = market_rate_api.get_routes(vessel_class_id=vessel_class.id)\n    for i, v in enumerate(vessel_routes):\n        if vessel_routes[i].description == route_description:\n            break\n    return vessel_routes[i]\n</pre> def return_selected_route(vessel_class, route_description):     vessel_routes = market_rate_api.get_routes(vessel_class_id=vessel_class.id)     for i, v in enumerate(vessel_routes):         if vessel_routes[i].description == route_description:             break     return vessel_routes[i]  <p>Which we can use to find the route object returned from the Market Rates API:</p> In\u00a0[44]: Copied! <pre>market_rate_route = return_selected_route(vessel_class, route_description)\n</pre> market_rate_route = return_selected_route(vessel_class, route_description)  <p>And use it to query for market rates:</p> In\u00a0[45]: Copied! <pre>market_rates = market_rate_api.get_market_rates(\n    start_date,\n    route_id=market_rate_route.id,\n    vessel_class_id=vessel_class.id,\n    end_date=end_date,\n    cargo_id=CargoId(market_rate_route.cargo_id)\n)\n\nmarket_rates = pd.DataFrame([vars(vr) for vr in market_rates])\nmarket_rates[\"rate_date\"] = pd.to_datetime(market_rates[\"rate_date\"])\nmarket_rates.set_index(\"rate_date\", inplace=True)\nmarket_rates\n</pre> market_rates = market_rate_api.get_market_rates(     start_date,     route_id=market_rate_route.id,     vessel_class_id=vessel_class.id,     end_date=end_date,     cargo_id=CargoId(market_rate_route.cargo_id) )  market_rates = pd.DataFrame([vars(vr) for vr in market_rates]) market_rates[\"rate_date\"] = pd.to_datetime(market_rates[\"rate_date\"]) market_rates.set_index(\"rate_date\", inplace=True) market_rates  Out[45]: route_id rate_value unit vessel_class_id deprecated_to rate_date 2023-06-09 R1 147.5 WS 86 None 2023-06-10 R1 147.5 WS 86 None 2023-06-11 R1 147.5 WS 86 None 2023-06-12 R1 142.5 WS 86 None 2023-06-13 R1 142.5 WS 86 None ... ... ... ... ... ... 2023-09-03 R1 101.5 WS 86 None 2023-09-04 R1 101.5 WS 86 None 2023-09-05 R1 96.5 WS 86 None 2023-09-06 R1 95.5 WS 86 None 2023-09-07 R1 95.5 WS 86 None <p>91 rows \u00d7 5 columns</p> In\u00a0[46]: Copied! <pre>plt.style.use(\"seaborn\")\nfig, axs = plt.subplots(figsize=(15, 6))\n\nsupply_trend = htl_for_supply_trend.groupby(IndexLevel.DATE, sort=True).size()\nsupply_trend.index = supply_trend.index.strftime(\"%d %b %y\")\n\n# Left axis (Supply plot)\nsupply_plot = supply_trend.plot(ax=axs, x=\"date\", color=\"#3086EF\", marker=\"o\")\nsupply_plot.set_ylabel(\n    \"Vessel count\", color=plt.gca().lines[-1].get_color(), fontsize=14\n)\nsupply_plot.set_ylim(ymin=0)\n\n# Right axis (Market rate plot)\nmarket_rates.index = market_rates.index.strftime(\"%d %b %y\")\nmr_plot = market_rates.plot(\n    ax=axs, y=\"rate_value\", secondary_y=True, color=\"#F06C6E\", marker=\"d\"\n)\nmr_plot.set_ylabel(\n    \"Market Rates (WS)\", color=plt.gca().lines[-1].get_color(), fontsize=14\n)\n\naxs.set_xlim(0, len(supply_trend) - 1)\naxs.set_xlabel(\"\")\naxs.get_legend().remove()\n</pre> plt.style.use(\"seaborn\") fig, axs = plt.subplots(figsize=(15, 6))  supply_trend = htl_for_supply_trend.groupby(IndexLevel.DATE, sort=True).size() supply_trend.index = supply_trend.index.strftime(\"%d %b %y\")  # Left axis (Supply plot) supply_plot = supply_trend.plot(ax=axs, x=\"date\", color=\"#3086EF\", marker=\"o\") supply_plot.set_ylabel(     \"Vessel count\", color=plt.gca().lines[-1].get_color(), fontsize=14 ) supply_plot.set_ylim(ymin=0)  # Right axis (Market rate plot) market_rates.index = market_rates.index.strftime(\"%d %b %y\") mr_plot = market_rates.plot(     ax=axs, y=\"rate_value\", secondary_y=True, color=\"#F06C6E\", marker=\"d\" ) mr_plot.set_ylabel(     \"Market Rates (WS)\", color=plt.gca().lines[-1].get_color(), fontsize=14 )  axs.set_xlim(0, len(supply_trend) - 1) axs.set_xlabel(\"\") axs.get_legend().remove()  <pre>C:\\Users\\Kimon\\AppData\\Local\\Temp\\ipykernel_18828\\1394344043.py:1: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use(\"seaborn\")\n</pre> In\u00a0[47]: Copied! <pre>point_a = today - timedelta(days=1)\npoint_b = today - timedelta(days=5)\n</pre> point_a = today - timedelta(days=1) point_b = today - timedelta(days=5)  In\u00a0[48]: Copied! <pre>dates = htl_for_supply_trend.index.get_level_values(\"date\").date\n\nif not any(dates == point_a):\n    print(\"Point A is not within imported date values.\")\nelif not any(dates == point_b):\n    print(\"Point B is not within imported date values.\")\n\nvessels_in_a = htl_for_supply_trend.loc[(dates == point_a)]\nvessels_in_b = htl_for_supply_trend.loc[(dates == point_b)]\n</pre> dates = htl_for_supply_trend.index.get_level_values(\"date\").date  if not any(dates == point_a):     print(\"Point A is not within imported date values.\") elif not any(dates == point_b):     print(\"Point B is not within imported date values.\")  vessels_in_a = htl_for_supply_trend.loc[(dates == point_a)] vessels_in_b = htl_for_supply_trend.loc[(dates == point_b)]  In\u00a0[49]: Copied! <pre>intersection = pd.merge(\n    vessels_in_a.add_suffix(\"_IN_A\"),\n    vessels_in_b.add_suffix(\"_IN_B\"),\n    how=\"inner\",\n    on=\"imo\",\n)\n\nintersection\n</pre> intersection = pd.merge(     vessels_in_a.add_suffix(\"_IN_A\"),     vessels_in_b.add_suffix(\"_IN_B\"),     how=\"inner\",     on=\"imo\", )  intersection  Out[49]: name_IN_A vessel_class_IN_A ice_class_IN_A year_built_IN_A deadweight_IN_A length_overall_IN_A breadth_extreme_IN_A subclass_IN_A market_deployment_point_in_time_IN_A push_type_point_in_time_IN_A ... open_prediction_accuracy_point_in_time_IN_B open_country_point_in_time_IN_B open_narrow_area_point_in_time_IN_B open_wide_area_point_in_time_IN_B availability_port_type_point_in_time_IN_B availability_date_type_point_in_time_IN_B fixture_type_point_in_time_IN_B current_vessel_sub_type_id_point_in_time_IN_B current_vessel_sub_type_point_in_time_IN_B willing_to_switch_current_vessel_sub_type_point_in_time_IN_B imo 9262924 Linda I Aframax NaN 2002 109189 241.00 42 Dirty Relet Pushed ... Narrow Area Russian Federation Black Sea Black Sea / Sea Of Marmara Source Source NaN 1 Source False 9407457 Matilda Aframax NaN 2009 112935 249.96 44 Dirty Spot Pushed ... Port Turkey Sea of Marmara Black Sea / Sea Of Marmara Source Prediction NaN 1 Prediction False 9276573 Minerva Eleonora Aframax 1C 2004 103622 244.00 42 Dirty Spot Pushed ... Port Saudi Arabia Red Sea Red Sea Source Prediction NaN 1 Prediction False 9930105 Ghat Aframax NaN 2022 115519 249.90 44 Dirty Spot Pushed ... Port Italy Central Mediterranean Mediterranean Source Prediction Scraped 1 Prediction False 9815616 Levantine Sea Aframax 1C 2018 114218 249.80 44 Dirty Spot Pushed ... Port Turkey Sea of Marmara Black Sea / Sea Of Marmara Source Prediction NaN 1 Prediction False 9801524 Ambelos Aframax NaN 2017 114674 250.00 44 Dirty Spot Pushed ... Narrow Area Oman Arabian Gulf Arabian Gulf Source Source NaN 1 Source False 9592290 Nissos Paros Aframax NaN 2012 115723 248.97 44 Dirty Spot Pushed ... Narrow Area Oman Arabian Gulf Arabian Gulf Source Source NaN 1 Source False 9259197 Thalia III Aframax NaN 2003 107127 246.78 42 Dirty Relet Pushed ... Port Turkey Sea of Marmara Black Sea / Sea Of Marmara Source Source NaN 1 Source False 9417452 Chrysanthemum Aframax NaN 2009 105187 243.97 42 Dirty Spot Pushed ... Narrow Area Spain Iberian Atlantic Coast UK Continent Source Source NaN 1 Source False <p>9 rows \u00d7 58 columns</p> In\u00a0[50]: Copied! <pre>vessels_in_a_but_not_in_b = (\n    vessels_in_a.add_suffix(\"_IN_A\")\n    .merge(\n        vessels_in_b.add_suffix(\"_IN_B\"), indicator=True, how=\"left\", on=\"imo\"\n    )\n    .loc[lambda x: x[\"_merge\"] != \"both\"]\n)\n\nvessels_in_a_but_not_in_b\n</pre> vessels_in_a_but_not_in_b = (     vessels_in_a.add_suffix(\"_IN_A\")     .merge(         vessels_in_b.add_suffix(\"_IN_B\"), indicator=True, how=\"left\", on=\"imo\"     )     .loc[lambda x: x[\"_merge\"] != \"both\"] )  vessels_in_a_but_not_in_b  Out[50]: name_IN_A vessel_class_IN_A ice_class_IN_A year_built_IN_A deadweight_IN_A length_overall_IN_A breadth_extreme_IN_A subclass_IN_A market_deployment_point_in_time_IN_A push_type_point_in_time_IN_A ... open_country_point_in_time_IN_B open_narrow_area_point_in_time_IN_B open_wide_area_point_in_time_IN_B availability_port_type_point_in_time_IN_B availability_date_type_point_in_time_IN_B fixture_type_point_in_time_IN_B current_vessel_sub_type_id_point_in_time_IN_B current_vessel_sub_type_point_in_time_IN_B willing_to_switch_current_vessel_sub_type_point_in_time_IN_B _merge imo 9293155 Wonder Vega Aframax NaN 2005 106062 244.00 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9308443 Royall Aframax 1D 2006 110531 244.50 42 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9913511 Nafsika Aframax NaN 2022 112100 237.00 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9773753 Seacalm Aframax NaN 2017 112119 238.30 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9337418 Patmos Warrior Aframax NaN 2007 105572 239.00 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9527855 Alicante Aframax NaN 2013 115708 248.97 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9779941 Shusha Aframax 1C 2017 113838 250.00 44 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9292515 Erik Spirit Aframax NaN 2005 115525 249.90 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9592252 Minerva Kythnos Aframax NaN 2011 115674 248.97 44 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9436020 Crude Centurion Aframax NaN 2010 112863 249.96 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9309423 Minerva Nounou Aframax 1A 2006 114850 253.59 44 Dirty Spot Pushed POSS ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9857468 Seatribute Aframax NaN 2020 111890 237.00 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9384992 Sousta Aframax NaN 2007 106045 240.50 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9787170 Minerva Karteria Aframax NaN 2018 114780 250.01 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9290361 Seaoath Aframax 1C 2005 105472 243.98 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9439670 Captain A. Stellatos Aframax NaN 2010 105849 243.97 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9402495 Dubai Charm Aframax NaN 2010 115514 250.00 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only <p>17 rows \u00d7 59 columns</p> In\u00a0[51]: Copied! <pre>vessels_in_b_but_not_in_a = (\n    vessels_in_b.add_suffix(\"_IN_B\")\n    .merge(\n        vessels_in_a.add_suffix(\"_IN_A\"), indicator=True, how=\"left\", on=\"imo\"\n    )\n    .loc[lambda x: x[\"_merge\"] != \"both\"]\n)\n\nvessels_in_b_but_not_in_a\n</pre> vessels_in_b_but_not_in_a = (     vessels_in_b.add_suffix(\"_IN_B\")     .merge(         vessels_in_a.add_suffix(\"_IN_A\"), indicator=True, how=\"left\", on=\"imo\"     )     .loc[lambda x: x[\"_merge\"] != \"both\"] )  vessels_in_b_but_not_in_a Out[51]: name_IN_B vessel_class_IN_B ice_class_IN_B year_built_IN_B deadweight_IN_B length_overall_IN_B breadth_extreme_IN_B subclass_IN_B market_deployment_point_in_time_IN_B push_type_point_in_time_IN_B ... open_country_point_in_time_IN_A open_narrow_area_point_in_time_IN_A open_wide_area_point_in_time_IN_A availability_port_type_point_in_time_IN_A availability_date_type_point_in_time_IN_A fixture_type_point_in_time_IN_A current_vessel_sub_type_id_point_in_time_IN_A current_vessel_sub_type_point_in_time_IN_A willing_to_switch_current_vessel_sub_type_point_in_time_IN_A _merge imo 9821706 Elandra Sound Aframax NaN 2018 115711 249.90 44 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9309435 Minerva Alice Aframax 1A 2006 114850 254.00 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9420617 Silver Aframax NaN 2010 107507 243.80 43 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9810513 Karabakh Aframax NaN 2018 114667 250.00 44 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9334739 Olib Aframax 1C 2009 108932 246.00 48 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9356438 Alyarmouk Aframax NaN 2008 116038 248.96 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9384564 Red Sun Aframax NaN 2008 115325 243.80 42 Dirty Spot Pushed POSS ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9373656 Seastar Aframax NaN 2008 116050 249.97 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9777931 Ryman Aframax 1A 2017 112870 250.00 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9458016 Delta Star Aframax NaN 2013 115618 249.97 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9696773 Alfa Baltica Aframax NaN 2015 106373 228.60 42 Dirty Spot Pushed POSS ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9276585 Minerva Roxanne Aframax 1C 2004 103560 243.56 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9802176 Sea Puma Aframax NaN 2018 114609 250.00 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9285861 Minerva Iris Aframax 1A 2004 103124 243.57 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9787168 Minerva Eleftheria Aframax NaN 2018 114696 250.00 44 Dirty Spot Pushed POSS ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9728241 Minerva Baltica Aframax 1B 2018 113172 250.00 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9398266 Kriti Legend Aframax NaN 2009 107518 243.80 42 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9317951 Minerva Libra Aframax 1A 2007 116779 249.88 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9927196 Green Admire Aframax NaN 2022 114377 249.99 44 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9446427 Altai Aframax NaN 2011 115952 248.96 44 Dirty Spot Pushed POSS ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9338917 Aegean Harmony Aframax NaN 2007 115824 248.93 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9893046 Pacific Diamond Aframax 1C 2021 113306 249.90 44 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9787194 Minerva Olympia Aframax NaN 2019 114780 250.00 44 Dirty Spot Pushed POSS ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9329409 Kriti Samaria Aframax NaN 2007 105865 241.03 42 Dirty Relet Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9288734 Seabravery Aframax 1C 2005 105042 243.96 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9334727 Dugi Otok Aframax 1C 2008 108932 246.00 48 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9439383 PS Genova Aframax NaN 2010 108983 243.00 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9801976 Prometheus Light Aframax NaN 2019 114700 249.99 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9304368 Seasenator Aframax NaN 2007 105715 241.03 42 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only 9796743 Rava Aframax 1C 2017 114385 250.00 44 Dirty Spot Pushed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN left_only <p>30 rows \u00d7 59 columns</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#supply-trend-with-market-rates","title":"Supply trend with market rates\u00b6","text":"<p>This is an example combining functionality from our Voyages, Market Rates and Tonnage List APIs. The aim of the example is to plot a supply trend with superimposed, predicted market rates, in order to get a hollistic view of market behaviour during a specific period, for a specific load port, and a specific vessel class.</p>"},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#parametrization","title":"Parametrization\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#retrieve-the-historical-tonnage-list","title":"Retrieve the historical tonnage list\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#get-daily-market-rates-for-the-route","title":"Get daily market rates for the route\u00b6","text":"<p>We'll need a helper function to find our desired route for the market rates:</p>"},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#plot-the-daily-supply-trend-with-market-rates","title":"Plot the daily supply trend with market rates\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#perform-a-point-to-point-comparison","title":"Perform a point-to-point comparison\u00b6","text":"<p>Here's an example of a workflow to compare two different points in time.</p> <p>Specify the dates to compare:</p>"},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#intersection-of-vessel-imos","title":"Intersection of Vessel IMOs\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#difference-between-vessel-imos-in-relation-to-point-a","title":"Difference between vessel IMOs in relation to point A\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/Supply%20trend%20with%20market%20rates/#difference-between-vessel-imos-in-relation-to-point-b","title":"Difference between vessel IMOs in relation to point B\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/","title":"VLCCs MEG/China Supply Trend &amp; Market Rates, implementing Filters","text":"In\u00a0[\u00a0]: Copied! <pre>#@title\n!pip install signal-ocean\nfrom datetime import datetime,date, timedelta\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom signal_ocean import Connection\nfrom signal_ocean.market_rates import MarketRatesAPI, CargoId\nfrom signal_ocean.tonnage_list import IndexLevel\nfrom signal_ocean.tonnage_list import (\n    TonnageListAPI,\n    VesselClassFilter,\n    PortFilter,\n    VesselFilter,\n    MarketDeployment,\n    CommercialStatus,\n    VesselSubclass,\n    DateRange,\n    PushType,\n    OperationalStatus,\n)\npd.set_option('display.max_columns', None)\n</pre> #@title !pip install signal-ocean from datetime import datetime,date, timedelta import pandas as pd import matplotlib.pyplot as plt  from signal_ocean import Connection from signal_ocean.market_rates import MarketRatesAPI, CargoId from signal_ocean.tonnage_list import IndexLevel from signal_ocean.tonnage_list import (     TonnageListAPI,     VesselClassFilter,     PortFilter,     VesselFilter,     MarketDeployment,     CommercialStatus,     VesselSubclass,     DateRange,     PushType,     OperationalStatus, ) pd.set_option('display.max_columns', None) <pre>Requirement already satisfied: signal-ocean in /usr/local/lib/python3.10/dist-packages (13.0.0)\nRequirement already satisfied: requests&lt;3,&gt;=2.23.0 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (2.32.3)\nRequirement already satisfied: python-dateutil&lt;3,&gt;=2.8.1 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (2.8.2)\nRequirement already satisfied: pandas&lt;3,&gt;=2 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (2.2.2)\nRequirement already satisfied: numpy&gt;=1.18.5 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (1.26.4)\nRequirement already satisfied: strictly-typed-pandas==0.1.4 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (0.1.4)\nRequirement already satisfied: typeguard&lt;3.0.0,&gt;=2.13.3 in /usr/local/lib/python3.10/dist-packages (from signal-ocean) (2.13.3)\nRequirement already satisfied: pandas-stubs in /usr/local/lib/python3.10/dist-packages (from strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2.2.2.240909)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.10/dist-packages (from pandas&lt;3,&gt;=2-&gt;signal-ocean) (2024.2)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.10/dist-packages (from pandas&lt;3,&gt;=2-&gt;signal-ocean) (2024.2)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.10/dist-packages (from python-dateutil&lt;3,&gt;=2.8.1-&gt;signal-ocean) (1.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /usr/local/lib/python3.10/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.4.0)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.10/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.2.3)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2024.8.30)\nRequirement already satisfied: types-pytz&gt;=2022.1.1 in /usr/local/lib/python3.10/dist-packages (from pandas-stubs-&gt;strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2024.2.0.20241003)\n</pre> <p>We need to specify the following parameters for our queries:</p> <ol> <li><p>route_description - the route of interest with available market rates.</p> </li> <li><p>port_name - the loading port.</p> </li> <li><p>vessel_class - the class of queried vessels.</p> </li> <li><p>laycan_end_in_days - the maximum estimated time of arrival for available vessels to reach the loading port.</p> </li> <li><p>days_to_look_back - the number of days the supply trend should reach back, starting from the current date.</p> </li> <li><p>latest_ais_since_value - how many days since the vessel has transmitted its AIS data.</p> </li> <li><p>vessel_subclass - the type of oil product the vessel is classified to carry</p> </li> <li><p>market_deployment - the vessels' market deployment.</p> </li> </ol> In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = ''  #replace with your subscription key\ncustomer_name='Internal'\nroute_description = \"VLCC - MEG/China\"\nport_name=\"Ras Tanura\"\nvessel_class=\"VLCC\"\nlaycan_end_in_days_20 = 20\nlaycan_end_in_days_10 = 10\nscenario_name_20 = vessel_class+\"-\"+port_name+\"-\"+str(laycan_end_in_days_20)+\"days\"\nscenario_name_10 = vessel_class+\"-\"+port_name+\"-\"+str(laycan_end_in_days_10)+\"days\"\ndays_to_look_back = 180\nlatest_ais_since_value = 5\n\nvessel_filter = VesselFilter(\n    vessel_subclass=VesselSubclass.DIRTY,\n    latest_ais_since=latest_ais_since_value,\n    market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT], # Only Relevant for Tankers\n    #push_types=[PushType.PUSHED_POSS, PushType.PUSHED], # TSOP: Pushed State\n    #commercial_statuses= [CommercialStatus.ON_SUBS] #[CommercialStatus.AVAILABLE, CommercialStatus.ON_SUBS, CommercialStatus.FAILED, CommercialStatus.CANCELLED], # TSOP: Availability State\n    #operational_statuses=[OperationalStatus.BALLAST_UNFIXED] #, OperationalStatus.BALLAST_FIXED], # TSOP: Voyage State\n)\n</pre> signal_ocean_api_key = ''  #replace with your subscription key customer_name='Internal' route_description = \"VLCC - MEG/China\" port_name=\"Ras Tanura\" vessel_class=\"VLCC\" laycan_end_in_days_20 = 20 laycan_end_in_days_10 = 10 scenario_name_20 = vessel_class+\"-\"+port_name+\"-\"+str(laycan_end_in_days_20)+\"days\" scenario_name_10 = vessel_class+\"-\"+port_name+\"-\"+str(laycan_end_in_days_10)+\"days\" days_to_look_back = 180 latest_ais_since_value = 5  vessel_filter = VesselFilter(     vessel_subclass=VesselSubclass.DIRTY,     latest_ais_since=latest_ais_since_value,     market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT], # Only Relevant for Tankers     #push_types=[PushType.PUSHED_POSS, PushType.PUSHED], # TSOP: Pushed State     #commercial_statuses= [CommercialStatus.ON_SUBS] #[CommercialStatus.AVAILABLE, CommercialStatus.ON_SUBS, CommercialStatus.FAILED, CommercialStatus.CANCELLED], # TSOP: Availability State     #operational_statuses=[OperationalStatus.BALLAST_UNFIXED] #, OperationalStatus.BALLAST_FIXED], # TSOP: Voyage State )  In\u00a0[\u00a0]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = TonnageListAPI(connection)\n\nmarket_rate_api = MarketRatesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = TonnageListAPI(connection)  market_rate_api = MarketRatesAPI(connection)  In\u00a0[\u00a0]: Copied! <pre>vessel_class_filter = VesselClassFilter(name_like=vessel_class)\nvessel_class = api.get_vessel_classes(vessel_class_filter)[0]\nvessel_class\n</pre> vessel_class_filter = VesselClassFilter(name_like=vessel_class) vessel_class = api.get_vessel_classes(vessel_class_filter)[0] vessel_class  Out[\u00a0]: <pre>VesselClass(id=84, name='VLCC')</pre> In\u00a0[\u00a0]: Copied! <pre>port_filter = PortFilter(name_like=port_name)\nport = api.get_ports(port_filter)[0]\nport\n</pre> port_filter = PortFilter(name_like=port_name) port = api.get_ports(port_filter)[0] port  Out[\u00a0]: <pre>Port(id=3778, name='Ras Tanura')</pre> In\u00a0[\u00a0]: Copied! <pre>start_date = date.today() - timedelta(days_to_look_back)\nend_date = date.today()\n\n\n\nhtl_for_supply_trend_20days = api.get_historical_tonnage_list(\n    port,\n    vessel_class,\n    laycan_end_in_days_20,\n    DateRange(start_date, end_date),\n    vessel_filter=vessel_filter,\n)\nsupply_trend_data_20_frame = htl_for_supply_trend_20days.to_data_frame()\n\n\nhtl_for_supply_trend_10days = api.get_historical_tonnage_list(\n    port,\n    vessel_class,\n    laycan_end_in_days_10,\n    DateRange(start_date, end_date),\n    vessel_filter=vessel_filter,\n)\nsupply_trend_data_10_frame = htl_for_supply_trend_10days.to_data_frame()\n</pre> start_date = date.today() - timedelta(days_to_look_back) end_date = date.today()    htl_for_supply_trend_20days = api.get_historical_tonnage_list(     port,     vessel_class,     laycan_end_in_days_20,     DateRange(start_date, end_date),     vessel_filter=vessel_filter, ) supply_trend_data_20_frame = htl_for_supply_trend_20days.to_data_frame()   htl_for_supply_trend_10days = api.get_historical_tonnage_list(     port,     vessel_class,     laycan_end_in_days_10,     DateRange(start_date, end_date),     vessel_filter=vessel_filter, ) supply_trend_data_10_frame = htl_for_supply_trend_10days.to_data_frame() In\u00a0[\u00a0]: Copied! <pre>supply_trend_data_20_frame[\"open_date_point_in_time\"] = pd.to_datetime(supply_trend_data_20_frame[\"open_date_point_in_time\"]).dt.tz_localize(None)\nsupply_trend_data_20_frame[\"eta_point_in_time\"] = pd.to_datetime(supply_trend_data_20_frame[\"eta_point_in_time\"]).dt.tz_localize(None)\nsupply_trend_data_20_frame[\"latest_ais_point_in_time\"] = pd.to_datetime(supply_trend_data_20_frame[\"latest_ais_point_in_time\"]).dt.tz_localize(None)\n\nremove_time_zones_20 = (\n    supply_trend_data_20_frame.reset_index()\n    .set_index(IndexLevel.IMO)\n)\nremove_time_zones_20[\"date\"] = pd.to_datetime(remove_time_zones_20[\"date\"]).dt.tz_localize(None)\n\n\n\n\nsupply_trend_data_10_frame[\"open_date_point_in_time\"] = pd.to_datetime(supply_trend_data_10_frame[\"open_date_point_in_time\"]).dt.tz_localize(None)\nsupply_trend_data_10_frame[\"eta_point_in_time\"] = pd.to_datetime(supply_trend_data_10_frame[\"eta_point_in_time\"]).dt.tz_localize(None)\nsupply_trend_data_10_frame[\"latest_ais_point_in_time\"] = pd.to_datetime(supply_trend_data_10_frame[\"latest_ais_point_in_time\"]).dt.tz_localize(None)\n\nremove_time_zones_10 = (\n    supply_trend_data_10_frame.reset_index()\n    .set_index(IndexLevel.IMO)\n)\nremove_time_zones_10[\"date\"] = pd.to_datetime(remove_time_zones_10[\"date\"]).dt.tz_localize(None)\n</pre>  supply_trend_data_20_frame[\"open_date_point_in_time\"] = pd.to_datetime(supply_trend_data_20_frame[\"open_date_point_in_time\"]).dt.tz_localize(None) supply_trend_data_20_frame[\"eta_point_in_time\"] = pd.to_datetime(supply_trend_data_20_frame[\"eta_point_in_time\"]).dt.tz_localize(None) supply_trend_data_20_frame[\"latest_ais_point_in_time\"] = pd.to_datetime(supply_trend_data_20_frame[\"latest_ais_point_in_time\"]).dt.tz_localize(None)  remove_time_zones_20 = (     supply_trend_data_20_frame.reset_index()     .set_index(IndexLevel.IMO) ) remove_time_zones_20[\"date\"] = pd.to_datetime(remove_time_zones_20[\"date\"]).dt.tz_localize(None)     supply_trend_data_10_frame[\"open_date_point_in_time\"] = pd.to_datetime(supply_trend_data_10_frame[\"open_date_point_in_time\"]).dt.tz_localize(None) supply_trend_data_10_frame[\"eta_point_in_time\"] = pd.to_datetime(supply_trend_data_10_frame[\"eta_point_in_time\"]).dt.tz_localize(None) supply_trend_data_10_frame[\"latest_ais_point_in_time\"] = pd.to_datetime(supply_trend_data_10_frame[\"latest_ais_point_in_time\"]).dt.tz_localize(None)  remove_time_zones_10 = (     supply_trend_data_10_frame.reset_index()     .set_index(IndexLevel.IMO) ) remove_time_zones_10[\"date\"] = pd.to_datetime(remove_time_zones_10[\"date\"]).dt.tz_localize(None) In\u00a0[\u00a0]: Copied! <pre>now = datetime.now() # current date and time\nremove_time_zones_20.to_excel(now.strftime(\"%Y.%m.%d-%H:%M:%S-\")+customer_name+'-'+scenario_name_20+'.xlsx')\nremove_time_zones_10.to_excel(now.strftime(\"%Y.%m.%d-%H:%M:%S-\")+customer_name+'-'+scenario_name_10+'.xlsx')\n</pre> now = datetime.now() # current date and time remove_time_zones_20.to_excel(now.strftime(\"%Y.%m.%d-%H:%M:%S-\")+customer_name+'-'+scenario_name_20+'.xlsx') remove_time_zones_10.to_excel(now.strftime(\"%Y.%m.%d-%H:%M:%S-\")+customer_name+'-'+scenario_name_10+'.xlsx') In\u00a0[\u00a0]: Copied! <pre>open_areas = [\n\"Indonesia\",\n\"Singapore / Malaysia\",\n\"Thailand / Vietnam\",\n\"Papua New Guinea\",\n\"Philippines\",\n\"South China\",\n\"Central China\",\n\"North China\",\n\"Taiwan\",\n\"Japan Island\",\n\"Korea\",\n\"Russian Pacific\"\n]\n\n###########################################################################\nareas_filter_20 = supply_trend_data_20_frame.open_narrow_area_point_in_time.isin(\n    open_areas\n)\n\nsupply_trend_data_20_frame = (\n    supply_trend_data_20_frame[areas_filter_20]\n)\n\n###########################################################################\nareas_filter_10 = supply_trend_data_10_frame.open_narrow_area_point_in_time.isin(\n    open_areas\n)\n\nsupply_trend_data_10_frame = (\n    supply_trend_data_10_frame[areas_filter_10]\n)\n</pre> open_areas = [ \"Indonesia\", \"Singapore / Malaysia\", \"Thailand / Vietnam\", \"Papua New Guinea\", \"Philippines\", \"South China\", \"Central China\", \"North China\", \"Taiwan\", \"Japan Island\", \"Korea\", \"Russian Pacific\" ]  ########################################################################### areas_filter_20 = supply_trend_data_20_frame.open_narrow_area_point_in_time.isin(     open_areas )  supply_trend_data_20_frame = (     supply_trend_data_20_frame[areas_filter_20] )  ########################################################################### areas_filter_10 = supply_trend_data_10_frame.open_narrow_area_point_in_time.isin(     open_areas )  supply_trend_data_10_frame = (     supply_trend_data_10_frame[areas_filter_10] ) In\u00a0[\u00a0]: Copied! <pre>aggregated_data = supply_trend_data_20_frame.groupby(\n    IndexLevel.DATE, sort=True\n).size()\naggregated_data = aggregated_data.to_frame()\naggregated_data.reset_index(drop=False, inplace=True)\naggregated_data['date'] = aggregated_data['date'].dt.date\naggregated_data.columns = ['date', '20days']\n\n\n\naggregated_data_10 = supply_trend_data_10_frame.groupby(\n    IndexLevel.DATE, sort=True\n).size()\naggregated_data_10 = aggregated_data_10.to_frame()\naggregated_data_10.reset_index(drop=False, inplace=True)\naggregated_data_10['date'] = aggregated_data_10['date'].dt.date\naggregated_data_10.columns = ['date', '10days']\n\nmerge_df = pd.merge(aggregated_data_10, aggregated_data, left_on='date', right_on='date', how='right')\n#aggregated_data\n</pre>   aggregated_data = supply_trend_data_20_frame.groupby(     IndexLevel.DATE, sort=True ).size() aggregated_data = aggregated_data.to_frame() aggregated_data.reset_index(drop=False, inplace=True) aggregated_data['date'] = aggregated_data['date'].dt.date aggregated_data.columns = ['date', '20days']    aggregated_data_10 = supply_trend_data_10_frame.groupby(     IndexLevel.DATE, sort=True ).size() aggregated_data_10 = aggregated_data_10.to_frame() aggregated_data_10.reset_index(drop=False, inplace=True) aggregated_data_10['date'] = aggregated_data_10['date'].dt.date aggregated_data_10.columns = ['date', '10days']  merge_df = pd.merge(aggregated_data_10, aggregated_data, left_on='date', right_on='date', how='right') #aggregated_data  In\u00a0[\u00a0]: Copied! <pre>ballast_unfixed = [\"Ballast Unfixed\"]\n\nballast_unfixed_filter = supply_trend_data_20_frame.operational_status_point_in_time.isin(\n    ballast_unfixed\n)\n\nballast_unfixed_dataframe = (\n    supply_trend_data_20_frame[ballast_unfixed_filter]\n)\n\nballast_unfixed_dataframe = ballast_unfixed_dataframe.groupby(\n    IndexLevel.DATE, sort=True\n).size()\nballast_unfixed_dataframe = ballast_unfixed_dataframe.to_frame()\nballast_unfixed_dataframe.reset_index(drop=False, inplace=True)\nballast_unfixed_dataframe['date'] = ballast_unfixed_dataframe['date'].dt.date\nballast_unfixed_dataframe.columns = ['date', 'ballast_unfixed_20']\n\nballast_unfixed_dataframe\n\nmerge_df = pd.merge(merge_df, ballast_unfixed_dataframe, left_on='date', right_on='date', how='left')\n</pre> ballast_unfixed = [\"Ballast Unfixed\"]  ballast_unfixed_filter = supply_trend_data_20_frame.operational_status_point_in_time.isin(     ballast_unfixed )  ballast_unfixed_dataframe = (     supply_trend_data_20_frame[ballast_unfixed_filter] )  ballast_unfixed_dataframe = ballast_unfixed_dataframe.groupby(     IndexLevel.DATE, sort=True ).size() ballast_unfixed_dataframe = ballast_unfixed_dataframe.to_frame() ballast_unfixed_dataframe.reset_index(drop=False, inplace=True) ballast_unfixed_dataframe['date'] = ballast_unfixed_dataframe['date'].dt.date ballast_unfixed_dataframe.columns = ['date', 'ballast_unfixed_20']  ballast_unfixed_dataframe  merge_df = pd.merge(merge_df, ballast_unfixed_dataframe, left_on='date', right_on='date', how='left')   In\u00a0[\u00a0]: Copied! <pre>commercial_status = [\"On Subs\"]\n\non_subs_filter = supply_trend_data_20_frame.commercial_status_point_in_time.isin(\n    commercial_status\n)\n\non_subs_dataframe = (\n    supply_trend_data_20_frame[on_subs_filter]\n)\n\non_subs_dataframe = on_subs_dataframe.groupby(\n    IndexLevel.DATE, sort=True\n).size()\non_subs_dataframe = on_subs_dataframe.to_frame()\non_subs_dataframe.reset_index(drop=False, inplace=True)\non_subs_dataframe['date'] = on_subs_dataframe['date'].dt.date\non_subs_dataframe.columns = ['date', 'on_subs_20']\n\n\nmerge_df = pd.merge(merge_df, on_subs_dataframe, left_on='date', right_on='date', how='left')\n</pre> commercial_status = [\"On Subs\"]  on_subs_filter = supply_trend_data_20_frame.commercial_status_point_in_time.isin(     commercial_status )  on_subs_dataframe = (     supply_trend_data_20_frame[on_subs_filter] )  on_subs_dataframe = on_subs_dataframe.groupby(     IndexLevel.DATE, sort=True ).size() on_subs_dataframe = on_subs_dataframe.to_frame() on_subs_dataframe.reset_index(drop=False, inplace=True) on_subs_dataframe['date'] = on_subs_dataframe['date'].dt.date on_subs_dataframe.columns = ['date', 'on_subs_20']   merge_df = pd.merge(merge_df, on_subs_dataframe, left_on='date', right_on='date', how='left') In\u00a0[\u00a0]: Copied! <pre>pushed_status = [\"Pushed\",\"Pushed POSS\"]\n\npushed_filter = supply_trend_data_20_frame.push_type_point_in_time.isin(\n    pushed_status\n)\n\npushed_dataframe = (\n    supply_trend_data_20_frame[pushed_filter]\n)\n\npushed_dataframe = pushed_dataframe.groupby(\n    IndexLevel.DATE, sort=True\n).size()\npushed_dataframe = pushed_dataframe.to_frame()\npushed_dataframe.reset_index(drop=False, inplace=True)\npushed_dataframe['date'] = pushed_dataframe['date'].dt.date\npushed_dataframe.columns = ['date', 'pushed_20']\n\n\nmerge_df = pd.merge(merge_df, pushed_dataframe, left_on='date', right_on='date', how='left')\n</pre> pushed_status = [\"Pushed\",\"Pushed POSS\"]  pushed_filter = supply_trend_data_20_frame.push_type_point_in_time.isin(     pushed_status )  pushed_dataframe = (     supply_trend_data_20_frame[pushed_filter] )  pushed_dataframe = pushed_dataframe.groupby(     IndexLevel.DATE, sort=True ).size() pushed_dataframe = pushed_dataframe.to_frame() pushed_dataframe.reset_index(drop=False, inplace=True) pushed_dataframe['date'] = pushed_dataframe['date'].dt.date pushed_dataframe.columns = ['date', 'pushed_20']   merge_df = pd.merge(merge_df, pushed_dataframe, left_on='date', right_on='date', how='left') In\u00a0[\u00a0]: Copied! <pre>def return_selected_route(vessel_class, route_description):\n    vessel_routes = market_rate_api.get_routes(vessel_class_id=vessel_class.id)\n    for i, _ in enumerate(vessel_routes):\n        if vessel_routes[i].description == route_description:\n            break\n    return vessel_routes[i]\n</pre> def return_selected_route(vessel_class, route_description):     vessel_routes = market_rate_api.get_routes(vessel_class_id=vessel_class.id)     for i, _ in enumerate(vessel_routes):         if vessel_routes[i].description == route_description:             break     return vessel_routes[i]  In\u00a0[\u00a0]: Copied! <pre>today = date.today()\nstart_date = today - timedelta(days_to_look_back)\nend_date = today\n\nmarket_rate_route = return_selected_route(vessel_class, route_description)\n\nmarket_rates = market_rate_api.get_market_rates(\n    start_date,\n    route_id=market_rate_route.id,\n    vessel_class_id=vessel_class.id,\n    end_date=end_date,\n    cargo_id=CargoId(market_rate_route.cargo_id)\n)\n</pre>     today = date.today() start_date = today - timedelta(days_to_look_back) end_date = today  market_rate_route = return_selected_route(vessel_class, route_description)  market_rates = market_rate_api.get_market_rates(     start_date,     route_id=market_rate_route.id,     vessel_class_id=vessel_class.id,     end_date=end_date,     cargo_id=CargoId(market_rate_route.cargo_id) )   In\u00a0[\u00a0]: Copied! <pre>market_rates_dataframe = pd.DataFrame([vars(vr) for vr in market_rates])\nmarket_rates_dataframe[\"rate_date\"] = pd.to_datetime(market_rates_dataframe[\"rate_date\"])\nmarket_rates_dataframe['rate_date'] = market_rates_dataframe['rate_date'].dt.date\nmarket_rates_dataframe['route_id'] = route_description\nmarket_rates_dataframe\n</pre> market_rates_dataframe = pd.DataFrame([vars(vr) for vr in market_rates]) market_rates_dataframe[\"rate_date\"] = pd.to_datetime(market_rates_dataframe[\"rate_date\"]) market_rates_dataframe['rate_date'] = market_rates_dataframe['rate_date'].dt.date market_rates_dataframe['route_id'] = route_description market_rates_dataframe Out[\u00a0]: route_id rate_date rate_value unit vessel_class_id deprecated_to 0 VLCC - MEG/China 2024-06-19 50.0 WS 84 None 1 VLCC - MEG/China 2024-06-20 49.5 WS 84 None 2 VLCC - MEG/China 2024-06-21 49.0 WS 84 None 3 VLCC - MEG/China 2024-06-22 49.0 WS 84 None 4 VLCC - MEG/China 2024-06-23 49.0 WS 84 None ... ... ... ... ... ... ... 176 VLCC - MEG/China 2024-12-12 39.5 WS 84 None 177 VLCC - MEG/China 2024-12-13 39.0 WS 84 None 178 VLCC - MEG/China 2024-12-14 39.0 WS 84 None 179 VLCC - MEG/China 2024-12-15 39.0 WS 84 None 180 VLCC - MEG/China 2024-12-16 39.0 WS 84 None <p>181 rows \u00d7 6 columns</p> In\u00a0[\u00a0]: Copied! <pre>merge_df = pd.merge(market_rates_dataframe, merge_df, left_on='rate_date', right_on='date', how='left').drop(['rate_date', 'deprecated_to', 'vessel_class_id'], axis=1)\n</pre> merge_df = pd.merge(market_rates_dataframe, merge_df, left_on='rate_date', right_on='date', how='left').drop(['rate_date', 'deprecated_to', 'vessel_class_id'], axis=1) In\u00a0[\u00a0]: Copied! <pre>merge_df\n</pre> merge_df Out[\u00a0]: route_id rate_value unit date 10days 20days ballast_unfixed_20 on_subs_20 pushed_20 0 VLCC - MEG/China 50.0 WS 2024-06-19 5.0 58 48 10.0 53.0 1 VLCC - MEG/China 49.5 WS 2024-06-20 2.0 51 40 3.0 49.0 2 VLCC - MEG/China 49.0 WS 2024-06-21 1.0 55 39 5.0 53.0 3 VLCC - MEG/China 49.0 WS 2024-06-22 6.0 56 44 6.0 54.0 4 VLCC - MEG/China 49.0 WS 2024-06-23 6.0 62 47 5.0 56.0 ... ... ... ... ... ... ... ... ... ... 176 VLCC - MEG/China 39.5 WS 2024-12-12 1.0 39 30 2.0 30.0 177 VLCC - MEG/China 39.0 WS 2024-12-13 NaN 42 30 1.0 35.0 178 VLCC - MEG/China 39.0 WS 2024-12-14 NaN 50 34 2.0 41.0 179 VLCC - MEG/China 39.0 WS 2024-12-15 4.0 56 41 2.0 47.0 180 VLCC - MEG/China 39.0 WS 2024-12-16 5.0 55 44 2.0 46.0 <p>181 rows \u00d7 9 columns</p> In\u00a0[\u00a0]: Copied! <pre>merge_df.to_excel(now.strftime(\"%Y.%m.%d-%H:%M:%S-\")+customer_name+'-'+route_description.replace(\"/\", \"-\")+'.xlsx')\n</pre> merge_df.to_excel(now.strftime(\"%Y.%m.%d-%H:%M:%S-\")+customer_name+'-'+route_description.replace(\"/\", \"-\")+'.xlsx') In\u00a0[\u00a0]: Copied! <pre>merge_df = merge_df.dropna(subset=['date'])\nplt.figure(figsize=(10, 6))  # Optional: Set the figure size\nplt.plot(merge_df['date'], merge_df['20days'], label='Vessel Counts', color='b', marker='o')\nplt.plot(merge_df['date'], merge_df['rate_value'], label='Rates', color='r', marker='x')\n\nplt.xlabel('Date')\nplt.ylabel('Counts Vs Rates')\nplt.title('')\nplt.xticks(rotation=45)  # Rotate x-axis labels for better readability\nplt.legend()\n\nplt.tight_layout()  # Adjust layout to make room for labels\nplt.show()\n</pre>  merge_df = merge_df.dropna(subset=['date']) plt.figure(figsize=(10, 6))  # Optional: Set the figure size plt.plot(merge_df['date'], merge_df['20days'], label='Vessel Counts', color='b', marker='o') plt.plot(merge_df['date'], merge_df['rate_value'], label='Rates', color='r', marker='x')  plt.xlabel('Date') plt.ylabel('Counts Vs Rates') plt.title('') plt.xticks(rotation=45)  # Rotate x-axis labels for better readability plt.legend()  plt.tight_layout()  # Adjust layout to make room for labels plt.show()"},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#vlccs-megchina-supply-trend-market-rates-implementing-filters","title":"VLCCs MEG/China Supply Trend &amp; Market Rates, implementing Filters\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":"<p>APIs Used: Tonnage List, Market Rates</p> <p>Description:</p> <p>The goal of this example is to plot the supply trend alongside predicted market rates, providing insights into market behavior. We are calling the Historical Tonnage List twice for two different scenarios: one with a Laycan End of 10 days and the other with 20 days. For both cases, Excel files are generated containing the full dataset. Subsequently, we apply filtering and grouping across various layers, such as Open Areas and Commercial Status, ultimately producing the Supply Trend Chart.</p> <p>Output: Excel Files for different scenarios, Supply Trend Chart</p>"},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#installation-and-imports","title":"Installation and imports\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#supply-and-market-rates-set","title":"Supply and Market Rates Set\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#getting-the-data","title":"Getting the Data\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#saving-full-dataset-to-excel","title":"Saving Full Dataset to Excel\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#areas-filtering","title":"Areas Filtering\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#grouping-and-filtering-the-data","title":"Grouping and Filtering the data\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#getting-the-rates","title":"Getting the Rates\u00b6","text":""},{"location":"examples/jupyter/Combined%20Examples/VLCCs_MEG_China_Supply_Trend_Versus_Market_Rates_with_Implementing_Filters/#result-dataframe","title":"Result Dataframe\u00b6","text":""},{"location":"examples/jupyter/CompaniesAPI/CompaniesAPI/","title":"Companies API Example","text":"In\u00a0[1]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[2]: Copied! <pre>from signal_ocean.companies import CompaniesAPI\nimport pandas as pd\nfrom signal_ocean import Connection\n\nsubscription_key = \"\" # paste your subscription key here\nconnection = Connection(subscription_key)\n</pre> from signal_ocean.companies import CompaniesAPI import pandas as pd from signal_ocean import Connection  subscription_key = \"\" # paste your subscription key here connection = Connection(subscription_key) In\u00a0[3]: Copied! <pre>api = CompaniesAPI(connection)\n</pre> api = CompaniesAPI(connection) In\u00a0[4]: Copied! <pre>company_id = 1926\nc = api.get_company(company_id)\nprint(f'Company {company_id}: {c.company_name} ({c.website})')\n</pre> company_id = 1926 c = api.get_company(company_id) print(f'Company {company_id}: {c.company_name} ({c.website})') <pre>Company 1926: Signal Maritime (http://signalmaritime.com/)\n</pre> In\u00a0[5]: Copied! <pre>companies = api.get_companies()\n</pre> companies = api.get_companies() In\u00a0[6]: Copied! <pre>len(companies)\n</pre> len(companies) Out[6]: <pre>4492</pre> In\u00a0[7]: Copied! <pre>df = pd.DataFrame([x.__dict__ for x in companies])\n</pre> df = pd.DataFrame([x.__dict__ for x in companies]) In\u00a0[8]: Copied! <pre>df.columns\n</pre> df.columns Out[8]: <pre>Index(['id', 'updated_date', 'company_name', 'website', 'fleet_list',\n       'synonyms', 'charterer_vessel_types',\n       'commercial_operator_vessel_types', 'geo_asset_owner_vessel_types',\n       'broker_vessel_types', 'port_agent_vessel_types', 'parent_company_id',\n       'children_companies_ids'],\n      dtype='object')</pre> In\u00a0[9]: Copied! <pre>df.head(10)\n</pre> df.head(10) Out[9]: id updated_date company_name website fleet_list synonyms charterer_vessel_types commercial_operator_vessel_types geo_asset_owner_vessel_types broker_vessel_types port_agent_vessel_types parent_company_id children_companies_ids 0 3 2018-06-22 14:09:27.793000+00:00 Abiola Shipping http://www.equasis.org/EquasisWeb/restricted/C... None None None (Tanker,) None None None NaN None 1 5 2018-08-08 09:39:21.360000+00:00 Abu Dhabi https://adnoc.ae/adnoc-onshore/notification None None None None (Tanker,) None None NaN None 2 6 2016-10-31 16:32:56.757000+00:00 Abu Dhabi Gas Industries http://www.gasco.ae/en/Pages/Index.aspx None (Gasco,) None None (Tanker,) None None NaN None 3 7 2016-10-31 16:32:56.757000+00:00 Abu Dhabi Marine Operating Company http://www.adma-opco.com/en/home/index.aspx?&amp;P... None (ADMA-OPCO,) None None (Tanker,) None None NaN None 4 8 2016-10-31 16:32:56.757000+00:00 Abu Dhabi Oil Company http://adocauh.cts-co.net/ None (ADOC,) (Tanker,) None (Tanker,) None None NaN None 5 9 2016-10-31 16:39:13.283000+00:00 Abu Dubai Oil Refining Company http://www.takreer.com/index.html None (TAKREER,) None None (Tanker,) None None NaN None 6 10 2016-10-31 16:32:56.757000+00:00 Aca Sa http://www.acacitv.com/ None None None None (Tanker,) None None NaN None 7 12 2016-10-31 16:32:56.757000+00:00 Ace Tankers http://www.ace-tankers.com/ http://www.ace-tankers.com/fleet.html None None (Tanker,) None None None NaN None 8 13 2016-10-31 16:32:56.757000+00:00 Aceitera General https://www.agd.com.ar/en/home/ None (AGD,) (Tanker,) None None None None NaN None 9 16 2016-12-23 17:55:50.580000+00:00 Achema Group http://www.achemosgrupe.lt/en/who-we-are/ None None None None (Tanker,) None None NaN None In\u00a0[10]: Copied! <pre>companies = api.get_companies('maritime')\n</pre> companies = api.get_companies('maritime') In\u00a0[11]: Copied! <pre>len(companies)\n</pre> len(companies) Out[11]: <pre>184</pre> In\u00a0[12]: Copied! <pre>df = pd.DataFrame([x.__dict__ for x in companies])\n</pre> df = pd.DataFrame([x.__dict__ for x in companies]) In\u00a0[13]: Copied! <pre>df.head(10)\n</pre> df.head(10) Out[13]: id updated_date company_name website fleet_list synonyms charterer_vessel_types commercial_operator_vessel_types geo_asset_owner_vessel_types broker_vessel_types port_agent_vessel_types parent_company_id children_companies_ids 0 43 2016-10-31 16:32:56.757000+00:00 Al Rekab Global Maritime http://marbnet.com/directory/listing/al-rekab-... None None None (Tanker,) None None None NaN None 1 53 2019-07-30 11:25:15.727000+00:00 Alma Maritime http://www.almamaritime.com/ http://www.almamaritime.com/content/fleet/004/... None None (Tanker, Dry) None None None NaN None 2 66 2016-10-31 16:32:56.757000+00:00 Alvan Maritime https://opencorporates.com/companies/pa/744162 None None None (Tanker,) None None None NaN None 3 81 2016-10-31 16:32:56.757000+00:00 Andros Maritime http://www.logisticscout.com/company-andros-ma... None None None (Tanker,) None None None NaN None 4 95 2018-05-11 08:29:26.513000+00:00 Arab Maritime Petroleum Transport http://www.amptc.net/ http://www.amptc.net/ (AMPTC,) None (Tanker,) None None None NaN None 5 118 2018-06-27 12:31:03.710000+00:00 Associated Maritime http://www.hkmw.com.hk/webappen/main.asp?sid=455 http://www.hkmw.com.hk/webappen/main3.asp?sid=482 (AMCL,) None (Tanker, Dry) None None None NaN (286,) 6 124 2016-10-31 16:32:56.757000+00:00 Atlas Maritime http://www.atlasmaritime.eu/ http://www.atlasmaritime.eu/fleet None (Tanker,) None None None None NaN None 7 168 2016-10-31 16:32:56.757000+00:00 Belavero Maritime http://marbnet.com/directory/listing/belavero-... None None None (Tanker,) None None None NaN None 8 203 2016-10-31 16:32:56.757000+00:00 Boray Maritime http://www.world-ships.com/company/df76f52c5e4... None None None (Tanker,) None None None NaN None 9 226 2018-07-06 13:08:51.450000+00:00 Byzantine Maritime http://www.bmc.gr/ http://www.bmc.gr/fleet/Fleet.htm (BMC,) None (Tanker, Dry) None None None NaN None In\u00a0[14]: Copied! <pre>df[df['company_name'].str.startswith('Signal')]\n</pre> df[df['company_name'].str.startswith('Signal')] Out[14]: id updated_date company_name website fleet_list synonyms charterer_vessel_types commercial_operator_vessel_types geo_asset_owner_vessel_types broker_vessel_types port_agent_vessel_types parent_company_id children_companies_ids 61 1926 2018-10-08 12:51:54.213000+00:00 Signal Maritime http://signalmaritime.com/ http://signalmaritime.com/ None None (Tanker, Dry) None None None NaN None"},{"location":"examples/jupyter/CompaniesAPI/CompaniesAPI/#companies-api-example","title":"Companies API Example\u00b6","text":""},{"location":"examples/jupyter/CompaniesAPI/CompaniesAPI/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/CompaniesAPI/CompaniesAPI/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Subscribe to the Companies API at https://apis.signalocean.com/ to get a subscription key. Use the key to configure your connection to the API:</p>"},{"location":"examples/jupyter/CompaniesAPI/CompaniesAPI/#call-the-companies-api","title":"Call the Companies API\u00b6","text":"<p>The Companies API retrieves information about companies.</p>"},{"location":"examples/jupyter/CompaniesAPI/CompaniesAPI/#get-company-by-id","title":"Get company by id\u00b6","text":""},{"location":"examples/jupyter/CompaniesAPI/CompaniesAPI/#get-details-for-all-companies","title":"Get details for all companies\u00b6","text":""},{"location":"examples/jupyter/CompaniesAPI/CompaniesAPI/#get-all-companies-the-name-of-which-contains-the-term-maritime","title":"Get all companies the name of which contains the term Maritime\u00b6","text":""},{"location":"examples/jupyter/DistancesAPI/AlternativeRoutes/","title":"Distances API - Alternative Routes Example","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[\u00a0]: Copied! <pre>pip install folium\n</pre> pip install folium In\u00a0[1]: Copied! <pre>from signal_ocean import Connection\n\nsubscription_key = \"\" # paste your subscription key here\nconnection = Connection(subscription_key)\n</pre> from signal_ocean import Connection  subscription_key = \"\" # paste your subscription key here connection = Connection(subscription_key) In\u00a0[2]: Copied! <pre>from decimal import Decimal\nfrom signal_ocean.distances import DistancesAPI, Point\n\ndistances_api = DistancesAPI(connection)\n\nmilazzo_coordinates = Point(Decimal(\"38.2115\"), Decimal(\"15.2665\"))\nbasrah_coordinates = Point(Decimal(\"29.6964\"), Decimal(\"48.8095\"))\n\nmain_route = distances_api.get_generic_point_to_point_route(milazzo_coordinates, basrah_coordinates, get_alternatives=True)\n</pre> from decimal import Decimal from signal_ocean.distances import DistancesAPI, Point  distances_api = DistancesAPI(connection)  milazzo_coordinates = Point(Decimal(\"38.2115\"), Decimal(\"15.2665\")) basrah_coordinates = Point(Decimal(\"29.6964\"), Decimal(\"48.8095\"))  main_route = distances_api.get_generic_point_to_point_route(milazzo_coordinates, basrah_coordinates, get_alternatives=True) <p>The return value is a route that contains a list of its alternatives:</p> In\u00a0[3]: Copied! <pre>print(\"Main route distance:\", main_route.distance)\nprint(\"Alternative routes:\", len(main_route.alternative_paths))\nfor n, alternative in enumerate(main_route.alternative_paths, start=1):\n    print(f\"Alternative {n} distance: {alternative.distance}\")\n</pre> print(\"Main route distance:\", main_route.distance) print(\"Alternative routes:\", len(main_route.alternative_paths)) for n, alternative in enumerate(main_route.alternative_paths, start=1):     print(f\"Alternative {n} distance: {alternative.distance}\") <pre>Main route distance: 4291.93\nAlternative routes: 2\nAlternative 1 distance: 4581.4\nAlternative 2 distance: 11268.02\n</pre> In\u00a0[4]: Copied! <pre>import folium\n\nm = folium.Map()\nfolium.Marker([milazzo_coordinates.lat, milazzo_coordinates.lon], popup=\"Milazzo\").add_to(m)\nfolium.Marker([basrah_coordinates.lat, basrah_coordinates.lon], popup=\"Basrah\").add_to(m)\n\nall_routes = [main_route.calculated_route] + [alternative.calculated_route for alternative in main_route.alternative_paths]\ncolors = [\"red\", \"blue\", \"green\", \"purple\", \"orange\"]\n\nfor index, route in enumerate(all_routes):\n    folium.PolyLine([[float(point.lat), float(point.lon)] for point in route], color=colors[index % len(colors)]).add_to(m)\n\nlatitudes = [float(point.lat) for point in route for route in all_routes]\nlongitudes = [float(point.lon) for point in route for route in all_routes]\nm.fit_bounds([\n    [min(latitudes), min(longitudes)],\n    [max(latitudes), max(longitudes)],\n])\n\nm\n</pre> import folium  m = folium.Map() folium.Marker([milazzo_coordinates.lat, milazzo_coordinates.lon], popup=\"Milazzo\").add_to(m) folium.Marker([basrah_coordinates.lat, basrah_coordinates.lon], popup=\"Basrah\").add_to(m)  all_routes = [main_route.calculated_route] + [alternative.calculated_route for alternative in main_route.alternative_paths] colors = [\"red\", \"blue\", \"green\", \"purple\", \"orange\"]  for index, route in enumerate(all_routes):     folium.PolyLine([[float(point.lat), float(point.lon)] for point in route], color=colors[index % len(colors)]).add_to(m)  latitudes = [float(point.lat) for point in route for route in all_routes] longitudes = [float(point.lon) for point in route for route in all_routes] m.fit_bounds([     [min(latitudes), min(longitudes)],     [max(latitudes), max(longitudes)], ])  m Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/jupyter/DistancesAPI/AlternativeRoutes/#distances-api-alternative-routes-example","title":"Distances API - Alternative Routes Example\u00b6","text":""},{"location":"examples/jupyter/DistancesAPI/AlternativeRoutes/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/DistancesAPI/AlternativeRoutes/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Subscribe to the Distances API at https://apis.signalocean.com/ to get a subscription key. Use the key to configure your connection to the API:</p>"},{"location":"examples/jupyter/DistancesAPI/AlternativeRoutes/#get-a-route-and-its-alternatives","title":"Get a route and its alternatives\u00b6","text":"<p>To get a route along with all possible alternative routes, use the <code>get_generic_point_to_point_route</code> method and set the <code>get_alternatives</code> parameter to <code>True</code>. For example, to find all possible routes between the ports in Milazzo and Basrah:</p>"},{"location":"examples/jupyter/DistancesAPI/AlternativeRoutes/#visualize-the-routes","title":"Visualize the routes\u00b6","text":"<p>To display the routes on a map:</p>"},{"location":"examples/jupyter/DistancesAPI/DistancesWithRouteExample/","title":"Distances API Route Example","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[\u00a0]: Copied! <pre>pip install folium\n</pre> pip install folium In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.distances import DistancesAPI, VesselClassFilter, PortFilter, LoadingCondition\n\nconnection = Connection(api_key=signal_ocean_api_key)\ndistances_api = DistancesAPI(connection)\n\nload_port = distances_api.get_ports(PortFilter(name_like='Basrah'))[0]\ndischarge_port = distances_api.get_ports(PortFilter(name_like='Milazzo'))[0]\n\nvessel_class = distances_api.get_vessel_classes(VesselClassFilter(name_like='suezmax'))[0]\nrouteResponse = distances_api.get_port_to_port_route(vessel_class, LoadingCondition.BALLAST, load_port, discharge_port)\n</pre> from signal_ocean import Connection from signal_ocean.distances import DistancesAPI, VesselClassFilter, PortFilter, LoadingCondition  connection = Connection(api_key=signal_ocean_api_key) distances_api = DistancesAPI(connection)  load_port = distances_api.get_ports(PortFilter(name_like='Basrah'))[0] discharge_port = distances_api.get_ports(PortFilter(name_like='Milazzo'))[0]  vessel_class = distances_api.get_vessel_classes(VesselClassFilter(name_like='suezmax'))[0] routeResponse = distances_api.get_port_to_port_route(vessel_class, LoadingCondition.BALLAST, load_port, discharge_port) In\u00a0[3]: Copied! <pre>print(f\"Total distance: {routeResponse.distance}\")\nprint(f\"Seca distance: {routeResponse.seca_distance}\")\nprint(f\"Hra distance: {routeResponse.piracy_distance}\")\nprint(f\"Significant routing points: {[(routing_point.name) for routing_point in routeResponse.routing_points_on_route if routing_point.is_shown]}\")\n</pre>  print(f\"Total distance: {routeResponse.distance}\") print(f\"Seca distance: {routeResponse.seca_distance}\") print(f\"Hra distance: {routeResponse.piracy_distance}\") print(f\"Significant routing points: {[(routing_point.name) for routing_point in routeResponse.routing_points_on_route if routing_point.is_shown]}\")  <pre>Total distance: 4574.86\nSeca distance: 0\nHra distance: 1301.22\nSignificant routing points: ['Suez']\n</pre> In\u00a0[4]: Copied! <pre>import folium\n\ncoordinatesList = []\nfor point in routeResponse.calculated_route:\n    newList = [float(point.lat), float(point.lon)]\n    coordinatesList.append(newList)\nm = folium.Map(zoom_start=10)\ngh_fg = folium.FeatureGroup(name=f\"Path ({load_port.name}) -&gt; ({discharge_port.name})\").add_to(m)\nfolium.PolyLine(locations=coordinatesList, weight=2, color='cadetblue').add_to(gh_fg)\nfolium.LayerControl().add_to(m)\n\n#Get bounding box of route:\nbbox = [[float(routeResponse.bbox[1]), float(routeResponse.bbox[0])], [float(routeResponse.bbox[3]), float(routeResponse.bbox[2])]]\nm.fit_bounds(bbox)\n\n#put some markers to display start and stop\nfolium.Marker(\n    location=[routeResponse.start_point.lat, routeResponse.start_point.lon],\n    popup= load_port.name,\n    icon=folium.Icon(color='green')\n).add_to(m)\n\nfolium.Marker(\n    location=[routeResponse.end_point.lat, routeResponse.end_point.lon],\n    popup= discharge_port.name,\n    icon=folium.Icon(color='red')\n).add_to(m)\n\nm\n</pre> import folium  coordinatesList = [] for point in routeResponse.calculated_route:     newList = [float(point.lat), float(point.lon)]     coordinatesList.append(newList) m = folium.Map(zoom_start=10) gh_fg = folium.FeatureGroup(name=f\"Path ({load_port.name}) -&gt; ({discharge_port.name})\").add_to(m) folium.PolyLine(locations=coordinatesList, weight=2, color='cadetblue').add_to(gh_fg) folium.LayerControl().add_to(m)  #Get bounding box of route: bbox = [[float(routeResponse.bbox[1]), float(routeResponse.bbox[0])], [float(routeResponse.bbox[3]), float(routeResponse.bbox[2])]] m.fit_bounds(bbox)  #put some markers to display start and stop folium.Marker(     location=[routeResponse.start_point.lat, routeResponse.start_point.lon],     popup= load_port.name,     icon=folium.Icon(color='green') ).add_to(m)  folium.Marker(     location=[routeResponse.end_point.lat, routeResponse.end_point.lon],     popup= discharge_port.name,     icon=folium.Icon(color='red') ).add_to(m)  m Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/jupyter/DistancesAPI/DistancesWithRouteExample/#distances-api-route-example","title":"Distances API Route Example\u00b6","text":""},{"location":"examples/jupyter/DistancesAPI/DistancesWithRouteExample/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/DistancesAPI/DistancesWithRouteExample/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/DistancesAPI/DistancesWithRouteExample/#get-the-route-between-2-ports","title":"Get the route between 2 ports\u00b6","text":"<p>Create a connections towards distances API. Then call the distance API to get the actual route between Basrah and Milazzo for a Suezmax vessel (corresponding restrictions applied)</p>"},{"location":"examples/jupyter/DistancesAPI/DistancesWithRouteExample/#display-some-properties-for-the-route","title":"Display some properties for the route\u00b6","text":"<p>The route response objects holds information on properties regarding the route like:</p> <ul> <li>The total distance covered.</li> <li>The seca distance covered within the route.</li> <li>The hra distance covered within the route.</li> <li>Any significant routing points met across the route (i.e: Suez)</li> </ul>"},{"location":"examples/jupyter/DistancesAPI/DistancesWithRouteExample/#display-the-route-on-a-map","title":"Display the route on a map\u00b6","text":"<p>Finally you can get all route coordinates and display them on the map.</p>"},{"location":"examples/jupyter/DistancesAPI/QuickStartDistancesAPI/","title":"Distances API Example","text":"In\u00a0[1]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[3]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.distances import DistancesAPI, VesselClassFilter, PortFilter, LoadingCondition\n\nconnection = Connection(api_key=signal_ocean_api_key)\ndistances_api = DistancesAPI(connection)\n\nload_port = distances_api.get_ports(PortFilter(name_like='Fujairah'))[0]\ndischarge_port = distances_api.get_ports(PortFilter(name_like='Singapore'))[0]\n\nvessel_class = distances_api.get_vessel_classes(VesselClassFilter(name_like='vlcc'))[0]\ndistanceInNM = distances_api.get_port_to_port_distance(vessel_class, LoadingCondition.BALLAST, load_port, discharge_port)\n\nprint(distanceInNM)\n</pre> from signal_ocean import Connection from signal_ocean.distances import DistancesAPI, VesselClassFilter, PortFilter, LoadingCondition  connection = Connection(api_key=signal_ocean_api_key) distances_api = DistancesAPI(connection)  load_port = distances_api.get_ports(PortFilter(name_like='Fujairah'))[0] discharge_port = distances_api.get_ports(PortFilter(name_like='Singapore'))[0]  vessel_class = distances_api.get_vessel_classes(VesselClassFilter(name_like='vlcc'))[0] distanceInNM = distances_api.get_port_to_port_distance(vessel_class, LoadingCondition.BALLAST, load_port, discharge_port)  print(distanceInNM) <pre>3302.86\n</pre> In\u00a0[4]: Copied! <pre>distancesFromTriesteDictionary = {}\n\nport_from = distances_api.get_ports(PortFilter(name_like='Trieste'))[0]\nports_to_get_distance = ['Rotterdam','Singapore','Lome','Long Beach','Galveston','Pazflor','Bonny','Ras Tanura','Houston','Escravos']\n\nfor port_to_filter in ports_to_get_distance:\n    port_to = distances_api.get_ports(PortFilter(name_like=port_to_filter))[0]\n    distanceInNM = distances_api.get_port_to_port_distance(vessel_class, LoadingCondition.BALLAST, port_from, port_to)\n    distancesFromTriesteDictionary[port_to.name] = float(distanceInNM)\n</pre> distancesFromTriesteDictionary = {}  port_from = distances_api.get_ports(PortFilter(name_like='Trieste'))[0] ports_to_get_distance = ['Rotterdam','Singapore','Lome','Long Beach','Galveston','Pazflor','Bonny','Ras Tanura','Houston','Escravos']  for port_to_filter in ports_to_get_distance:     port_to = distances_api.get_ports(PortFilter(name_like=port_to_filter))[0]     distanceInNM = distances_api.get_port_to_port_distance(vessel_class, LoadingCondition.BALLAST, port_from, port_to)     distancesFromTriesteDictionary[port_to.name] = float(distanceInNM) In\u00a0[5]: Copied! <pre>import pandas as pd\nimport openpyxl\n\ndf = pd.DataFrame(data=distancesFromTriesteDictionary, index=[0])\npd.options.display.float_format = '{:,.2f}'.format\ndf = (df.T)\ndf.to_excel('simpleDistanceMatrix_Trieste_Aframax_Ballast.xlsx')\ndf\n</pre> import pandas as pd import openpyxl  df = pd.DataFrame(data=distancesFromTriesteDictionary, index=[0]) pd.options.display.float_format = '{:,.2f}'.format df = (df.T) df.to_excel('simpleDistanceMatrix_Trieste_Aframax_Ballast.xlsx') df Out[5]: 0 Rotterdam 3,079.19 Singapore 6,386.87 Lome 4,688.84 Long Beach 13,980.85 Galveston 6,403.92 Pazflor 5,500.45 Bonny 5,027.66 Ras Tanura 4,480.52 Houston 6,430.57 Escravos 4,884.11"},{"location":"examples/jupyter/DistancesAPI/QuickStartDistancesAPI/#distances-api-example","title":"Distances API Example\u00b6","text":""},{"location":"examples/jupyter/DistancesAPI/QuickStartDistancesAPI/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/DistancesAPI/QuickStartDistancesAPI/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/DistancesAPI/QuickStartDistancesAPI/#calculate-a-distance-over-2-ports","title":"Calculate a distance over 2 ports\u00b6","text":"<p>Create a connections towards distances API. Then call the distance API to get a distance between Fuijairah and Singapore for a VLCC vessel (corresponding restrictions applied)</p>"},{"location":"examples/jupyter/DistancesAPI/QuickStartDistancesAPI/#create-a-distance-matrix","title":"Create a distance matrix\u00b6","text":"<p>Find distance in NM for a Aframax vessel from Trieste to every available port. Persist the output in an excel file.</p>"},{"location":"examples/jupyter/FreightRatesAPI/FreightRatesAPI/","title":"Freight Rates API Example","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection, FreightRatesAPI\nfrom signal_ocean.freight_rates import PortFilter\n\nconnection = Connection(api_key=signal_ocean_api_key)\nfr_api = FreightRatesAPI(connection)\n</pre> from signal_ocean import Connection, FreightRatesAPI from signal_ocean.freight_rates import PortFilter  connection = Connection(api_key=signal_ocean_api_key) fr_api = FreightRatesAPI(connection) In\u00a0[3]: Copied! <pre>vessel_classes = fr_api.get_vessel_classes()\nprint(vessel_classes)\n</pre> vessel_classes = fr_api.get_vessel_classes() print(vessel_classes) <pre>('VLCC', 'Suezmax', 'Aframax', 'PanamaxTanker', 'MR2', 'MR1')\n</pre> In\u00a0[4]: Copied! <pre>from signal_ocean.freight_rates.utils import create_dataframe\nfrom signal_ocean.plots import styled_table, line_chart\n\namsterdam = fr_api.get_ports(PortFilter(name_like='Amsterdam'))[0]\nlome = fr_api.get_ports(PortFilter(name_like='Lome'))[0]\nfr = fr_api.get_freight_pricing(load_ports=[amsterdam.id],\n                                discharge_ports=[lome.id],\n                                vessel_classes=[\"PanamaxTanker\"],\n                                is_clean=True)\ndf = create_dataframe(fr)\nstyled_table(df.T)\n</pre> from signal_ocean.freight_rates.utils import create_dataframe from signal_ocean.plots import styled_table, line_chart  amsterdam = fr_api.get_ports(PortFilter(name_like='Amsterdam'))[0] lome = fr_api.get_ports(PortFilter(name_like='Lome'))[0] fr = fr_api.get_freight_pricing(load_ports=[amsterdam.id],                                 discharge_ports=[lome.id],                                 vessel_classes=[\"PanamaxTanker\"],                                 is_clean=True) df = create_dataframe(fr) styled_table(df.T) <p>We can also plot the freight rates for the same combination from 1st of January until today:</p> In\u00a0[5]: Copied! <pre>from datetime import date, timedelta\nimport pandas as pd\n\ndates = [date(2021, 4, 1) + timedelta(days=i) for i in\n         range((date.today()-date(2021, 4, 1)).days + 1)]\ncpc = fr_api.get_ports(PortFilter(name_like='CPC'))[0]\naugusta = fr_api.get_ports(PortFilter(name_like='Augusta'))[0]\nrates = []\n\nfor day in dates:\n    frates = fr_api.get_freight_pricing(load_ports=[cpc.id],\n                                        discharge_ports=[augusta.id],\n                                        vessel_classes=[\"Aframax\"],\n                                        is_clean=False,\n                                        date=day)\n    rates.append(frates[0].total_freight_rate)\n\ndf = pd.DataFrame({'Date':dates,'Rate':rates})\n\nline_chart(df,'Date','Rate')\n</pre> from datetime import date, timedelta import pandas as pd  dates = [date(2021, 4, 1) + timedelta(days=i) for i in          range((date.today()-date(2021, 4, 1)).days + 1)] cpc = fr_api.get_ports(PortFilter(name_like='CPC'))[0] augusta = fr_api.get_ports(PortFilter(name_like='Augusta'))[0] rates = []  for day in dates:     frates = fr_api.get_freight_pricing(load_ports=[cpc.id],                                         discharge_ports=[augusta.id],                                         vessel_classes=[\"Aframax\"],                                         is_clean=False,                                         date=day)     rates.append(frates[0].total_freight_rate)  df = pd.DataFrame({'Date':dates,'Rate':rates})  line_chart(df,'Date','Rate') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/FreightRatesAPI/FreightRatesAPI/#freight-rates-api-example","title":"Freight Rates API Example\u00b6","text":""},{"location":"examples/jupyter/FreightRatesAPI/FreightRatesAPI/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/FreightRatesAPI/FreightRatesAPI/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/FreightRatesAPI/FreightRatesAPI/#freight-rates-api","title":"Freight Rates API\u00b6","text":"<p>The Freight Rates API retrieves freight costs breakdown for a given load, discharge port and vessel class. First create connection towards Freight Rates API in order to find available ports and vessel classes:</p>"},{"location":"examples/jupyter/FreightRatesAPI/FreightRatesAPI/#find-available-ports-and-vessel-classes","title":"Find available ports and vessel classes\u00b6","text":"<p>Now retrieve the available vessel classes and look if specific ports are available. If you want to get all the available ports do not pass any parameter to the corresponding method.</p>"},{"location":"examples/jupyter/FreightRatesAPI/FreightRatesAPI/#get-freight-rates-for-specific-ports-and-vessel-class","title":"Get freight rates for specific ports and vessel class\u00b6","text":"<p>In this example we retrieve today\u2019s freight rate for Clean Panamax Amsterdam - Lome:</p>"},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/","title":"Geos API Example","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p> In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[\u00a0]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.geos import GeosAPI\nimport numpy as np\nimport pandas as pd\nimport requests\nimport json\n</pre> from signal_ocean import Connection from signal_ocean.geos import GeosAPI import numpy as np import pandas as pd import requests import json In\u00a0[\u00a0]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = GeosAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = GeosAPI(connection) <p>In this notebook we will show how you can get all the different kinds of Geo data available.</p> <p>There are three kinds of Geo data:</p> <ul> <li>Areas</li> <li>Countries</li> <li>Ports</li> <li>GeoAssets</li> </ul> In\u00a0[\u00a0]: Copied! <pre>all_areas = api.get_areas()\n</pre> all_areas = api.get_areas() In\u00a0[\u00a0]: Copied! <pre>df_areas = pd.DataFrame([a.__dict__ for a in all_areas])\n</pre> df_areas = pd.DataFrame([a.__dict__ for a in all_areas]) In\u00a0[\u00a0]: Copied! <pre>df_areas.head(10)\n</pre> df_areas.head(10) <p>This can create a tree-like structure.</p> <p>Example</p> <ul> <li>West<ul> <li>Black Sea / Sea Of Marmara</li> <li>Atlantic America</li> <li>Baltic / North Sea</li> <li>Mediterranean / UK Continent<ul> <li>UK Continent</li> <li>Mediterranean<ul> <li>West Mediterranean</li> <li>East Mediterranean</li> <li>Central Mediterranean</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>We can get a dataframe with the complete area tree by gradually merging an area type with the one below it.</p> In\u00a0[\u00a0]: Copied! <pre>df_areas_all = df_areas[df_areas['location_taxonomy_id'] == 7].merge(df_areas,\n                                                             how = 'left',\n                                                             left_on = 'area_id',\n                                                             right_on = 'parent_area_id',\n                                                             suffixes = ['_type7','_type6'])[['area_id_type7',\n                                                                                              'area_name_type7',\n                                                                                              'area_id_type6',\n                                                                                              'area_name_type6']]\\\n                                                      .merge(df_areas,\n                                                             how = 'left',\n                                                             left_on = 'area_id_type6',\n                                                             right_on = 'parent_area_id')[['area_id_type7',\n                                                                                           'area_name_type7',\n                                                                                           'area_id_type6',\n                                                                                           'area_name_type6',\n                                                                                           'area_id',\n                                                                                           'area_name']]\\\n                                                      .merge(df_areas,\n                                                             how = 'left',\n                                                             left_on = 'area_id',\n                                                             right_on = 'parent_area_id',\n                                                             suffixes = ['_type5','_type4'])[['area_id_type7',\n                                                                                              'area_name_type7',\n                                                                                              'area_id_type6',\n                                                                                              'area_name_type6',\n                                                                                              'area_id_type5',\n                                                                                              'area_name_type5',\n                                                                                              'area_id_type4',\n                                                                                              'area_name_type4']]\n</pre> df_areas_all = df_areas[df_areas['location_taxonomy_id'] == 7].merge(df_areas,                                                              how = 'left',                                                              left_on = 'area_id',                                                              right_on = 'parent_area_id',                                                              suffixes = ['_type7','_type6'])[['area_id_type7',                                                                                               'area_name_type7',                                                                                               'area_id_type6',                                                                                               'area_name_type6']]\\                                                       .merge(df_areas,                                                              how = 'left',                                                              left_on = 'area_id_type6',                                                              right_on = 'parent_area_id')[['area_id_type7',                                                                                            'area_name_type7',                                                                                            'area_id_type6',                                                                                            'area_name_type6',                                                                                            'area_id',                                                                                            'area_name']]\\                                                       .merge(df_areas,                                                              how = 'left',                                                              left_on = 'area_id',                                                              right_on = 'parent_area_id',                                                              suffixes = ['_type5','_type4'])[['area_id_type7',                                                                                               'area_name_type7',                                                                                               'area_id_type6',                                                                                               'area_name_type6',                                                                                               'area_id_type5',                                                                                               'area_name_type5',                                                                                               'area_id_type4',                                                                                               'area_name_type4']]  In\u00a0[\u00a0]: Copied! <pre>df_areas_all.head(10)\n</pre> df_areas_all.head(10) <p>From there we can recreate the area tree example from above, by filetring a specific type 3 area.</p> In\u00a0[\u00a0]: Copied! <pre>df_areas_all[df_areas_all['area_name_type7'] == 'West']\n</pre> df_areas_all[df_areas_all['area_name_type7'] == 'West'] In\u00a0[\u00a0]: Copied! <pre>all_countries = api.get_countries()\n</pre> all_countries = api.get_countries() In\u00a0[\u00a0]: Copied! <pre>df_countries = pd.DataFrame([a.__dict__ for a in all_countries])\n</pre> df_countries = pd.DataFrame([a.__dict__ for a in all_countries]) In\u00a0[\u00a0]: Copied! <pre>df_countries.head(10)\n</pre> df_countries.head(10) In\u00a0[\u00a0]: Copied! <pre>all_ports = api.get_ports()\n</pre> all_ports = api.get_ports() In\u00a0[\u00a0]: Copied! <pre>df_ports = pd.DataFrame([a.__dict__ for a in all_ports])\n</pre> df_ports = pd.DataFrame([a.__dict__ for a in all_ports]) In\u00a0[\u00a0]: Copied! <pre>df_ports.head(10)\n</pre> df_ports.head(10) In\u00a0[\u00a0]: Copied! <pre>area_name = 'US Gulf'\n</pre> area_name = 'US Gulf' In\u00a0[\u00a0]: Copied! <pre>df_Ports_In_Area = df_areas[  (df_areas['area_name'] == area_name ) \n                            &amp; (df_areas['location_taxonomy_id'] == 4)].merge(df_ports,\n                                                                     how = 'left',\n                                                                     left_on = 'area_id',\n                                                                     right_on = 'area_id_level0',\n                                                                     suffixes = ['_area','_port'])[['port_id','port_name','area_id','area_name']]\n</pre> df_Ports_In_Area = df_areas[  (df_areas['area_name'] == area_name )                              &amp; (df_areas['location_taxonomy_id'] == 4)].merge(df_ports,                                                                      how = 'left',                                                                      left_on = 'area_id',                                                                      right_on = 'area_id_level0',                                                                      suffixes = ['_area','_port'])[['port_id','port_name','area_id','area_name']] In\u00a0[\u00a0]: Copied! <pre>df_Ports_In_Area.head(10)\n</pre> df_Ports_In_Area.head(10) In\u00a0[\u00a0]: Copied! <pre>country_name = 'United Arab Emirates'\n</pre> country_name = 'United Arab Emirates' In\u00a0[\u00a0]: Copied! <pre>df_Ports_In_Country = df_countries[df_countries['country_name'] == country_name].merge(df_ports,\n                                                                               how = 'left',\n                                                                               left_on = 'country_id',\n                                                                               right_on = 'country_id',\n                                                                               suffixes = ['_country','_port'])[['port_id','port_name','country_id','country_name_country']]\n</pre> df_Ports_In_Country = df_countries[df_countries['country_name'] == country_name].merge(df_ports,                                                                                how = 'left',                                                                                left_on = 'country_id',                                                                                right_on = 'country_id',                                                                                suffixes = ['_country','_port'])[['port_id','port_name','country_id','country_name_country']] In\u00a0[\u00a0]: Copied! <pre>df_Ports_In_Country.head(10)\n</pre> df_Ports_In_Country.head(10) <p>Some countries can span across multiple type 0 areas. We can make that connection through ports.</p> In\u00a0[\u00a0]: Copied! <pre>country_name = 'United States'\n</pre> country_name = 'United States' In\u00a0[\u00a0]: Copied! <pre>df_countries[df_countries['country_name'] == country_name].merge(df_ports,\n                                                         how = 'left',\n                                                         left_on = 'country_id',\n                                                         right_on = 'country_id',\n                                                         suffixes = ['_country',None])[['port_id','port_name','country_id','country_name_country','area_id_level0']]\\\n                                                  .merge(df_areas,\n                                                         how = 'left',\n                                                         left_on = 'area_id_level0',\n                                                         right_on = 'area_id',\n                                                         suffixes = (None, '_area'))[['country_id','country_name_country','area_id', 'area_name']].area_name.unique()\n</pre> df_countries[df_countries['country_name'] == country_name].merge(df_ports,                                                          how = 'left',                                                          left_on = 'country_id',                                                          right_on = 'country_id',                                                          suffixes = ['_country',None])[['port_id','port_name','country_id','country_name_country','area_id_level0']]\\                                                   .merge(df_areas,                                                          how = 'left',                                                          left_on = 'area_id_level0',                                                          right_on = 'area_id',                                                          suffixes = (None, '_area'))[['country_id','country_name_country','area_id', 'area_name']].area_name.unique() In\u00a0[\u00a0]: Copied! <pre>df_Ports_country_count =  df_ports.merge(df_countries,\n                                         how = 'left',\n                                         left_on = 'country_id',\n                                         right_on = 'country_id',\n                                         suffixes =['_port','_country'])[['port_id','port_name','country_id','country_name_country']] \n</pre> df_Ports_country_count =  df_ports.merge(df_countries,                                          how = 'left',                                          left_on = 'country_id',                                          right_on = 'country_id',                                          suffixes =['_port','_country'])[['port_id','port_name','country_id','country_name_country']]  In\u00a0[\u00a0]: Copied! <pre>df_Ports_country_count.country_name_country.value_counts().head(10)\n</pre> df_Ports_country_count.country_name_country.value_counts().head(10) In\u00a0[\u00a0]: Copied! <pre>all_geoAssets = api.get_geoAssets()\n</pre> all_geoAssets = api.get_geoAssets() In\u00a0[\u00a0]: Copied! <pre>df_geoAssets = pd.DataFrame([a.__dict__ for a in all_geoAssets])\n</pre> df_geoAssets = pd.DataFrame([a.__dict__ for a in all_geoAssets]) In\u00a0[\u00a0]: Copied! <pre>df_geoAssets.head(10)\n</pre> df_geoAssets.head(10)"},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#geos-api-example","title":"Geos API Example\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#scope","title":"Scope\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#areas","title":"Areas\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#get-all-available-areas","title":"Get all available areas\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#get-a-dataframe-with-all-area-level-names","title":"Get a dataframe with all area level names\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#countries","title":"Countries\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#get-available-countries","title":"Get available countries\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#ports","title":"Ports\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#get-availabe-ports","title":"Get availabe ports\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#using-all-of-the-data-above","title":"Using all of the data above\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#get-all-ports-in-a-specific-level-0-area","title":"Get all ports in a specific level 0 area\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#get-all-ports-in-a-specific-country","title":"Get all ports in a specific country\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#get-all-areas-in-a-country","title":"Get all areas in a country\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#find-the-top-10-countries-with-the-most-ports","title":"Find the top 10 Countries with the most Ports\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#geo-assets","title":"Geo Assets\u00b6","text":""},{"location":"examples/jupyter/GeosAPI/GeosAPI%20Use%20Case/#get-availabe-geo-assets","title":"Get availabe geo assets\u00b6","text":""},{"location":"examples/jupyter/MarketRatesAPI/MarketRatesAPI/","title":"Market Rates API Example","text":"In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection, MarketRatesAPI\nfrom datetime import date\n\nconnection = Connection(api_key=signal_ocean_api_key)\nmr_api = MarketRatesAPI(connection)\n</pre> from signal_ocean import Connection, MarketRatesAPI from datetime import date  connection = Connection(api_key=signal_ocean_api_key) mr_api = MarketRatesAPI(connection) In\u00a0[3]: Copied! <pre>from signal_ocean.market_rates.utils import create_dataframe\nfrom signal_ocean.plots import styled_table, line_chart\n\nvessel_classes = mr_api.get_vessel_classes()\nstyled_table(create_dataframe(vessel_classes))\n</pre> from signal_ocean.market_rates.utils import create_dataframe from signal_ocean.plots import styled_table, line_chart  vessel_classes = mr_api.get_vessel_classes() styled_table(create_dataframe(vessel_classes)) In\u00a0[4]: Copied! <pre>vlcc_routes = mr_api.get_routes(vessel_class_id=84)\nvlcc_routes_df = create_dataframe(vlcc_routes).drop(\n    ['LoadPortId', 'DischargePortId', 'LoadAreaId',\n     'DischargeAreaId', 'LoadPort2Id', 'DischargePort2Id', 'LoadArea2Id',\n     'DischargeArea2Id', 'DeprecatedTo', 'DeprecatedSince'], axis=1)\nstyled_table(vlcc_routes_df)\n</pre> vlcc_routes = mr_api.get_routes(vessel_class_id=84) vlcc_routes_df = create_dataframe(vlcc_routes).drop(     ['LoadPortId', 'DischargePortId', 'LoadAreaId',      'DischargeAreaId', 'LoadPort2Id', 'DischargePort2Id', 'LoadArea2Id',      'DischargeArea2Id', 'DeprecatedTo', 'DeprecatedSince'], axis=1) styled_table(vlcc_routes_df) In\u00a0[5]: Copied! <pre>from signal_ocean.market_rates import CargoId\n\nmarket_rates_for_vlcc = mr_api.get_market_rates(date(2020, 1, 2),\n                                                vessel_class_id=84,\n                                                cargo_id=CargoId.DIRTY)\nstyled_table(create_dataframe(market_rates_for_vlcc))\n</pre> from signal_ocean.market_rates import CargoId  market_rates_for_vlcc = mr_api.get_market_rates(date(2020, 1, 2),                                                 vessel_class_id=84,                                                 cargo_id=CargoId.DIRTY) styled_table(create_dataframe(market_rates_for_vlcc)) <p>We can also see how market rates evolve on the routes of a certain vessel class for a given time period. Below we plot the VLCC market rates in WS from October through December 2020.</p> In\u00a0[9]: Copied! <pre>import warnings\nwarnings.filterwarnings('ignore')\n\nvlcc_rates = mr_api.get_market_rates(start_date=date(2020, 10, 1),\n                                end_date=date(2020, 12, 31),\n                                vessel_class_id=88,\n                                cargo_id=CargoId.CLEAN)\nline_chart(create_dataframe(vlcc_rates), 'RateDate', \"RateValue\", \"RouteId\")\n</pre> import warnings warnings.filterwarnings('ignore')  vlcc_rates = mr_api.get_market_rates(start_date=date(2020, 10, 1),                                 end_date=date(2020, 12, 31),                                 vessel_class_id=88,                                 cargo_id=CargoId.CLEAN) line_chart(create_dataframe(vlcc_rates), 'RateDate', \"RateValue\", \"RouteId\") In\u00a0[89]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/MarketRatesAPI/MarketRatesAPI/#market-rates-api-example","title":"Market Rates API Example\u00b6","text":""},{"location":"examples/jupyter/MarketRatesAPI/MarketRatesAPI/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/MarketRatesAPI/MarketRatesAPI/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/MarketRatesAPI/MarketRatesAPI/#market-rates-api","title":"Market Rates API\u00b6","text":"<p>The Market Rates API retrieves available routes and market rates. First create connection towards Market Rates API in order to find available routes by vessel class:</p>"},{"location":"examples/jupyter/MarketRatesAPI/MarketRatesAPI/#get-the-available-vessel-classes","title":"Get the available vessel classes\u00b6","text":"<p>Retrieve the vessel classes for which we can get routes or market rates:</p>"},{"location":"examples/jupyter/MarketRatesAPI/MarketRatesAPI/#get-routes-for-a-vessel-class","title":"Get routes for a vessel class\u00b6","text":"<p>Based on the vessel classes that we got above we can request available routes for VLCC vessels</p>"},{"location":"examples/jupyter/MarketRatesAPI/MarketRatesAPI/#get-the-market-rates","title":"Get the market rates\u00b6","text":"<p>Now we can request the market rate on a given date for one of the routes we got in previous step or for all routes matching this vessel class</p>"},{"location":"examples/jupyter/PortExpensesAPI/PortExpensesAPI/","title":"Port Expenses API Example","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection, PortExpensesAPI\nfrom signal_ocean.port_expenses import PortFilter\nfrom datetime import datetime\n\nconnection = Connection(api_key=signal_ocean_api_key)\npe_api = PortExpensesAPI(connection)\n</pre> from signal_ocean import Connection, PortExpensesAPI from signal_ocean.port_expenses import PortFilter from datetime import datetime  connection = Connection(api_key=signal_ocean_api_key) pe_api = PortExpensesAPI(connection) In\u00a0[3]: Copied! <pre>ningbo = pe_api.get_ports(PortFilter(name_like='Ningbo'))[0]\npe_api.get_port_expenses(imo = 9867621, port_id = ningbo.id)\n</pre> ningbo = pe_api.get_ports(PortFilter(name_like='Ningbo'))[0] pe_api.get_port_expenses(imo = 9867621, port_id = ningbo.id) Out[3]: <pre>PortExpenses(port_id=3302, towage=6676, port_dues=23067, pilotage=9337, agency_fees=14769, other=2580, suez_dues=0, total_cost=56429, miscellaneous_dues=0, is_estimated=False, canal_dues=0, berth_dues=0, lighthouse_dues=0, mooring_unmooring=0, quay_dues=0, anchorage_dues=0)</pre> <p>The result contains a breakdown of the costs as well as the total cost. In cases where we do not have the exact port costs modelled in our system, a total cost based on historical actual DAs is returned. In that case the is_estimated is True.</p> In\u00a0[4]: Copied! <pre>pe_api.get_required_formula_parameters(port_id = ningbo.id, vessel_type_id = 1)\n</pre> pe_api.get_required_formula_parameters(port_id = ningbo.id, vessel_type_id = 1) Out[4]: <pre>['EstimatedTimeOfBerth', 'EstimatedTimeOfSail']</pre> <p>Get again the expenses for the port of Ningbo, this time by also passing one of the optional parameters retrieved above i.e. estimated time of berth:</p> In\u00a0[5]: Copied! <pre>pe_api.get_port_expenses(imo = 9867621, port_id = ningbo.id, estimated_time_of_berth=datetime(2019, 2, 27, 17, 48, 11))\n</pre> pe_api.get_port_expenses(imo = 9867621, port_id = ningbo.id, estimated_time_of_berth=datetime(2019, 2, 27, 17, 48, 11)) Out[5]: <pre>PortExpenses(port_id=3302, towage=6676, port_dues=23067, pilotage=7622, agency_fees=14769, other=2580, suez_dues=0, total_cost=54714, miscellaneous_dues=0, is_estimated=False, canal_dues=0, berth_dues=0, lighthouse_dues=0, mooring_unmooring=0, quay_dues=0, anchorage_dues=0)</pre> In\u00a0[6]: Copied! <pre>vessel_types = pe_api.get_vessel_types()\nprint(vessel_types)\n</pre> vessel_types = pe_api.get_vessel_types() print(vessel_types) <pre>(VesselType(id=1, name='Tanker'), VesselType(id=3, name='Dry'), VesselType(id=4, name='Container'), VesselType(id=5, name='LNG'), VesselType(id=6, name='LPG'))\n</pre> <p>Get expenses for Ningbo for dry vessels as of 8-3-2020:</p> In\u00a0[7]: Copied! <pre>dry_vessel_type = next(vt for vt in vessel_types if vt.name=='Dry')\npe_api.get_port_model_vessel_expenses(port_id = ningbo.id, vessel_type_id = dry_vessel_type.id, formula_calculation_date = datetime(2020, 3, 8, 0, 0, 0))\n</pre> dry_vessel_type = next(vt for vt in vessel_types if vt.name=='Dry') pe_api.get_port_model_vessel_expenses(port_id = ningbo.id, vessel_type_id = dry_vessel_type.id, formula_calculation_date = datetime(2020, 3, 8, 0, 0, 0)) Out[7]: <pre>PortExpenses(port_id=3302, towage=3748, port_dues=19687, pilotage=8067, agency_fees=4411, other=1117, suez_dues=0, total_cost=37672, miscellaneous_dues=0, is_estimated=False, canal_dues=0, berth_dues=0, lighthouse_dues=0, mooring_unmooring=0, quay_dues=0, anchorage_dues=642)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/PortExpensesAPI/PortExpensesAPI/#port-expenses-api-example","title":"Port Expenses API Example\u00b6","text":""},{"location":"examples/jupyter/PortExpensesAPI/PortExpensesAPI/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/PortExpensesAPI/PortExpensesAPI/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/PortExpensesAPI/PortExpensesAPI/#port-expenses-api","title":"Port expenses API\u00b6","text":"<p>The Port Expenses API retrieves expenses breakdown for a given port. First create connection towards Port Expenses API in order to find available ports by name:</p>"},{"location":"examples/jupyter/PortExpensesAPI/PortExpensesAPI/#get-the-port-expenses-for-an-imo","title":"Get the port expenses for an IMO\u00b6","text":"<p>Now retrieve the expenses for the port of Ningbo for a given vessel IMO:</p>"},{"location":"examples/jupyter/PortExpensesAPI/PortExpensesAPI/#optional-port-expenses-calculation-parameters","title":"Optional port expenses calculation parameters\u00b6","text":"<p>Depending on the port, the expenses calculation can be more precise by passing some extra parameters. Retrieve the list of the parameters for the port of Ningbo.</p>"},{"location":"examples/jupyter/PortExpensesAPI/PortExpensesAPI/#get-the-port-expenses-for-a-model-vessel","title":"Get the port expenses for a model vessel\u00b6","text":"<p>Port expenses can also be calculated based on a model vessel. Retrieve all available vessel types:</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/","title":"Historical Cargo Distribution in a Level 1 Area","text":"<p>Install the Signal Ocean package</p> In\u00a0[\u00a0]: Copied! <pre>%%capture\n%pip install signal-ocean\n</pre> %%capture %pip install signal-ocean <p>Import <code>signal_ocean</code> and other modules required for this demo</p> In\u00a0[\u00a0]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.scraped_cargoes import ScrapedCargoesAPI, ScrapedCargo\nfrom signal_ocean.geos import GeosAPI\n\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', 50)\n</pre> from signal_ocean import Connection from signal_ocean.scraped_cargoes import ScrapedCargoesAPI, ScrapedCargo from signal_ocean.geos import GeosAPI  from datetime import datetime, timedelta import pandas as pd import matplotlib.pyplot as plt import numpy as np  pd.set_option('display.max_columns', None) pd.set_option('display.max_rows', 50)  <p>To get all tanker cargoes received the last X days, we must declare <code>vessel_type_id = 1</code>  and <code>received_date_from</code> variables</p> In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = '' # Replace with your subscription key\nvessel_type_id = 1  # Tanker\ndays_back = 20\nreceived_date_from = datetime.utcnow() - timedelta(days=days_back)\nArea_level_1 = 'US Gulf &amp; Mainland' # Area Level 1 that we want to visualize\n</pre> signal_ocean_api_key = '' # Replace with your subscription key vessel_type_id = 1  # Tanker days_back = 20 received_date_from = datetime.utcnow() - timedelta(days=days_back) Area_level_1 = 'US Gulf &amp; Mainland' # Area Level 1 that we want to visualize <p>Create a new instance of the <code>ScrapedCargoesAPI</code> and <code>GeosAPI</code> classes</p> In\u00a0[\u00a0]: Copied! <pre>connection = Connection(signal_ocean_api_key)\nscraped_cargoes_api = ScrapedCargoesAPI(connection)\ngeos_api = GeosAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) scraped_cargoes_api = ScrapedCargoesAPI(connection) geos_api = GeosAPI(connection) <p>Now we are ready to retrieve our data</p> <p>You may also find more on our Scraped Cargoes API here, including documentation of the object methods used and more examples.</p> <p>Call <code>get_cargoes</code> method, as below</p> In\u00a0[\u00a0]: Copied! <pre>scraped_cargoes = scraped_cargoes_api.get_cargoes(vessel_type = vessel_type_id,received_date_from = received_date_from)\n\nscraped_cargoes = [cargo for cargo in scraped_cargoes if not cargo.is_deleted]\n</pre> scraped_cargoes = scraped_cargoes_api.get_cargoes(vessel_type = vessel_type_id,received_date_from = received_date_from)  scraped_cargoes = [cargo for cargo in scraped_cargoes if not cargo.is_deleted] <p>For better visualization, it's convenient to insert data into a DataFrame</p> In\u00a0[\u00a0]: Copied! <pre>scraped_cargoes_df = pd.DataFrame(scraped_cargoes)\nscraped_cargoes_df.head()\n</pre> scraped_cargoes_df = pd.DataFrame(scraped_cargoes) scraped_cargoes_df.head() Out[\u00a0]: cargo_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date is_deleted low_confidence scraped_laycan laycan_from laycan_to scraped_load load_geo_id load_name load_taxonomy_id load_taxonomy scraped_load2 load_geo_id2 load_name2 load_taxonomy_id2 load_taxonomy2 scraped_discharge scraped_discharge_options discharge_geo_id discharge_name discharge_taxonomy_id discharge_taxonomy scraped_discharge2 discharge_geo_id2 discharge_name2 discharge_taxonomy_id2 discharge_taxonomy2 scraped_charterer charterer_id charterer scraped_cargo_type cargo_type_id cargo_type cargo_type_group_id cargo_type_group scraped_quantity quantity quantity_buffer quantity_from quantity_to size_from size_to scraped_delivery_date delivery_date_from delivery_date_to scraped_delivery_from delivery_from_geo_id delivery_from_name delivery_from_taxonomy_id delivery_from_taxonomy scraped_delivery_to delivery_to_geo_id delivery_to_name delivery_to_taxonomy_id delivery_to_taxonomy scraped_redelivery_from redelivery_from_geo_id redelivery_from_name redelivery_from_taxonomy_id redelivery_from_taxonomy scraped_redelivery_to redelivery_to_geo_id redelivery_to_name redelivery_to_taxonomy_id redelivery_to_taxonomy charter_type_id charter_type cargo_status_id cargo_status content subject sender is_private 0 54777015 88353911 None 88135885 17 17 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 19-20 mar 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 chennai 3517.0 Chennai 2.0 Port None NaN None NaN None east None 84.0 East 7.0 Level3 None NaN None NaN None vitol 1831.0 Vitol nap 9.0 Naphtha 120000.0 Clean 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None vitol 19-20 mar nap 35 chennai east unsure there harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 1 54777016 88353911 None 88135884 17 17 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 19-20 mar 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 chennai 3517.0 Chennai 2.0 Port None NaN None NaN None east None 84.0 East 7.0 Level3 None NaN None NaN None vitol 1831.0 Vitol nap 9.0 Naphtha 120000.0 Clean 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None vitol 19-20 mar nap 35 chennai east unsure there harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 2 54777017 88353911 None 88135885 18 18 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 21-23 mar 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 sikka 3530.0 Sikka 2.0 Port None NaN None NaN None oz None 16.0 Australia / New Zealand 5.0 Level1 None NaN None NaN None bp 209.0 BP ulsd 60.0 Ultra Low Sulphur Diesel 120000.0 Clean 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None bp 21-23 mar ulsd 35 sikka oz outstanding harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 3 54777018 88353911 None 88135884 18 18 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 21-23 mar 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 sikka 3530.0 Sikka 2.0 Port None NaN None NaN None oz None 16.0 Australia / New Zealand 5.0 Level1 None NaN None NaN None bp 209.0 BP ulsd 60.0 Ultra Low Sulphur Diesel 120000.0 Clean 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None bp 21-23 mar ulsd 35 sikka oz outstanding harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 4 54777019 88353911 None 88135885 19 19 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 23-25 mar 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 ag eaf -1.0 None -1.0 Unknown None NaN None NaN None saf None 24776.0 South Africa 4.0 Level0 None NaN None NaN None trafigura 1713.0 Trafigura cpp 120000.0 Clean NaN None 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None trafigura 23-25 mar cpp 35 ag eaf / saf outsta... harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True <p>We perform a deduplication based on Quantity size, Delivery location, Delivery Date and Laycan Date.</p> <p>Adding columns to DataFrame to condense information of interest</p> In\u00a0[\u00a0]: Copied! <pre>scraped_cargoes_df[\"quantity_size_from\"] = \"\"\nscraped_cargoes_df[\"quantity_size_to\"] = \"\"\nscraped_cargoes_df[\"load_delivery_id\"] = \"\"\nscraped_cargoes_df[\"load_delivery_name\"] = \"\"\nscraped_cargoes_df[\"laycan_delivery_date_from\"] = \"\"\nscraped_cargoes_df[\"laycan_delivery_date_to\"] = \"\"\n\nfor ind in scraped_cargoes_df.index:\n    CharterType = scraped_cargoes_df.loc[ind, 'charter_type']\n\n\n    if  not pd.isna(scraped_cargoes_df.loc[ind, \"quantity_from\"]):\n       scraped_cargoes_df.loc[ind, \"quantity_size_from\"] = scraped_cargoes_df.loc[ind, \"quantity_from\"]\n       scraped_cargoes_df.loc[ind, \"quantity_size_to\"] = scraped_cargoes_df.loc[ind, \"quantity_to\"]\n    else:\n       scraped_cargoes_df.loc[ind, \"quantity_size_from\"] = scraped_cargoes_df.loc[ind, \"size_from\"]\n       scraped_cargoes_df.loc[ind, \"quantity_size_to\"] = scraped_cargoes_df.loc[ind, \"size_to\"]\n\n    if CharterType == 'Voyage':\n        scraped_cargoes_df.loc[ind, \"load_delivery_id\"] = scraped_cargoes_df.loc[ind, \"load_geo_id\"]\n        scraped_cargoes_df.loc[ind, \"load_delivery_name\"] = scraped_cargoes_df.loc[ind, \"load_name\"]\n        scraped_cargoes_df.loc[ind, \"laycan_delivery_date_from\"] = scraped_cargoes_df.loc[ind, \"laycan_from\"]\n        scraped_cargoes_df.loc[ind, \"laycan_delivery_date_to\"] = scraped_cargoes_df.loc[ind, \"laycan_to\"]\n    else:\n        scraped_cargoes_df.loc[ind, \"load_delivery_id\"] = scraped_cargoes_df.loc[ind, \"delivery_from_geo_id\"]\n        scraped_cargoes_df.loc[ind, \"load_delivery_name\"] = scraped_cargoes_df.loc[ind, \"delivery_from_name\"]\n        scraped_cargoes_df.loc[ind, \"laycan_delivery_date_from\"] = scraped_cargoes_df.loc[ind, \"delivery_date_from\"]\n        scraped_cargoes_df.loc[ind, \"laycan_delivery_date_to\"] = scraped_cargoes_df.loc[ind, \"delivery_date_to\"]\nscraped_cargoes_df[\"parent_cargo\"] = 0\n\nscraped_cargoes_df.head()\n</pre> scraped_cargoes_df[\"quantity_size_from\"] = \"\" scraped_cargoes_df[\"quantity_size_to\"] = \"\" scraped_cargoes_df[\"load_delivery_id\"] = \"\" scraped_cargoes_df[\"load_delivery_name\"] = \"\" scraped_cargoes_df[\"laycan_delivery_date_from\"] = \"\" scraped_cargoes_df[\"laycan_delivery_date_to\"] = \"\"  for ind in scraped_cargoes_df.index:     CharterType = scraped_cargoes_df.loc[ind, 'charter_type']       if  not pd.isna(scraped_cargoes_df.loc[ind, \"quantity_from\"]):        scraped_cargoes_df.loc[ind, \"quantity_size_from\"] = scraped_cargoes_df.loc[ind, \"quantity_from\"]        scraped_cargoes_df.loc[ind, \"quantity_size_to\"] = scraped_cargoes_df.loc[ind, \"quantity_to\"]     else:        scraped_cargoes_df.loc[ind, \"quantity_size_from\"] = scraped_cargoes_df.loc[ind, \"size_from\"]        scraped_cargoes_df.loc[ind, \"quantity_size_to\"] = scraped_cargoes_df.loc[ind, \"size_to\"]      if CharterType == 'Voyage':         scraped_cargoes_df.loc[ind, \"load_delivery_id\"] = scraped_cargoes_df.loc[ind, \"load_geo_id\"]         scraped_cargoes_df.loc[ind, \"load_delivery_name\"] = scraped_cargoes_df.loc[ind, \"load_name\"]         scraped_cargoes_df.loc[ind, \"laycan_delivery_date_from\"] = scraped_cargoes_df.loc[ind, \"laycan_from\"]         scraped_cargoes_df.loc[ind, \"laycan_delivery_date_to\"] = scraped_cargoes_df.loc[ind, \"laycan_to\"]     else:         scraped_cargoes_df.loc[ind, \"load_delivery_id\"] = scraped_cargoes_df.loc[ind, \"delivery_from_geo_id\"]         scraped_cargoes_df.loc[ind, \"load_delivery_name\"] = scraped_cargoes_df.loc[ind, \"delivery_from_name\"]         scraped_cargoes_df.loc[ind, \"laycan_delivery_date_from\"] = scraped_cargoes_df.loc[ind, \"delivery_date_from\"]         scraped_cargoes_df.loc[ind, \"laycan_delivery_date_to\"] = scraped_cargoes_df.loc[ind, \"delivery_date_to\"] scraped_cargoes_df[\"parent_cargo\"] = 0  scraped_cargoes_df.head() Out[\u00a0]: cargo_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date is_deleted low_confidence scraped_laycan laycan_from laycan_to scraped_load load_geo_id load_name load_taxonomy_id load_taxonomy scraped_load2 load_geo_id2 load_name2 load_taxonomy_id2 load_taxonomy2 scraped_discharge scraped_discharge_options discharge_geo_id discharge_name discharge_taxonomy_id discharge_taxonomy scraped_discharge2 discharge_geo_id2 discharge_name2 discharge_taxonomy_id2 discharge_taxonomy2 scraped_charterer charterer_id charterer scraped_cargo_type cargo_type_id cargo_type cargo_type_group_id cargo_type_group scraped_quantity quantity quantity_buffer quantity_from quantity_to size_from size_to scraped_delivery_date delivery_date_from delivery_date_to scraped_delivery_from delivery_from_geo_id delivery_from_name delivery_from_taxonomy_id delivery_from_taxonomy scraped_delivery_to delivery_to_geo_id delivery_to_name delivery_to_taxonomy_id delivery_to_taxonomy scraped_redelivery_from redelivery_from_geo_id redelivery_from_name redelivery_from_taxonomy_id redelivery_from_taxonomy scraped_redelivery_to redelivery_to_geo_id redelivery_to_name redelivery_to_taxonomy_id redelivery_to_taxonomy charter_type_id charter_type cargo_status_id cargo_status content subject sender is_private quantity_size_from quantity_size_to load_delivery_id load_delivery_name laycan_delivery_date_from laycan_delivery_date_to parent_cargo 0 54777015 88353911 None 88135885 17 17 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 19-20 mar 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 chennai 3517.0 Chennai 2.0 Port None NaN None NaN None east None 84.0 East 7.0 Level3 None NaN None NaN None vitol 1831.0 Vitol nap 9.0 Naphtha 120000.0 Clean 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None vitol 19-20 mar nap 35 chennai east unsure there harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 35000.0 35000.0 3517.0 Chennai 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 0 1 54777016 88353911 None 88135884 17 17 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 19-20 mar 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 chennai 3517.0 Chennai 2.0 Port None NaN None NaN None east None 84.0 East 7.0 Level3 None NaN None NaN None vitol 1831.0 Vitol nap 9.0 Naphtha 120000.0 Clean 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None vitol 19-20 mar nap 35 chennai east unsure there harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 35000.0 35000.0 3517.0 Chennai 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 0 2 54777017 88353911 None 88135885 18 18 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 21-23 mar 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 sikka 3530.0 Sikka 2.0 Port None NaN None NaN None oz None 16.0 Australia / New Zealand 5.0 Level1 None NaN None NaN None bp 209.0 BP ulsd 60.0 Ultra Low Sulphur Diesel 120000.0 Clean 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None bp 21-23 mar ulsd 35 sikka oz outstanding harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 35000.0 35000.0 3530.0 Sikka 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 0 3 54777018 88353911 None 88135884 18 18 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 21-23 mar 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 sikka 3530.0 Sikka 2.0 Port None NaN None NaN None oz None 16.0 Australia / New Zealand 5.0 Level1 None NaN None NaN None bp 209.0 BP ulsd 60.0 Ultra Low Sulphur Diesel 120000.0 Clean 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None bp 21-23 mar ulsd 35 sikka oz outstanding harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 35000.0 35000.0 3530.0 Sikka 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 0 4 54777019 88353911 None 88135885 19 19 NaN Email 2025-03-13 16:02:08+00:00 2025-03-13 16:00:20+00:00 False False 23-25 mar 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 ag eaf -1.0 None -1.0 Unknown None NaN None NaN None saf None 24776.0 South Africa 4.0 Level0 None NaN None NaN None trafigura 1713.0 Trafigura cpp 120000.0 Clean NaN None 35 35000.0 0.0 35000.0 35000.0 NaN NaN None NaT NaT None NaN None NaN None None NaN None NaN None None NaN None NaN None None NaN None NaN None 0 Voyage NaN None trafigura 23-25 mar cpp 35 ag eaf / saf outsta... harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True 35000.0 35000.0 -1.0 None 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 0 <p>Drop Columns from DataFrame that are not needed</p> In\u00a0[\u00a0]: Copied! <pre>scraped_cargoes_df = scraped_cargoes_df[['received_date','charterer','quantity_size_from','quantity_size_to','load_delivery_name','load_taxonomy','load_delivery_id','laycan_delivery_date_from','laycan_delivery_date_to','charter_type','parent_cargo']]\nscraped_cargoes_df.loc[:, 'received_date'] = scraped_cargoes_df['received_date'].dt.normalize()\nscraped_cargoes_df.head(5)\n</pre> scraped_cargoes_df = scraped_cargoes_df[['received_date','charterer','quantity_size_from','quantity_size_to','load_delivery_name','load_taxonomy','load_delivery_id','laycan_delivery_date_from','laycan_delivery_date_to','charter_type','parent_cargo']] scraped_cargoes_df.loc[:, 'received_date'] = scraped_cargoes_df['received_date'].dt.normalize() scraped_cargoes_df.head(5) Out[\u00a0]: received_date charterer quantity_size_from quantity_size_to load_delivery_name load_taxonomy load_delivery_id laycan_delivery_date_from laycan_delivery_date_to charter_type parent_cargo 0 2025-03-13 00:00:00+00:00 Vitol 35000.0 35000.0 Chennai Port 3517.0 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 Voyage 0 1 2025-03-13 00:00:00+00:00 Vitol 35000.0 35000.0 Chennai Port 3517.0 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 Voyage 0 2 2025-03-13 00:00:00+00:00 BP 35000.0 35000.0 Sikka Port 3530.0 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 Voyage 0 3 2025-03-13 00:00:00+00:00 BP 35000.0 35000.0 Sikka Port 3530.0 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 Voyage 0 4 2025-03-13 00:00:00+00:00 Trafigura 35000.0 35000.0 None Unknown -1.0 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 Voyage 0 <p>Cargo count before deduplication</p> In\u00a0[\u00a0]: Copied! <pre>print (\"Count of cargoes before deduplications:\" ,len(scraped_cargoes_df.index))\n</pre> print (\"Count of cargoes before deduplications:\" ,len(scraped_cargoes_df.index)) <pre>Count of cargoes before deduplications: 10467\n</pre> In\u00a0[\u00a0]: Copied! <pre>scraped_cargoes_df.set_index('received_date').head(10)\n</pre> scraped_cargoes_df.set_index('received_date').head(10) Out[\u00a0]: charterer quantity_size_from quantity_size_to load_delivery_name load_taxonomy load_delivery_id laycan_delivery_date_from laycan_delivery_date_to charter_type parent_cargo received_date 2025-03-13 00:00:00+00:00 Vitol 35000.0 35000.0 Chennai Port 3517.0 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 Vitol 35000.0 35000.0 Chennai Port 3517.0 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 BP 35000.0 35000.0 Sikka Port 3530.0 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 BP 35000.0 35000.0 Sikka Port 3530.0 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 Trafigura 35000.0 35000.0 None Unknown -1.0 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 Trafigura 35000.0 35000.0 None Unknown -1.0 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 Aramco Trading Singapore 35000.0 35000.0 Arabian Gulf Level0 24777.0 2025-03-28 00:00:00+00:00 2025-03-29 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 Aramco Trading Singapore 35000.0 35000.0 Arabian Gulf Level0 24777.0 2025-03-28 00:00:00+00:00 2025-03-29 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 Emirates National Oil 35000.0 35000.0 Umm Qasr Port 7117.0 2025-03-28 00:00:00+00:00 2025-03-30 00:00:00+00:00 Voyage 0 2025-03-13 00:00:00+00:00 Emirates National Oil 35000.0 35000.0 Umm Qasr Port 7117.0 2025-03-28 00:00:00+00:00 2025-03-30 00:00:00+00:00 Voyage 0 <p>Drop Duplicated Cargo Records</p> In\u00a0[\u00a0]: Copied! <pre>scraped_cargoes_df_deduplicated=scraped_cargoes_df.drop_duplicates()\nscraped_cargoes_df_deduplicated.head(10)\n</pre> scraped_cargoes_df_deduplicated=scraped_cargoes_df.drop_duplicates() scraped_cargoes_df_deduplicated.head(10) Out[\u00a0]: received_date charterer quantity_size_from quantity_size_to load_delivery_name load_taxonomy load_delivery_id laycan_delivery_date_from laycan_delivery_date_to charter_type parent_cargo 0 2025-03-13 00:00:00+00:00 Vitol 35000.0 35000.0 Chennai Port 3517.0 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 Voyage 0 2 2025-03-13 00:00:00+00:00 BP 35000.0 35000.0 Sikka Port 3530.0 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 Voyage 0 4 2025-03-13 00:00:00+00:00 Trafigura 35000.0 35000.0 None Unknown -1.0 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 Voyage 0 6 2025-03-13 00:00:00+00:00 Aramco Trading Singapore 35000.0 35000.0 Arabian Gulf Level0 24777.0 2025-03-28 00:00:00+00:00 2025-03-29 00:00:00+00:00 Voyage 0 8 2025-03-13 00:00:00+00:00 Emirates National Oil 35000.0 35000.0 Umm Qasr Port 7117.0 2025-03-28 00:00:00+00:00 2025-03-30 00:00:00+00:00 Voyage 0 10 2025-03-13 00:00:00+00:00 Total 35000.0 35000.0 Jebel Ali Port 3157.0 2025-03-19 00:00:00+00:00 2025-03-19 00:00:00+00:00 Voyage 0 12 2025-03-13 00:00:00+00:00 Trafigura 35000.0 35000.0 None Unknown -1.0 2025-03-11 00:00:00+00:00 2025-03-12 00:00:00+00:00 Voyage 0 14 2025-03-13 00:00:00+00:00 Bayegan 30000.0 30000.0 None Unknown -1.0 2025-03-15 00:00:00+00:00 2025-03-16 00:00:00+00:00 Voyage 0 15 2025-03-13 00:00:00+00:00 Mercuria 30000.0 37000.0 Fawley Port 3426.0 2025-03-16 00:00:00+00:00 2025-03-18 00:00:00+00:00 Voyage 0 17 2025-03-13 00:00:00+00:00 Trafigura 30000.0 37000.0 Terneuzen Port 3691.0 NaT NaT Voyage 0 <p>Count of cargoes after deduplication</p> In\u00a0[\u00a0]: Copied! <pre>print (\"Count of cargoes after deduplications:\" ,len(scraped_cargoes_df_deduplicated.index))\n</pre> print (\"Count of cargoes after deduplications:\" ,len(scraped_cargoes_df_deduplicated.index)) <pre>Count of cargoes after deduplications: 4108\n</pre> <p>Calculation of cargoes recieved per day globally</p> In\u00a0[\u00a0]: Copied! <pre>date_counts = scraped_cargoes_df_deduplicated.groupby('received_date').size().reset_index(name='count')\ndate_counts\n</pre> date_counts = scraped_cargoes_df_deduplicated.groupby('received_date').size().reset_index(name='count') date_counts Out[\u00a0]: received_date count 0 2025-03-13 00:00:00+00:00 48 1 2025-03-14 00:00:00+00:00 218 2 2025-03-15 00:00:00+00:00 54 3 2025-03-17 00:00:00+00:00 338 4 2025-03-18 00:00:00+00:00 339 5 2025-03-19 00:00:00+00:00 362 6 2025-03-20 00:00:00+00:00 345 7 2025-03-21 00:00:00+00:00 338 8 2025-03-24 00:00:00+00:00 244 9 2025-03-25 00:00:00+00:00 271 10 2025-03-26 00:00:00+00:00 278 11 2025-03-27 00:00:00+00:00 330 12 2025-03-28 00:00:00+00:00 315 13 2025-03-31 00:00:00+00:00 137 14 2025-04-01 00:00:00+00:00 261 15 2025-04-02 00:00:00+00:00 230 In\u00a0[\u00a0]: Copied! <pre>distinct_taxonomies = scraped_cargoes_df['load_taxonomy'].unique()\ndistinct_taxonomies\n</pre> distinct_taxonomies = scraped_cargoes_df['load_taxonomy'].unique() distinct_taxonomies Out[\u00a0]: <pre>array(['Port', 'Unknown', 'Level0', 'GeoAsset', 'Country', None, 'Level1',\n       'Level2'], dtype=object)</pre> <p>Scraped cargoes come with different location names, ranging from Port to Area Level 2.</p> <p>In order to make our analysis, we have to normalize the Area Level to all cargoes retrieved. Thus, we use the Geos API to have a look-up table of the ports and their correspondent areas.</p> <p>You may also find more on our Geos API here, including documentation of the object methods used and more examples.</p> In\u00a0[\u00a0]: Copied! <pre>all_areas = geos_api.get_areas()\ndf_areas = pd.DataFrame([a.__dict__ for a in all_areas])\n</pre> all_areas = geos_api.get_areas() df_areas = pd.DataFrame([a.__dict__ for a in all_areas]) In\u00a0[\u00a0]: Copied! <pre>all_ports = geos_api.get_ports()\ndf_ports = pd.DataFrame([a.__dict__ for a in all_ports])\n</pre> all_ports = geos_api.get_ports() df_ports = pd.DataFrame([a.__dict__ for a in all_ports]) In\u00a0[\u00a0]: Copied! <pre>all_countries= geos_api.get_ports()\ndf_countries = pd.DataFrame([a.__dict__ for a in all_countries])\n</pre> all_countries= geos_api.get_ports() df_countries = pd.DataFrame([a.__dict__ for a in all_countries]) In\u00a0[\u00a0]: Copied! <pre>all_geoAssets = geos_api.get_geoAssets()\ndf_geoAssets = pd.DataFrame([a.__dict__ for a in all_geoAssets])\n</pre> all_geoAssets = geos_api.get_geoAssets() df_geoAssets = pd.DataFrame([a.__dict__ for a in all_geoAssets]) In\u00a0[\u00a0]: Copied! <pre>df_areas_all = df_areas[df_areas['location_taxonomy_id'] == 7].merge(df_areas,how = 'left',left_on = 'area_id',right_on = 'parent_area_id',suffixes = ['_level3','_level2'])[['area_id_level3','area_name_level3','area_id_level2','area_name_level2']]\\\n                                                              .merge(df_areas,how = 'left',left_on = 'area_id_level2',right_on = 'parent_area_id')[['area_id_level3','area_name_level3','area_id_level2','area_name_level2','area_id','area_name']]\\\n                                                              .merge(df_areas,how = 'left',left_on = 'area_id',right_on = 'parent_area_id',suffixes = ['_level1','_level0'])[['area_id_level3','area_name_level3','area_id_level2','area_name_level2','area_id_level1','area_name_level1','area_id_level0','area_name_level0']]\\\n\n\n# DataFrame with Area3,Area2,Area1,Area0 of ports\ndf_areas_ports_all = df_areas_all.merge(df_ports,how = 'right',left_on = ['area_id_level2','area_id_level1','area_id_level0'], right_on = ['area_id_level2','area_id_level1','area_id_level0'],suffixes = ['_prev', '_port'])\ndf_areas_ports_all = df_areas_ports_all[['area_id_level2','area_name_level2_prev','area_id_level1','area_name_level1_prev','area_id_level0', 'area_name_level0_prev','port_id','port_name']]\ndf_areas_ports_all = df_areas_ports_all.loc[df_areas_ports_all['area_id_level1'] &gt; 0].loc[df_areas_ports_all['port_id'] &gt; 0]\n</pre> df_areas_all = df_areas[df_areas['location_taxonomy_id'] == 7].merge(df_areas,how = 'left',left_on = 'area_id',right_on = 'parent_area_id',suffixes = ['_level3','_level2'])[['area_id_level3','area_name_level3','area_id_level2','area_name_level2']]\\                                                               .merge(df_areas,how = 'left',left_on = 'area_id_level2',right_on = 'parent_area_id')[['area_id_level3','area_name_level3','area_id_level2','area_name_level2','area_id','area_name']]\\                                                               .merge(df_areas,how = 'left',left_on = 'area_id',right_on = 'parent_area_id',suffixes = ['_level1','_level0'])[['area_id_level3','area_name_level3','area_id_level2','area_name_level2','area_id_level1','area_name_level1','area_id_level0','area_name_level0']]\\   # DataFrame with Area3,Area2,Area1,Area0 of ports df_areas_ports_all = df_areas_all.merge(df_ports,how = 'right',left_on = ['area_id_level2','area_id_level1','area_id_level0'], right_on = ['area_id_level2','area_id_level1','area_id_level0'],suffixes = ['_prev', '_port']) df_areas_ports_all = df_areas_ports_all[['area_id_level2','area_name_level2_prev','area_id_level1','area_name_level1_prev','area_id_level0', 'area_name_level0_prev','port_id','port_name']] df_areas_ports_all = df_areas_ports_all.loc[df_areas_ports_all['area_id_level1'] &gt; 0].loc[df_areas_ports_all['port_id'] &gt; 0]   In\u00a0[\u00a0]: Copied! <pre># DataFrame with country, Areas level 1 of countries\ndf_country_arealevel1 = df_countries.merge(df_ports,how = 'left',left_on = 'country_id',right_on = 'country_id',suffixes = ['_country',None])[['port_id','port_name','country_id','country_name_country','area_id_level1']]\\\n                                                  .merge(df_areas.loc[df_areas['location_taxonomy_id'] == 5],how = 'left',left_on = 'area_id_level1',right_on = 'area_id',suffixes = (None, '_area'))[['country_id','country_name_country','area_id', 'area_name']]\n\ndf_country_areaslevel1 = df_country_arealevel1.copy()\ndf_country_areaslevel1 = df_country_areaslevel1[['country_id','country_name_country']].drop_duplicates()\ndf_country_areaslevel1['Areas_Level_1_In_Country'] = None\ndf_country_areaslevel1 = df_country_areaslevel1.reset_index(drop=True)\nfor idx, country in df_country_areaslevel1.iterrows():\n  country_name = country['country_name_country']\n  df_country_areaslevel1.at[idx,'Areas_Level_1_In_Country'] = df_country_arealevel1.loc[df_country_arealevel1['country_name_country'] == country_name ]['area_name'].unique()\ndf_country_areaslevel1\n</pre> # DataFrame with country, Areas level 1 of countries df_country_arealevel1 = df_countries.merge(df_ports,how = 'left',left_on = 'country_id',right_on = 'country_id',suffixes = ['_country',None])[['port_id','port_name','country_id','country_name_country','area_id_level1']]\\                                                   .merge(df_areas.loc[df_areas['location_taxonomy_id'] == 5],how = 'left',left_on = 'area_id_level1',right_on = 'area_id',suffixes = (None, '_area'))[['country_id','country_name_country','area_id', 'area_name']]  df_country_areaslevel1 = df_country_arealevel1.copy() df_country_areaslevel1 = df_country_areaslevel1[['country_id','country_name_country']].drop_duplicates() df_country_areaslevel1['Areas_Level_1_In_Country'] = None df_country_areaslevel1 = df_country_areaslevel1.reset_index(drop=True) for idx, country in df_country_areaslevel1.iterrows():   country_name = country['country_name_country']   df_country_areaslevel1.at[idx,'Areas_Level_1_In_Country'] = df_country_arealevel1.loc[df_country_arealevel1['country_name_country'] == country_name ]['area_name'].unique() df_country_areaslevel1 Out[\u00a0]: country_id country_name_country Areas_Level_1_In_Country 0 -105 Russia Black Sea / Sea Of Marmara 1 -104 Korea Korea / Japan 2 -103 Arabian Gulf Arabian Gulf 3 -102 Caribs Caribs 4 -101 East Mediterranean Mediterranean ... ... ... ... 192 234 Tuvalu Pacific Islands 193 33 Saint Barthelemy Caribs 194 146 Moldova, Republic of Black Sea / Sea Of Marmara 195 61 Christmas Island South East Asia 196 216 Sao Tome and Principe West Africa <p>197 rows \u00d7 3 columns</p> In\u00a0[\u00a0]: Copied! <pre>scraped_cargoes_df_deduplicated = scraped_cargoes_df_deduplicated.copy()\nscraped_cargoes_df_deduplicated['level1_area_load_delivery'] = None\nscraped_cargoes_df_deduplicated.head(5)\n</pre> scraped_cargoes_df_deduplicated = scraped_cargoes_df_deduplicated.copy() scraped_cargoes_df_deduplicated['level1_area_load_delivery'] = None scraped_cargoes_df_deduplicated.head(5) Out[\u00a0]: received_date charterer quantity_size_from quantity_size_to load_delivery_name load_taxonomy load_delivery_id laycan_delivery_date_from laycan_delivery_date_to charter_type parent_cargo level1_area_load_delivery 0 2025-03-13 00:00:00+00:00 Vitol 35000.0 35000.0 Chennai Port 3517.0 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 Voyage 0 None 2 2025-03-13 00:00:00+00:00 BP 35000.0 35000.0 Sikka Port 3530.0 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 Voyage 0 None 4 2025-03-13 00:00:00+00:00 Trafigura 35000.0 35000.0 None Unknown -1.0 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 Voyage 0 None 6 2025-03-13 00:00:00+00:00 Aramco Trading Singapore 35000.0 35000.0 Arabian Gulf Level0 24777.0 2025-03-28 00:00:00+00:00 2025-03-29 00:00:00+00:00 Voyage 0 None 8 2025-03-13 00:00:00+00:00 Emirates National Oil 35000.0 35000.0 Umm Qasr Port 7117.0 2025-03-28 00:00:00+00:00 2025-03-30 00:00:00+00:00 Voyage 0 None <p>In the below codeblock, we match cargoes that have a Level0 location to its correspondent Level 1 Area.</p> In\u00a0[\u00a0]: Copied! <pre>load_taxonomy_valid = ['GeoAsset', 'Port', 'Level0', 'Country', 'Level1']\nload_taxonomy_invalid = ['Unknown','Level2']\n\nfor idx, row in scraped_cargoes_df_deduplicated.iterrows():\n  taxonomy = row['load_taxonomy']\n\n  if taxonomy in load_taxonomy_invalid:\n    scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery'] = \"N/A\"\n\n  #Load Taxonomy = AreaLevel1\n  if taxonomy == 'Level1':\n    area_name = row['load_delivery_name']\n    scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery'] = area_name\n  #Load Taxonomy = AreaLevel0\n  if taxonomy == 'Level0':\n    area_level_0_id = row['load_delivery_id']\n    scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery']=df_areas_all.loc[df_areas_all['area_id_level0'] == area_level_0_id]['area_name_level1'].values[0]\n  #Load Taxonomy = Country\n  if taxonomy == 'Country':\n    country_id= row['load_delivery_id']\n    scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery']=df_country_areaslevel1.loc[df_country_areaslevel1['country_id'] == country_id]['Areas_Level_1_In_Country'].values\n  #Load Taxonomy = Port\n  if taxonomy == 'Port':\n    port_id = row['load_delivery_id']\n    scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery']= df_areas_ports_all.loc[df_areas_ports_all['port_id'] == port_id]['area_name_level1_prev'].values[0]\n  #Load Taxonomy = GeoAsset\n  if taxonomy == 'GeoAsset':\n    geoasset_id = row['load_delivery_id']\n    scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery']= df_geoAssets.loc[df_geoAssets['geo_asset_id'] == geoasset_id]['area_name_level1'].values\n\nscraped_cargoes_df_deduplicated.reset_index(drop = True)\n</pre> load_taxonomy_valid = ['GeoAsset', 'Port', 'Level0', 'Country', 'Level1'] load_taxonomy_invalid = ['Unknown','Level2']  for idx, row in scraped_cargoes_df_deduplicated.iterrows():   taxonomy = row['load_taxonomy']    if taxonomy in load_taxonomy_invalid:     scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery'] = \"N/A\"    #Load Taxonomy = AreaLevel1   if taxonomy == 'Level1':     area_name = row['load_delivery_name']     scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery'] = area_name   #Load Taxonomy = AreaLevel0   if taxonomy == 'Level0':     area_level_0_id = row['load_delivery_id']     scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery']=df_areas_all.loc[df_areas_all['area_id_level0'] == area_level_0_id]['area_name_level1'].values[0]   #Load Taxonomy = Country   if taxonomy == 'Country':     country_id= row['load_delivery_id']     scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery']=df_country_areaslevel1.loc[df_country_areaslevel1['country_id'] == country_id]['Areas_Level_1_In_Country'].values   #Load Taxonomy = Port   if taxonomy == 'Port':     port_id = row['load_delivery_id']     scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery']= df_areas_ports_all.loc[df_areas_ports_all['port_id'] == port_id]['area_name_level1_prev'].values[0]   #Load Taxonomy = GeoAsset   if taxonomy == 'GeoAsset':     geoasset_id = row['load_delivery_id']     scraped_cargoes_df_deduplicated.at[idx,'level1_area_load_delivery']= df_geoAssets.loc[df_geoAssets['geo_asset_id'] == geoasset_id]['area_name_level1'].values  scraped_cargoes_df_deduplicated.reset_index(drop = True) Out[\u00a0]: received_date charterer quantity_size_from quantity_size_to load_delivery_name load_taxonomy load_delivery_id laycan_delivery_date_from laycan_delivery_date_to charter_type parent_cargo level1_area_load_delivery 0 2025-03-13 00:00:00+00:00 Vitol 35000.0 35000.0 Chennai Port 3517.0 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 Voyage 0 India / Pakistan 1 2025-03-13 00:00:00+00:00 BP 35000.0 35000.0 Sikka Port 3530.0 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 Voyage 0 India / Pakistan 2 2025-03-13 00:00:00+00:00 Trafigura 35000.0 35000.0 None Unknown -1.0 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 Voyage 0 N/A 3 2025-03-13 00:00:00+00:00 Aramco Trading Singapore 35000.0 35000.0 Arabian Gulf Level0 24777.0 2025-03-28 00:00:00+00:00 2025-03-29 00:00:00+00:00 Voyage 0 Arabian Gulf 4 2025-03-13 00:00:00+00:00 Emirates National Oil 35000.0 35000.0 Umm Qasr Port 7117.0 2025-03-28 00:00:00+00:00 2025-03-30 00:00:00+00:00 Voyage 0 Arabian Gulf ... ... ... ... ... ... ... ... ... ... ... ... ... 4103 2025-04-02 00:00:00+00:00 None 30000.0 30000.0 Mersin Port 3816.0 2025-04-03 00:00:00+00:00 2025-04-05 00:00:00+00:00 Voyage 0 Mediterranean 4104 2025-04-02 00:00:00+00:00 Trafigura 37000.0 37000.0 Augusta Port 3547.0 2025-04-05 00:00:00+00:00 2025-04-10 00:00:00+00:00 Voyage 0 Mediterranean 4105 2025-04-02 00:00:00+00:00 None 30000.0 30000.0 Sidi Kerir Port 3375.0 2025-04-07 00:00:00+00:00 2025-04-09 00:00:00+00:00 Voyage 0 Mediterranean 4106 2025-04-02 00:00:00+00:00 ST Shipping &amp; Transport 80000.0 80000.0 Hound Point Port 3444.0 2025-04-08 00:00:00+00:00 2025-04-08 00:00:00+00:00 Voyage 0 UK Continent 4107 2025-04-02 00:00:00+00:00 BP 80000.0 80000.0 Norway Country 174.0 2025-04-08 00:00:00+00:00 2025-04-10 00:00:00+00:00 Voyage 0 ['North Sea' 'Arctic Ocean &amp; Barents Sea'] <p>4108 rows \u00d7 12 columns</p> <p>Find the Cargoes that correspond to the specific Level 1 Area</p> In\u00a0[\u00a0]: Copied! <pre>timeseries_table = scraped_cargoes_df_deduplicated.copy()\nmatching_rows = timeseries_table['level1_area_load_delivery'].apply(\n    lambda x: Area_level_1 == x if isinstance(x, str) else Area_level_1 in x if isinstance(x, list) else False) # Some countries belong to multiple level 1 areas.\ntimeseries_table['matching_rows'] = matching_rows\ntimeseries_table.head(5)\n</pre> timeseries_table = scraped_cargoes_df_deduplicated.copy() matching_rows = timeseries_table['level1_area_load_delivery'].apply(     lambda x: Area_level_1 == x if isinstance(x, str) else Area_level_1 in x if isinstance(x, list) else False) # Some countries belong to multiple level 1 areas. timeseries_table['matching_rows'] = matching_rows timeseries_table.head(5) Out[\u00a0]: received_date charterer quantity_size_from quantity_size_to load_delivery_name load_taxonomy load_delivery_id laycan_delivery_date_from laycan_delivery_date_to charter_type parent_cargo level1_area_load_delivery matching_rows 0 2025-03-13 00:00:00+00:00 Vitol 35000.0 35000.0 Chennai Port 3517.0 2025-03-19 00:00:00+00:00 2025-03-20 00:00:00+00:00 Voyage 0 India / Pakistan False 2 2025-03-13 00:00:00+00:00 BP 35000.0 35000.0 Sikka Port 3530.0 2025-03-21 00:00:00+00:00 2025-03-23 00:00:00+00:00 Voyage 0 India / Pakistan False 4 2025-03-13 00:00:00+00:00 Trafigura 35000.0 35000.0 None Unknown -1.0 2025-03-23 00:00:00+00:00 2025-03-25 00:00:00+00:00 Voyage 0 N/A False 6 2025-03-13 00:00:00+00:00 Aramco Trading Singapore 35000.0 35000.0 Arabian Gulf Level0 24777.0 2025-03-28 00:00:00+00:00 2025-03-29 00:00:00+00:00 Voyage 0 Arabian Gulf False 8 2025-03-13 00:00:00+00:00 Emirates National Oil 35000.0 35000.0 Umm Qasr Port 7117.0 2025-03-28 00:00:00+00:00 2025-03-30 00:00:00+00:00 Voyage 0 Arabian Gulf False <p>Daily Calculation of public cargoes</p> In\u00a0[\u00a0]: Copied! <pre>date_counts = timeseries_table.loc[timeseries_table['matching_rows'] == True].groupby('received_date').size().reset_index(name='count') # Make the cargoes received per day globally\ndate_counts # We count the cargoes that were public for every day in our timeframe\n</pre> date_counts = timeseries_table.loc[timeseries_table['matching_rows'] == True].groupby('received_date').size().reset_index(name='count') # Make the cargoes received per day globally date_counts # We count the cargoes that were public for every day in our timeframe Out[\u00a0]: received_date count 0 2025-03-13 00:00:00+00:00 5 1 2025-03-14 00:00:00+00:00 8 2 2025-03-15 00:00:00+00:00 2 3 2025-03-17 00:00:00+00:00 29 4 2025-03-18 00:00:00+00:00 39 5 2025-03-19 00:00:00+00:00 44 6 2025-03-20 00:00:00+00:00 46 7 2025-03-21 00:00:00+00:00 44 8 2025-03-24 00:00:00+00:00 33 9 2025-03-25 00:00:00+00:00 47 10 2025-03-26 00:00:00+00:00 41 11 2025-03-27 00:00:00+00:00 32 12 2025-03-28 00:00:00+00:00 32 13 2025-03-31 00:00:00+00:00 19 14 2025-04-01 00:00:00+00:00 25 15 2025-04-02 00:00:00+00:00 11 <p>Chart Creation, addiing chart details</p> In\u00a0[\u00a0]: Copied! <pre>plt.figure(figsize=(12, 6))\n\nplt.plot(date_counts[\"received_date\"], date_counts[\"count\"], marker=\"o\", linestyle=\"-\", color=\"b\", label=\"Cargoes\")\nplt.title(\"Cargo time Series Visualization in \" + Area_level_1 )\nplt.xlabel(\"Date\")\nplt.ylabel(\"Value\")\nplt.grid(True)\nplt.legend()\nplt.xticks(date_counts[\"received_date\"], rotation=45)\n\n\nplt.tight_layout()\nplt.show()\n</pre> plt.figure(figsize=(12, 6))  plt.plot(date_counts[\"received_date\"], date_counts[\"count\"], marker=\"o\", linestyle=\"-\", color=\"b\", label=\"Cargoes\") plt.title(\"Cargo time Series Visualization in \" + Area_level_1 ) plt.xlabel(\"Date\") plt.ylabel(\"Value\") plt.grid(True) plt.legend() plt.xticks(date_counts[\"received_date\"], rotation=45)   plt.tight_layout() plt.show()"},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#historical-cargo-distribution-in-a-level-1-area","title":"Historical Cargo Distribution in a Level 1 Area\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":"<p>APIs Used : Scraped Cargoes API, Geos API</p> <p>Description :</p> <p>In this Notebook the main goal is to find and display the Cargo Supply in a given Level 1 Area over a specific time window.</p> <p>The script walks though the installation of the signal ocean SDK and import of the required dependencies used for the processing of the data.</p> <p>Also the parameters <code>vessel_type_id, days_back, Area_Level_1</code> are initialized, in order to be used to achieve the desired output.</p> <p>Lastly, we display the chart of the data that we retrieved and present them as time series.</p> <p>Output : Time-Series Graph displaying the public supply of cargoes in a Level 1 Area for a specific time frame. More on area levels here.</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#setup","title":"Setup\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#parameters-setup","title":"Parameters Setup\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#connection","title":"Connection\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#main-codeblock","title":"Main CodeBlock\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#scraped-cargoes-api-fetch-data-and-deduplicate","title":"Scraped Cargoes API: Fetch Data and Deduplicate\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#geos-api-retrieve-all-ports-with-arealevel0arealevel1arealevel2-names","title":"Geos API: Retrieve All ports with AreaLevel0,AreaLevel1,AreaLevel2 Names\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#normalize-cargo-locations-to-area-level-1","title":"Normalize cargo locations to Area Level 1\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#prepare-final-table-and-graph","title":"Prepare final table and Graph\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Historical%20Cargo%20Distribution%20in%20Area%20Level%20leveraging%20Geos%20API/#output","title":"Output\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/","title":"Scraped Cargoes API Example","text":"<p>Get your personal Signal Ocean API subscription key (acquired here) and replace it below:</p> In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' # Replace with your subscription key\n</pre> signal_ocean_api_key = '' # Replace with your subscription key <p>To install Signal Ocean SDK, simply run the following command</p> In\u00a0[2]: Copied! <pre>%%capture\n%pip install signal-ocean\n</pre> %%capture %pip install signal-ocean <p>Import <code>signal-ocean</code> and other modules required for this demo</p> In\u00a0[3]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.scraped_cargoes import ScrapedCargoesAPI, ScrapedCargo\n\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport plotly.graph_objects as go\n</pre> from signal_ocean import Connection from signal_ocean.scraped_cargoes import ScrapedCargoesAPI, ScrapedCargo  from datetime import datetime, timedelta import pandas as pd import plotly.graph_objects as go <p>Create a new instance of the <code>ScrapedCargoesAPI</code> class</p> In\u00a0[4]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = ScrapedCargoesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = ScrapedCargoesAPI(connection) <p>Now you are ready to retrieve your data</p> <p>To get all tanker cargoes received the last 4 days, you must declare appropriate <code>vessel_type</code> and <code>received_date_from</code> variables</p> In\u00a0[5]: Copied! <pre>vessel_type = 1  # Tanker\nreceived_date_from = datetime.utcnow() - timedelta(days=4)\n</pre> vessel_type = 1  # Tanker received_date_from = datetime.utcnow() - timedelta(days=4) <p>And then call <code>get_cargoes</code> method, as below</p> In\u00a0[6]: Copied! <pre>scraped_cargoes = api.get_cargoes(\n    vessel_type=vessel_type,\n    received_date_from=received_date_from,\n)\n\nnext(iter(scraped_cargoes), None)\n</pre> scraped_cargoes = api.get_cargoes(     vessel_type=vessel_type,     received_date_from=received_date_from, )  next(iter(scraped_cargoes), None) Out[6]: <pre>ScrapedCargo(cargo_id=45442083, message_id=69570386, external_message_id=None, parsed_part_id=74686406, line_from=80, line_to=80, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 7, 29, 9, 16, 43, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 29, 9, 15, 42, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_laycan='07-08/aug', laycan_from=datetime.datetime(2024, 8, 7, 0, 0, tzinfo=datetime.timezone.utc), laycan_to=datetime.datetime(2024, 8, 8, 0, 0, tzinfo=datetime.timezone.utc), scraped_load='ag', load_geo_id=24777, load_name='Arabian Gulf', load_taxonomy_id=4, load_taxonomy='Level0', scraped_load2=None, load_geo_id2=None, load_name2=None, load_taxonomy_id2=None, load_taxonomy2=None, scraped_discharge='japan', scraped_discharge_options=None, discharge_geo_id=121, discharge_name='Japan', discharge_taxonomy_id=3, discharge_taxonomy='Country', scraped_discharge2=None, discharge_geo_id2=None, discharge_name2=None, discharge_taxonomy_id2=None, discharge_taxonomy2=None, scraped_charterer='shell', charterer_id=1482, charterer='Shell', scraped_cargo_type=None, cargo_type_id=None, cargo_type=None, cargo_type_group_id=None, cargo_type_group=None, scraped_quantity='75', quantity=75000.0, quantity_buffer=0.0, quantity_from=75000.0, quantity_to=75000.0, size_from=None, size_to=None, scraped_delivery_date=None, delivery_date_from=None, delivery_date_to=None, scraped_delivery_from=None, delivery_from_geo_id=None, delivery_from_name=None, delivery_from_taxonomy_id=None, delivery_from_taxonomy=None, scraped_delivery_to=None, delivery_to_geo_id=None, delivery_to_name=None, delivery_to_taxonomy_id=None, delivery_to_taxonomy=None, scraped_redelivery_from=None, redelivery_from_geo_id=None, redelivery_from_name=None, redelivery_from_taxonomy_id=None, redelivery_from_taxonomy=None, scraped_redelivery_to=None, redelivery_to_geo_id=None, redelivery_to_name=None, redelivery_to_taxonomy_id=None, redelivery_to_taxonomy=None, charter_type_id=0, charter_type='Voyage', cargo_status_id=None, cargo_status=None, content='07-08/aug shell ag japan 75 naf o/p proteus harvonne hld', subject='McQuilling Asia - Clean East Daily Market Report (29 Jul 2024)', sender='McQuilling', is_private=True)</pre> <p>For better visualization, it's convenient to insert data into a DataFrame</p> In\u00a0[7]: Copied! <pre>df = pd.DataFrame(scraped_cargoes)\n\ndf.head()\n</pre> df = pd.DataFrame(scraped_cargoes)  df.head() Out[7]: cargo_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... redelivery_to_taxonomy_id redelivery_to_taxonomy charter_type_id charter_type cargo_status_id cargo_status content subject sender is_private 0 45442083 69570386 None 74686406 80 80 NaN Email 2024-07-29 09:16:43+00:00 2024-07-29 09:15:42+00:00 ... NaN None 0 Voyage NaN None 07-08/aug shell ag japan 75 naf o/p proteus ha... McQuilling Asia - Clean East Daily Market Repo... McQuilling True 1 45442084 69570386 None 74686406 58 58 1.0 Email 2024-07-29 09:16:43+00:00 2024-07-29 09:15:42+00:00 ... NaN None 0 Voyage 0.0 OnSubs 01-02/aug ats taiwan spore-ag 60 um s 850k-14m... McQuilling Asia - Clean East Daily Market Repo... McQuilling True 2 45442085 69570386 None 74686406 51 51 NaN Email 2024-07-29 09:16:43+00:00 2024-07-29 09:15:42+00:00 ... NaN None 0 Voyage 0.0 OnSubs 5-aug bf muara spore 35 cpf 285k daian subs McQuilling Asia - Clean East Daily Market Repo... McQuilling True 3 45442086 69570386 None 74686406 41 41 NaN Email 2024-07-29 09:16:43+00:00 2024-07-29 09:15:42+00:00 ... NaN None 0 Voyage 0.0 OnSubs 03-05/aug marubeni korea japan 35 um s rnr ten... McQuilling Asia - Clean East Daily Market Repo... McQuilling True 4 45442087 69570386 None 74686406 58 58 NaN Email 2024-07-29 09:16:43+00:00 2024-07-29 09:15:42+00:00 ... NaN None 0 Voyage 0.0 OnSubs 01-02/aug ats taiwan spore-ag 60 um s 850k-14m... McQuilling Asia - Clean East Daily Market Repo... McQuilling True <p>5 rows \u00d7 82 columns</p> <p>To retrieve cargoes for particular message ID(s), you should include an extra parameter called <code>message_ids</code> when using the <code>get_cargoes</code> method. This parameter should contain a list of message IDs. For instance,</p> In\u00a0[8]: Copied! <pre>message_ids = [69320619,69201092,69216273,69274650,69314539]\nscraped_cargoes_by_message_ids = api.get_cargoes(\n    vessel_type=vessel_type,\n    message_ids=message_ids,\n)\n\nnext(iter(scraped_cargoes_by_message_ids), None)\n</pre> message_ids = [69320619,69201092,69216273,69274650,69314539] scraped_cargoes_by_message_ids = api.get_cargoes(     vessel_type=vessel_type,     message_ids=message_ids, )  next(iter(scraped_cargoes_by_message_ids), None) Out[8]: <pre>ScrapedCargo(cargo_id=45279461, message_id=69201092, external_message_id=None, parsed_part_id=74439682, line_from=71, line_to=71, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 7, 24, 4, 32, 16, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 24, 4, 30, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_laycan='26-27 aug', laycan_from=datetime.datetime(2024, 8, 26, 0, 0, tzinfo=datetime.timezone.utc), laycan_to=datetime.datetime(2024, 8, 27, 0, 0, tzinfo=datetime.timezone.utc), scraped_load='balikpapan', load_geo_id=3486, load_name='Balikpapan', load_taxonomy_id=2, load_taxonomy='Port', scraped_load2=None, load_geo_id2=None, load_name2=None, load_taxonomy_id2=None, load_taxonomy2=None, scraped_discharge='opts', scraped_discharge_options=None, discharge_geo_id=None, discharge_name=None, discharge_taxonomy_id=None, discharge_taxonomy=None, scraped_discharge2=None, discharge_geo_id2=None, discharge_name2=None, discharge_taxonomy_id2=None, discharge_taxonomy2=None, scraped_charterer='tender', charterer_id=None, charterer=None, scraped_cargo_type=None, cargo_type_id=None, cargo_type=None, cargo_type_group_id=None, cargo_type_group=None, scraped_quantity=None, quantity=None, quantity_buffer=None, quantity_from=None, quantity_to=None, size_from=None, size_to=None, scraped_delivery_date=None, delivery_date_from=None, delivery_date_to=None, scraped_delivery_from=None, delivery_from_geo_id=None, delivery_from_name=None, delivery_from_taxonomy_id=None, delivery_from_taxonomy=None, scraped_delivery_to=None, delivery_to_geo_id=None, delivery_to_name=None, delivery_to_taxonomy_id=None, delivery_to_taxonomy=None, scraped_redelivery_from=None, redelivery_from_geo_id=None, redelivery_from_name=None, redelivery_from_taxonomy_id=None, redelivery_from_taxonomy=None, scraped_redelivery_to=None, redelivery_to_geo_id=None, redelivery_to_name=None, redelivery_to_taxonomy_id=None, redelivery_to_taxonomy=None, charter_type_id=0, charter_type='Voyage', cargo_status_id=None, cargo_status=None, content='tender 200kb v1250 balikpapan opts 26-27 aug clsd', subject='RAFFLES MARKET REPORT 24TH JUL 2024', sender='Raffles Shipbrokers', is_private=True)</pre> <p>You can achieve a similar result for external message IDs by providing an argument called <code>external_message_ids</code>.</p> <p>To retrieve cargoes for particular cargo ID(s), you should include an extra parameter called <code>cargo_ids</code> when using the <code>get_cargoes</code> method. This parameter should contain a list of cargo IDs. For instance,</p> In\u00a0[9]: Copied! <pre>cargo_ids = [45336637,45336638,45336639,45336640,45336641]    # Or add a list of your desired cargo IDs\n\nscraped_cargoes_by_ids = api.get_cargoes(\n    vessel_type=vessel_type,\n    cargo_ids=cargo_ids,\n)\n\ndf_by_ids = pd.DataFrame(scraped_cargoes_by_ids)\ndf_by_ids.head()\n</pre> cargo_ids = [45336637,45336638,45336639,45336640,45336641]    # Or add a list of your desired cargo IDs  scraped_cargoes_by_ids = api.get_cargoes(     vessel_type=vessel_type,     cargo_ids=cargo_ids, )  df_by_ids = pd.DataFrame(scraped_cargoes_by_ids) df_by_ids.head() Out[9]: cargo_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... redelivery_to_taxonomy_id redelivery_to_taxonomy charter_type_id charter_type cargo_status_id cargo_status content subject sender is_private 0 45336637 69320619 None 74519826 124 124 None Email 2024-07-25 05:33:57+00:00 2024-07-25 05:30:18+00:00 ... None None 0 Voyage None None tender 200 kb mfo dumai opts 23-24 aug clsd SHIPLINKS EAST OF SUEZ DIRTY MARKET REPORT (25... ShipLinks True 1 45336638 69320619 None 74519826 119 119 None Email 2024-07-25 05:33:57+00:00 2024-07-25 05:30:18+00:00 ... None None 0 Voyage None None tender 200 kb v1250 sungai pakning opts 02-03 ... SHIPLINKS EAST OF SUEZ DIRTY MARKET REPORT (25... ShipLinks True 2 45336639 69320619 None 74519826 120 120 None Email 2024-07-25 05:33:57+00:00 2024-07-25 05:30:18+00:00 ... None None 0 Voyage None None tender 200 kb v1250 sungai pakning opts 13-14 ... SHIPLINKS EAST OF SUEZ DIRTY MARKET REPORT (25... ShipLinks True 3 45336640 69320619 None 74519825 103 103 None Email 2024-07-25 05:33:57+00:00 2024-07-25 05:30:18+00:00 ... None None 0 Voyage None None tender 200 kb mfo cilacap opts 21-22 aug clsd SHIPLINKS EAST OF SUEZ DIRTY MARKET REPORT (25... ShipLinks True 4 45336641 69320619 None 74519825 102 102 None Email 2024-07-25 05:33:57+00:00 2024-07-25 05:30:18+00:00 ... None None 0 Voyage None None tender 200 kb v1250 sungai pakning opts 26-27 ... SHIPLINKS EAST OF SUEZ DIRTY MARKET REPORT (25... ShipLinks True <p>5 rows \u00d7 82 columns</p> <p>For instance, to retrieve the relevant page token for last week's data, you must call the <code>get_cargoes_incremental_token</code>, as below</p> In\u00a0[10]: Copied! <pre>updated_date_from = datetime.utcnow() - timedelta(days=7)\npage_token = api.get_cargoes_incremental_token(\n    updated_date_from=updated_date_from,\n)\n\npage_token\n</pre> updated_date_from = datetime.utcnow() - timedelta(days=7) page_token = api.get_cargoes_incremental_token(     updated_date_from=updated_date_from, )  page_token Out[10]: <pre>'MjAyNC0wNy0yNlQwODo0NzoyMy4wMDBa'</pre> <p>If the <code>page_token</code> parameter is not specified, the <code>get_cargoes_incremental</code> method will retrieve all cargoes. You can call the <code>get_cargoes_incremental</code> method, as below</p> In\u00a0[11]: Copied! <pre>scraped_cargoes_incremental = api.get_cargoes_incremental(\n    vessel_type=vessel_type,\n    page_token=page_token,\n)\n\ndf_by_ids = pd.DataFrame(scraped_cargoes_incremental.data)\ndf_by_ids.head()\n</pre> scraped_cargoes_incremental = api.get_cargoes_incremental(     vessel_type=vessel_type,     page_token=page_token, )  df_by_ids = pd.DataFrame(scraped_cargoes_incremental.data) df_by_ids.head() Out[11]: cargo_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... redelivery_to_taxonomy_id redelivery_to_taxonomy charter_type_id charter_type cargo_status_id cargo_status content subject sender is_private 0 45396552 69453094 None 74606440.0 41.0 41.0 NaN Email 2024-07-26 09:10:02+00:00 2024-07-26 09:08:58+00:00 ... NaN None 0.0 Voyage NaN None repsol 130 12-aug nhc sankofa spain 90ws popi p - DA' OCEANIC SHIPPING - DAILY DPP MARKET REPORT... Da'oceanic Shipping True 1 45397078 69454207 None 74607105.0 203.0 203.0 NaN Email 2024-07-26 09:20:30+00:00 2024-07-26 09:19:24+00:00 ... NaN None 0.0 Voyage NaN None equinor mongstad trans-atlantic 210ws green sky - DA' OCEANIC SHIPPING - WEEKLY CPP MARKET REPOR... Da'oceanic Shipping True 2 45397079 69454207 None 74607105.0 91.0 91.0 NaN Email 2024-07-26 09:20:30+00:00 2024-07-26 09:19:24+00:00 ... NaN None 0.0 Voyage NaN None kpc kuwait pakistan $595k em zenith - DA' OCEANIC SHIPPING - WEEKLY CPP MARKET REPOR... Da'oceanic Shipping True 3 45397080 69454207 None 74607105.0 61.0 61.0 1.0 Email 2024-07-26 09:20:30+00:00 2024-07-26 09:19:24+00:00 ... NaN None 0.0 Voyage NaN None reliance sikka ukc-usac $4.30-4.75m hafnia yar... DA' OCEANIC SHIPPING - WEEKLY CPP MARKET REPOR... Da'oceanic Shipping True 4 45397081 69454207 None 74607105.0 226.0 226.0 NaN Email 2024-07-26 09:20:30+00:00 2024-07-26 09:19:24+00:00 ... NaN None 0.0 Voyage NaN None maersk usg opts own fpmc 36 - DA' OCEANIC SHIPPING - WEEKLY CPP MARKET REPOR... Da'oceanic Shipping True <p>5 rows \u00d7 82 columns</p> <p>Also, the <code>get_cargoes_incremental</code> method will retrieve the <code>next_request_token</code>, which should be used as the <code>page_token</code> for the next incremental call and retrieve only new or updated cargoes.</p> In\u00a0[12]: Copied! <pre>next_request_token = scraped_cargoes_incremental.next_request_token\n\nnext_request_token\n</pre> next_request_token = scraped_cargoes_incremental.next_request_token  next_request_token Out[12]: <pre>'MjAyNC0wOC0wMlQwODo0NzoyNC4xNDha'</pre> <p>By default, all fields are returned. In many cases, it is convenient to select specific columns. For example, if we want to compare scraped and mapped fields</p> In\u00a0[13]: Copied! <pre>scraped_mapped_columns = [\n    'scraped_charterer',\n    'charterer',\n    'scraped_quantity',\n    'quantity',\n    'scraped_load',\n    'load_name',\n]\n\nscraped_mapped_df = pd.DataFrame(scraped_cargoes, columns=scraped_mapped_columns)\n\nscraped_mapped_df.head()\n</pre> scraped_mapped_columns = [     'scraped_charterer',     'charterer',     'scraped_quantity',     'quantity',     'scraped_load',     'load_name', ]  scraped_mapped_df = pd.DataFrame(scraped_cargoes, columns=scraped_mapped_columns)  scraped_mapped_df.head() Out[13]: scraped_charterer charterer scraped_quantity quantity scraped_load load_name 0 shell Shell 75 75000.0 ag Arabian Gulf 1 lr None 60 60000.0 ats taiwan Taiwan 2 None None 35 35000.0 muara Muara 3 None None 35 35000.0 marubeni korea Korea, Republic of 4 lr None 60 60000.0 ats taiwan Taiwan <p>Let's start by fetching all tanker cargoes received the last 2 weeks</p> In\u00a0[14]: Copied! <pre>example_vessel_type = 1  # Tanker\nexample_date_from = datetime.utcnow() - timedelta(days=14)\n\nexample_scraped_cargoes = api.get_cargoes(\n   vessel_type=example_vessel_type,\n   received_date_from=example_date_from,\n)\n</pre> example_vessel_type = 1  # Tanker example_date_from = datetime.utcnow() - timedelta(days=14)  example_scraped_cargoes = api.get_cargoes(    vessel_type=example_vessel_type,    received_date_from=example_date_from, ) <p>The <code>is_deleted</code> property of a scraped cargo indicates whether it is valid or not. If it is set to <code>True</code>, the corresponding <code>cargo_id</code> has been replaced by a new one.</p> <p>For the sake of completeness, we will exclude deleted scraped cargoes in the following examples</p> In\u00a0[15]: Copied! <pre>example_scraped_cargoes = [cargo for cargo in example_scraped_cargoes if not cargo.is_deleted]\n\nnext(iter(example_scraped_cargoes), None)\n</pre> example_scraped_cargoes = [cargo for cargo in example_scraped_cargoes if not cargo.is_deleted]  next(iter(example_scraped_cargoes), None) Out[15]: <pre>ScrapedCargo(cargo_id=45136695, message_id=68888739, external_message_id=None, parsed_part_id=74227216, line_from=26, line_to=26, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 7, 19, 9, 14, 26, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 19, 9, 9, 22, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_laycan='20-25/8', laycan_from=datetime.datetime(2024, 8, 20, 0, 0, tzinfo=datetime.timezone.utc), laycan_to=datetime.datetime(2024, 8, 25, 0, 0, tzinfo=datetime.timezone.utc), scraped_load='usg', load_geo_id=24676, load_name='US Gulf', load_taxonomy_id=4, load_taxonomy='Level0', scraped_load2=None, load_geo_id2=None, load_name2=None, load_taxonomy_id2=None, load_taxonomy2=None, scraped_discharge='ulsan', scraped_discharge_options=None, discharge_geo_id=3602, discharge_name='Ulsan', discharge_taxonomy_id=2, discharge_taxonomy='Port', scraped_discharge2=None, discharge_geo_id2=None, discharge_name2=None, discharge_taxonomy_id2=None, discharge_taxonomy2=None, scraped_charterer='sk', charterer_id=1528, charterer='SK', scraped_cargo_type=None, cargo_type_id=None, cargo_type=None, cargo_type_group_id=None, cargo_type_group=None, scraped_quantity='270', quantity=270000.0, quantity_buffer=0.0, quantity_from=270000.0, quantity_to=270000.0, size_from=None, size_to=None, scraped_delivery_date=None, delivery_date_from=None, delivery_date_to=None, scraped_delivery_from=None, delivery_from_geo_id=None, delivery_from_name=None, delivery_from_taxonomy_id=None, delivery_from_taxonomy=None, scraped_delivery_to=None, delivery_to_geo_id=None, delivery_to_name=None, delivery_to_taxonomy_id=None, delivery_to_taxonomy=None, scraped_redelivery_from=None, redelivery_from_geo_id=None, redelivery_from_name=None, redelivery_from_taxonomy_id=None, redelivery_from_taxonomy=None, scraped_redelivery_to=None, redelivery_to_geo_id=None, redelivery_to_name=None, redelivery_to_taxonomy_id=None, redelivery_to_taxonomy=None, charter_type_id=0, charter_type='Voyage', cargo_status_id=None, cargo_status=None, content='sk 270 usg/ulsan 20-25/8 -rptd', subject='VLCC update', sender='Fearnleys', is_private=True)</pre> <p>Now, we are ready to insert our data into a dataframe and keep only specific fields</p> In\u00a0[16]: Copied! <pre>example_columns = [\n    'charterer',   \n    'laycan_from',\n    'load_name',\n    'quantity',\n    'is_deleted',\n]\n\ndata = pd.DataFrame(example_scraped_cargoes, columns=example_columns)\n\ndata.head()\n</pre> example_columns = [     'charterer',        'laycan_from',     'load_name',     'quantity',     'is_deleted', ]  data = pd.DataFrame(example_scraped_cargoes, columns=example_columns)  data.head() Out[16]: charterer laycan_from load_name quantity is_deleted 0 SK 2024-08-20 00:00:00+00:00 US Gulf 270000.0 False 1 Equinor 2024-08-20 00:00:00+00:00 US Gulf 270000.0 False 2 Equinor 2024-08-20 00:00:00+00:00 US Gulf 270000.0 False 3 Petco Chartering 2024-08-01 00:00:00+00:00 Arabian Gulf 270000.0 False 4 BP 2024-08-04 00:00:00+00:00 Jebel Dhanna 270000.0 False <p>In this example, we will find the top 10 Charterers, based on the number of distinct available cargoes</p> In\u00a0[17]: Copied! <pre>top_chrtr_ser = data[['charterer', 'laycan_from']].drop_duplicates().charterer.value_counts().head(10)\n\ntop_chrtr_df = top_chrtr_ser.to_frame(name='CargoCount').reset_index().rename(columns={'index': 'Charterer'})\n\ntop_chrtr_df\n</pre> top_chrtr_ser = data[['charterer', 'laycan_from']].drop_duplicates().charterer.value_counts().head(10)  top_chrtr_df = top_chrtr_ser.to_frame(name='CargoCount').reset_index().rename(columns={'index': 'Charterer'})  top_chrtr_df Out[17]: charterer CargoCount 0 Aramco Trading Company 30 1 Vitol 27 2 Shell 22 3 Unipec 21 4 BP 20 5 Trafigura 16 6 CSSA 16 7 ExxonMobil 15 8 ADMIC 15 9 Indian Oil 14 <p>And display results in a bar plot</p> In\u00a0[18]: Copied! <pre>top_chrtr_fig = go.Figure()\n\nbar = go.Bar(\n    x=top_chrtr_df.charterer.tolist(),\n    y=top_chrtr_df.CargoCount.tolist(),\n)\n\ntop_chrtr_fig.add_trace(bar)\ntop_chrtr_fig.update_xaxes(title_text=\"Charterer\")\ntop_chrtr_fig.update_yaxes(title_text=\"Number of available Cargoes\")\ntop_chrtr_fig.show()\n</pre> top_chrtr_fig = go.Figure()  bar = go.Bar(     x=top_chrtr_df.charterer.tolist(),     y=top_chrtr_df.CargoCount.tolist(), )  top_chrtr_fig.add_trace(bar) top_chrtr_fig.update_xaxes(title_text=\"Charterer\") top_chrtr_fig.update_yaxes(title_text=\"Number of available Cargoes\") top_chrtr_fig.show() In\u00a0[19]: Copied! <pre>this_week_days = pd.date_range(start=datetime.utcnow().date(), freq='D', periods=7, tz='UTC')\nareas = data[data.load_name.notna()].load_name.value_counts().head().index.tolist()\n\nareas\n</pre> this_week_days = pd.date_range(start=datetime.utcnow().date(), freq='D', periods=7, tz='UTC') areas = data[data.load_name.notna()].load_name.value_counts().head().index.tolist()  areas Out[19]: <pre>['US Gulf', 'Arabian Gulf', 'Singapore', 'Mumbai', 'Sikka']</pre> <p>Create the pivot table</p> In\u00a0[20]: Copied! <pre>areas_mask = data.load_name.isin(areas) &amp; data.laycan_from.isin(this_week_days)\n\ndf_areas = data[areas_mask]\n\ndf_pivot = pd.pivot_table(\n    df_areas,\n    columns='load_name',\n    index='laycan_from',\n    values='quantity',\n    aggfunc=pd.Series.sum,\n    fill_value=0,\n).reindex(index=this_week_days, fill_value=0).reset_index().rename(columns={'index': 'laycan_from'})\n\ndf_pivot\n</pre> areas_mask = data.load_name.isin(areas) &amp; data.laycan_from.isin(this_week_days)  df_areas = data[areas_mask]  df_pivot = pd.pivot_table(     df_areas,     columns='load_name',     index='laycan_from',     values='quantity',     aggfunc=pd.Series.sum,     fill_value=0, ).reindex(index=this_week_days, fill_value=0).reset_index().rename(columns={'index': 'laycan_from'})  df_pivot Out[20]: load_name laycan_from Arabian Gulf Mumbai Sikka Singapore US Gulf 0 2024-08-02 00:00:00+00:00 2480000 0 0 240000 2014000 1 2024-08-03 00:00:00+00:00 1350000 0 960000 140000 3184000 2 2024-08-04 00:00:00+00:00 1585000 0 120000 3440000 76000 3 2024-08-05 00:00:00+00:00 1605000 1140000 0 1040000 1662000 4 2024-08-06 00:00:00+00:00 2865000 650000 70000 360000 1232000 5 2024-08-07 00:00:00+00:00 1165000 0 0 480000 4536000 6 2024-08-08 00:00:00+00:00 4310000 30000 210000 885960 178000 <p>And display the results as timeseries</p> In\u00a0[21]: Copied! <pre>def area_button(area):\n    args = [\n        {'visible': [i == areas.index(area) for i in range(len(areas))]},\n        {\n            'title': f'Total Quantity to load in {area} per day',\n            'showlegend': True\n        },\n    ]\n    \n    return dict(\n        label=area,\n        method='update',\n        args=args,\n    )\n\ntitle = 'Total Quantity to load per day'\ntoday = datetime.combine(datetime.utcnow().date(), datetime.min.time())\n\nareas_fig = go.Figure()\n\narea_buttons = []\n\nfor area in areas:\n    if area not in df_pivot.columns:\n        continue\n    area_scatter_plot = go.Scatter(    \n        x=df_pivot.laycan_from,\n        y=df_pivot[area],\n        name=area,\n        mode='lines',\n    )\n\n    areas_fig.add_trace(area_scatter_plot)\n    \n    area_buttons.append(area_button(area))\n    \nbuttons = list([\n    dict(\n        label='All',\n        method='update',\n        args=[    \n            {'visible': [True for _ in range(len(areas))]},\n            {\n                'title': title,\n                'showlegend': True\n            }\n        ],\n    ),\n    *area_buttons,\n])\n\nareas_fig.update_layout(\n    title=title,\n    updatemenus=[go.layout.Updatemenu(\n        active=0,\n        buttons=buttons,\n    )],\n    xaxis_range=[today - timedelta(hours=4), today + timedelta(hours=24*6 + 4)],\n)\n\nareas_fig.show()\n</pre> def area_button(area):     args = [         {'visible': [i == areas.index(area) for i in range(len(areas))]},         {             'title': f'Total Quantity to load in {area} per day',             'showlegend': True         },     ]          return dict(         label=area,         method='update',         args=args,     )  title = 'Total Quantity to load per day' today = datetime.combine(datetime.utcnow().date(), datetime.min.time())  areas_fig = go.Figure()  area_buttons = []  for area in areas:     if area not in df_pivot.columns:         continue     area_scatter_plot = go.Scatter(             x=df_pivot.laycan_from,         y=df_pivot[area],         name=area,         mode='lines',     )      areas_fig.add_trace(area_scatter_plot)          area_buttons.append(area_button(area))      buttons = list([     dict(         label='All',         method='update',         args=[                 {'visible': [True for _ in range(len(areas))]},             {                 'title': title,                 'showlegend': True             }         ],     ),     *area_buttons, ])  areas_fig.update_layout(     title=title,     updatemenus=[go.layout.Updatemenu(         active=0,         buttons=buttons,     )],     xaxis_range=[today - timedelta(hours=4), today + timedelta(hours=24*6 + 4)], )  areas_fig.show() In\u00a0[22]: Copied! <pre>output_path = '' # Change output_path with your path\nfilename = 'last_two_weeks_cargoes.csv'\nif not data.empty:\n    data.to_csv(output_path+filename, index=False)\n</pre> output_path = '' # Change output_path with your path filename = 'last_two_weeks_cargoes.csv' if not data.empty:     data.to_csv(output_path+filename, index=False) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#scraped-cargoes-api-example","title":"Scraped Cargoes API Example\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#scraped-cargoes-api","title":"Scraped Cargoes API\u00b6","text":"<p>The goal of Scraped Cargoes API is to collect and return scraped cargoes by the given filters. This can be done by using the <code>ScrapedCargoesAPI</code> class and calling appropriate methods</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#1-request-by-filters","title":"1. Request by filters\u00b6","text":"<p>Cargoes can be retrieved for specific filters, by calling the <code>get_cargoes</code> method with the following arguments:</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>vessel_type</code> The vessel type</p> <p>Additionally, at least one of the following is required</p> <p><code>cargo_ids</code> List of CargoIDs</p> <p><code>message_ids</code> List of MessageIDs</p> <p><code>external_message_ids</code> List of ExternalMessageIDs</p> <p><code>received_date_from</code> Earliest date the cargo received</p> <p><code>received_date_to</code> Latest date the cargo received</p> <p><code>updated_date_from</code> Earliest date the cargo updated</p> <p><code>updated_date_to</code> Latest date the cargo updated</p> <p>Mixing received and updated dates is not allowed</p> <p>It's highly recommended to use UTC  dates, since this is the internally used format</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#2-request-by-page-token","title":"2. Request by page token\u00b6","text":"<p>Cargoes can also be retrieved, by calling the <code>get_cargoes_incremental</code> method. This method will also return <code>next_request_token</code>, which the user should use to their next incremental request to retrieve only the latest updated cargoes.</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>vessel_type</code> The vessel type</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#optional","title":"Optional\u00b6","text":"<p><code>page_token</code> The key that should be used as a parameter of the token to retrieve the relevant page.</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#3-retrieve-page-token","title":"3. Retrieve page token\u00b6","text":"<p>The token referenced above can be retrieved for a specific date, by calling the <code>get_cargoes_incremental_token</code> method with the following argument:</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>updated_date_from</code> Earliest date the cargo updated</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#additional-optional-arguments","title":"Additional optional arguments\u00b6","text":"<p>Methods <code>get_cargoes</code> and <code>get_cargoes_incremental</code>, also accept the following optional arguments:</p> <p><code>include_details</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>parsed_part_id, line_from, line_to, in_line_order, source\n</code></pre> <p><code>include_scraped_fields</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>scraped_laycan, scraped_load, scraped_load2, scraped_discharge, scraped_discharge_options, scraped_discharge2, scraped_charterer, scraped_cargo_type, scraped_quantity, scraped_delivery_date, scraped_delivery_from, scraped_delivery_to, \nscraped_redelivery_from, scraped_redelivery_to\n</code></pre> <p><code>include_labels</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>load_name, load_taxonomy, load_name2, load_taxonomy2, discharge_name, discharge_taxonomy, discharge_name2, discharge_taxonomy2, charterer, cargo_type, cargo_type_group, delivery_from_name, delivery_from_taxonomy, delivery_to_name, delivery_to_taxonomy, redelivery_from_name, redelivery_from_taxonomy, redelivery_to_name, redelivery_to_taxonomy, charter_type, cargo_status\n</code></pre> <p><code>include_content</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>content\n</code></pre> <p><code>include_sender</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>sender\n</code></pre> <p><code>include_debug_info</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>is_private\n</code></pre> <p>Default value is <code>True</code> for the arguments described above</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#installation","title":"Installation\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#quickstart","title":"Quickstart\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#request-by-date","title":"Request by date\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#request-by-message-or-externalmessage-ids","title":"Request by Message or ExternalMessage IDs\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#request-by-cargo-ids","title":"Request by Cargo IDs\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#retrieve-incremental-token","title":"Retrieve incremental token\u00b6","text":"<p>The <code>get_cargoes_incremental_token</code> allows retrieval of <code>page_token</code> by adding the <code>updated_date_from</code> value. This <code>page_token</code> can be used as a variable to the <code>get_cargoes_incremental</code> method, in order to retrieve only new or updated cargoes.</p>"},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#request-by-page-token","title":"Request by page token\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#usage-of-optional-arguments","title":"Usage of optional arguments\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#examples","title":"Examples\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#exclude-deleted-scraped-cargoes","title":"Exclude deleted scraped cargoes\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#top-10-charterers","title":"Top 10 Charterers\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#total-quantity-to-load-in-specific-areas-per-day-the-next-week","title":"Total quantity to load in specific areas per day the next week\u00b6","text":""},{"location":"examples/jupyter/ScrapedCargoesAPI/Scraped%20Cargoes%20API%20Example/#export-data-to-csv","title":"Export data to csv\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/","title":"Scraped Fixtures API Example","text":"<p>Get your personal Signal Ocean API subscription key (acquired here) and replace it below:</p> In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' # Replace with your subscription key\n</pre> signal_ocean_api_key = '' # Replace with your subscription key <p>To install Signal Ocean SDK, simply run the following command</p> In\u00a0[2]: Copied! <pre>%%capture\n%pip install signal-ocean\n</pre> %%capture %pip install signal-ocean <p>Import <code>signal-ocean</code> and other modules required for this demo</p> In\u00a0[3]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.scraped_fixtures import ScrapedFixturesAPI\n\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport plotly.graph_objects as go\n</pre> from signal_ocean import Connection from signal_ocean.scraped_fixtures import ScrapedFixturesAPI  from datetime import datetime, timedelta import pandas as pd import plotly.graph_objects as go <p>Create a new instance of the <code>ScrapedFixturesAPI</code> class</p> In\u00a0[4]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = ScrapedFixturesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = ScrapedFixturesAPI(connection) <p>Now you are ready to retrieve your data</p> <p>To get all tanker fixtures received the last 2 days, you must declare appropriate <code>vessel_type</code> and <code>received_date_from</code> variables</p> In\u00a0[5]: Copied! <pre>vessel_type = 1  # Tanker\nreceived_date_from = datetime.utcnow() - timedelta(days=2)\n</pre> vessel_type = 1  # Tanker received_date_from = datetime.utcnow() - timedelta(days=2) <p>And then call <code>get_fixtures</code> method, as below</p> In\u00a0[6]: Copied! <pre>scraped_fixtures = api.get_fixtures(\n    vessel_type=vessel_type,\n    received_date_from=received_date_from,\n)\n\nnext(iter(scraped_fixtures), None)\n</pre> scraped_fixtures = api.get_fixtures(     vessel_type=vessel_type,     received_date_from=received_date_from, )  next(iter(scraped_fixtures), None) Out[6]: <pre>ScrapedFixture(fixture_id=151714760, message_id=69800782, external_message_id=None, parsed_part_id=74839673, line_from=26, line_to=26, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 7, 31, 8, 47, 37, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 31, 8, 45, 37, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name=None, scraped_deadweight=None, scraped_year_built=None, imo=9403322, vessel_name='Atlantic T', deadweight=45989, year_built=2009, liquid_capacity=52517, vessel_type_id=1, vessel_type='Tanker', vessel_class_id=88, vessel_class='MR2', commercial_operator_id=1088, commercial_operator='Norden Tanker Pool', scraped_laycan=None, laycan_from=None, laycan_to=None, scraped_load=None, load_geo_id=None, load_name=None, load_taxonomy_id=None, load_taxonomy=None, scraped_load2=None, load_geo_id2=None, load_name2=None, load_taxonomy_id2=None, load_taxonomy2=None, scraped_discharge=None, scraped_discharge_options=None, discharge_geo_id=None, discharge_name=None, discharge_taxonomy_id=None, discharge_taxonomy=None, scraped_discharge2=None, discharge_geo_id2=None, discharge_name2=None, discharge_taxonomy_id2=None, discharge_taxonomy2=None, scraped_charterer=None, charterer_id=None, charterer=None, scraped_cargo_type=None, cargo_type_id=None, cargo_type=None, cargo_group_id=None, cargo_group=None, scraped_quantity=None, quantity=None, quantity_buffer=None, quantity_from=None, quantity_to=None, scraped_rate=None, scraped_rate_options=None, rate_value=None, rate_type=None, open_geo_id=3794, open_geo_name='Singapore', open_taxonomy_id=2, open_taxonomy='Port', open_date=datetime.datetime(2024, 8, 3, 0, 0, tzinfo=datetime.timezone.utc), scraped_delivery_date=None, delivery_date_from=None, delivery_date_to=None, scraped_delivery=None, delivery_geo_id=None, delivery_name=None, delivery_taxonomy_id=None, delivery_taxonomy=None, scraped_redelivery_from=None, redelivery_from_geo_id=None, redelivery_from_name=None, redelivery_from_taxonomy_id=None, redelivery_from_taxonomy=None, scraped_redelivery_to=None, redelivery_to_geo_id=None, redelivery_to_name=None, redelivery_to_taxonomy_id=None, redelivery_to_taxonomy=None, charter_type_id=0, charter_type='Voyage', fixture_status_id=0, fixture_status='OnSubs', is_owners_option=False, is_coa=False, content=None, subject='BRS CPP MR LIST BSS SPORE - 31/07/24', sender='BRS Group', is_private=True, is_invalidated=False, is_partial=True)</pre> <p>For better visualization, it's convenient to insert data into a DataFrame</p> In\u00a0[7]: Copied! <pre>df = pd.DataFrame(scraped_fixtures)\n\ndf.head()\n</pre> df = pd.DataFrame(scraped_fixtures)  df.head() Out[7]: fixture_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... fixture_status_id fixture_status is_owners_option is_coa content subject sender is_private is_invalidated is_partial 0 151714760 69800782 None 74839673 26 26 NaN Email 2024-07-31 08:47:37+00:00 2024-07-31 08:45:37+00:00 ... 0.0 OnSubs False False None BRS CPP MR LIST BSS SPORE - 31/07/24 BRS Group True False True 1 151714761 69800782 None 74839673 9 9 NaN Email 2024-07-31 08:47:37+00:00 2024-07-31 08:45:37+00:00 ... 0.0 OnSubs False False None BRS CPP MR LIST BSS SPORE - 31/07/24 BRS Group True False True 2 151714762 69800782 None 74839673 35 35 NaN Email 2024-07-31 08:47:37+00:00 2024-07-31 08:45:37+00:00 ... 0.0 OnSubs False False None BRS CPP MR LIST BSS SPORE - 31/07/24 BRS Group True False True 3 151714763 69800782 None 74839673 28 28 NaN Email 2024-07-31 08:47:37+00:00 2024-07-31 08:45:37+00:00 ... 0.0 OnSubs False False None BRS CPP MR LIST BSS SPORE - 31/07/24 BRS Group True False True 4 151714764 69800782 None 74839673 38 38 NaN Email 2024-07-31 08:47:37+00:00 2024-07-31 08:45:37+00:00 ... 0.0 OnSubs False False None BRS CPP MR LIST BSS SPORE - 31/07/24 BRS Group True False True <p>5 rows \u00d7 102 columns</p> <p>To get fixtures for specific vessel(s) by their IMO number(s), you can simple call the <code>get_fixtures</code> method for a list of desired IMO(s)</p> <p>Adding some date argument is always feasible</p> In\u00a0[8]: Copied! <pre>imos = [9786164,9732929,9510682,9740586,9917892]  # Or add a list of your desired IMOs\n\nscraped_fixtures_by_imos = api.get_fixtures(\n    vessel_type=vessel_type,\n    received_date_from=received_date_from,\n    imos=imos,\n)\n\ndf_by_imos = pd.DataFrame(scraped_fixtures_by_imos)\ndf_by_imos.head()\n</pre> imos = [9786164,9732929,9510682,9740586,9917892]  # Or add a list of your desired IMOs  scraped_fixtures_by_imos = api.get_fixtures(     vessel_type=vessel_type,     received_date_from=received_date_from,     imos=imos, )  df_by_imos = pd.DataFrame(scraped_fixtures_by_imos) df_by_imos.head() Out[8]: fixture_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... fixture_status_id fixture_status is_owners_option is_coa content subject sender is_private is_invalidated is_partial 0 151766489 69818876 None 74851203 20 20 None Email 2024-07-31 11:06:57+00:00 2024-07-31 11:05:23+00:00 ... 0 OnSubs False False None HOWEROB FUJAIRAH MR POSITION LIST - 31TH JULY ... Howerob True False True 1 151783860 69836061 None 74864037 76 76 None Email 2024-07-31 14:35:39+00:00 2024-07-31 14:34:19+00:00 ... 0 OnSubs False False None CLARKSONS AG MR LIST DATED 31.07.24 Clarksons True False True 2 151785145 69836593 None 74864427 47 47 None Email 2024-07-31 14:44:45+00:00 2024-07-31 14:43:18+00:00 ... 2 Failed False False high challenge no details failed harbour. | AG MR CLEAN - Evening fixture report Harbour Marine True False True 3 151836128 69895515 None 74903725 39 39 None Email 2024-08-01 07:55:12+00:00 2024-08-01 07:52:29+00:00 ... 0 OnSubs False False None BRS MR POSITION LIST BSS FUJAIRAH - 01.08.2024 BRS Group True False True 4 151840557 69904244 None 74908859 17 17 None Email 2024-08-01 08:37:29+00:00 2024-08-01 08:36:01+00:00 ... 0 OnSubs False False None HOWEROB SIKKA MR POSITION LIST - 1ST AUGUST 2024 Howerob True False True <p>5 rows \u00d7 102 columns</p> <p>To retrieve fixtures for particular message ID(s), you should include an extra parameter called <code>message_ids</code> when using the <code>get_fixtures</code> method. This parameter should contain a list of message IDs. For instance,</p> In\u00a0[9]: Copied! <pre>message_ids = [69293490,69206864,69292355,69292233,69289483]\nscraped_fixtures_by_message_ids = api.get_fixtures(\n    vessel_type=vessel_type,\n    message_ids=message_ids,\n)\n\nnext(iter(scraped_fixtures_by_message_ids), None)\n</pre> message_ids = [69293490,69206864,69292355,69292233,69289483] scraped_fixtures_by_message_ids = api.get_fixtures(     vessel_type=vessel_type,     message_ids=message_ids, )  next(iter(scraped_fixtures_by_message_ids), None) Out[9]: <pre>ScrapedFixture(fixture_id=151241265, message_id=69206864, external_message_id=None, parsed_part_id=74443270, line_from=162, line_to=162, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 7, 24, 5, 28, 21, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 24, 5, 27, 1, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name='vitol tbn', scraped_deadweight=None, scraped_year_built=None, imo=None, vessel_name=None, deadweight=None, year_built=None, liquid_capacity=None, vessel_type_id=0, vessel_type=None, vessel_class_id=None, vessel_class=None, commercial_operator_id=None, commercial_operator=None, scraped_laycan='01-aug', laycan_from=datetime.datetime(2024, 8, 1, 0, 0, tzinfo=datetime.timezone.utc), laycan_to=datetime.datetime(2024, 8, 1, 0, 0, tzinfo=datetime.timezone.utc), scraped_load='quanzhou', load_geo_id=3306, load_name='Quanzhou', load_taxonomy_id=2, load_taxonomy='Port', scraped_load2=None, load_geo_id2=None, load_name2=None, load_taxonomy_id2=None, load_taxonomy2=None, scraped_discharge='philippines', scraped_discharge_options=None, discharge_geo_id=184, discharge_name='Philippines', discharge_taxonomy_id=3, discharge_taxonomy='Country', scraped_discharge2=None, discharge_geo_id2=None, discharge_name2=None, discharge_taxonomy_id2=None, discharge_taxonomy2=None, scraped_charterer='vitol', charterer_id=1831, charterer='Vitol', scraped_cargo_type='ulsd', cargo_type_id=60, cargo_type='Ultra Low Sulphur Diesel', cargo_group_id=120000, cargo_group='Clean', scraped_quantity='35', quantity=35000.0, quantity_buffer=0.0, quantity_from=35000.0, quantity_to=35000.0, scraped_rate=None, scraped_rate_options=None, rate_value=None, rate_type=None, open_geo_id=None, open_geo_name=None, open_taxonomy_id=None, open_taxonomy=None, open_date=None, scraped_delivery_date=None, delivery_date_from=None, delivery_date_to=None, scraped_delivery=None, delivery_geo_id=None, delivery_name=None, delivery_taxonomy_id=None, delivery_taxonomy=None, scraped_redelivery_from=None, redelivery_from_geo_id=None, redelivery_from_name=None, redelivery_from_taxonomy_id=None, redelivery_from_taxonomy=None, scraped_redelivery_to=None, redelivery_to_geo_id=None, redelivery_to_name=None, redelivery_to_taxonomy_id=None, redelivery_to_taxonomy=None, charter_type_id=0, charter_type='Voyage', fixture_status_id=None, fixture_status=None, is_owners_option=False, is_coa=True, content='vitol tbn - 35 01-aug ulsd quanzhou philippines o/p vitol', subject='LA MER DAILY CPP MARKET REPORT 24 JULY 2024', sender='La Mer Maritime', is_private=True, is_invalidated=False, is_partial=False)</pre> <p>You can achieve a similar result for external message IDs by providing an argument called <code>external_message_ids</code>.</p> <p>In the same manner, to get data for specific fixtures ID(s), you must call the <code>get_fixtures</code> method for a list of desired fixture ID(s).</p> <p>Date arguments are not available in this method</p> In\u00a0[10]: Copied! <pre>fixture_ids = [151345310,151345311,151345312,151345313,151345314]  # Or add a list of your desired fixture IDs\n\nscraped_fixtures_by_ids = api.get_fixtures(\n    vessel_type=vessel_type,\n    fixture_ids=fixture_ids,\n)\n\ndf_by_ids = pd.DataFrame(scraped_fixtures_by_ids)\ndf_by_ids.head()\n</pre> fixture_ids = [151345310,151345311,151345312,151345313,151345314]  # Or add a list of your desired fixture IDs  scraped_fixtures_by_ids = api.get_fixtures(     vessel_type=vessel_type,     fixture_ids=fixture_ids, )  df_by_ids = pd.DataFrame(scraped_fixtures_by_ids) df_by_ids.head() Out[10]: fixture_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... fixture_status_id fixture_status is_owners_option is_coa content subject sender is_private is_invalidated is_partial 0 151345310 69293490 None 74501355 123 123 1.0 Email 2024-07-24 17:43:06+00:00 2024-07-24 17:40:41+00:00 ... 0 OnSubs False False total maersk cayman 35 ulsd 03-04 aug duqm eaf... Fearnleys Clean Evening Market Report - 24th J... Fearnleys True False False 1 151345311 69293490 None 74501355 122 122 1.0 Email 2024-07-24 17:43:06+00:00 2024-07-24 17:40:41+00:00 ... 0 OnSubs False False st cl huaiyang 35 ulsd 03-04 aug sikka eafr/sa... Fearnleys Clean Evening Market Report - 24th J... Fearnleys True False False 2 151345312 69293490 None 74501355 121 121 NaN Email 2024-07-24 17:43:06+00:00 2024-07-24 17:40:41+00:00 ... 0 OnSubs False False reliance torm astrid 35 cpp 02-04 aug sikka uk... Fearnleys Clean Evening Market Report - 24th J... Fearnleys True False False 3 151345313 69293490 None 74501355 114 114 1.0 Email 2024-07-24 17:43:06+00:00 2024-07-24 17:40:41+00:00 ... 0 OnSubs False False admic high challenge 35 jet 27-29 jul ruwais u... Fearnleys Clean Evening Market Report - 24th J... Fearnleys True False False 4 151345314 69293490 None 74501355 115 115 NaN Email 2024-07-24 17:43:06+00:00 2024-07-24 17:40:41+00:00 ... 0 OnSubs False False ats amwaj 35 nap 27-28 jul ag japan ws 177.5 o... Fearnleys Clean Evening Market Report - 24th J... Fearnleys True False False <p>5 rows \u00d7 102 columns</p> <p>For instance, to retrieve the relevant page token for last day's data, you must call the <code>get_fixtures_incremental_token</code>, as below</p> In\u00a0[11]: Copied! <pre>updated_date_from = datetime.utcnow() - timedelta(days=1)\npage_token = api.get_fixtures_incremental_token(\n    updated_date_from=updated_date_from,\n)\n\npage_token\n</pre> updated_date_from = datetime.utcnow() - timedelta(days=1) page_token = api.get_fixtures_incremental_token(     updated_date_from=updated_date_from, )  page_token Out[11]: <pre>'MjAyNC0wOC0wMVQwODo0MzozNi4wMDBa'</pre> <p>If the <code>page_token</code> parameter is not specified, the <code>get_fixtures_incremental</code> method will retrieve all fixtures. You can call the <code>get_fixtures_incremental</code> method, as below</p> In\u00a0[12]: Copied! <pre>scraped_fixtures_incremental = api.get_fixtures_incremental(\n    vessel_type=vessel_type,\n    page_token=page_token,\n)\n\ndf_by_ids = pd.DataFrame(scraped_fixtures_incremental.data)\ndf_by_ids.head()\n</pre> scraped_fixtures_incremental = api.get_fixtures_incremental(     vessel_type=vessel_type,     page_token=page_token, )  df_by_ids = pd.DataFrame(scraped_fixtures_incremental.data) df_by_ids.head() Out[12]: fixture_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... fixture_status_id fixture_status is_owners_option is_coa content subject sender is_private is_invalidated is_partial 0 151841295 69907550 None 74910700.0 53.0 53.0 NaN Email 2024-08-01 08:54:47+00:00 2024-08-01 08:51:53+00:00 ... NaN None False False dynacom tbn 130kt nhc 28-30/8 ceyhan/vadinar u... MERIDIAN CRUDE MARKET REPORT 01/08/2024 ** MSG... Meridian True False False 1 151841296 69907550 None 74910700.0 106.0 106.0 NaN Email 2024-08-01 08:54:47+00:00 2024-08-01 08:51:53+00:00 ... NaN None False False teekay tbn 70kt nhc 11/8 caribs/usg ws 135 atm... MERIDIAN CRUDE MARKET REPORT 01/08/2024 ** MSG... Meridian True False False 2 151841297 69907550 None 74910700.0 112.0 112.0 NaN Email 2024-08-01 08:54:47+00:00 2024-08-01 08:51:53+00:00 ... NaN None False False teekay tbn 70kt nhc 8-9/8 ecm/usg ws 117.5 valero MERIDIAN CRUDE MARKET REPORT 01/08/2024 ** MSG... Meridian True False False 3 151841298 69907550 None 74910700.0 105.0 105.0 NaN Email 2024-08-01 08:54:47+00:00 2024-08-01 08:51:53+00:00 ... NaN None False False fline tbn 70kt nhc 6-8/8 usg/ukcm ws 135 conoc... MERIDIAN CRUDE MARKET REPORT 01/08/2024 ** MSG... Meridian True False False 4 151841299 69907550 None 74910700.0 107.0 107.0 NaN Email 2024-08-01 08:54:47+00:00 2024-08-01 08:51:53+00:00 ... NaN None False False north sea 70kt nhc 13-15/8 whiffenhead/ukcm ws... MERIDIAN CRUDE MARKET REPORT 01/08/2024 ** MSG... Meridian True False False <p>5 rows \u00d7 102 columns</p> <p>Also, the <code>get_fixtures_incremental</code> method will retrieve the <code>next_request_token</code>, which should be used as the <code>page_token</code> for the next incremental call and retrieve only new or updated fixtures.</p> In\u00a0[13]: Copied! <pre>next_request_token = scraped_fixtures_incremental.next_request_token\n\nnext_request_token\n</pre> next_request_token = scraped_fixtures_incremental.next_request_token  next_request_token Out[13]: <pre>'MjAyNC0wOC0wMlQwODo0MzozNi42OTla'</pre> <p>By default, all fields are returned. In many cases, it is convenient to select specific columns. For example, if we want to compare scraped and mapped fields</p> In\u00a0[14]: Copied! <pre>scraped_mapped_columns = [\n    'scraped_vessel_name',\n    'vessel_name',\n    'scraped_quantity',\n    'quantity',\n    'scraped_charterer',\n    'charterer',\n    'scraped_laycan',\n    'laycan_from',\n    'laycan_to',\n]\n\nscraped_mapped_df = pd.DataFrame(scraped_fixtures, columns=scraped_mapped_columns)\n\nscraped_mapped_df.head()\n</pre> scraped_mapped_columns = [     'scraped_vessel_name',     'vessel_name',     'scraped_quantity',     'quantity',     'scraped_charterer',     'charterer',     'scraped_laycan',     'laycan_from',     'laycan_to', ]  scraped_mapped_df = pd.DataFrame(scraped_fixtures, columns=scraped_mapped_columns)  scraped_mapped_df.head() Out[14]: scraped_vessel_name vessel_name scraped_quantity quantity scraped_charterer charterer scraped_laycan laycan_from laycan_to 0 None Atlantic T None NaN None None None NaT NaT 1 None Sea Spike None NaN None None None NaT NaT 2 None Yong Ao None NaN None None None NaT NaT 3 None STI Bronx None NaN None None None NaT NaT 4 None Torm Lotte None NaN None None None NaT NaT <p>Let's start by fetching all tanker fixtures received the last week</p> In\u00a0[15]: Copied! <pre>example_vessel_type = 1  # Tanker\nexample_date_from = datetime.utcnow() - timedelta(days=7)\n\nexample_scraped_fixtures = api.get_fixtures(\n   vessel_type=example_vessel_type,\n   received_date_from=example_date_from,\n)\n</pre> example_vessel_type = 1  # Tanker example_date_from = datetime.utcnow() - timedelta(days=7)  example_scraped_fixtures = api.get_fixtures(    vessel_type=example_vessel_type,    received_date_from=example_date_from, ) <p>The <code>is_deleted</code> property of a scraped fixture indicates whether it is valid or not. If it is set to <code>True</code>, the corresponding <code>fixture_id</code> has been replaced by a new one.</p> <p>For the sake of completeness, we will exclude deleted scraped fixtures in the following examples.</p> In\u00a0[16]: Copied! <pre>example_scraped_fixtures = [fixture for fixture in example_scraped_fixtures if not fixture.is_deleted]\n\nnext(iter(example_scraped_fixtures), None)\n</pre> example_scraped_fixtures = [fixture for fixture in example_scraped_fixtures if not fixture.is_deleted]  next(iter(example_scraped_fixtures), None) Out[16]: <pre>ScrapedFixture(fixture_id=151440093, message_id=69453094, external_message_id=None, parsed_part_id=74606440, line_from=17, line_to=17, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 7, 26, 9, 10, 2, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 26, 9, 8, 58, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name='cardiff tbn', scraped_deadweight=None, scraped_year_built=None, imo=None, vessel_name=None, deadweight=None, year_built=None, liquid_capacity=None, vessel_type_id=0, vessel_type=None, vessel_class_id=None, vessel_class=None, commercial_operator_id=None, commercial_operator=None, scraped_laycan='10-aug', laycan_from=datetime.datetime(2024, 8, 10, 0, 0, tzinfo=datetime.timezone.utc), laycan_to=datetime.datetime(2024, 8, 10, 0, 0, tzinfo=datetime.timezone.utc), scraped_load='bashayer', load_geo_id=3782, load_name='Bashayer', load_taxonomy_id=2, load_taxonomy='Port', scraped_load2=None, load_geo_id2=None, load_name2=None, load_taxonomy_id2=None, load_taxonomy2=None, scraped_discharge='fuja', scraped_discharge_options=None, discharge_geo_id=3153, discharge_name='Fujairah', discharge_taxonomy_id=2, discharge_taxonomy='Port', scraped_discharge2=None, discharge_geo_id2=None, discharge_name2=None, discharge_taxonomy_id2=None, discharge_taxonomy2=None, scraped_charterer='cardiff', charterer_id=-1, charterer=None, scraped_cargo_type='hc', cargo_type_id=19, cargo_type='Crude Oil', cargo_group_id=130000, cargo_group='Dirty', scraped_quantity='130', quantity=130000.0, quantity_buffer=0.0, quantity_from=130000.0, quantity_to=130000.0, scraped_rate='$1.90m', scraped_rate_options=None, rate_value=1900000.0, rate_type='LS', open_geo_id=None, open_geo_name=None, open_taxonomy_id=None, open_taxonomy=None, open_date=None, scraped_delivery_date=None, delivery_date_from=None, delivery_date_to=None, scraped_delivery=None, delivery_geo_id=None, delivery_name=None, delivery_taxonomy_id=None, delivery_taxonomy=None, scraped_redelivery_from=None, redelivery_from_geo_id=None, redelivery_from_name=None, redelivery_from_taxonomy_id=None, redelivery_from_taxonomy=None, scraped_redelivery_to=None, redelivery_to_geo_id=None, redelivery_to_name=None, redelivery_to_taxonomy_id=None, redelivery_to_taxonomy=None, charter_type_id=0, charter_type='Voyage', fixture_status_id=None, fixture_status=None, is_owners_option=False, is_coa=False, content='cardiff tbn 130 10-aug hc bashayer fuja $1.90m cardiff tbn -', subject=\"DA' OCEANIC SHIPPING - DAILY DPP MARKET REPORT 26.07.2024\", sender=\"Da'oceanic Shipping\", is_private=True, is_invalidated=False, is_partial=False)</pre> <p>Now, we are ready to insert our data into a dataframe and keep only specific fields</p> In\u00a0[17]: Copied! <pre>example_columns = [\n    'imo',\n    'charterer',   \n    'laycan_from',\n    'load_name',\n    'is_deleted',\n]\n\ndata = pd.DataFrame(example_scraped_fixtures, columns=example_columns).astype({'imo': 'Int64'})\n\ndata.head()\n</pre> example_columns = [     'imo',     'charterer',        'laycan_from',     'load_name',     'is_deleted', ]  data = pd.DataFrame(example_scraped_fixtures, columns=example_columns).astype({'imo': 'Int64'})  data.head() Out[17]: imo charterer laycan_from load_name is_deleted 0 &lt;NA&gt; None 2024-08-10 00:00:00+00:00 Bashayer False 1 9305611 Heritage Petroleum 2024-08-07 00:00:00+00:00 Ceyhan False 2 9449405 Shell 2024-08-11 00:00:00+00:00 Nigeria False 3 9305623 Heritage Petroleum 2024-08-07 00:00:00+00:00 Ceyhan False 4 9749556 ENI 2024-08-04 00:00:00+00:00 US Gulf False <p>In this example, we will find the top 10 Charterers, based on the number of distinct voyages</p> In\u00a0[18]: Copied! <pre>top_chrtr_ser = data[['charterer', 'imo']].drop_duplicates().charterer.value_counts().head(10)\n\ntop_chrtr_df = top_chrtr_ser.to_frame(name='FixtureCount').reset_index().rename(columns={'index': 'Charterer'})\n\ntop_chrtr_df\n</pre> top_chrtr_ser = data[['charterer', 'imo']].drop_duplicates().charterer.value_counts().head(10)  top_chrtr_df = top_chrtr_ser.to_frame(name='FixtureCount').reset_index().rename(columns={'index': 'Charterer'})  top_chrtr_df Out[18]: charterer FixtureCount 0 Aramco Trading Company 69 1 Total 48 2 BP 45 3 Vitol 43 4 Shell 41 5 Unipec 34 6 Chevron 31 7 Reliance 29 8 ExxonMobil 29 9 Abu Dhabi National Oil Company 28 <p>And display results in a bar plot</p> In\u00a0[19]: Copied! <pre>top_chrtr_fig = go.Figure()\n\nbar = go.Bar(\n    x=top_chrtr_df.charterer.tolist(),\n    y=top_chrtr_df.FixtureCount.tolist(),\n)\n\ntop_chrtr_fig.add_trace(bar)\ntop_chrtr_fig.update_xaxes(title_text=\"Charterer\")\ntop_chrtr_fig.update_yaxes(title_text=\"Number of Voyages\")\ntop_chrtr_fig.show()\n</pre> top_chrtr_fig = go.Figure()  bar = go.Bar(     x=top_chrtr_df.charterer.tolist(),     y=top_chrtr_df.FixtureCount.tolist(), )  top_chrtr_fig.add_trace(bar) top_chrtr_fig.update_xaxes(title_text=\"Charterer\") top_chrtr_fig.update_yaxes(title_text=\"Number of Voyages\") top_chrtr_fig.show() <p>In this example, we will create a visualization, for the number of distinct vessels loading in specific areas per day over the next week</p> In\u00a0[20]: Copied! <pre>this_week_days = pd.date_range(start=datetime.utcnow().date(), freq='D', periods=7, tz='UTC')\nareas = data[data.load_name.notna()].load_name.value_counts().head().index.tolist()\n\nareas\n</pre> this_week_days = pd.date_range(start=datetime.utcnow().date(), freq='D', periods=7, tz='UTC') areas = data[data.load_name.notna()].load_name.value_counts().head().index.tolist()  areas Out[20]: <pre>['Arabian Gulf', 'US Gulf', 'Sikka', 'Singapore', 'Korea, Republic of']</pre> <p>Create the pivot table</p> In\u00a0[21]: Copied! <pre>areas_mask = data.load_name.isin(areas) &amp; data.laycan_from.isin(this_week_days)\n\ndf_areas = data[areas_mask]\n\ndf_pivot = pd.pivot_table(\n    df_areas,\n    columns='load_name',\n    index='laycan_from',\n    values='imo',\n    aggfunc=pd.Series.nunique,\n    fill_value=0,\n).reindex(index=this_week_days, fill_value=0).reset_index().rename(columns={'index': 'laycan_from'})\n\ndf_pivot\n</pre> areas_mask = data.load_name.isin(areas) &amp; data.laycan_from.isin(this_week_days)  df_areas = data[areas_mask]  df_pivot = pd.pivot_table(     df_areas,     columns='load_name',     index='laycan_from',     values='imo',     aggfunc=pd.Series.nunique,     fill_value=0, ).reindex(index=this_week_days, fill_value=0).reset_index().rename(columns={'index': 'laycan_from'})  df_pivot Out[21]: load_name laycan_from Arabian Gulf Korea, Republic of Sikka Singapore US Gulf 0 2024-08-02 00:00:00+00:00 6 1 4 3 14 1 2024-08-03 00:00:00+00:00 5 5 1 2 19 2 2024-08-04 00:00:00+00:00 8 0 5 1 6 3 2024-08-05 00:00:00+00:00 10 1 7 2 15 4 2024-08-06 00:00:00+00:00 12 1 4 4 15 5 2024-08-07 00:00:00+00:00 11 1 4 0 4 6 2024-08-08 00:00:00+00:00 13 4 3 4 5 <p>And display the results as timeseries</p> In\u00a0[22]: Copied! <pre>def area_button(area):\n    args = [\n        {'visible': [i == areas.index(area) for i in range(len(areas))]},\n        {\n            'title': f'Vessels loading in {area} per day',\n            'showlegend': True\n        },\n    ]\n    \n    return dict(\n        label=area,\n        method='update',\n        args=args,\n    )\n\ntitle = 'Vessels loading per day'\ntoday = datetime.combine(datetime.utcnow().date(), datetime.min.time())\n\nareas_fig = go.Figure()\n\narea_buttons = []\n\nfor area in areas:\n    if area not in df_pivot.columns:\n        continue\n    area_scatter_plot = go.Scatter(    \n        x=df_pivot.laycan_from,\n        y=df_pivot[area],\n        name=area,\n        mode='lines',\n    )\n\n    areas_fig.add_trace(area_scatter_plot)\n    \n    area_buttons.append(area_button(area))\n    \nbuttons = list([\n    dict(\n        label='All',\n        method='update',\n        args=[    \n            {'visible': [True for _ in range(len(areas))]},\n            {\n                'title': title,\n                'showlegend': True\n            }\n        ],\n    ),\n    *area_buttons,\n])\n\nareas_fig.update_layout(\n    title=title,\n    updatemenus=[go.layout.Updatemenu(\n        active=0,\n        buttons=buttons,\n    )],\n    xaxis_range=[today - timedelta(hours=4), today + timedelta(hours=24*6 + 4)],\n)\n\nareas_fig.show()\n</pre> def area_button(area):     args = [         {'visible': [i == areas.index(area) for i in range(len(areas))]},         {             'title': f'Vessels loading in {area} per day',             'showlegend': True         },     ]          return dict(         label=area,         method='update',         args=args,     )  title = 'Vessels loading per day' today = datetime.combine(datetime.utcnow().date(), datetime.min.time())  areas_fig = go.Figure()  area_buttons = []  for area in areas:     if area not in df_pivot.columns:         continue     area_scatter_plot = go.Scatter(             x=df_pivot.laycan_from,         y=df_pivot[area],         name=area,         mode='lines',     )      areas_fig.add_trace(area_scatter_plot)          area_buttons.append(area_button(area))      buttons = list([     dict(         label='All',         method='update',         args=[                 {'visible': [True for _ in range(len(areas))]},             {                 'title': title,                 'showlegend': True             }         ],     ),     *area_buttons, ])  areas_fig.update_layout(     title=title,     updatemenus=[go.layout.Updatemenu(         active=0,         buttons=buttons,     )],     xaxis_range=[today - timedelta(hours=4), today + timedelta(hours=24*6 + 4)], )  areas_fig.show() In\u00a0[23]: Copied! <pre>output_path = '' # Change output_path with your path\nfilename = 'last_week_fixtures.csv'\nif not data.empty:\n    data.to_csv(output_path+filename, index=False)\n</pre> output_path = '' # Change output_path with your path filename = 'last_week_fixtures.csv' if not data.empty:     data.to_csv(output_path+filename, index=False) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#scraped-fixtures-api-example","title":"Scraped Fixtures API Example\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#scraped-fixtures-api","title":"Scraped Fixtures API\u00b6","text":"<p>The goal of Scraped Fixtures API is to collect and return scraped fixtures by the given filters. This can be done by using the <code>ScrapedFixturesAPI</code> class and calling appropriate methods</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#1-request-by-filters","title":"1. Request by filters\u00b6","text":"<p>Fixtures can be retrieved for specific filters, by calling the <code>get_fixtures</code> method with the following arguments:</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>vessel_type</code> The vessel type</p> <p>Additionally, at least one of the following is required</p> <p><code>fixture_ids</code> List of FixtureIDs</p> <p><code>imos</code> List of IMOs</p> <p><code>message_ids</code> List of MessageIDs</p> <p><code>external_message_ids</code> List of ExternalMessageIDs</p> <p><code>received_date_from</code> Earliest date the fixture received</p> <p><code>received_date_to</code> Latest date the fixture received</p> <p><code>updated_date_from</code> Earliest date the fixture updated</p> <p><code>updated_date_to</code> Latest date the fixture updated</p> <p>Mixing received and updated dates is not allowed</p> <p>It's highly recommended to use UTC  dates, since this is the internally used format</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#2-request-by-page-token","title":"2. Request by page token\u00b6","text":"<p>Fixtures can also be retrieved, by calling the <code>get_fixtures_incremental</code> method. This method will also return <code>next_request_token</code>, which the user should use to their next incremental request to retrieve only the latest updated cargoes.</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>vessel_type</code> The vessel type</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#optional","title":"Optional\u00b6","text":"<p><code>page_token</code> The key that should be used as a parameter of the token to retrieve the relevant page.</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#3-retrieve-page-token","title":"3. Retrieve page token\u00b6","text":"<p>The token referenced above can be retrieved for a specific date, by calling the <code>get_fixtures_incremental_token</code> method with the following argument:</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>updated_date_from</code> Earliest date the fixture updated</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#additional-optional-arguments","title":"Additional optional arguments\u00b6","text":"<p>Methods <code>get_fixtures</code> and <code>get_fixtures_incremental</code>, also accept the following optional arguments:</p> <p><code>include_details</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>parsed_part_id, line_from, line_to, in_line_order, source\n</code></pre> <p><code>include_scraped_fields</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>scraped_vessel_name, scraped_deadweight, scraped_year_built, scraped_laycan, scraped_load, scraped_load2, scraped_discharge, scraped_discharge_options, scraped_discharge2, scraped_charterer, scraped_cargo_type, scraped_quantity, scraped_rate, scraped_rate_options, scraped_delivery_date, scraped_delivery, scraped_redelivery_from, scraped_redelivery_to\n</code></pre> <p><code>include_vessel_details</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>vessel_name, deadweight, year_built, liquid_capacity, vessel_type_id, vessel_type, vessel_class, commercial_operator_id, commercial_operator\n</code></pre> <p><code>include_labels</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>load_name, load_taxonomy, load_name2, load_taxonomy2, discharge_name, discharge_taxonomy, discharge_name2, discharge_taxonomy2, charterer, cargo_type, cargo_group, open_geo_name, open_taxonomy, delivery_name, delivery_taxonomy, redelivery_from_name, redelivery_from_taxonomy, redelivery_to_name, redelivery_to_taxonomy, charter_type, fixture_status\n</code></pre> <p><code>include_content</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>content\n</code></pre> <p><code>include_sender</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>sender\n</code></pre> <p><code>include_debug_info</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>is_private, is_invalidated, is_partial\n</code></pre> <p>Default value is <code>True</code> for the arguments described above</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#installation","title":"Installation\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#quickstart","title":"Quickstart\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#request-by-date","title":"Request by date\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#request-by-imos","title":"Request by IMOs\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#request-by-message-or-externalmessage-ids","title":"Request by Message or ExternalMessage IDs\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#request-by-fixture-ids","title":"Request by Fixture IDs\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#retrieve-incremental-token","title":"Retrieve incremental token\u00b6","text":"<p>The <code>get_fixtures_incremental_token</code> allows retrieval of <code>page_token</code> by adding the <code>updated_date_from</code> value. This <code>page_token</code> can be used as a variable to the <code>get_fixtures_incremental</code> method, in order to retrieve only new or updated fixtures.</p>"},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#request-by-page-token","title":"Request by page token\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#usage-of-optional-arguments","title":"Usage of optional arguments\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#examples","title":"Examples\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#exclude-deleted-scraped-fixtures","title":"Exclude deleted scraped fixtures\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#top-10-charterers","title":"Top 10 Charterers\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#vessels-loading-in-specific-areas","title":"Vessels loading in specific areas\u00b6","text":""},{"location":"examples/jupyter/ScrapedFixturesAPI/Scraped%20Fixtures%20API%20Example/#export-data-to-csv","title":"Export data to csv\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/","title":"Scraped Lineups API Example","text":"<p>Get your personal Signal Ocean API subscription key (acquired here) and replace it below:</p> In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' # Replace with your subscription key\n</pre> signal_ocean_api_key = '' # Replace with your subscription key <p>To install Signal Ocean SDK, simply run the following command</p> In\u00a0[2]: Copied! <pre>%%capture\n%pip install signal-ocean\n</pre> %%capture %pip install signal-ocean <p>Import <code>signal-ocean</code> and other modules required for this demo</p> In\u00a0[3]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.scraped_lineups import ScrapedLineupsAPI\n\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport plotly.graph_objects as go\n</pre> from signal_ocean import Connection from signal_ocean.scraped_lineups import ScrapedLineupsAPI  from datetime import datetime, timedelta import pandas as pd import plotly.graph_objects as go <p>Create a new instance of the <code>ScrapedLineupsAPI</code> class</p> In\u00a0[4]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = ScrapedLineupsAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = ScrapedLineupsAPI(connection) <p>Now you are ready to retrieve your data</p> <p>To get all tanker lineups received the last twelve hours, you must declare appropriate <code>vessel_type</code> and <code>received_date_from</code> variables</p> In\u00a0[5]: Copied! <pre>vessel_type = 1  # Tanker\nreceived_date_from = datetime.utcnow() - timedelta(hours=12)\n</pre> vessel_type = 1  # Tanker received_date_from = datetime.utcnow() - timedelta(hours=12) <p>And then call <code>get_lineups</code> method, as below</p> In\u00a0[6]: Copied! <pre>scraped_lineups = api.get_lineups(\n    vessel_type=vessel_type,\n    received_date_from=received_date_from,\n)\n\nnext(iter(scraped_lineups), None)\n</pre> scraped_lineups = api.get_lineups(     vessel_type=vessel_type,     received_date_from=received_date_from, )  next(iter(scraped_lineups), None) Out[6]: <pre>ScrapedLineup(lineup_id=46348340, message_id=69973665, external_message_id=None, parsed_part_id=74958019, line_from=82, line_to=82, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 8, 2, 6, 26, 27, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 8, 2, 6, 24, 24, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name='SUEZ PROTOPIA', scraped_imo=None, scraped_deadweight=None, scraped_year_built=None, imo=9380893, vessel_name='Suez Protopia', deadweight=159999, year_built=2008, liquid_capacity=172092, vessel_type_id=1, vessel_type='Tanker', vessel_class_id=85, vessel_class='Suezmax', commercial_operator_id=1597, commercial_operator='Stealth Maritime Corp', scraped_eta='02.08.2024', eta=datetime.datetime(2024, 8, 2, 0, 0, tzinfo=datetime.timezone.utc), scraped_etb=None, etb=None, scraped_etd=None, etd=None, scraped_location='DARDANELLES', location_geo_id=7258, location_name='Dardanelles (WP)', location_taxonomy_id=1, location_taxonomy='GeoAsset', operation_type_id=3, operation_type='Waypoint', scraped_quantity=None, quantity=None, quantity_unit=None, scraped_cargo_type=None, cargo_type_id=None, cargo_type=None, cargo_group_id=None, cargo_group=None, scraped_api_gravity=None, api_gravity=None, scraped_origin='KOCAELI', origin_geo_id=-1, origin_name=None, origin_taxonomy_id=-1, origin_taxonomy='Unknown', scraped_destination='TALLIN', destination_geo_id=3369, destination_name='Tallinn', destination_taxonomy_id=2, destination_taxonomy='Port', scraped_supplier=None, supplier_id=None, supplier=None, scraped_charterer=None, charterer_id=None, charterer=None, scraped_buyer=None, buyer_id=None, buyer=None, scraped_port_agent=None, port_agent_id=None, port_agent=None, vessel_status_id=None, vessel_status=None, content='TTA/ SUEZ PROTOPIA  KOCAELI  TALLIN  02.08.2024- 08:15 HRS', subject='Turkish Straits Daily Report by Boutrosmar Istanbul August 2, 2024', sender='Boutros Maritime &amp; Transports', is_private=True)</pre> <p>For better visualization, it's convenient to insert data into a DataFrame</p> In\u00a0[7]: Copied! <pre>df = pd.DataFrame(scraped_lineups)\n\ndf.head()\n</pre> df = pd.DataFrame(scraped_lineups)  df.head() Out[7]: lineup_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... buyer scraped_port_agent port_agent_id port_agent vessel_status_id vessel_status content subject sender is_private 0 46348340 69973665 None 74958019 82 82 NaN Email 2024-08-02 06:26:27+00:00 2024-08-02 06:24:24+00:00 ... None None None None NaN None TTA/ SUEZ PROTOPIA  KOCAELI  TALLIN  02.08.202... Turkish Straits Daily Report by Boutrosmar Ist... Boutros Maritime &amp; Transports True 1 46348341 69973665 None 74958019 81 81 NaN Email 2024-08-02 06:26:27+00:00 2024-08-02 06:24:24+00:00 ... None None None None NaN None TTA/ ADVANTAGE LOVE  TUAPSE  PORT SAID  02.08.... Turkish Straits Daily Report by Boutrosmar Ist... Boutros Maritime &amp; Transports True 2 46348342 69973665 None 74958019 62 62 NaN Email 2024-08-02 06:26:27+00:00 2024-08-02 06:24:24+00:00 ... None None None None NaN None TTA/ AEGEAN NOBILITY  JEDDAH  NOVOROSSIYSK  02... Turkish Straits Daily Report by Boutrosmar Ist... Boutros Maritime &amp; Transports True 3 46348343 69973665 None 74958019 83 83 NaN Email 2024-08-02 06:26:27+00:00 2024-08-02 06:24:24+00:00 ... None None None None NaN None TTA/ AGIOS GERASIMOS  NOVOROSSIYSK  TRIESTE  0... Turkish Straits Daily Report by Boutrosmar Ist... Boutros Maritime &amp; Transports True 4 46348344 69973665 None 74958019 60 60 NaN Email 2024-08-02 06:26:27+00:00 2024-08-02 06:24:24+00:00 ... None None None None NaN None TTA/ VELOS AMBER  UST LUGA  ISTANBUL  02.08.20... Turkish Straits Daily Report by Boutrosmar Ist... Boutros Maritime &amp; Transports True <p>5 rows \u00d7 78 columns</p> <p>To get lineups for specific vessel(s) by their IMO number(s), you can simple call the <code>get_lineups</code> method for a list of desired IMO(s)</p> <p>Adding some date argument is always feasible</p> In\u00a0[8]: Copied! <pre>imos = [9380673,9359571,9377200,9383651,9287833]  # Or add a list of your desired IMOs\n\nscraped_lineups_by_imos = api.get_lineups(\n    vessel_type=vessel_type,\n    received_date_from=received_date_from,\n    imos=imos,\n)\n\ndf_by_imos = pd.DataFrame(scraped_lineups_by_imos)\ndf_by_imos.head()\n</pre> imos = [9380673,9359571,9377200,9383651,9287833]  # Or add a list of your desired IMOs  scraped_lineups_by_imos = api.get_lineups(     vessel_type=vessel_type,     received_date_from=received_date_from,     imos=imos, )  df_by_imos = pd.DataFrame(scraped_lineups_by_imos) df_by_imos.head() Out[8]: lineup_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... buyer scraped_port_agent port_agent_id port_agent vessel_status_id vessel_status content subject sender is_private 0 46350600 69990985 None 74968644 14 14 NaN Email 2024-08-02 08:23:00+00:00 2024-08-02 08:21:37+00:00 ... None ISS-AUGUSTA None None None None 01/08/2024 11:04\\tCALAJUNCO M\\tITA\\t13671\\tBRI... Augusta and S.ta Panagia Bay daily situation Nolarma True 1 46350616 69990985 None 74968644 77 77 NaN Email 2024-08-02 08:23:00+00:00 2024-08-02 08:21:37+00:00 ... None ISS-AUGUSTA None None None None 01/08/2024 12:00\\t25 Isab Nord\\tCALAJUNCO M\\tI... Augusta and S.ta Panagia Bay daily situation Nolarma True 2 46350961 69991561 None 74968988 17 17 NaN Email 2024-08-02 08:26:40+00:00 2024-08-02 08:26:06+00:00 ... None None None None None None calajunco m\\tbrindisi\\teni\\t03/1500\\ttbc\\ttbc\\... TARANTO TANKER SITUATION - Nolarma True 3 46350963 69991561 None 74968988 9 9 1.0 Email 2024-08-02 08:26:40+00:00 2024-08-02 08:26:06+00:00 ... None None None None None None divina\\tortona\\teni 1\\t02/0700\\t02/0848\\t03/12... TARANTO TANKER SITUATION - Nolarma True 4 46350964 69991561 None 74968988 9 9 NaN Email 2024-08-02 08:26:40+00:00 2024-08-02 08:26:06+00:00 ... None None None None None None divina\\tortona\\teni 1\\t02/0700\\t02/0848\\t03/12... TARANTO TANKER SITUATION - Nolarma True <p>5 rows \u00d7 78 columns</p> <p>To retrieve lineups for particular message ID(s), you should include an extra parameter called <code>message_ids</code> when using the <code>get_lineups</code> method. This parameter should contain a list of message IDs. For instance,</p> In\u00a0[9]: Copied! <pre>message_ids = [69347177,69344714,69344260,69342271,69339979]\nscraped_lineups_by_message_ids = api.get_lineups(\n    vessel_type=vessel_type,\n    message_ids=message_ids,\n)\n\nnext(iter(scraped_lineups_by_message_ids), None)\n</pre> message_ids = [69347177,69344714,69344260,69342271,69339979] scraped_lineups_by_message_ids = api.get_lineups(     vessel_type=vessel_type,     message_ids=message_ids, )  next(iter(scraped_lineups_by_message_ids), None) Out[9]: <pre>ScrapedLineup(lineup_id=45619246, message_id=69339979, external_message_id=None, parsed_part_id=74531114, line_from=5, line_to=5, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 7, 25, 7, 29, 5, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 25, 7, 27, 20, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name='meltemi', scraped_imo=None, scraped_deadweight=None, scraped_year_built=None, imo=-1, vessel_name=None, deadweight=None, year_built=None, liquid_capacity=None, vessel_type_id=-1, vessel_type='Unknown', vessel_class_id=-1, vessel_class='Unknown', commercial_operator_id=None, commercial_operator=None, scraped_eta='20/07/2024', eta=datetime.datetime(2024, 7, 20, 0, 0, tzinfo=datetime.timezone.utc), scraped_etb='25/07/2024', etb=datetime.datetime(2024, 7, 25, 0, 0, tzinfo=datetime.timezone.utc), scraped_etd='26/07/2024', etd=datetime.datetime(2024, 7, 26, 0, 0, tzinfo=datetime.timezone.utc), scraped_location='trieste', location_geo_id=3565, location_name='Trieste', location_taxonomy_id=2, location_taxonomy='Port', operation_type_id=2, operation_type='Discharge', scraped_quantity='139,091', quantity=139091.0, quantity_unit='Tonnes', scraped_cargo_type='CRUDE', cargo_type_id=19, cargo_type='Crude Oil', cargo_group_id=19, cargo_group=None, scraped_api_gravity=None, api_gravity=None, scraped_origin='marsa el hariga', origin_geo_id=3625, origin_name='Marsa El Hariga', origin_taxonomy_id=2, origin_taxonomy='Port', scraped_destination=None, destination_geo_id=-1, destination_name=None, destination_taxonomy_id=-1, destination_taxonomy='Unknown', scraped_supplier=None, supplier_id=None, supplier=None, scraped_charterer=None, charterer_id=None, charterer=None, scraped_buyer='p66d/ruhr-roor', buyer_id=6064, buyer='Ruhr Oel', scraped_port_agent=None, port_agent_id=None, port_agent=None, vessel_status_id=None, vessel_status=None, content='meltemi\\t20/07/2024\\t23:00\\tyes\\t25/07/2024\\t13:00\\tsiot\\t3\\t\\t26/07/2024\\t22:00\\tmarsa el hariga\\tsame\\t139,091\\tp66d/ruhr-roor', subject='SIOT TERMINAL TRIESTE DAILY SITUATION', sender='Nolarma', is_private=True)</pre> <p>You can achieve a similar result for external message IDs by providing an argument called <code>external_message_ids</code>.</p> <p>In the same manner, to get data for specific lineup ID(s), you must call the <code>get_lineups</code> method for a list of desired lineup ID(s)</p> <p>Date arguments are not available in this method</p> In\u00a0[10]: Copied! <pre>lineup_ids = [45618852,45621364,45619822,45619821,45619820]  # Or add a list of your desired lineup IDs\n\nscraped_lineups_by_ids = api.get_lineups(\n    vessel_type=vessel_type,\n    lineup_ids=lineup_ids,\n)\n\ndf_by_ids = pd.DataFrame(scraped_lineups_by_ids)\ndf_by_ids.head()\n</pre> lineup_ids = [45618852,45621364,45619822,45619821,45619820]  # Or add a list of your desired lineup IDs  scraped_lineups_by_ids = api.get_lineups(     vessel_type=vessel_type,     lineup_ids=lineup_ids, )  df_by_ids = pd.DataFrame(scraped_lineups_by_ids) df_by_ids.head() Out[10]: lineup_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... buyer scraped_port_agent port_agent_id port_agent vessel_status_id vessel_status content subject sender is_private 0 45618852 69335109 None 74528225 81 81 None Email 2024-07-25 07:07:11+00:00 2024-07-25 07:05:19+00:00 ... None None None None None None TTA/ NEW VISION  KOCAELI  ALIAGA  25.07.2024- ... Turkish Straits Daily Report by Boutrosmar Ist... Boutros Maritime &amp; Transports True 1 45619820 69344260 None 74533628 33 33 None Email 2024-07-25 07:47:03+00:00 2024-07-25 07:45:21+00:00 ... None None None None None None \\tvalle di granada\\t\\t\\t\\t\\t27/1500\\tload cpp Milazzo daily situation Nolarma True 2 45619821 69344260 None 74533628 32 32 None Email 2024-07-25 07:47:03+00:00 2024-07-25 07:45:21+00:00 ... None None None None None None \\tred garnet\\t\\t\\t\\t\\t26/0800\\tload vgo Milazzo daily situation Nolarma True 3 45619822 69344260 None 74533628 31 31 None Email 2024-07-25 07:47:03+00:00 2024-07-25 07:45:21+00:00 ... None None None None None None \\ttiger eye\\t\\t\\t\\t\\t26/0800\\tload cpp Milazzo daily situation Nolarma True 4 45621364 69347177 None 74535337 19 19 None Email 2024-07-25 07:59:13+00:00 2024-07-25 07:58:51+00:00 ... Saras None None None None None ohio\\t\\t30/1900\\t\\t\\t\\tceyhan\\tdisch\\tcrude oi... Sarroch daily situation - Nolarma True <p>5 rows \u00d7 78 columns</p> <p>For instance, to retrieve the relevant page token for last week's data, you must call the <code>get_lineups_incremental_token</code>, as below</p> In\u00a0[11]: Copied! <pre>updated_date_from = datetime.utcnow() - timedelta(days=7)\npage_token = api.get_lineups_incremental_token(\n    updated_date_from=updated_date_from,\n)\n\npage_token\n</pre> updated_date_from = datetime.utcnow() - timedelta(days=7) page_token = api.get_lineups_incremental_token(     updated_date_from=updated_date_from, )  page_token Out[11]: <pre>'MjAyNC0wNy0yNlQwODo0MjoyNi4wMDBa'</pre> <p>If the <code>page_token</code> parameter is not specified, the <code>get_lineups_incremental</code> method will retrieve all lineups. You can call the <code>get_lineups_incremental</code> method, as below</p> In\u00a0[12]: Copied! <pre>scraped_lineups_incremental = api.get_lineups_incremental(\n    vessel_type=vessel_type,\n    page_token=page_token,\n)\n\ndf_by_ids = pd.DataFrame(scraped_lineups_incremental.data)\ndf_by_ids.head()\n</pre> scraped_lineups_incremental = api.get_lineups_incremental(     vessel_type=vessel_type,     page_token=page_token, )  df_by_ids = pd.DataFrame(scraped_lineups_incremental.data) df_by_ids.head() Out[12]: lineup_id message_id external_message_id parsed_part_id line_from line_to in_line_order source updated_date received_date ... buyer scraped_port_agent port_agent_id port_agent vessel_status_id vessel_status content subject sender is_private 0 45726016 69455361 None 74607744 23 23 NaN Email 2024-07-26 09:28:49+00:00 2024-07-26 09:27:55+00:00 ... None None None None 1.0 Expected \\tWHITE STAR\\tGIBILTERRA\\tENI\\t27/0200\\tTBC\\tT... CAMBIASO RISSO - DAILY  PORT SITUATION Cambiaso Risso Group True 1 45726017 69455361 None 74607746 24 24 NaN Email 2024-07-26 09:28:49+00:00 2024-07-26 09:27:55+00:00 ... None None None None 3.0 AtAnchor 25/2000\\tSYN ZUBE\\tITA\\t3827\\tNEMRUT\\tL\\t2000\\... CAMBIASO RISSO - DAILY  PORT SITUATION Cambiaso Risso Group True 2 45726018 69455361 None 74607746 34 34 NaN Email 2024-07-26 09:28:49+00:00 2024-07-26 09:27:55+00:00 ... None None None None 1.0 Expected 28/0700\\tLADY\\tITA\\t24494\\tLIVORNO\\t\\t\\t\\t CAMBIASO RISSO - DAILY  PORT SITUATION Cambiaso Risso Group True 3 45726019 69455361 None 74607743 3 3 NaN Email 2024-07-26 09:28:49+00:00 2024-07-26 09:27:55+00:00 ... None None None None 4.0 AtBerth ORIENTAL TULIP\\tAT BERTH\\t23/07 14,36\\t26/07 P... CAMBIASO RISSO - DAILY  PORT SITUATION Cambiaso Risso Group True 4 45726020 69455361 None 74607743 4 4 NaN Email 2024-07-26 09:28:49+00:00 2024-07-26 09:27:55+00:00 ... None None None None 4.0 AtBerth SUPERBA\\tAT BERTH\\t23/07 13,18\\t28/07 P.M.\\tEL... CAMBIASO RISSO - DAILY  PORT SITUATION Cambiaso Risso Group True <p>5 rows \u00d7 78 columns</p> <p>Also, the <code>get_lineups_incremental</code> method will retrieve the <code>next_request_token</code>, which should be used as the <code>page_token</code> for the next incremental call and retrieve only new or updated lineups.</p> In\u00a0[13]: Copied! <pre>next_request_token = scraped_lineups_incremental.next_request_token\n\nnext_request_token\n</pre> next_request_token = scraped_lineups_incremental.next_request_token  next_request_token Out[13]: <pre>'MjAyNC0wOC0wMlQwODo0MjoyNi43NDNa'</pre> <p>By default, all fields are returned. In many cases, it is convenient to select specific columns. For example, if we want to compare scraped and mapped fields</p> In\u00a0[14]: Copied! <pre>scraped_mapped_columns = [\n    'scraped_vessel_name',\n    'vessel_name',\n    'scraped_location',\n    'location_name',\n    'scraped_origin',\n    'origin_name',\n    'scraped_cargo_type',\n    'cargo_type',\n    'scraped_quantity',\n    'quantity',\n]\n\nscraped_mapped_df = pd.DataFrame(scraped_lineups, columns=scraped_mapped_columns)\n\nscraped_mapped_df.head()\n</pre> scraped_mapped_columns = [     'scraped_vessel_name',     'vessel_name',     'scraped_location',     'location_name',     'scraped_origin',     'origin_name',     'scraped_cargo_type',     'cargo_type',     'scraped_quantity',     'quantity', ]  scraped_mapped_df = pd.DataFrame(scraped_lineups, columns=scraped_mapped_columns)  scraped_mapped_df.head() Out[14]: scraped_vessel_name vessel_name scraped_location location_name scraped_origin origin_name scraped_cargo_type cargo_type scraped_quantity quantity 0 SUEZ PROTOPIA Suez Protopia DARDANELLES Dardanelles (WP) KOCAELI None None None None NaN 1 ADVANTAGE LOVE Advantage Love DARDANELLES Dardanelles (WP) TUAPSE Tuapse None None None NaN 2 AEGEAN NOBILITY Aegean Nobility BOSPHORUS Bosphorus JEDDAH Jeddah None None None NaN 3 AGIOS GERASIMOS Agios Gerasimos DARDANELLES Dardanelles (WP) NOVOROSSIYSK Novorossiysk None None None NaN 4 VELOS AMBER Velos Amber BOSPHORUS Bosphorus UST LUGA Ust-Luga None None None NaN <p>Let's start by fetching all tanker lineups received the last week</p> In\u00a0[15]: Copied! <pre>example_vessel_type = 1  # Tanker\nexample_date_from = datetime.utcnow() - timedelta(days=7)\n\nexample_scraped_lineups = api.get_lineups(\n    vessel_type=example_vessel_type,\n    received_date_from=example_date_from,\n)\n</pre> example_vessel_type = 1  # Tanker example_date_from = datetime.utcnow() - timedelta(days=7)  example_scraped_lineups = api.get_lineups(     vessel_type=example_vessel_type,     received_date_from=example_date_from, ) <p>The <code>is_deleted</code> property of a scraped lineup indicates whether it is valid or not. If it is set to <code>True</code>, the corresponding <code>lineup_id</code> has been replaced by a new one.</p> <p>For the sake of completeness, we will exclude deleted scraped lineups in the following examples.</p> In\u00a0[16]: Copied! <pre>example_scraped_lineups = [lineup for lineup in example_scraped_lineups if not lineup.is_deleted]\n\nnext(iter(example_scraped_lineups), None)\n</pre> example_scraped_lineups = [lineup for lineup in example_scraped_lineups if not lineup.is_deleted]  next(iter(example_scraped_lineups), None) Out[16]: <pre>ScrapedLineup(lineup_id=45726016, message_id=69455361, external_message_id=None, parsed_part_id=74607744, line_from=23, line_to=23, in_line_order=None, source='Email', updated_date=datetime.datetime(2024, 7, 26, 9, 28, 49, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 26, 9, 27, 55, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name='WHITE STAR', scraped_imo=None, scraped_deadweight=None, scraped_year_built=None, imo=-1, vessel_name=None, deadweight=None, year_built=None, liquid_capacity=None, vessel_type_id=-1, vessel_type='Unknown', vessel_class_id=-1, vessel_class='Unknown', commercial_operator_id=None, commercial_operator=None, scraped_eta='27/0200', eta=datetime.datetime(2024, 7, 27, 0, 0, tzinfo=datetime.timezone.utc), scraped_etb='TBC', etb=None, scraped_etd='TBC', etd=None, scraped_location='TARANTO', location_geo_id=3564, location_name='Taranto', location_taxonomy_id=2, location_taxonomy='Port', operation_type_id=1, operation_type='Load', scraped_quantity='5.5 KT', quantity=5500.0, quantity_unit='Tonnes', scraped_cargo_type='BITUMEN', cargo_type_id=18, cargo_type='Bitumen', cargo_group_id=130000, cargo_group='Dirty', scraped_api_gravity=None, api_gravity=None, scraped_origin=None, origin_geo_id=None, origin_name=None, origin_taxonomy_id=None, origin_taxonomy=None, scraped_destination='TBC', destination_geo_id=-1, destination_name=None, destination_taxonomy_id=-1, destination_taxonomy='Unknown', scraped_supplier=None, supplier_id=None, supplier=None, scraped_charterer=None, charterer_id=None, charterer=None, scraped_buyer=None, buyer_id=None, buyer=None, scraped_port_agent=None, port_agent_id=None, port_agent=None, vessel_status_id=1, vessel_status='Expected', content='\\tWHITE STAR\\tGIBILTERRA\\tENI\\t27/0200\\tTBC\\tTBC\\tLOADING\\tBITUMEN\\t5.5 KT\\tTBC\\t', subject='CAMBIASO RISSO - DAILY  PORT SITUATION', sender='Cambiaso Risso Group', is_private=True)</pre> <p>Now, we are ready to insert our data into a dataframe and keep only specific fields</p> In\u00a0[17]: Copied! <pre>example_columns = [\n    'imo',\n    'location_name',   \n    'operation_type',\n    'eta',\n    'quantity',\n    'is_deleted'\n]\n\ndata = pd.DataFrame(example_scraped_lineups, columns=example_columns).astype({'imo': 'Int64'})\n\ndata.head()\n</pre> example_columns = [     'imo',     'location_name',        'operation_type',     'eta',     'quantity',     'is_deleted' ]  data = pd.DataFrame(example_scraped_lineups, columns=example_columns).astype({'imo': 'Int64'})  data.head() Out[17]: imo location_name operation_type eta quantity is_deleted 0 -1 Taranto Load 2024-07-27 00:00:00+00:00 5500.0 False 1 -1 Raffineria Di Milazzo Load 2024-07-25 00:00:00+00:00 2000.0 False 2 -1 Raffineria Di Milazzo Discharge 2024-07-28 00:00:00+00:00 NaN False 3 9890549 Genoa Load 2024-07-23 00:00:00+00:00 12000.0 False 4 9538165 Genoa None 2024-07-23 00:00:00+00:00 30000.0 False <p>In this example, we will find the top 10 Ports, based on the number of distinct operations</p> In\u00a0[18]: Copied! <pre>top_ports = data[data.operation_type.notna()]\\\n    [['location_name', 'imo', 'operation_type']]\\\n    .drop_duplicates()\\\n    .location_name\\\n    .value_counts()\\\n    .head(10)\\\n    .index\\\n    .tolist()\n\ntop_ports_df = data[data.location_name.isin(top_ports)]\n\ntop_ports_pivot = pd.pivot_table(\n    top_ports_df,\n    index='location_name',\n    columns='operation_type',\n    values='imo',\n    aggfunc=lambda x: len(x.unique()),\n    fill_value=0,\n    dropna=False,\n).reset_index().rename_axis(None, axis=1)\n\ntop_ports_pivot.index = top_ports_pivot.location_name\n\ntop_ports_pivot  = top_ports_pivot.loc[top_ports].reset_index(drop=True)\ntop_ports_pivot\n</pre> top_ports = data[data.operation_type.notna()]\\     [['location_name', 'imo', 'operation_type']]\\     .drop_duplicates()\\     .location_name\\     .value_counts()\\     .head(10)\\     .index\\     .tolist()  top_ports_df = data[data.location_name.isin(top_ports)]  top_ports_pivot = pd.pivot_table(     top_ports_df,     index='location_name',     columns='operation_type',     values='imo',     aggfunc=lambda x: len(x.unique()),     fill_value=0,     dropna=False, ).reset_index().rename_axis(None, axis=1)  top_ports_pivot.index = top_ports_pivot.location_name  top_ports_pivot  = top_ports_pivot.loc[top_ports].reset_index(drop=True) top_ports_pivot Out[18]: location_name Discharge Load Unknown Waypoint 0 Sikka 30 22 0 0 1 Ceyhan 0 44 0 0 2 Hodeidah 36 1 0 0 3 Basrah 10 17 0 0 4 Aden 17 3 0 6 5 Sarroch 8 17 1 0 6 Mumbai 18 5 0 0 7 Vadinar 18 4 0 0 8 Dardanelles (WP) 0 0 0 20 9 Trieste 18 0 0 0 <p>And display results in a stacked bar plot</p> In\u00a0[19]: Copied! <pre>ports_list = top_ports_pivot.location_name.tolist()\n\ndisch_bar = 'Discharge' in top_ports_pivot and go.Bar(\n    name='Discharge',\n    x=ports_list,\n    y=top_ports_pivot.Discharge.tolist(),\n)\nload_bar = 'Load' in top_ports_pivot and go.Bar(\n    name='Load',\n    x=ports_list,\n    y=top_ports_pivot.Load.tolist(),\n)\nwaypoint_bar = 'Waypoint' in top_ports_pivot and go.Bar(\n    name='Waypoint',\n    x=ports_list,\n    y=top_ports_pivot.Waypoint.tolist(),\n)\nfig_data = list(filter(\n    lambda x: x,\n    [disch_bar, load_bar, waypoint_bar]\n))\n\nfig = go.Figure(data=fig_data)\n\nfig.update_layout(barmode='stack')\nfig.show()\n</pre> ports_list = top_ports_pivot.location_name.tolist()  disch_bar = 'Discharge' in top_ports_pivot and go.Bar(     name='Discharge',     x=ports_list,     y=top_ports_pivot.Discharge.tolist(), ) load_bar = 'Load' in top_ports_pivot and go.Bar(     name='Load',     x=ports_list,     y=top_ports_pivot.Load.tolist(), ) waypoint_bar = 'Waypoint' in top_ports_pivot and go.Bar(     name='Waypoint',     x=ports_list,     y=top_ports_pivot.Waypoint.tolist(), ) fig_data = list(filter(     lambda x: x,     [disch_bar, load_bar, waypoint_bar] ))  fig = go.Figure(data=fig_data)  fig.update_layout(barmode='stack') fig.show() <p>In this example, we will create a visualization, for the total cargo quantity discharging in specifc ports per day over the next week</p> In\u00a0[20]: Copied! <pre>ports = data[data.operation_type == 'Discharge'][['imo', 'location_name']]\\\n    .drop_duplicates()\\\n    .location_name\\\n    .value_counts()\\\n    .head()\\\n    .index\\\n    .tolist()\n\nthis_week_days = pd.date_range(start=datetime.utcnow().date(), freq='D', periods=7, tz='UTC')\n\nports\n</pre> ports = data[data.operation_type == 'Discharge'][['imo', 'location_name']]\\     .drop_duplicates()\\     .location_name\\     .value_counts()\\     .head()\\     .index\\     .tolist()  this_week_days = pd.date_range(start=datetime.utcnow().date(), freq='D', periods=7, tz='UTC')  ports Out[20]: <pre>['Hodeidah', 'Sikka', 'Trieste', 'Mumbai', 'Vadinar']</pre> <p>Create the pivot table</p> In\u00a0[21]: Copied! <pre>exports_mask = data.location_name.isin(ports) &amp; (data.operation_type == 'Discharge')\n\ndf_exports = data[exports_mask][['eta', 'location_name', 'quantity', 'imo']].drop_duplicates()\n\ndf_pivot = pd\\\n    .pivot_table(\n        df_exports,\n        columns='location_name',\n        index='eta',\n        values='quantity',\n        aggfunc=sum,\n        fill_value=0,\n    )\\\n    .reindex(index=this_week_days, fill_value=0)\\\n    .reset_index()\\\n    .rename(columns={'index': 'eta'})\\\n    .rename_axis(None, axis=1)\n\ndf_pivot\n</pre> exports_mask = data.location_name.isin(ports) &amp; (data.operation_type == 'Discharge')  df_exports = data[exports_mask][['eta', 'location_name', 'quantity', 'imo']].drop_duplicates()  df_pivot = pd\\     .pivot_table(         df_exports,         columns='location_name',         index='eta',         values='quantity',         aggfunc=sum,         fill_value=0,     )\\     .reindex(index=this_week_days, fill_value=0)\\     .reset_index()\\     .rename(columns={'index': 'eta'})\\     .rename_axis(None, axis=1)  df_pivot Out[21]: eta Hodeidah Mumbai Sikka Trieste Vadinar 0 2024-08-02 00:00:00+00:00 0 11700 153000 209932 278000 1 2024-08-03 00:00:00+00:00 0 0 532302 264951 1015201 2 2024-08-04 00:00:00+00:00 0 0 332308 187887 0 3 2024-08-05 00:00:00+00:00 0 0 100000 425414 0 4 2024-08-06 00:00:00+00:00 0 29000 0 137357 0 5 2024-08-07 00:00:00+00:00 0 0 200000 0 0 6 2024-08-08 00:00:00+00:00 0 0 0 0 0 <p>And display the results as timeseries</p> In\u00a0[22]: Copied! <pre>def port_button(port):\n    args = [\n        {'visible': [i == ports.index(port) for i in range(len(ports))]},\n        {\n            'title': f'Exported quantity in {port} per day',\n            'showlegend': True\n        },\n    ]\n    \n    return dict(\n        label=port,\n        method='update',\n        args=args,\n    )\n\ntitle = 'Exported quantity per day'\ntoday = datetime.combine(datetime.utcnow().date(), datetime.min.time())\n\nports_fig = go.Figure()\n\nport_buttons = []\n\nfor port in ports:\n    if port not in df_pivot.columns:\n        continue\n    port_scatter_plot = go.Scatter(    \n        x=df_pivot.eta,\n        y=df_pivot[port],\n        name=port,\n        mode='lines',\n    )\n\n    ports_fig.add_trace(port_scatter_plot)\n    \n    port_buttons.append(port_button(port))\n    \nbuttons = list([\n    dict(\n        label='All',\n        method='update',\n        args=[    \n            {'visible': [True for _ in range(len(ports))]},\n            {\n                'title': title,\n                'showlegend': True\n            }\n        ],\n    ),\n    *port_buttons,\n])\n\nports_fig.update_layout(\n    title=title,\n    updatemenus=[go.layout.Updatemenu(\n        active=0,\n        buttons=buttons,\n    )],\n    xaxis_range=[today - timedelta(hours=4), today + timedelta(hours=24*6 + 4)],\n)\n\nports_fig.show()\n</pre> def port_button(port):     args = [         {'visible': [i == ports.index(port) for i in range(len(ports))]},         {             'title': f'Exported quantity in {port} per day',             'showlegend': True         },     ]          return dict(         label=port,         method='update',         args=args,     )  title = 'Exported quantity per day' today = datetime.combine(datetime.utcnow().date(), datetime.min.time())  ports_fig = go.Figure()  port_buttons = []  for port in ports:     if port not in df_pivot.columns:         continue     port_scatter_plot = go.Scatter(             x=df_pivot.eta,         y=df_pivot[port],         name=port,         mode='lines',     )      ports_fig.add_trace(port_scatter_plot)          port_buttons.append(port_button(port))      buttons = list([     dict(         label='All',         method='update',         args=[                 {'visible': [True for _ in range(len(ports))]},             {                 'title': title,                 'showlegend': True             }         ],     ),     *port_buttons, ])  ports_fig.update_layout(     title=title,     updatemenus=[go.layout.Updatemenu(         active=0,         buttons=buttons,     )],     xaxis_range=[today - timedelta(hours=4), today + timedelta(hours=24*6 + 4)], )  ports_fig.show() In\u00a0[23]: Copied! <pre>output_path = '' # Change output_path with your path\nfilename = 'last_week_lineups.csv'\nif not data.empty:\n    data.to_csv(output_path+filename, index=False)\n</pre> output_path = '' # Change output_path with your path filename = 'last_week_lineups.csv' if not data.empty:     data.to_csv(output_path+filename, index=False) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#scraped-lineups-api-example","title":"Scraped Lineups API Example\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#scraped-lineups-api","title":"Scraped Lineups API\u00b6","text":"<p>The goal of Scraped Lineups API is to collect and return scraped lineups by the given filters. This can be done by using the <code>ScrapedLineupsAPI</code> class and calling appropriate methods</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#1-request-by-filters","title":"1. Request by filters\u00b6","text":"<p>Lineups can be retrieved for specific filters, by calling the <code>get_lineups</code> method with the following arguments:</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>vessel_type</code> The vessel type</p> <p>Additionally, at least one of the following is required</p> <p><code>lineup_ids</code> List of LineupIDs</p> <p><code>imos</code> List of IMOs</p> <p><code>message_ids</code> List of MessageIDs</p> <p><code>external_message_ids</code> List of ExternalMessageIDs</p> <p><code>received_date_from</code> Earliest date the lineup received</p> <p><code>received_date_to</code> Latest date the lineup received</p> <p><code>updated_date_from</code> Earliest date the lineup updated</p> <p><code>updated_date_to</code> Latest date the lineup updated</p> <p>Mixing received and updated dates is not allowed</p> <p>It's highly recommended to use UTC  dates, since this is the internally used format</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#2-request-by-page-token","title":"2. Request by page token\u00b6","text":"<p>Lineups can also be retrieved, by calling the <code>get_lineups_incremental</code> method. This method will also return <code>next_request_token</code>, which the user should use to their next incremental request to retrieve only the latest updated cargoes.</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>vessel_type</code> The vessel type</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#optional","title":"Optional\u00b6","text":"<p><code>page_token</code> The key that should be used as a parameter of the token to retrieve the relevant page.</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#3-retrieve-page-token","title":"3. Retrieve page token\u00b6","text":"<p>The token referenced above can be retrieved for a specific date, by calling the <code>get_lineups_incremental_token</code> method with the following argument:</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>updated_date_from</code> Earliest date the lineup updated</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#additional-optional-arguments","title":"Additional optional arguments\u00b6","text":"<p>Methods <code>get_lineups</code> and <code>get_lineups_incremental</code> also accept the following optional arguments:</p> <p><code>include_details</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>parsed_part_id, line_from, line_to, in_line_order, source\n</code></pre> <p><code>include_scraped_fields</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>scraped_vessel_name, scraped_imo, scraped_deadweight, scraped_year_built, scraped_eta, scraped_etb, scraped_etd, scraped_location, scraped_quantity, scraped_cargo_type, scraped_api_gravity, scraped_origin, scraped_destination, scraped_supplier, scraped_charterer, scraped_buyer, scraped_port_agent\n</code></pre> <p><code>include_vessel_details</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>vessel_name, deadweight, year_built, liquid_capacity, vessel_type_id, vessel_type, vessel_class, commercial_operator_id, commercial_operator\n</code></pre> <p><code>include_labels</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>location_name, location_taxonomy, operation_type, cargo_type, cargo_group, origin_name, origin_taxonomy, destination_name, destination_taxonomy, supplier, charterer, buyer, port_agent, vessel_status\n</code></pre> <p><code>include_content</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>content, subject\n</code></pre> <p><code>include_sender</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>sender\n</code></pre> <p><code>include_debug_info</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>is_private\n</code></pre> <p>Default value is <code>True</code> for the arguments described above</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#installation","title":"Installation\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#quickstart","title":"Quickstart\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#request-by-date","title":"Request by date\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#request-by-imos","title":"Request by IMOs\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#request-by-message-or-externalmessage-ids","title":"Request by Message or ExternalMessage IDs\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#request-by-lineup-ids","title":"Request by Lineup IDs\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#retrieve-incremental-token","title":"Retrieve incremental token\u00b6","text":"<p>The <code>get_lineups_incremental_token</code> allows retrieval of <code>page_token</code> by adding the <code>updated_date_from</code> value. This <code>page_token</code> can be used as a variable to the <code>get_lineups_incremental</code> method, in order to retrieve only new or updated lineups.</p>"},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#request-by-page-token","title":"Request by page token\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#usage-of-optional-arguments","title":"Usage of optional arguments\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#examples","title":"Examples\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#exclude-deleted-scraped-lineups","title":"Exclude deleted scraped lineups\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#top-10-ports","title":"Top 10 Ports\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#imported-quantity-in-specific-ports","title":"Imported quantity in specific ports\u00b6","text":""},{"location":"examples/jupyter/ScrapedLineupsAPI/Scraped%20Lineups%20API%20Example/#export-data-to-csv","title":"Export data to csv\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/","title":"Scraped Positions API Example","text":"<p>Get your personal Signal Ocean API subscription key (acquired here) and replace it below:</p> In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' # Replace with your subscription key\n</pre> signal_ocean_api_key = '' # Replace with your subscription key <p>To install Signal Ocean SDK, simply run the following command</p> In\u00a0[2]: Copied! <pre>%%capture\n%pip install signal-ocean\n</pre> %%capture %pip install signal-ocean <p>Import <code>signal-ocean</code> and other modules required for this demo</p> In\u00a0[3]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.scraped_positions import ScrapedPositionsAPI\n\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport plotly.graph_objects as go\n</pre> from signal_ocean import Connection from signal_ocean.scraped_positions import ScrapedPositionsAPI  from datetime import datetime, timedelta import pandas as pd import plotly.graph_objects as go <p>Create a new instance of the <code>ScrapedPositionsAPI</code> class</p> In\u00a0[4]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = ScrapedPositionsAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = ScrapedPositionsAPI(connection) <p>Now you are ready to retrieve your data</p> <p>To get all tanker positions received the last 4 days, you must declare appropriate <code>vessel_type</code> and <code>received_date_from</code> variables</p> In\u00a0[5]: Copied! <pre>vessel_type = 1  # Tanker\nreceived_date_from = datetime.utcnow() - timedelta(days=4)\n</pre> vessel_type = 1  # Tanker received_date_from = datetime.utcnow() - timedelta(days=4) <p>And then call <code>get_positions</code> method, as below</p> In\u00a0[6]: Copied! <pre>scraped_positions = api.get_positions(\n    vessel_type=vessel_type,\n    received_date_from=received_date_from,\n)\n\nnext(iter(scraped_positions), None)\n</pre> scraped_positions = api.get_positions(     vessel_type=vessel_type,     received_date_from=received_date_from, )  next(iter(scraped_positions), None) Out[6]: <pre>ScrapedPosition(position_id=280995305, message_id=69566610, external_message_id=None, parsed_part_id=74684036, line_from=5, line_to=5, source='Email', updated_date=datetime.datetime(2024, 7, 29, 8, 58, 8, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 29, 8, 56, 1, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name='BLUE SKY I', scraped_deadweight='38402mts', scraped_year_built=None, imo=9335903, vessel_name='Blue Sky I', deadweight=38402, year_built=2006, liquid_capacity=43744, vessel_type_id=1, vessel_type='Tanker', vessel_class_id=89, vessel_class='MR1', scraped_open_date='05/Aug', open_date_from=datetime.datetime(2024, 8, 5, 0, 0, tzinfo=datetime.timezone.utc), open_date_to=datetime.datetime(2024, 8, 5, 0, 0, tzinfo=datetime.timezone.utc), scraped_open_port='Chittagong', open_geo_id=3215, open_name='Chittagong', open_taxonomy_id=2, open_taxonomy='Port', scraped_commercial_operator=None, commercial_operator_id=None, commercial_operator=None, scraped_cargo_type=None, cargo_type_id=None, cargo_type=None, cargo_type_group_id=None, cargo_type_group=None, scraped_last_cargo_types=None, last_cargo_types_ids=None, last_cargo_types=None, has_ballast=False, has_dry_dock=False, has_if=False, has_on_hold=False, has_on_subs=False, has_prompt=False, has_uncertain=False, is_position_list=True, content='Vessel: M/T BLUE SKY I dwt 38402mts open  Chittagong 05/Aug', subject='Harper Petersen Albis - Special Vessel Position - MT BLUE SKY I', sender='harperpetersen.com', is_private=True)</pre> <p>For better visualization, it's convenient to insert data into a DataFrame</p> In\u00a0[7]: Copied! <pre>df = pd.DataFrame(scraped_positions)\n\ndf.head()\n</pre> df = pd.DataFrame(scraped_positions)  df.head() Out[7]: position_id message_id external_message_id parsed_part_id line_from line_to source updated_date received_date is_deleted ... has_if has_on_hold has_on_subs has_prompt has_uncertain is_position_list content subject sender is_private 0 280995305 69566610 None 74684036 5 5 Email 2024-07-29 08:58:08+00:00 2024-07-29 08:56:01+00:00 False ... False False False False False True Vessel: M/T BLUE SKY I dwt 38402mts open  Chit... Harper Petersen Albis - Special Vessel Positio... harperpetersen.com True 1 280996508 69568756 None 74685478 99 99 Email 2024-07-29 09:08:29+00:00 2024-07-29 09:07:57+00:00 False ... False False False False False False grand winner 5 50 52 21 mackay 09/08 pan ocean... BRS CPP MR LIST BSS YOSU - 29/07/24 BRS Group True 2 280996509 69568756 None 74685478 21 21 Email 2024-07-29 09:08:29+00:00 2024-07-29 09:07:57+00:00 False ... False False True False False False grand winner 2 49 52 21 mackay 22/07 pan ocean... BRS CPP MR LIST BSS YOSU - 29/07/24 BRS Group True 3 280996510 69568756 None 74685478 110 110 Email 2024-07-29 09:08:29+00:00 2024-07-29 09:07:57+00:00 False ... False False False False False False grand winner 3 49 52 21 tauranga 08/08 pan oce... BRS CPP MR LIST BSS YOSU - 29/07/24 BRS Group True 4 280996511 69568756 None 74685478 75 75 Email 2024-07-29 09:08:29+00:00 2024-07-29 09:07:57+00:00 False ... False False False False False False nomiki 44 42 02 pulau laut 05/08 unknown go - ... BRS CPP MR LIST BSS YOSU - 29/07/24 BRS Group True <p>5 rows \u00d7 54 columns</p> <p>To get positions for specific vessel(s) by their IMO number(s), you can simple call the <code>get_positions</code> method for a list of desired IMO(s)</p> <p>Adding some date argument is always feasible</p> In\u00a0[8]: Copied! <pre>imos = [9321720,9385192,9325049,9406013,9645437]  # Or add a list of your desired IMOs\n\nscraped_positions_by_imos = api.get_positions(\n    vessel_type=vessel_type,\n    received_date_from=received_date_from,\n    imos=imos,\n)\n\ndf_by_imos = pd.DataFrame(scraped_positions_by_imos)\ndf_by_imos.head()\n</pre> imos = [9321720,9385192,9325049,9406013,9645437]  # Or add a list of your desired IMOs  scraped_positions_by_imos = api.get_positions(     vessel_type=vessel_type,     received_date_from=received_date_from,     imos=imos, )  df_by_imos = pd.DataFrame(scraped_positions_by_imos) df_by_imos.head() Out[8]: position_id message_id external_message_id parsed_part_id line_from line_to source updated_date received_date is_deleted ... has_if has_on_hold has_on_subs has_prompt has_uncertain is_position_list content subject sender is_private 0 281075434 69600287 None 74706024 10 10 Email 2024-07-29 12:55:06+00:00 2024-07-29 12:54:33+00:00 False ... False False False False False False 30/07 aegean vision arcadia 158 17 dty 29/07 a... SIDI KERIR SUEZMAX POSITIONS LIST  29TH JUL  2024 Bravo Tankers True 1 281075440 69600287 None 74706024 42 42 Email 2024-07-29 12:55:06+00:00 2024-07-29 12:54:33+00:00 False ... False False False False False False 09/08 pinnacle spirit teekay 159 08 dty 29/07 ... SIDI KERIR SUEZMAX POSITIONS LIST  29TH JUL  2024 Bravo Tankers True 2 281139185 69611578 None 74714401 56 56 Email 2024-07-29 15:01:49+00:00 2024-07-29 14:59:22+00:00 False ... False False False False False False 14-aug pinnacle spirit 160 08 wilhelmshaven 29... GALBRAITHS SUEZMAX LIST BASIS USG Ifchor Galbraiths True 3 281139194 69611578 None 74714401 7 7 Email 2024-07-29 15:01:49+00:00 2024-07-29 14:59:22+00:00 False ... True False False False False False 2-aug cape benat 157 10 houston 2-aug maersk proj GALBRAITHS SUEZMAX LIST BASIS USG Ifchor Galbraiths True 4 281161463 69615532 None 74717700 69 69 Email 2024-07-29 16:03:05+00:00 2024-07-29 16:00:47+00:00 False ... False False False False False False 16-aug pinnacle spirit 159 08 wilhelmshaven 29... MJLF USG SUEZMAX POSITIONS MJLF False <p>5 rows \u00d7 54 columns</p> <p>To retrieve positions for particular message ID(s), you should include an extra parameter called <code>message_ids</code> when using the <code>get_positions</code> method. This parameter should contain a list of message IDs. For instance,</p> In\u00a0[9]: Copied! <pre>message_ids = [47238320,47244008,47244573,69350262,69348062]\nscraped_positions_by_message_ids = api.get_positions(\n    vessel_type=vessel_type,\n    message_ids=message_ids,\n)\n\nnext(iter(scraped_positions_by_message_ids), None)\n</pre> message_ids = [47238320,47244008,47244573,69350262,69348062] scraped_positions_by_message_ids = api.get_positions(     vessel_type=vessel_type,     message_ids=message_ids, )  next(iter(scraped_positions_by_message_ids), None) Out[9]: <pre>ScrapedPosition(position_id=231186063, message_id=47238320, external_message_id=None, parsed_part_id=58295114, line_from=75, line_to=75, source='Email', updated_date=datetime.datetime(2023, 9, 11, 13, 40, 25, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2023, 9, 11, 13, 36, 39, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name='t.kurucesme', scraped_deadweight='105', scraped_year_built='15', imo=9692478, vessel_name='T. Kurucesme', deadweight=105171, year_built=2015, liquid_capacity=116922, vessel_type_id=1, vessel_type='Tanker', vessel_class_id=86, vessel_class='Aframax', scraped_open_date='28/09', open_date_from=datetime.datetime(2023, 9, 28, 0, 0, tzinfo=datetime.timezone.utc), open_date_to=datetime.datetime(2023, 9, 28, 0, 0, tzinfo=datetime.timezone.utc), scraped_open_port='milazzo', open_geo_id=3557, open_name='Milazzo', open_taxonomy_id=2, open_taxonomy='Port', scraped_commercial_operator='ditas', commercial_operator_id=412, commercial_operator='Ditas Deniz', scraped_cargo_type=None, cargo_type_id=None, cargo_type=None, cargo_type_group_id=None, cargo_type_group=None, scraped_last_cargo_types=None, last_cargo_types_ids=None, last_cargo_types=None, has_ballast=False, has_dry_dock=False, has_if=True, has_on_hold=False, has_on_subs=False, has_prompt=False, has_uncertain=False, is_position_list=False, content='t.kurucesme ditas 105 15 milazzo 28/09 2 prjctng x usg', subject='aframax med-blsea and ukc-balt position list(s) ...', sender='Banchero &amp; Costa', is_private=False)</pre> <p>You can achieve a similar result for external message IDs by providing an argument called <code>external_message_ids</code>.</p> <p>In the same manner, to get data for specific position ID(s), you must call the <code>get_positions</code> method for a list of desired position ID(s)</p> <p>Date arguments are not available in this method</p> In\u00a0[10]: Copied! <pre>position_ids = [182459667,182459702,182624943,182624998,182508037]  # Or add a list of your desired position IDs\n\nscraped_positions_by_ids = api.get_positions(\n    vessel_type=vessel_type,\n    position_ids=position_ids,\n)\n\ndf_by_ids = pd.DataFrame(scraped_positions_by_ids)\ndf_by_ids.head()\n</pre> position_ids = [182459667,182459702,182624943,182624998,182508037]  # Or add a list of your desired position IDs  scraped_positions_by_ids = api.get_positions(     vessel_type=vessel_type,     position_ids=position_ids, )  df_by_ids = pd.DataFrame(scraped_positions_by_ids) df_by_ids.head() Out[10]: position_id message_id external_message_id parsed_part_id line_from line_to source updated_date received_date is_deleted ... has_if has_on_hold has_on_subs has_prompt has_uncertain is_position_list content subject sender is_private 0 182459667 30791168 None 45785098 21 21 Email 2022-11-17 11:57:58+00:00 2022-11-17 11:54:41+00:00 False ... False False False False False False 20/11 SEASHARK  32  178 37,947  11.00 GER 04  ... SIMPSON|SPENCE|YOUNG LTD \u2013 HANDY LIST (BASIS M... SSY False 1 182459702 30791168 None 45785098 59 59 Email 2022-11-17 11:57:58+00:00 2022-11-17 11:54:41+00:00 False ... False False False False False False 27/11 MOUNT OLYMPUS  40  182 42,241  11.97 MAR... SIMPSON|SPENCE|YOUNG LTD \u2013 HANDY LIST (BASIS M... SSY False 2 182508037 30800115 None 45793950 27 27 Email 2022-11-17 15:27:04+00:00 2022-11-17 15:23:16+00:00 False ... False False False False False False ardmore exporter 49 52 14 yabucoa 19/11 ardmor... MJLF MR LIST BSS HOUSTON NOV 17 MJLF False 3 182624943 30849799 None 45839901 88 88 Email 2022-11-18 16:58:54+00:00 2022-11-18 16:55:19+00:00 False ... False False False False False False 14-dec advantage spice 156 10 48.1 rotterdam 2... MJLF USG SUEZMAX POSITIONS MJLF False 4 182624998 30849799 None 45839901 12 12 Email 2022-11-18 16:58:54+00:00 2022-11-18 16:55:19+00:00 False ... True False False False False False 26-nov proj eagle san pedro 157 12 49.0 off ga... MJLF USG SUEZMAX POSITIONS MJLF False <p>5 rows \u00d7 54 columns</p> <p>For instance, to retrieve the relevant page token for last 3 days' data, you must call the <code>get_positions_incremental_token</code>, as below</p> In\u00a0[11]: Copied! <pre>updated_date_from = datetime.utcnow() - timedelta(days=3)\npage_token = api.get_positions_incremental_token(\n    updated_date_from=updated_date_from,\n)\n\npage_token\n</pre> updated_date_from = datetime.utcnow() - timedelta(days=3) page_token = api.get_positions_incremental_token(     updated_date_from=updated_date_from, )  page_token Out[11]: <pre>'MjAyNC0wNy0zMFQwODo1MDoxOC4wMDBa'</pre> <p>If the <code>page_token</code> parameter is not specified, the <code>get_positions_incremental</code> method will retrieve all positions. You can call the <code>get_positions_incremental</code> method, as below</p> In\u00a0[12]: Copied! <pre>scraped_positions_incremental = api.get_positions_incremental(\n    vessel_type=vessel_type,\n    page_token=page_token,\n)\n\ndf_by_ids = pd.DataFrame(scraped_positions_incremental.data)\ndf_by_ids.head()\n</pre> scraped_positions_incremental = api.get_positions_incremental(     vessel_type=vessel_type,     page_token=page_token, )  df_by_ids = pd.DataFrame(scraped_positions_incremental.data) df_by_ids.head() Out[12]: position_id message_id external_message_id parsed_part_id line_from line_to source updated_date received_date is_deleted ... has_if has_on_hold has_on_subs has_prompt has_uncertain is_position_list content subject sender is_private 0 281297965 69693869 None 74767967.0 43.0 43.0 Email 2024-07-30 09:15:14+00:00 2024-07-30 09:12:43+00:00 False ... True False False False False False 15/08 ncc danah 46 183 52590 12.17 sau 11 gibr... SSY \u2013 MR LIST (BASIS MALTA) \u2013 TUESDAY 30TH JUL... SSY False 1 281297976 69693869 None 74767967.0 45.0 45.0 Email 2024-07-30 09:15:14+00:00 2024-07-30 09:12:43+00:00 False ... False False False False False False 20/08 uog constantine g 50 183 53879 13.14 lib... SSY \u2013 MR LIST (BASIS MALTA) \u2013 TUESDAY 30TH JUL... SSY False 2 281297977 69693869 None 74767967.0 40.0 40.0 Email 2024-07-30 09:15:14+00:00 2024-07-30 09:12:43+00:00 False ... False False False False True False 14/08 arvin 47 183 53184 12.22 lib 08 gaeta 13... SSY \u2013 MR LIST (BASIS MALTA) \u2013 TUESDAY 30TH JUL... SSY False 3 281297978 69693869 None 74767967.0 39.0 39.0 Email 2024-07-30 09:15:14+00:00 2024-07-30 09:12:43+00:00 False ... False False False False True False 14/08 hakata princess 50 183 56949 13.10 pan 1... SSY \u2013 MR LIST (BASIS MALTA) \u2013 TUESDAY 30TH JUL... SSY False 4 281297979 69693869 None 74767967.0 32.0 32.0 Email 2024-07-30 09:15:14+00:00 2024-07-30 09:12:43+00:00 False ... False False False False False False 11/08 avax 50 183 53658 13.32 mar 23 gibraltar... SSY \u2013 MR LIST (BASIS MALTA) \u2013 TUESDAY 30TH JUL... SSY False <p>5 rows \u00d7 54 columns</p> <p>Also, the <code>get_positions_incremental</code> method will retrieve the <code>next_request_token</code>, which should be used as the <code>page_token</code> for the next incremental call and retrieve only new or updated positions.</p> In\u00a0[13]: Copied! <pre>next_request_token = scraped_positions_incremental.next_request_token\n\nnext_request_token\n</pre> next_request_token = scraped_positions_incremental.next_request_token  next_request_token Out[13]: <pre>'MjAyNC0wOC0wMlQwODo1MDoxOC45MDha'</pre> <p>By default, all fields are returned. In many cases, it is convenient to select specific columns. For example, if we want to compare scraped and mapped fields</p> In\u00a0[14]: Copied! <pre>scraped_mapped_columns = [\n    'scraped_vessel_name',\n    'vessel_name',\n    'scraped_deadweight',\n    'deadweight',\n    'scraped_commercial_operator',\n    'commercial_operator',\n    'scraped_open_port',\n    'open_name',\n]\n\nscraped_mapped_df = pd.DataFrame(scraped_positions, columns=scraped_mapped_columns)\n\nscraped_mapped_df.head()\n</pre> scraped_mapped_columns = [     'scraped_vessel_name',     'vessel_name',     'scraped_deadweight',     'deadweight',     'scraped_commercial_operator',     'commercial_operator',     'scraped_open_port',     'open_name', ]  scraped_mapped_df = pd.DataFrame(scraped_positions, columns=scraped_mapped_columns)  scraped_mapped_df.head() Out[14]: scraped_vessel_name vessel_name scraped_deadweight deadweight scraped_commercial_operator commercial_operator scraped_open_port open_name 0 BLUE SKY I Blue Sky I 38402mts 38402.0 None None Chittagong Chittagong 1 grand winner None 50 NaN pan ocean Pan Ocean mackay Mackay 2 grand winner None 49 NaN pan ocean Pan Ocean mackay Mackay 3 grand winner None 49 NaN pan ocean Pan Ocean tauranga Tauranga 4 nomiki Nomiki 44 44485.0 unknown None pulau laut Tanjung Pemancingan <p>Let's start by fetching all tanker positions received the last week</p> In\u00a0[15]: Copied! <pre>example_vessel_type = 1  # Tanker\nexample_date_from = datetime.utcnow() - timedelta(days=7)\n\nexample_scraped_positions = api.get_positions(\n   vessel_type=example_vessel_type,\n   received_date_from=example_date_from,\n)\n</pre> example_vessel_type = 1  # Tanker example_date_from = datetime.utcnow() - timedelta(days=7)  example_scraped_positions = api.get_positions(    vessel_type=example_vessel_type,    received_date_from=example_date_from, ) <p>The <code>is_deleted</code> property of a scraped position indicates whether it is valid or not. If it is set to <code>True</code>, the corresponding <code>position_id</code> has been replaced by a new one.</p> <p>For the sake of completeness, we will exclude deleted scraped positions in the following examples.</p> In\u00a0[16]: Copied! <pre>example_scraped_positions = [position for position in example_scraped_positions if not position.is_deleted]\n\nnext(iter(example_scraped_positions), None)\n</pre> example_scraped_positions = [position for position in example_scraped_positions if not position.is_deleted]  next(iter(example_scraped_positions), None) Out[16]: <pre>ScrapedPosition(position_id=280874923, message_id=69455617, external_message_id=None, parsed_part_id=74607938, line_from=21, line_to=21, source='Email', updated_date=datetime.datetime(2024, 7, 26, 9, 30, 24, tzinfo=datetime.timezone.utc), received_date=datetime.datetime(2024, 7, 26, 9, 29, 39, tzinfo=datetime.timezone.utc), is_deleted=False, low_confidence=False, scraped_vessel_name='british sailor', scraped_deadweight='45', scraped_year_built='16', imo=9724673, vessel_name='British Sailor', deadweight=45999, year_built=2016, liquid_capacity=53838, vessel_type_id=1, vessel_type='Tanker', vessel_class_id=88, vessel_class='MR2', scraped_open_date='01/08', open_date_from=datetime.datetime(2024, 8, 1, 0, 0, tzinfo=datetime.timezone.utc), open_date_to=datetime.datetime(2024, 8, 1, 0, 0, tzinfo=datetime.timezone.utc), scraped_open_port='lagos', open_geo_id=3683, open_name='Lagos', open_taxonomy_id=2, open_taxonomy='Port', scraped_commercial_operator=None, commercial_operator_id=None, commercial_operator=None, scraped_cargo_type=None, cargo_type_id=None, cargo_type=None, cargo_type_group_id=None, cargo_type_group=None, scraped_last_cargo_types=None, last_cargo_types_ids=None, last_cargo_types=None, has_ballast=False, has_dry_dock=False, has_if=False, has_on_hold=False, has_on_subs=False, has_prompt=False, has_uncertain=False, is_position_list=False, content='british sailor 45 53 16 12.32 183.06 3 bp lagos 01/08 waiting to berth', subject='WAFR HANDY/MR LIST BSS LAGOS', sender='BRS Group', is_private=True)</pre> <p>Now, we are ready to insert our data into a dataframe and keep only specific fields</p> In\u00a0[17]: Copied! <pre>example_columns = [\n    'imo',\n    'commercial_operator',\n    'open_date_to',\n    'open_name',\n    'is_deleted',\n]\n\ndata = pd.DataFrame(example_scraped_positions, columns=example_columns).astype({'imo': 'Int64'})\n\ndata.head()\n</pre> example_columns = [     'imo',     'commercial_operator',     'open_date_to',     'open_name',     'is_deleted', ]  data = pd.DataFrame(example_scraped_positions, columns=example_columns).astype({'imo': 'Int64'})  data.head() Out[17]: imo commercial_operator open_date_to open_name is_deleted 0 9724673 None 2024-08-01 00:00:00+00:00 Lagos False 1 9682394 Vitol 2024-08-01 00:00:00+00:00 Walvis Bay False 2 9465966 Torm 2024-08-04 00:00:00+00:00 Lome False 3 9637076 Ardmore Shipping 2024-08-02 00:00:00+00:00 West Africa False 4 9455741 Tankerska Plovidba 2024-08-01 00:00:00+00:00 Limboh False <p>In this example, we will find the top 10 Commercial Operators, based on the number of their vessels opening</p> In\u00a0[18]: Copied! <pre>top_co_ser = data[['commercial_operator', 'imo']].drop_duplicates().commercial_operator.value_counts().head(10)\n\ntop_co_df = top_co_ser.to_frame(name='VesselCount').reset_index().rename(columns={'index': 'CommercialOperator'})\n\ntop_co_df\n</pre> top_co_ser = data[['commercial_operator', 'imo']].drop_duplicates().commercial_operator.value_counts().head(10)  top_co_df = top_co_ser.to_frame(name='VesselCount').reset_index().rename(columns={'index': 'CommercialOperator'})  top_co_df Out[18]: commercial_operator VesselCount 0 Trafigura 107 1 Hafnia 93 2 Shell 78 3 Maersk 74 4 Torm 70 5 Vitol 66 6 Scorpio Commercial Management 64 7 Norden 58 8 Clearlake Shipping 56 9 Norden Tanker Pool 53 <p>And display results in a bar plot</p> In\u00a0[19]: Copied! <pre>top_co_fig = go.Figure()\n\nbar = go.Bar(\n    x=top_co_df.commercial_operator.tolist(),\n    y=top_co_df.VesselCount.tolist(),\n)\n\ntop_co_fig.add_trace(bar)\ntop_co_fig.update_xaxes(title_text=\"Commercial Operator\")\ntop_co_fig.update_yaxes(title_text=\"Number of Vessels opening\")\ntop_co_fig.show()\n</pre> top_co_fig = go.Figure()  bar = go.Bar(     x=top_co_df.commercial_operator.tolist(),     y=top_co_df.VesselCount.tolist(), )  top_co_fig.add_trace(bar) top_co_fig.update_xaxes(title_text=\"Commercial Operator\") top_co_fig.update_yaxes(title_text=\"Number of Vessels opening\") top_co_fig.show() <p>In this example, we will create a visualization, for the number of distinct vessels opening at specific ports per day over the next week</p> In\u00a0[20]: Copied! <pre>this_week_days = pd.date_range(start=datetime.utcnow().date(), freq='D', periods=7, tz='UTC')\nports = data[data.open_name.notna()].open_name.value_counts().head().index.tolist()\n\nports\n</pre> this_week_days = pd.date_range(start=datetime.utcnow().date(), freq='D', periods=7, tz='UTC') ports = data[data.open_name.notna()].open_name.value_counts().head().index.tolist()  ports Out[20]: <pre>['Singapore', 'US Gulf', 'New York', 'Fujairah', 'Rotterdam']</pre> <p>Create the pivot table</p> In\u00a0[21]: Copied! <pre>ports_mask = data.open_name.isin(ports) &amp; data.open_date_to.isin(this_week_days)\n\ndf_ports = data[ports_mask]\n\ndf_pivot = pd.pivot_table(\n    df_ports,\n    columns='open_name',\n    index='open_date_to',\n    values='imo',\n    aggfunc=pd.Series.nunique,\n    fill_value=0,\n).reindex(index=this_week_days, fill_value=0).reset_index().rename(columns={'index': 'open_date_to'})\n\ndf_pivot\n</pre> ports_mask = data.open_name.isin(ports) &amp; data.open_date_to.isin(this_week_days)  df_ports = data[ports_mask]  df_pivot = pd.pivot_table(     df_ports,     columns='open_name',     index='open_date_to',     values='imo',     aggfunc=pd.Series.nunique,     fill_value=0, ).reindex(index=this_week_days, fill_value=0).reset_index().rename(columns={'index': 'open_date_to'})  df_pivot Out[21]: open_name open_date_to Fujairah New York Rotterdam Singapore US Gulf 0 2024-08-02 00:00:00+00:00 23 13 10 33 17 1 2024-08-03 00:00:00+00:00 20 8 8 24 12 2 2024-08-04 00:00:00+00:00 12 3 9 17 14 3 2024-08-05 00:00:00+00:00 11 4 7 21 11 4 2024-08-06 00:00:00+00:00 10 4 5 22 7 5 2024-08-07 00:00:00+00:00 6 7 6 19 3 6 2024-08-08 00:00:00+00:00 8 3 5 25 3 <p>And display the results as timeseries</p> In\u00a0[22]: Copied! <pre>def port_button(port):\n    args = [\n        {'visible': [i == ports.index(port) for i in range(len(ports))]},\n        {\n            'title': f'Vessels opening at {port} per day',\n            'showlegend': True\n        },\n    ]\n    \n    return dict(label=port,\n          method='update',\n          args=args,\n        )\n\ntitle = 'Vessels opening per day'\ntoday = datetime.combine(datetime.utcnow().date(), datetime.min.time())\n\nports_fig = go.Figure()\n\nport_buttons = []\n\nfor port in ports:\n    if port not in df_pivot.columns:\n        continue\n    port_scatter_plot = go.Scatter(    \n        x=df_pivot.open_date_to,\n        y=df_pivot[port],\n        name=port,\n        mode='lines',\n    )\n\n    ports_fig.add_trace(port_scatter_plot)\n    \n    port_buttons.append(port_button(port))\n    \nbuttons = list([\n    dict(\n        label='All',\n        method='update',\n        args=[    \n            {'visible': [True for _ in range(len(ports))]},\n            {\n                'title': title,\n                'showlegend': True\n            }\n        ],\n    ),\n    *port_buttons,\n])\n\nports_fig.update_layout(\n    title=title,\n    updatemenus=[go.layout.Updatemenu(\n        active=0,\n        buttons=buttons,\n    )],\n    xaxis_range=[today - timedelta(hours=4), today + timedelta(hours=24*6 + 4)],\n)\n\nports_fig.show()\n</pre> def port_button(port):     args = [         {'visible': [i == ports.index(port) for i in range(len(ports))]},         {             'title': f'Vessels opening at {port} per day',             'showlegend': True         },     ]          return dict(label=port,           method='update',           args=args,         )  title = 'Vessels opening per day' today = datetime.combine(datetime.utcnow().date(), datetime.min.time())  ports_fig = go.Figure()  port_buttons = []  for port in ports:     if port not in df_pivot.columns:         continue     port_scatter_plot = go.Scatter(             x=df_pivot.open_date_to,         y=df_pivot[port],         name=port,         mode='lines',     )      ports_fig.add_trace(port_scatter_plot)          port_buttons.append(port_button(port))      buttons = list([     dict(         label='All',         method='update',         args=[                 {'visible': [True for _ in range(len(ports))]},             {                 'title': title,                 'showlegend': True             }         ],     ),     *port_buttons, ])  ports_fig.update_layout(     title=title,     updatemenus=[go.layout.Updatemenu(         active=0,         buttons=buttons,     )],     xaxis_range=[today - timedelta(hours=4), today + timedelta(hours=24*6 + 4)], )  ports_fig.show() In\u00a0[23]: Copied! <pre>output_path = '' # Change output_path with your path\nfilename = 'last_week_positions.csv'\nif not data.empty:\n    data.to_csv(output_path+filename, index=False)\n</pre> output_path = '' # Change output_path with your path filename = 'last_week_positions.csv' if not data.empty:     data.to_csv(output_path+filename, index=False) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#scraped-positions-api-example","title":"Scraped Positions API Example\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#scraped-positions-api","title":"Scraped Positions API\u00b6","text":"<p>The goal of Scraped Positions API is to collect and return scraped positions by the given filters. This can be done by using the <code>ScrapedPositionsAPI</code> class and calling appropriate methods</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#1-request-by-filters","title":"1. Request by filters\u00b6","text":"<p>Positions can be retrieved for specific filters, by calling the <code>get_positions</code> method with the following arguments:</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>vessel_type</code> The vessel type</p> <p>Additionally, at least one of the following is required</p> <p><code>position_ids</code> List of PositionIDs to retrieve</p> <p><code>imos</code> List of IMOs</p> <p><code>message_ids</code> List of MessageIDs</p> <p><code>external_message_ids</code> List of  ExternalMessageIDs</p> <p><code>received_date_from</code> Earliest date the position received</p> <p><code>received_date_to</code> Latest date the position received</p> <p><code>updated_date_from</code> Earliest date the position updated</p> <p><code>updated_date_to</code> Latest date the position updated</p> <p>Mixing received and updated dates is not allowed</p> <p>It's highly recommended to use UTC  dates, since this is the internally used format</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#2-request-by-page-token","title":"2. Request by page token\u00b6","text":"<p>Positions can also be retrieved, by calling the <code>get_positions_incremental</code> method. This method will also return <code>next_request_token</code>, which the user should use to their next incremental request to retrieve only the latest updated cargoes.</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>vessel_type</code> The vessel type</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#optional","title":"Optional\u00b6","text":"<p><code>page_token</code> The key that should be used as a parameter of the token to retrieve the relevant page.</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#3-retrieve-page-token","title":"3. Retrieve page token\u00b6","text":"<p>The token referenced above can be retrieved for a specific date, by calling the <code>get_positions_incremental_token</code> method with the following argument:</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#required","title":"Required\u00b6","text":"<p><code>updated_date_from</code> Earliest the position updated.</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#additional-optional-arguments","title":"Additional optional arguments\u00b6","text":"<p>Methods <code>get_positions</code> and <code>get_positions_incremental</code>, also accept the following optional arguments:</p> <p><code>include_details</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>parsed_part_id, line_from, line_to, source\n</code></pre> <p><code>include_scraped_fields</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>scraped_vessel_name, scraped_deadweight, scraped_year_built, scraped_open_date, scraped_open_port, scraped_commercial_operator, scraped_cargo_type, scraped_last_cargo_types\n</code></pre> <p><code>include_vessel_details</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>vessel_name, deadweight, year_built, liquid_capacity, vessel_type_id, vessel_type, vessel_class\n</code></pre> <p><code>include_labels</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>open_name, open_taxonomy, commercial_operator, cargo_type, cargo_type_group, last_cargo_types\n</code></pre> <p><code>include_content</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>content\n</code></pre> <p><code>include_sender</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>sender\n</code></pre> <p><code>include_debug_info</code> If this field is <code>True</code> the following columns will be included in the response (otherwise they will be <code>None</code>):</p> <pre><code>is_private\n</code></pre> <p>Default value is <code>True</code> for all the optional arguments described above</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#installation","title":"Installation\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#quickstart","title":"Quickstart\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#request-by-date","title":"Request by date\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#request-by-imos","title":"Request by IMOs\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#request-by-message-or-externalmessage-ids","title":"Request by Message or ExternalMessage IDs\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#request-by-position-ids","title":"Request by Position IDs\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#retrieve-incremental-token","title":"Retrieve incremental token\u00b6","text":"<p>The <code>get_positions_incremental_token</code> allows retrieval of <code>page_token</code> by adding the <code>updated_date_from</code> value. This <code>page_token</code> can be used as a variable to the <code>get_positions_incremental</code> method, in order to retrieve only new or updated positions.</p>"},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#request-by-page-token","title":"Request by page token\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#usage-of-optional-arguments","title":"Usage of optional arguments\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#examples","title":"Examples\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#exclude-deleted-scraped-positions","title":"Exclude deleted scraped positions\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#top-10-commercical-operators","title":"Top 10 Commercical Operators\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#vessels-opening-at-specific-ports","title":"Vessels opening at specific ports\u00b6","text":""},{"location":"examples/jupyter/ScrapedPositionsAPI/Scraped%20Positions%20API%20Example/#export-data-to-csv","title":"Export data to csv\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20opening%20east%20and%20west%20of%20Suez/","title":"Finding vessels opening east and west of Suez","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <p>Set your subscription key, acquired here: https://apis.signalocean.com/profile</p> In\u00a0[12]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[13]: Copied! <pre>from datetime import date, timedelta\nfrom signal_ocean import Connection\nfrom signal_ocean.tonnage_list import (\n    TonnageListAPI,\n    VesselClassFilter,\n    PortFilter,\n    VesselFilter,\n    MarketDeployment,\n    VesselSubclass,\n    DateRange\n)\n\nconnection = Connection(signal_ocean_api_key)\napi = TonnageListAPI(connection)\n\nvessel_class_filter = VesselClassFilter(name_like=\"aframax\")\nvessel_class = api.get_vessel_classes(vessel_class_filter)[0]\n\nport_filter = PortFilter(name_like=\"ceyhan\")\nport = api.get_ports(port_filter)[0]\n\nlaycan_end_in_days = 512\nstart_date = date.today() - timedelta(days=5)\nend_date = date.today()\n\nhistorical_tonnage_list = api.get_historical_tonnage_list(\n    port,\n    vessel_class,\n    laycan_end_in_days,\n    DateRange(start_date, end_date))\n</pre> from datetime import date, timedelta from signal_ocean import Connection from signal_ocean.tonnage_list import (     TonnageListAPI,     VesselClassFilter,     PortFilter,     VesselFilter,     MarketDeployment,     VesselSubclass,     DateRange )  connection = Connection(signal_ocean_api_key) api = TonnageListAPI(connection)  vessel_class_filter = VesselClassFilter(name_like=\"aframax\") vessel_class = api.get_vessel_classes(vessel_class_filter)[0]  port_filter = PortFilter(name_like=\"ceyhan\") port = api.get_ports(port_filter)[0]  laycan_end_in_days = 512 start_date = date.today() - timedelta(days=5) end_date = date.today()  historical_tonnage_list = api.get_historical_tonnage_list(     port,     vessel_class,     laycan_end_in_days,     DateRange(start_date, end_date))  <p>Then, convert the data to a data frame, filter, and plot:</p> In\u00a0[14]: Copied! <pre>from signal_ocean.tonnage_list import IndexLevel\n\ndata_frame = historical_tonnage_list.to_data_frame()\nopen_wide_area_west_of_suez = [\n\"Caribs\",\n\"UK Continent\",\n\"Mediterranean\",\n\"West Africa\",\n\"Black Sea / Sea Of Marmara\",\n\"North Sea\",\n\"Baltic\",\n\"East Coast Canada\",\n\"US Atlantic Coast\",\n\"West Coast Central America\",\n\"US Gulf &amp; Mainland\",\n\"East Coast Mexico\",\n\"East Coast Central America\"\n]\n\nopen_wide_area_east_of_suez = [\n\"South East Asia\",\n\"Arabian Gulf\",\n\"Red Sea\",\n\"Korea / Japan\",\n\"India / Pakistan\",\n\"South East Africa\",\n\"China / Taiwan\",\n\"Australia / New Zealand\",\n\"Russian Pacific\",\n\"West Coast South America\",\n\"West Coast North America\",\n\"Pacific Islands\"\n]\nwest_areas_filter = data_frame.open_wide_area_point_in_time.isin(\n    open_wide_area_west_of_suez\n)\n\n\neast_areas_filter = data_frame.open_wide_area_point_in_time.isin(\n    open_wide_area_east_of_suez\n)\n\nwest_vessels = (\n    data_frame[west_areas_filter]\n    .groupby(IndexLevel.DATE, sort=True)\n    .size()\n)\n\neast_vessels = (\n    data_frame[east_areas_filter]\n    .groupby(IndexLevel.DATE, sort=True)\n    .size()\n)\n\nax = west_vessels.plot(\n    markerfacecolor=\"blue\",\n    color=\"skyblue\",\n    linewidth=4,\n    label=\"West\",\n    figsize=(12, 9),\n)\nax2 = east_vessels.plot(\n    ax=ax,\n    markerfacecolor=\"darkgreen\",\n    color=\"lime\",\n    linewidth=4,\n    label=\"East\",\n    figsize=(12, 9),\n)\n\nax2.set_ylabel(\"Vessel count\")\nax2.legend()\n</pre> from signal_ocean.tonnage_list import IndexLevel  data_frame = historical_tonnage_list.to_data_frame() open_wide_area_west_of_suez = [ \"Caribs\", \"UK Continent\", \"Mediterranean\", \"West Africa\", \"Black Sea / Sea Of Marmara\", \"North Sea\", \"Baltic\", \"East Coast Canada\", \"US Atlantic Coast\", \"West Coast Central America\", \"US Gulf &amp; Mainland\", \"East Coast Mexico\", \"East Coast Central America\" ]  open_wide_area_east_of_suez = [ \"South East Asia\", \"Arabian Gulf\", \"Red Sea\", \"Korea / Japan\", \"India / Pakistan\", \"South East Africa\", \"China / Taiwan\", \"Australia / New Zealand\", \"Russian Pacific\", \"West Coast South America\", \"West Coast North America\", \"Pacific Islands\" ] west_areas_filter = data_frame.open_wide_area_point_in_time.isin(     open_wide_area_west_of_suez )   east_areas_filter = data_frame.open_wide_area_point_in_time.isin(     open_wide_area_east_of_suez )  west_vessels = (     data_frame[west_areas_filter]     .groupby(IndexLevel.DATE, sort=True)     .size() )  east_vessels = (     data_frame[east_areas_filter]     .groupby(IndexLevel.DATE, sort=True)     .size() )  ax = west_vessels.plot(     markerfacecolor=\"blue\",     color=\"skyblue\",     linewidth=4,     label=\"West\",     figsize=(12, 9), ) ax2 = east_vessels.plot(     ax=ax,     markerfacecolor=\"darkgreen\",     color=\"lime\",     linewidth=4,     label=\"East\",     figsize=(12, 9), )  ax2.set_ylabel(\"Vessel count\") ax2.legend()  Out[14]: <pre>&lt;matplotlib.legend.Legend at 0x21c5b2aea60&gt;</pre>"},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20opening%20east%20and%20west%20of%20Suez/#finding-vessels-opening-east-and-west-of-suez","title":"Finding vessels opening east and west of Suez\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20opening%20east%20and%20west%20of%20Suez/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20opening%20east%20and%20west%20of%20Suez/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20opening%20east%20and%20west%20of%20Suez/#example-1-number-of-spot-and-relet-vessels-over-time","title":"Example 1: Number of spot and relet vessels over time\u00b6","text":"<p>In this example, a supply trend is generated in order to calculate the number of spot and relet vessels which open in specific areas. A time period of 5 days is explored here but this number can go up until the date you subscribed to The Signal Ocean Platform.</p> <p>First, get a historical tonnage list containing the relevant data:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20on%20subs%20around%20Houston/","title":"Finding vessels that were on subs around Houston","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <p>Set your subscription key, acquired here: https://apis.signalocean.com/profile</p> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' # replace with your subscription key\n</pre> signal_ocean_api_key = '' # replace with your subscription key In\u00a0[3]: Copied! <pre>from datetime import timedelta, date\n\nfrom signal_ocean import Connection\nfrom signal_ocean.tonnage_list import (\n    TonnageListAPI,\n    VesselClassFilter,\n    PortFilter,\n    VesselFilter,\n    MarketDeployment,\n    CommercialStatus,\n    VesselSubclass,\n    DateRange,\n)\n\nconnection = Connection(signal_ocean_api_key)\napi = TonnageListAPI(connection)\n\nvessel_class_filter = VesselClassFilter(name_like=\"aframax\")\nvessel_class = api.get_vessel_classes(vessel_class_filter)[0]\n\nport_filter = PortFilter(name_like=\"houston\")\nport = api.get_ports(port_filter)[0]\n\nlaycan_end_in_days = 10\nstart_date = date.today() - timedelta(days=5)\nend_date = date.today()\n\nvessel_filter = VesselFilter(\n    market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],\n    vessel_subclass=VesselSubclass.DIRTY,\n    commercial_statuses=[CommercialStatus.ON_SUBS],\n    latest_ais_since=5,\n)\n\nhtl_for_supply_trend = api.get_historical_tonnage_list(\n    port,\n    vessel_class,\n    laycan_end_in_days,\n    DateRange(start_date, end_date),\n    vessel_filter=vessel_filter,\n)\n</pre> from datetime import timedelta, date  from signal_ocean import Connection from signal_ocean.tonnage_list import (     TonnageListAPI,     VesselClassFilter,     PortFilter,     VesselFilter,     MarketDeployment,     CommercialStatus,     VesselSubclass,     DateRange, )  connection = Connection(signal_ocean_api_key) api = TonnageListAPI(connection)  vessel_class_filter = VesselClassFilter(name_like=\"aframax\") vessel_class = api.get_vessel_classes(vessel_class_filter)[0]  port_filter = PortFilter(name_like=\"houston\") port = api.get_ports(port_filter)[0]  laycan_end_in_days = 10 start_date = date.today() - timedelta(days=5) end_date = date.today()  vessel_filter = VesselFilter(     market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],     vessel_subclass=VesselSubclass.DIRTY,     commercial_statuses=[CommercialStatus.ON_SUBS],     latest_ais_since=5, )  htl_for_supply_trend = api.get_historical_tonnage_list(     port,     vessel_class,     laycan_end_in_days,     DateRange(start_date, end_date),     vessel_filter=vessel_filter, )  <p>Now, we can use the data to generate a supply trend:</p> In\u00a0[4]: Copied! <pre>from signal_ocean.tonnage_list import IndexLevel\n\nsupply_trend_data_frame = htl_for_supply_trend.to_data_frame()\n\naggregated_data = supply_trend_data_frame.groupby(\n    IndexLevel.DATE, sort=True\n).size()\n\nax = aggregated_data.plot(\n    markerfacecolor=\"blue\",\n    color=\"skyblue\",\n    linewidth=4,\n    label=\"Spot\",\n    figsize=(12, 9),\n)\n\nax.set_ylabel(\"Vessel count\")\nax.legend()\n</pre> from signal_ocean.tonnage_list import IndexLevel  supply_trend_data_frame = htl_for_supply_trend.to_data_frame()  aggregated_data = supply_trend_data_frame.groupby(     IndexLevel.DATE, sort=True ).size()  ax = aggregated_data.plot(     markerfacecolor=\"blue\",     color=\"skyblue\",     linewidth=4,     label=\"Spot\",     figsize=(12, 9), )  ax.set_ylabel(\"Vessel count\") ax.legend()  Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x7f180fe015b0&gt;</pre>"},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20on%20subs%20around%20Houston/#finding-vessels-that-were-on-subs-around-houston","title":"Finding vessels that were on subs around Houston\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20on%20subs%20around%20Houston/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20on%20subs%20around%20Houston/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20on%20subs%20around%20Houston/#description","title":"Description\u00b6","text":"<p>In order to perform our analysis, we will query historical tonnage lists for vessels that were \"on subs\" in the last 5 days in the area of Houston:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20opening%20at%20Fos/","title":"Finding vessels that were opening at Fos","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <p>Set your subscription key, acquired here: https://apis.signalocean.com/profile</p> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = \"\"  # replace with your subscription key\n</pre> signal_ocean_api_key = \"\"  # replace with your subscription key  In\u00a0[3]: Copied! <pre>from datetime import date, timedelta\n\nfrom signal_ocean import Connection\nfrom signal_ocean.tonnage_list import (\n    TonnageListAPI,\n    VesselClassFilter,\n    PortFilter,\n    VesselFilter,\n    MarketDeployment,\n    CommercialStatus,\n    VesselSubclass,\n    DateRange,\n)\n\nconnection = Connection(signal_ocean_api_key)\napi = TonnageListAPI(connection)\n\nvessel_class_filter = VesselClassFilter(name_like=\"aframax\")\nvessel_class = api.get_vessel_classes(vessel_class_filter)[0]\n\nport_filter = PortFilter(name_like=\"Ceyhan\")\nport = api.get_ports(port_filter)[0]\n\nlaycan_end_in_days = 20\nstart_date = date.today() - timedelta(days=5)\nend_date = date.today()\n\nvessel_filter = VesselFilter(\n    market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],\n    vessel_subclass=VesselSubclass.DIRTY,\n    commercial_statuses=[CommercialStatus.ON_SUBS],\n    latest_ais_since=5,\n)\n\nhtl_for_supply_trend = api.get_historical_tonnage_list(\n    port,\n    vessel_class,\n    laycan_end_in_days,\n    DateRange(start_date, end_date),\n    vessel_filter=vessel_filter,\n)\n</pre> from datetime import date, timedelta  from signal_ocean import Connection from signal_ocean.tonnage_list import (     TonnageListAPI,     VesselClassFilter,     PortFilter,     VesselFilter,     MarketDeployment,     CommercialStatus,     VesselSubclass,     DateRange, )  connection = Connection(signal_ocean_api_key) api = TonnageListAPI(connection)  vessel_class_filter = VesselClassFilter(name_like=\"aframax\") vessel_class = api.get_vessel_classes(vessel_class_filter)[0]  port_filter = PortFilter(name_like=\"Ceyhan\") port = api.get_ports(port_filter)[0]  laycan_end_in_days = 20 start_date = date.today() - timedelta(days=5) end_date = date.today()  vessel_filter = VesselFilter(     market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],     vessel_subclass=VesselSubclass.DIRTY,     commercial_statuses=[CommercialStatus.ON_SUBS],     latest_ais_since=5, )  htl_for_supply_trend = api.get_historical_tonnage_list(     port,     vessel_class,     laycan_end_in_days,     DateRange(start_date, end_date),     vessel_filter=vessel_filter, )  <p>Now, we can use the data to generate a supply trend for our analysis:</p> In\u00a0[4]: Copied! <pre>from signal_ocean.tonnage_list import IndexLevel\n\nsupply_trend_data_frame = htl_for_supply_trend.to_data_frame()\n\nopen_ports_of_interest = [\"Fos\"]\nopen_ports_filter = supply_trend_data_frame.open_port_point_in_time.isin(\n    open_ports_of_interest\n)\n\naggregated_data = supply_trend_data_frame.groupby(\n    IndexLevel.DATE, sort=True\n).size()\n\nax = aggregated_data.plot(\n    markerfacecolor=\"blue\",\n    color=\"skyblue\",\n    linewidth=4,\n    label=\"Vessels opening at Fos\",\n    figsize=(12, 9),\n)\n\nax.set_ylabel(\"Vessel count\")\nax.legend()\n</pre> from signal_ocean.tonnage_list import IndexLevel  supply_trend_data_frame = htl_for_supply_trend.to_data_frame()  open_ports_of_interest = [\"Fos\"] open_ports_filter = supply_trend_data_frame.open_port_point_in_time.isin(     open_ports_of_interest )  aggregated_data = supply_trend_data_frame.groupby(     IndexLevel.DATE, sort=True ).size()  ax = aggregated_data.plot(     markerfacecolor=\"blue\",     color=\"skyblue\",     linewidth=4,     label=\"Vessels opening at Fos\",     figsize=(12, 9), )  ax.set_ylabel(\"Vessel count\") ax.legend()  Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x7f1600e1bca0&gt;</pre>"},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20opening%20at%20Fos/#finding-vessels-that-were-opening-at-fos","title":"Finding vessels that were opening at Fos\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20opening%20at%20Fos/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20opening%20at%20Fos/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Finding%20vessels%20that%20were%20opening%20at%20Fos/#description","title":"Description\u00b6","text":"<p>In order to perform our analysis, we will query historical tonnage lists for vessel that, in the last 5 days, were opening at Fos and could make it to Ceyhan within a 20-day window:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Historical%20analysis%20over%20all%20vessels/","title":"Analyzing historical data for all vessels in a specific vessel class","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <p>Set your subscription key, acquired here: https://apis.signalocean.com/profile</p> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[3]: Copied! <pre>from datetime import date, timedelta\nfrom signal_ocean import Connection\nfrom signal_ocean.tonnage_list import (\n    TonnageListAPI,\n    VesselClassFilter,\n    PortFilter,\n    VesselFilter,\n    MarketDeployment,\n    VesselSubclass,\n    DateRange\n)\n\nconnection = Connection(signal_ocean_api_key)\napi = TonnageListAPI(connection)\n\nvessel_class_filter = VesselClassFilter(name_like=\"aframax\")\nvessel_class = api.get_vessel_classes(vessel_class_filter)[0]\n\nport_filter = PortFilter(name_like=\"ceyhan\")\nport = api.get_ports(port_filter)[0]\n\nlaycan_end_in_days = 512\nstart_date = date.today() - timedelta(days=5)\nend_date = date.today()\n\nvessel_filter = VesselFilter(\n    market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],\n    vessel_subclass=VesselSubclass.DIRTY,\n    latest_ais_since=5,\n)\n\nhistorical_tonnage_list = api.get_historical_tonnage_list(\n    port,\n    vessel_class,\n    laycan_end_in_days,\n    DateRange(start_date, end_date),\n    vessel_filter=vessel_filter,\n)\n</pre> from datetime import date, timedelta from signal_ocean import Connection from signal_ocean.tonnage_list import (     TonnageListAPI,     VesselClassFilter,     PortFilter,     VesselFilter,     MarketDeployment,     VesselSubclass,     DateRange )  connection = Connection(signal_ocean_api_key) api = TonnageListAPI(connection)  vessel_class_filter = VesselClassFilter(name_like=\"aframax\") vessel_class = api.get_vessel_classes(vessel_class_filter)[0]  port_filter = PortFilter(name_like=\"ceyhan\") port = api.get_ports(port_filter)[0]  laycan_end_in_days = 512 start_date = date.today() - timedelta(days=5) end_date = date.today()  vessel_filter = VesselFilter(     market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],     vessel_subclass=VesselSubclass.DIRTY,     latest_ais_since=5, )  historical_tonnage_list = api.get_historical_tonnage_list(     port,     vessel_class,     laycan_end_in_days,     DateRange(start_date, end_date),     vessel_filter=vessel_filter, )  <p>Then, convert the data to a data frame, filter, and plot:</p> In\u00a0[4]: Copied! <pre>from signal_ocean.tonnage_list import IndexLevel\n\ndata_frame = historical_tonnage_list.to_data_frame()\nopen_areas_of_interest = [\n    \"Iberian Atlantic Coast\",\n    \"British Isles\",\n    \"North Sea\",\n    \"Baltic Sea Low\",\n    \"Baltic Sea Upper\",\n    \"Continent\",\n]\nareas_filter = data_frame.open_narrow_area_point_in_time.isin(\n    open_areas_of_interest\n)\n\nspot_filter = data_frame.market_deployment_point_in_time == \"Spot\"\nspot_vessels = (\n    data_frame[spot_filter &amp; areas_filter]\n    .groupby(IndexLevel.DATE, sort=True)\n    .size()\n)\n\nrelet_filter = data_frame.market_deployment_point_in_time == \"Relet\"\nrelet_vessels = (\n    data_frame[relet_filter &amp; areas_filter]\n    .groupby(IndexLevel.DATE, sort=True)\n    .size()\n)\n\nax = spot_vessels.plot(\n    markerfacecolor=\"blue\",\n    color=\"skyblue\",\n    linewidth=4,\n    label=\"Spot\",\n    figsize=(12, 9),\n)\nax2 = relet_vessels.plot(\n    ax=ax,\n    markerfacecolor=\"darkgreen\",\n    color=\"lime\",\n    linewidth=4,\n    label=\"Relet\",\n    figsize=(12, 9),\n)\n\nax2.set_ylabel(\"Vessel count\")\nax2.legend()\n</pre> from signal_ocean.tonnage_list import IndexLevel  data_frame = historical_tonnage_list.to_data_frame() open_areas_of_interest = [     \"Iberian Atlantic Coast\",     \"British Isles\",     \"North Sea\",     \"Baltic Sea Low\",     \"Baltic Sea Upper\",     \"Continent\", ] areas_filter = data_frame.open_narrow_area_point_in_time.isin(     open_areas_of_interest )  spot_filter = data_frame.market_deployment_point_in_time == \"Spot\" spot_vessels = (     data_frame[spot_filter &amp; areas_filter]     .groupby(IndexLevel.DATE, sort=True)     .size() )  relet_filter = data_frame.market_deployment_point_in_time == \"Relet\" relet_vessels = (     data_frame[relet_filter &amp; areas_filter]     .groupby(IndexLevel.DATE, sort=True)     .size() )  ax = spot_vessels.plot(     markerfacecolor=\"blue\",     color=\"skyblue\",     linewidth=4,     label=\"Spot\",     figsize=(12, 9), ) ax2 = relet_vessels.plot(     ax=ax,     markerfacecolor=\"darkgreen\",     color=\"lime\",     linewidth=4,     label=\"Relet\",     figsize=(12, 9), )  ax2.set_ylabel(\"Vessel count\") ax2.legend()  Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x7f4a14c3b130&gt;</pre> In\u00a0[5]: Copied! <pre>from signal_ocean.tonnage_list import OperationalStatus\n\ndata_frame = historical_tonnage_list.to_data_frame()\nopen_areas_of_interest = [\n    \"East Mediterranean\",\n    \"Central Mediterranean\",\n    \"West Mediterranean\",\n    \"Black Sea\",\n]\n\noperationalStatuses = [OperationalStatus.BALLAST_UNFIXED]\nareas_filter = data_frame.open_narrow_area_point_in_time.isin(\n    open_areas_of_interest\n)\noperational_status_filter = data_frame.operational_status_point_in_time.isin(\n    operationalStatuses\n)\n\naggregatedData = (\n    data_frame[operational_status_filter &amp; areas_filter]\n    .groupby(IndexLevel.DATE, sort=True)\n    .size()\n)\n\n\nax = aggregatedData.plot(\n    markerfacecolor=\"blue\",\n    color=\"skyblue\",\n    linewidth=4,\n    label=\"Spot\",\n    figsize=(12, 9),\n)\n\nax2.set_ylabel(\"Vessel count\")\nax2.legend()\n</pre> from signal_ocean.tonnage_list import OperationalStatus  data_frame = historical_tonnage_list.to_data_frame() open_areas_of_interest = [     \"East Mediterranean\",     \"Central Mediterranean\",     \"West Mediterranean\",     \"Black Sea\", ]  operationalStatuses = [OperationalStatus.BALLAST_UNFIXED] areas_filter = data_frame.open_narrow_area_point_in_time.isin(     open_areas_of_interest ) operational_status_filter = data_frame.operational_status_point_in_time.isin(     operationalStatuses )  aggregatedData = (     data_frame[operational_status_filter &amp; areas_filter]     .groupby(IndexLevel.DATE, sort=True)     .size() )   ax = aggregatedData.plot(     markerfacecolor=\"blue\",     color=\"skyblue\",     linewidth=4,     label=\"Spot\",     figsize=(12, 9), )  ax2.set_ylabel(\"Vessel count\") ax2.legend()  Out[5]: <pre>&lt;matplotlib.legend.Legend at 0x7f4a161b7280&gt;</pre>"},{"location":"examples/jupyter/Tonnage%20List%20API/Historical%20analysis%20over%20all%20vessels/#analyzing-historical-data-for-all-vessels-in-a-specific-vessel-class","title":"Analyzing historical data for all vessels in a specific vessel class\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Historical%20analysis%20over%20all%20vessels/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Historical%20analysis%20over%20all%20vessels/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Historical%20analysis%20over%20all%20vessels/#example-1-number-of-spot-and-relet-vessels-over-time","title":"Example 1: Number of spot and relet vessels over time\u00b6","text":"<p>In this example, a supply trend is generated in order to calculate the number of spot and relet vessels which open in specific areas. A time period of 5 days is explored here but this number can go up until the date you subscribed to The Signal Ocean Platform.</p> <p>First, get a historical tonnage list containing the relevant data:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Historical%20analysis%20over%20all%20vessels/#example-2-number-of-ballast-unfixed-vessels-in-the-mediterranean-and-black-sea","title":"Example 2: Number of ballast unfixed vessels in the Mediterranean and Black Sea\u00b6","text":"<p>In this example, the same data collected from the first call will be used to detect ballast unfixed vessels in the Mediterranean and Black Sea areas.</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/","title":"Persisting data in SQLite","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <p>Set your subscription key, acquired here: https://apis.signalocean.com/profile</p> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = \"\"  # replace with your subscription key\n</pre> signal_ocean_api_key = \"\"  # replace with your subscription key  <p>This notebook demonstrates a way of persisting historical tonnage list data into a local SQLite database.</p> <p>SQLite is a C-language library that implements a small, fast, self-contained, high-reliability, full-featured, SQL database engine.</p> <p>Source: https://www.sqlite.org/index.html</p> <p>Python has a built-in <code>sqlite3</code> module that allows us to work with SQLite. There is no installation and configuration process; in order to use SQLite, we only need to import the module:</p> In\u00a0[3]: Copied! <pre>import sqlite3\n</pre> import sqlite3  In\u00a0[4]: Copied! <pre>db_connection = sqlite3.connect(\"HistoricalTonnageList.db\")\n</pre> db_connection = sqlite3.connect(\"HistoricalTonnageList.db\")  <p>Note that a <code>HistoricalTonnageList.db</code> file has been created in the current working directory. This is the database that we have just created and connected to. Running this code a second time will not result in a new database file being created; it will simply connect to the existing database with the specified name.</p> In\u00a0[5]: Copied! <pre>from datetime import date, timedelta\n\nfrom signal_ocean import Connection\nfrom signal_ocean.tonnage_list import (\n    TonnageListAPI,\n    VesselClassFilter,\n    PortFilter,\n    DateRange,\n)\n\n\napi_connection = Connection(signal_ocean_api_key)\napi = TonnageListAPI(api_connection)\n\nvessel_class_filter = VesselClassFilter(name_like=\"aframax\")\nvessel_class = api.get_vessel_classes(vessel_class_filter)[0]\n\nport_filter = PortFilter(name_like=\"ceyhan\")\nport = api.get_ports(port_filter)[0]\n\nlaycan_end_in_days = 512\nstart_date = date.today() - timedelta(days=7)\nend_date = date.today()\n\nhtl = api.get_historical_tonnage_list(\n    port, vessel_class, laycan_end_in_days, DateRange(start_date, end_date),\n)\n\ndata_frame = htl.to_data_frame()\nprint(data_frame.shape)\ndata_frame.head()\n</pre> from datetime import date, timedelta  from signal_ocean import Connection from signal_ocean.tonnage_list import (     TonnageListAPI,     VesselClassFilter,     PortFilter,     DateRange, )   api_connection = Connection(signal_ocean_api_key) api = TonnageListAPI(api_connection)  vessel_class_filter = VesselClassFilter(name_like=\"aframax\") vessel_class = api.get_vessel_classes(vessel_class_filter)[0]  port_filter = PortFilter(name_like=\"ceyhan\") port = api.get_ports(port_filter)[0]  laycan_end_in_days = 512 start_date = date.today() - timedelta(days=7) end_date = date.today()  htl = api.get_historical_tonnage_list(     port, vessel_class, laycan_end_in_days, DateRange(start_date, end_date), )  data_frame = htl.to_data_frame() print(data_frame.shape) data_frame.head()  <pre>(7613, 23)\n</pre> Out[5]: name vessel_class ice_class year_built deadweight length_overall breadth_extreme subclass market_deployment_point_in_time push_type_point_in_time ... commercial_operator_point_in_time commercial_status_point_in_time eta_point_in_time latest_ais_point_in_time open_prediction_accuracy_point_in_time open_country_point_in_time open_narrow_area_point_in_time open_wide_area_point_in_time availability_port_type_point_in_time availability_date_type_point_in_time date imo 2021-10-12 12:00:00+00:00 9486910 Beta Aframax NaN 2010 105319 228.60 42 Dirty Contract Not Pushed ... Held Maritime Shipping Available 2019-10-27 09:00:00+00:00 2019-10-13 04:47:29+00:00 Narrow Area Netherlands Continent UK Continent Prediction Prediction 9138604 Barakuda Natuna Aframax NaN 1998 109277 244.60 42 Clean Spot Not Pushed ... Soechi Lines Available 2020-09-12 17:00:00+00:00 2020-08-23 01:45:14+00:00 Narrow Area Malaysia Singapore / Malaysia South East Asia Source Source 9038830 Proteo Aframax NaN 1993 99392 243.97 46 Dirty Program Not Pushed ... PDVSA Available 2021-01-12 04:00:00+00:00 2020-12-22 22:32:34+00:00 Narrow Area Venezuela, Bolivarian Republic of Caribs Caribs Source Source 8508292 Gunung Kemala Aframax NaN 1986 86962 242.00 42 Dirty Program Not Pushed ... Pertamina Available 2021-03-09 07:00:00+00:00 2021-02-09 16:04:53+00:00 Narrow Area Indonesia Indonesia South East Asia Prediction Prediction 9038854 Warrior King Aframax NaN 1993 99371 243.97 46 Dirty Program Not Pushed ... PDVSA Available 2021-07-02 06:00:00+00:00 2021-06-06 21:34:32+00:00 Narrow Area Curacao Caribs Caribs Prediction Prediction <p>5 rows \u00d7 23 columns</p> In\u00a0[\u00a0]: Copied! <pre>!pip install sqlalchemy\n</pre> !pip install sqlalchemy <p>We'll use SQLAlchemy to create a table for our historical tonnage list:</p> In\u00a0[7]: Copied! <pre>import os\n\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\n    f'sqlite:///{os.path.join(os.path.abspath(os.getcwd()), \"HistoricalTonnageList.db\")}'\n)\n\ndata_frame.to_sql(\"htl_ceyhan_aframax\", engine, index=True, if_exists=\"append\")\n</pre> import os  from sqlalchemy import create_engine  engine = create_engine(     f'sqlite:///{os.path.join(os.path.abspath(os.getcwd()), \"HistoricalTonnageList.db\")}' )  data_frame.to_sql(\"htl_ceyhan_aframax\", engine, index=True, if_exists=\"append\")  In\u00a0[8]: Copied! <pre>import pandas as pd\n\ndata_frame_from_db = pd.read_sql_query(\n    \"select * from htl_ceyhan_aframax\", db_connection\n)\n\ndata_frame_from_db.head()\n</pre> import pandas as pd  data_frame_from_db = pd.read_sql_query(     \"select * from htl_ceyhan_aframax\", db_connection )  data_frame_from_db.head()  Out[8]: date imo name vessel_class ice_class year_built deadweight length_overall breadth_extreme subclass ... commercial_operator_point_in_time commercial_status_point_in_time eta_point_in_time latest_ais_point_in_time open_prediction_accuracy_point_in_time open_country_point_in_time open_narrow_area_point_in_time open_wide_area_point_in_time availability_port_type_point_in_time availability_date_type_point_in_time 0 2021-10-12 12:00:00.000000 9486910 Beta Aframax None 2010 105319 228.60 42 Dirty ... Held Maritime Shipping Available 2019-10-27 09:00:00.000000 2019-10-13 04:47:29.000000 Narrow Area Netherlands Continent UK Continent Prediction Prediction 1 2021-10-12 12:00:00.000000 9138604 Barakuda Natuna Aframax None 1998 109277 244.60 42 Clean ... Soechi Lines Available 2020-09-12 17:00:00.000000 2020-08-23 01:45:14.000000 Narrow Area Malaysia Singapore / Malaysia South East Asia Source Source 2 2021-10-12 12:00:00.000000 9038830 Proteo Aframax None 1993 99392 243.97 46 Dirty ... PDVSA Available 2021-01-12 04:00:00.000000 2020-12-22 22:32:34.000000 Narrow Area Venezuela, Bolivarian Republic of Caribs Caribs Source Source 3 2021-10-12 12:00:00.000000 8508292 Gunung Kemala Aframax None 1986 86962 242.00 42 Dirty ... Pertamina Available 2021-03-09 07:00:00.000000 2021-02-09 16:04:53.000000 Narrow Area Indonesia Indonesia South East Asia Prediction Prediction 4 2021-10-12 12:00:00.000000 9038854 Warrior King Aframax None 1993 99371 243.97 46 Dirty ... PDVSA Available 2021-07-02 06:00:00.000000 2021-06-06 21:34:32.000000 Narrow Area Curacao Caribs Caribs Prediction Prediction <p>5 rows \u00d7 25 columns</p> <p>As time passes and new historical tonnage lists become available, we want to append their contents to our table.</p> <p>To do this, we can query the data we already have stored for the most recent historical tonnage list's date:</p> In\u00a0[9]: Copied! <pre>cursor = db_connection.cursor()\ncursor.execute(\"select max(date(date)) from htl_ceyhan_aframax\")\nmax_date_in_table = cursor.fetchone()[0]\n\nmax_date_in_table\n</pre> cursor = db_connection.cursor() cursor.execute(\"select max(date(date)) from htl_ceyhan_aframax\") max_date_in_table = cursor.fetchone()[0]  max_date_in_table  Out[9]: <pre>'2021-10-12'</pre> <p>Then, we can use that date as the <code>start_date</code> for further historical tonnage list requests:</p> In\u00a0[10]: Copied! <pre>start_date = date.fromisoformat(max_date_in_table)\nend_date = date.today()\n\nhtl = api.get_historical_tonnage_list(\n    port, vessel_class, laycan_end_in_days, DateRange(start_date, end_date),\n)\n\ndata_frame = htl.to_data_frame()\n</pre> start_date = date.fromisoformat(max_date_in_table) end_date = date.today()  htl = api.get_historical_tonnage_list(     port, vessel_class, laycan_end_in_days, DateRange(start_date, end_date), )  data_frame = htl.to_data_frame()  <p>In order to append them to our table:</p> In\u00a0[11]: Copied! <pre>data_frame.to_sql(\"htl_ceyhan_aframax\", engine, index=True, if_exists=\"append\")\n</pre> data_frame.to_sql(\"htl_ceyhan_aframax\", engine, index=True, if_exists=\"append\")"},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#persisting-data-in-sqlite","title":"Persisting data in SQLite\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#description","title":"Description\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#step-1-create-the-database","title":"Step 1 - Create the database\u00b6","text":"<p>Create a database named <code>HistoricalTonnageList.db</code> and connect to it:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#step-2-query-the-tonnage-list-api","title":"Step 2 - Query the Tonnage List API\u00b6","text":"<p>For this example, we are going to retrieve data for all Aframax vessels for the last seven days.</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#step-3-import-the-data-into-the-database","title":"Step 3 - Import the data into the database\u00b6","text":"<p>In order to import the data we have to install <code>sqlalchemy</code>:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#step-4-verify-that-the-data-has-been-correctly-imported","title":"Step 4 - Verify that the data has been correctly imported\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Persisting%20data%20in%20SQLite/#step-5-update-the-created-table","title":"Step 5 - Update the created table\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Recall%20live%20Tonnage%20List/","title":"Recall live tonnage list","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <p>Set your subscription key, acquired here: https://apis.signalocean.com/profile</p> In\u00a0[30]: Copied! <pre>signal_ocean_api_key = \"\"  # replace with your subscription key\n</pre> signal_ocean_api_key = \"\"  # replace with your subscription key <p>First, we need to create an instance of the <code>TonnageListAPI</code>:</p> In\u00a0[31]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.tonnage_list import TonnageListAPI\n\nconnection = Connection(signal_ocean_api_key)\napi = TonnageListAPI(connection)\n</pre> from signal_ocean import Connection from signal_ocean.tonnage_list import TonnageListAPI  connection = Connection(signal_ocean_api_key) api = TonnageListAPI(connection) In\u00a0[32]: Copied! <pre>from datetime import timedelta, date\nfrom signal_ocean.tonnage_list import VesselClassFilter\nfrom signal_ocean.tonnage_list import PortFilter\nfrom signal_ocean.tonnage_list import (\n    VesselFilter,\n    PushType,\n    MarketDeployment,\n    CommercialStatus,\n    VesselSubclass,\n)\n\nvessel_class_filter = VesselClassFilter(name_like=\"aframax\")\nvessel_class = api.get_vessel_classes(vessel_class_filter)[0]\n\nport_filter = PortFilter(name_like=\"ceyhan\")\nport = api.get_ports(port_filter)[0]\n\nlaycan_end_in_days = 6\n\nvessel_filter = VesselFilter(\n    push_types=[PushType.PUSHED],\n    market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],\n    commercial_statuses=[\n        CommercialStatus.AVAILABLE,\n        CommercialStatus.CANCELLED,\n        CommercialStatus.FAILED,\n    ],\n    vessel_subclass=VesselSubclass.DIRTY,\n    latest_ais_since=5,\n)\n\n\ntonnage_list = api.get_tonnage_list(\n    port, vessel_class, laycan_end_in_days, vessel_filter\n)\ntl_data_frame = tonnage_list.to_data_frame()\ntl_data_frame\n</pre> from datetime import timedelta, date from signal_ocean.tonnage_list import VesselClassFilter from signal_ocean.tonnage_list import PortFilter from signal_ocean.tonnage_list import (     VesselFilter,     PushType,     MarketDeployment,     CommercialStatus,     VesselSubclass, )  vessel_class_filter = VesselClassFilter(name_like=\"aframax\") vessel_class = api.get_vessel_classes(vessel_class_filter)[0]  port_filter = PortFilter(name_like=\"ceyhan\") port = api.get_ports(port_filter)[0]  laycan_end_in_days = 6  vessel_filter = VesselFilter(     push_types=[PushType.PUSHED],     market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],     commercial_statuses=[         CommercialStatus.AVAILABLE,         CommercialStatus.CANCELLED,         CommercialStatus.FAILED,     ],     vessel_subclass=VesselSubclass.DIRTY,     latest_ais_since=5, )   tonnage_list = api.get_tonnage_list(     port, vessel_class, laycan_end_in_days, vessel_filter ) tl_data_frame = tonnage_list.to_data_frame() tl_data_frame Out[32]: name vessel_class ice_class year_built deadweight length_overall breadth_extreme subclass market_deployment_point_in_time push_type_point_in_time ... open_prediction_accuracy_point_in_time open_country_point_in_time open_narrow_area_point_in_time open_wide_area_point_in_time availability_port_type_point_in_time availability_date_type_point_in_time fixture_type_point_in_time current_vessel_sub_type_id_point_in_time current_vessel_sub_type_point_in_time willing_to_switch_current_vessel_sub_type_point_in_time 9488011 Safeen Elona Aframax NaN 2012 105258 244.38 42 Dirty Spot Pushed ... Narrow Area Greece East Mediterranean Mediterranean Source Source NaN 1 Source False 9592305 Nissos Delos Aframax NaN 2012 115691 248.97 44 Dirty Spot Pushed ... Narrow Area Egypt Red Sea Red Sea Source Source NaN 1 Source False 9291262 Themis 1 Aframax 1C 2005 114834 253.50 44 Dirty Spot Pushed ... Narrow Area Saudi Arabia Red Sea Red Sea Source Source NaN 1 Source False 9407457 Matilda Aframax NaN 2009 112935 249.96 44 Dirty Spot Pushed ... Narrow Area Turkey Sea of Marmara Black Sea / Sea Of Marmara Source Source NaN 1 Source False 9458016 Delta Star Aframax NaN 2013 115618 249.97 44 Dirty Spot Pushed ... Port Croatia Central Mediterranean Mediterranean Source Prediction NaN 1 Prediction False 9253325 Nurkez Aframax NaN 2004 105650 248.00 43 Dirty Relet Pushed ... Narrow Area Saudi Arabia Red Sea Red Sea Source Source NaN 1 Source False 9330599 Lambada Aframax NaN 2006 104866 243.56 42 Dirty Spot Pushed ... Port Saudi Arabia Red Sea Red Sea Source Prediction NaN 1 Prediction False 9370848 Anafi Warrior Aframax NaN 2009 107593 243.80 42 Dirty Spot Pushed ... Port Italy Central Mediterranean Mediterranean Source Prediction NaN 1 Prediction False <p>8 rows \u00d7 29 columns</p> In\u00a0[34]: Copied! <pre>import pandas as pd\n\nwithout_time_zones = tl_data_frame\nwithout_time_zones[\"open_date_point_in_time\"] = pd.to_datetime(without_time_zones[\"open_date_point_in_time\"]).dt.tz_localize(None)\nwithout_time_zones[\"eta_point_in_time\"] = pd.to_datetime(without_time_zones[\"eta_point_in_time\"]).dt.tz_localize(None)\nwithout_time_zones[\"latest_ais_point_in_time\"] = pd.to_datetime(without_time_zones[\"latest_ais_point_in_time\"]).dt.tz_localize(None)\n\nwithout_time_zones.to_excel('Ceyhan_Afra_6days_live.xlsx')\n</pre> import pandas as pd  without_time_zones = tl_data_frame without_time_zones[\"open_date_point_in_time\"] = pd.to_datetime(without_time_zones[\"open_date_point_in_time\"]).dt.tz_localize(None) without_time_zones[\"eta_point_in_time\"] = pd.to_datetime(without_time_zones[\"eta_point_in_time\"]).dt.tz_localize(None) without_time_zones[\"latest_ais_point_in_time\"] = pd.to_datetime(without_time_zones[\"latest_ais_point_in_time\"]).dt.tz_localize(None)  without_time_zones.to_excel('Ceyhan_Afra_6days_live.xlsx') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/Tonnage%20List%20API/Recall%20live%20Tonnage%20List/#recall-live-tonnage-list","title":"Recall live tonnage list\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Recall%20live%20Tonnage%20List/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Recall%20live%20Tonnage%20List/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Recall%20live%20Tonnage%20List/#retrieving-a-live-tonnage-list","title":"Retrieving a live tonnage list\u00b6","text":"<p>Retrieving a live tonnage list is almost exactly the same as getting a historical one except, instead of using the <code>get_historical_tonnage_list</code> method, you use the <code>get_tonnage_list</code> method and you don't pass a <code>DateRange</code> as an argument. The <code>get_tonnage_list</code> method returns a single <code>TonnageList</code> that contains live vessel data.</p> <p>Because of this similarity, we can reuse the parameters we used for our HTL queries:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Working%20with%20the%20TonnageListAPI/","title":"Working with the","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <p>Set your subscription key, acquired here: https://apis.signalocean.com/profile</p> In\u00a0[1]: Copied! <pre>signal_ocean_api_key = \"\"  # replace with your subscription key\n</pre> signal_ocean_api_key = \"\"  # replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.tonnage_list import TonnageListAPI\n\nconnection = Connection(signal_ocean_api_key)\napi = TonnageListAPI(connection)\n</pre> from signal_ocean import Connection from signal_ocean.tonnage_list import TonnageListAPI  connection = Connection(signal_ocean_api_key) api = TonnageListAPI(connection) <p>Then, we need to determine the parameters of the historical tonnage list (HTL). In order to fetch an HTL, we will need to specify:</p> <ul> <li>a loading port,</li> <li>a vessel class,</li> <li>a time frame.</li> </ul> <p>Ports and vessel classes can be retrieved through the <code>get_ports</code> and <code>get_vessel_classes</code> methods:</p> In\u00a0[3]: Copied! <pre>api.get_vessel_classes()\n</pre> api.get_vessel_classes()  Out[3]: <pre>(VesselClass(id=60, name='VLGCLpg'),\n VesselClass(id=61, name='MidsizeLpg'),\n VesselClass(id=62, name='HandyLpg'),\n VesselClass(id=63, name='SmallLpg'),\n VesselClass(id=69, name='VLOC'),\n VesselClass(id=70, name='Capesize'),\n VesselClass(id=72, name='PostPanamaxDry'),\n VesselClass(id=74, name='PanamaxDry'),\n VesselClass(id=75, name='Supramax'),\n VesselClass(id=76, name='Handymax'),\n VesselClass(id=77, name='Handysize'),\n VesselClass(id=78, name='ULCV'),\n VesselClass(id=79, name='NewPanamaxContainer'),\n VesselClass(id=80, name='PostPanamaxContainer'),\n VesselClass(id=81, name='PanamaxContainer'),\n VesselClass(id=82, name='FeedermaxContainer'),\n VesselClass(id=83, name='FeederContainer'),\n VesselClass(id=84, name='VLCC'),\n VesselClass(id=85, name='Suezmax'),\n VesselClass(id=86, name='Aframax'),\n VesselClass(id=87, name='PanamaxTanker'),\n VesselClass(id=88, name='MR2'),\n VesselClass(id=89, name='MR1'),\n VesselClass(id=90, name='Small'),\n VesselClass(id=91, name='LNGLng'),\n VesselClass(id=92, name='SmallDry'),\n VesselClass(id=94, name='ULCC'),\n VesselClass(id=95, name='SmallContainer'))</pre> <p>Ports can be looked up by their name using the <code>PortFilter</code>:</p> In\u00a0[4]: Copied! <pre>from signal_ocean.tonnage_list import PortFilter\n\napi.get_ports(PortFilter(name_like=\"rot\"))\n</pre> from signal_ocean.tonnage_list import PortFilter  api.get_ports(PortFilter(name_like=\"rot\")) Out[4]: <pre>(Port(id=3689, name='Rotterdam'),\n Port(id=6625, name='Rota'),\n Port(id=8920, name='Crotone'),\n Port(id=15617, name='Rarotonga'),\n Port(id=4048, name='Rotterdam Anchorage'),\n Port(id=4429, name='Rotterdam Lightering Zone'),\n Port(id=4890, name='Bp Rotterdam Refinery'),\n Port(id=4895, name='Rotterdam Refinery (Esso)'),\n Port(id=5750, name='Vopak Terminal Eurotank'),\n Port(id=5754, name='Eurotank Amsterdam'),\n Port(id=6183, name='Eurotank Terminal Amsterdam'),\n Port(id=6328, name='Petrotitan Xiao Hu Terminal'),\n Port(id=6745, name='Rotim Bulk Terminal'),\n Port(id=6861, name='Rota Dock'),\n Port(id=6862, name='Damen Shiprepair Rotterdam'),\n Port(id=6863, name='Damen Shiprepair Van Brink Rotterdam'),\n Port(id=6865, name='Frigocare Rotterdam'),\n Port(id=6867, name='Lbc Rotterdam'),\n Port(id=7058, name='Phoenix Petroterminals &amp; Industrial Park'),\n Port(id=8476, name='Rotterdam Bulk Terminal'),\n Port(id=9376, name='Crotone Bulk Terminal'),\n Port(id=12788, name='Rotterdam World Gateway'),\n Port(id=12790, name='APM Terminals Rotterdam'),\n Port(id=12792, name='Rotterdam Container Terminal (Kramer Group)'),\n Port(id=12794, name='Rotterdam Shortsea Terminals'),\n Port(id=12953, name='Antwerp Euroterminal NV Container Terminal (Grimaldi Group)'),\n Port(id=15788, name='Rarotonga Tanker Terminal'),\n Port(id=16742, name='Rotterdam Ship Repair'),\n Port(id=17220, name='Gate LNG Terminal (LNG Terminal Rotterdam)'))</pre> <p>And so can vessel classes with the use of the <code>VesselClassFilter</code>:</p> In\u00a0[5]: Copied! <pre>from signal_ocean.tonnage_list import VesselClassFilter\n\napi.get_vessel_classes(VesselClassFilter(name_like=\"MAX\"))\n</pre> from signal_ocean.tonnage_list import VesselClassFilter  api.get_vessel_classes(VesselClassFilter(name_like=\"MAX\")) Out[5]: <pre>(VesselClass(id=72, name='PostPanamaxDry'),\n VesselClass(id=74, name='PanamaxDry'),\n VesselClass(id=75, name='Supramax'),\n VesselClass(id=76, name='Handymax'),\n VesselClass(id=79, name='NewPanamaxContainer'),\n VesselClass(id=80, name='PostPanamaxContainer'),\n VesselClass(id=81, name='PanamaxContainer'),\n VesselClass(id=82, name='FeedermaxContainer'),\n VesselClass(id=85, name='Suezmax'),\n VesselClass(id=86, name='Aframax'),\n VesselClass(id=87, name='PanamaxTanker'))</pre> <p>Note that the search is case-insensitive and does not require specifying exact names.</p> <p>We want our HTL to contain Aframax vessels in Ceyhan, with a 6-day forward laycan end, for the last 90 days:</p> In\u00a0[6]: Copied! <pre>from datetime import timedelta, date\n\nvessel_class_filter = VesselClassFilter(name_like=\"aframax\")\nvessel_class = api.get_vessel_classes(vessel_class_filter)[0]\n\nport_filter = PortFilter(name_like=\"ceyhan\")\nport = api.get_ports(port_filter)[0]\n\nlaycan_end_in_days = 6\ntoday = date.today()\nstart_date = today - timedelta(days=5)\n</pre> from datetime import timedelta, date  vessel_class_filter = VesselClassFilter(name_like=\"aframax\") vessel_class = api.get_vessel_classes(vessel_class_filter)[0]  port_filter = PortFilter(name_like=\"ceyhan\") port = api.get_ports(port_filter)[0]  laycan_end_in_days = 6 today = date.today() start_date = today - timedelta(days=5) <p>With the parameters above, we can now request an HTL:</p> In\u00a0[7]: Copied! <pre>from signal_ocean.tonnage_list import DateRange\n\nhtl = api.get_historical_tonnage_list(\n    port, vessel_class, laycan_end_in_days, DateRange(start_date, today)\n)\n</pre> from signal_ocean.tonnage_list import DateRange  htl = api.get_historical_tonnage_list(     port, vessel_class, laycan_end_in_days, DateRange(start_date, today) )  <p>The resulting historical tonnage list is a Python object that contains a collection of tonnage lists, each of which has a timestamp and a collection of vessel data. The tonnage lists are ordered by date in descending order:</p> In\u00a0[8]: Copied! <pre>yesterdays_tl = htl[1]\nprint(\"Date:\", yesterdays_tl.date)\nprint(\"Vessel count:\", len(yesterdays_tl.vessels))\nprint(\"Example vessel:\", yesterdays_tl.vessels[0])\n</pre> yesterdays_tl = htl[1] print(\"Date:\", yesterdays_tl.date) print(\"Vessel count:\", len(yesterdays_tl.vessels)) print(\"Example vessel:\", yesterdays_tl.vessels[0]) <pre>Date: 2023-09-26 12:00:00+00:00\nVessel count: 90\nExample vessel: Vessel(imo=9038842, name='Icaro', vessel_class='Aframax', ice_class=None, year_built=1993, deadweight=99450, length_overall=243.97, breadth_extreme=46, market_deployment='Program', push_type='Not Pushed', open_port_id=8805, open_port='Taizhou (Zhejiang)', open_date=datetime.datetime(2022, 10, 22, 10, 57, 49, 215000, tzinfo=datetime.timezone.utc), operational_status='Laden', commercial_operator_id=1219, commercial_operator='PDVSA', commercial_status='Available', eta=datetime.datetime(2022, 11, 18, 8, 0, tzinfo=datetime.timezone.utc), latest_ais=datetime.datetime(2022, 10, 19, 0, 23, 51, tzinfo=datetime.timezone.utc), subclass='Dirty', willing_to_switch_subclass=False, open_prediction_accuracy='Narrow Area', open_areas=(Area(id=24726, name='Central China', location_taxonomy='Narrow Area', taxonomy_id=4), Area(id=17, name='China / Taiwan', location_taxonomy='Wide Area', taxonomy_id=5), Area(id=55, name='China', location_taxonomy='Country', taxonomy_id=3)), availability_port_type='Prediction', availability_date_type='Prediction', fixture_type=None, current_vessel_sub_type_id=1, current_vessel_sub_type='Dirty', willing_to_switch_current_vessel_sub_type=False)\n</pre> <p>The result can also be converted into a Pandas data frame:</p> In\u00a0[9]: Copied! <pre>data_frame = htl.to_data_frame()\ndata_frame\n</pre> data_frame = htl.to_data_frame() data_frame Out[9]: name vessel_class ice_class year_built deadweight length_overall breadth_extreme subclass market_deployment_point_in_time push_type_point_in_time ... open_prediction_accuracy_point_in_time open_country_point_in_time open_narrow_area_point_in_time open_wide_area_point_in_time availability_port_type_point_in_time availability_date_type_point_in_time fixture_type_point_in_time current_vessel_sub_type_id_point_in_time current_vessel_sub_type_point_in_time willing_to_switch_current_vessel_sub_type_point_in_time date imo 2023-09-26 12:00:00+00:00 9038842 Icaro Aframax NaN 1993 99450 243.97 46 Dirty Program Not Pushed ... Narrow Area China Central China China / Taiwan Prediction Prediction NaN 1 Prediction False 9543512 Paramaconi Aframax NaN 2011 104554 228.60 42 Dirty Program Not Pushed ... Narrow Area Venezuela, Bolivarian Republic of Caribs Caribs Source Source NaN 1 Source False 9199713 Bovista Aframax NaN 1999 106644 240.50 42 Dirty Contract Not Pushed ... Narrow Area Namibia South Africa South East Africa Source Source NaN 1 Source False 9133587 Pablo Aframax NaN 1997 96773 232.04 42 Dirty Contract Not Pushed ... Narrow Area Singapore Singapore / Malaysia South East Asia Source Source NaN 1 Source False 9187629 Artavil Aframax NaN 2000 99144 248.00 43 Dirty Contract Not Pushed ... Narrow Area Singapore Singapore / Malaysia South East Asia Prediction Prediction NaN 1 Prediction False ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2023-09-22 12:00:00+00:00 9304643 Chris Aframax NaN 2004 105778 239.00 42 Dirty Contract Not Pushed ... Port Egypt Red Sea Red Sea Source Prediction NaN 1 Prediction False 9865116 Sparto Aframax NaN 2020 115468 249.90 44 Dirty Relet Pushed ... Narrow Area Algeria West Mediterranean Mediterranean Source Source NaN 1 Source False 9920497 Newbury Aframax NaN 2022 112095 237.00 44 Dirty Spot Pushed ... Port Italy Central Mediterranean Mediterranean Source Prediction NaN 1 Prediction False 9791298 Navig8 Promise Aframax NaN 2019 109992 249.90 44 Dirty Spot Not Pushed ... Narrow Area Spain West Mediterranean Mediterranean Source Source Scraped 1 Source False 9460576 Safeen Baroness Aframax NaN 2011 105335 228.60 42 Dirty Spot Pushed POSS ... Narrow Area Turkey East Mediterranean Mediterranean Prediction Prediction NaN 1 Prediction False <p>432 rows \u00d7 29 columns</p> In\u00a0[10]: Copied! <pre>from signal_ocean.tonnage_list import (\n    VesselFilter,\n    PushType,\n    MarketDeployment,\n    CommercialStatus,\n    VesselSubclass,\n)\n\nvessel_filter = VesselFilter(\n    push_types=[PushType.PUSHED],\n    market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],\n    commercial_statuses=[\n        CommercialStatus.AVAILABLE,\n        CommercialStatus.CANCELLED,\n        CommercialStatus.FAILED,\n    ],\n    vessel_subclass=VesselSubclass.DIRTY,\n    latest_ais_since=5,\n)\n</pre> from signal_ocean.tonnage_list import (     VesselFilter,     PushType,     MarketDeployment,     CommercialStatus,     VesselSubclass, )  vessel_filter = VesselFilter(     push_types=[PushType.PUSHED],     market_deployments=[MarketDeployment.RELET, MarketDeployment.SPOT],     commercial_statuses=[         CommercialStatus.AVAILABLE,         CommercialStatus.CANCELLED,         CommercialStatus.FAILED,     ],     vessel_subclass=VesselSubclass.DIRTY,     latest_ais_since=5, )  <p>Note the usage of the <code>PushType</code>, <code>MarketDeployment</code>, <code>CommercialStatus</code>, and <code>VesselSubclass</code>. These are enum-like classes that contain constants for all the possible values for a given <code>VesselFilter</code> parameter. To list the available values for any of the classes, just invoke <code>list()</code> on the class:</p> In\u00a0[11]: Copied! <pre>list(CommercialStatus)\n</pre> list(CommercialStatus) Out[11]: <pre>['On Subs', 'Failed', 'Cancelled', 'Available', 'Poss Fixed']</pre> <p>You can use these values directly or use a corresponding class member:</p> In\u00a0[12]: Copied! <pre>CommercialStatus.ON_SUBS == 'On Subs'\n</pre> CommercialStatus.ON_SUBS == 'On Subs' Out[12]: <pre>True</pre> <p>Let's get the HTL for our filter:</p> In\u00a0[43]: Copied! <pre>beginning_of_year = date(today.year, 1, 1)\n\nhtl_for_supply_trend = api.get_historical_tonnage_list(\n    port,\n    vessel_class,\n    laycan_end_in_days,\n    DateRange(start_date, today),\n    vessel_filter=vessel_filter,\n)\n\nsupply_trend_data_frame = htl_for_supply_trend.to_data_frame()\nsupply_trend_data_frame\n</pre> beginning_of_year = date(today.year, 1, 1)  htl_for_supply_trend = api.get_historical_tonnage_list(     port,     vessel_class,     laycan_end_in_days,     DateRange(start_date, today),     vessel_filter=vessel_filter, )  supply_trend_data_frame = htl_for_supply_trend.to_data_frame() supply_trend_data_frame  Out[43]: name vessel_class ice_class year_built deadweight length_overall breadth_extreme subclass market_deployment_point_in_time push_type_point_in_time ... open_prediction_accuracy_point_in_time open_country_point_in_time open_narrow_area_point_in_time open_wide_area_point_in_time availability_port_type_point_in_time availability_date_type_point_in_time fixture_type_point_in_time current_vessel_sub_type_id_point_in_time current_vessel_sub_type_point_in_time willing_to_switch_current_vessel_sub_type_point_in_time date imo 2023-09-26 12:00:00+00:00 9437684 Chrysalis Aframax NaN 2010 115867 248.96 44 Dirty Spot Pushed ... Narrow Area Egypt East Mediterranean Mediterranean Source Source NaN 1 Source False 9592264 Nissos Serifos Aframax NaN 2012 115689 248.97 44 Dirty Spot Pushed ... Narrow Area Egypt East Mediterranean Mediterranean Source Source NaN 1 Source False 9386536 Stealth Haralambos Aframax NaN 2009 113021 249.96 44 Dirty Spot Pushed ... Narrow Area Egypt East Mediterranean Mediterranean Source Source NaN 1 Source False 9231468 Giuse Aframax NaN 2002 109390 244.60 42 Dirty Relet Pushed ... Narrow Area Greece East Mediterranean Mediterranean Source Source NaN 1 Source False 9592305 Nissos Delos Aframax NaN 2012 115691 248.97 44 Dirty Spot Pushed ... Narrow Area Egypt Red Sea Red Sea Source Source NaN 1 Source False ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2023-09-22 12:00:00+00:00 9309423 Minerva Nounou Aframax 1A 2006 114850 253.59 44 Dirty Spot Pushed ... Narrow Area Turkey Sea of Marmara Black Sea / Sea Of Marmara Source Source NaN 1 Source False 9386536 Stealth Haralambos Aframax NaN 2009 113021 249.96 44 Dirty Spot Pushed ... Narrow Area Sudan Red Sea Red Sea Source Source NaN 1 Source False 9388364 Merbabu Aframax NaN 2008 105746 243.97 42 Dirty Spot Pushed ... Port Saudi Arabia Red Sea Red Sea Source Prediction NaN 1 Prediction False 9865116 Sparto Aframax NaN 2020 115468 249.90 44 Dirty Relet Pushed ... Narrow Area Algeria West Mediterranean Mediterranean Source Source NaN 1 Source False 9920497 Newbury Aframax NaN 2022 112095 237.00 44 Dirty Spot Pushed ... Port Italy Central Mediterranean Mediterranean Source Prediction NaN 1 Prediction False <p>63 rows \u00d7 29 columns</p> <p>Now, we can generate the plot:</p> In\u00a0[44]: Copied! <pre>from signal_ocean.tonnage_list import IndexLevel\n\nsupply_trend = supply_trend_data_frame.groupby(\n    IndexLevel.DATE, sort=True\n).size()\n\nplot = supply_trend.plot()\nplot.set_ylabel(\"Vessel count\")\nplot.set_title(\"Ceyhan Aframax Laycan 6 days\")\nplot\n</pre> from signal_ocean.tonnage_list import IndexLevel  supply_trend = supply_trend_data_frame.groupby(     IndexLevel.DATE, sort=True ).size()  plot = supply_trend.plot() plot.set_ylabel(\"Vessel count\") plot.set_title(\"Ceyhan Aframax Laycan 6 days\") plot  Out[44]: <pre>&lt;AxesSubplot: title={'center': 'Ceyhan Aframax Laycan 6 days'}, xlabel='date', ylabel='Vessel count'&gt;</pre> In\u00a0[70]: Copied! <pre>import pandas as pd\n\nsupply_trend_data_frame[\"open_date_point_in_time\"] = pd.to_datetime(supply_trend_data_frame[\"open_date_point_in_time\"]).dt.tz_localize(None)\nsupply_trend_data_frame[\"eta_point_in_time\"] = pd.to_datetime(supply_trend_data_frame[\"eta_point_in_time\"]).dt.tz_localize(None)\nsupply_trend_data_frame[\"latest_ais_point_in_time\"] = pd.to_datetime(supply_trend_data_frame[\"latest_ais_point_in_time\"]).dt.tz_localize(None)\n\nwithout_time_zones = (\n    supply_trend_data_frame.reset_index()\n    .set_index(IndexLevel.IMO)\n)\nwithout_time_zones[\"date\"] = pd.to_datetime(without_time_zones[\"date\"]).dt.tz_localize(None)\n</pre> import pandas as pd  supply_trend_data_frame[\"open_date_point_in_time\"] = pd.to_datetime(supply_trend_data_frame[\"open_date_point_in_time\"]).dt.tz_localize(None) supply_trend_data_frame[\"eta_point_in_time\"] = pd.to_datetime(supply_trend_data_frame[\"eta_point_in_time\"]).dt.tz_localize(None) supply_trend_data_frame[\"latest_ais_point_in_time\"] = pd.to_datetime(supply_trend_data_frame[\"latest_ais_point_in_time\"]).dt.tz_localize(None)  without_time_zones = (     supply_trend_data_frame.reset_index()     .set_index(IndexLevel.IMO) ) without_time_zones[\"date\"] = pd.to_datetime(without_time_zones[\"date\"]).dt.tz_localize(None) <p>Now, we can generate the Excel file:</p> In\u00a0[71]: Copied! <pre>without_time_zones.to_excel('Ceyhan_Afra_6days_history.xlsx')\n</pre> without_time_zones.to_excel('Ceyhan_Afra_6days_history.xlsx') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/Tonnage%20List%20API/Working%20with%20the%20TonnageListAPI/#working-with-the-tonnagelistapi","title":"Working with the <code>TonnageListAPI</code>\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Working%20with%20the%20TonnageListAPI/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/Tonnage%20List%20API/Working%20with%20the%20TonnageListAPI/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Working%20with%20the%20TonnageListAPI/#retrieving-a-historical-tonnage-list","title":"Retrieving a historical tonnage list\u00b6","text":"<p>First, we need to create an instance of the <code>TonnageListAPI</code>:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Working%20with%20the%20TonnageListAPI/#example-1-plotting-a-supply-trend","title":"Example 1 - Plotting a supply trend\u00b6","text":"<p>The data frame format makes it very easy to generate a supply trend plot.</p> <p>We'll generate a supply trend from the beginning of the year, but we'll also filter the vessel list by looking for vessels that:</p> <ul> <li>are pushed,</li> <li>have a market deployment type of \"Relet\" or \"Spot\",</li> <li>their commercial status is available, cancelled or failed,</li> <li>are crude oil tankers (their vessel subclass is \"Dirty\"),</li> <li>their AIS information is no older than 5 days.</li> </ul> <p>Filtering can be achieved by creating an instance of a <code>VesselFilter</code> and passing it to the <code>get_historical_tonnage_list</code> method. A <code>VesselFilter</code> meeting the above criteria will look as follows:</p>"},{"location":"examples/jupyter/Tonnage%20List%20API/Working%20with%20the%20TonnageListAPI/#example-2-generating-an-excel-sheet","title":"Example 2 - Generating an Excel sheet\u00b6","text":"<p>The data frame can be easily saved as an Excel file by using Pandas's built-in <code>to_excel()</code> function.</p> <p>Before we do that, we need to remove all the time zone information from all timestamps in the data frame. This is because Excel does not support storing time zone information along with timestamps. However, Signal Ocean's SDK always provides time zone information to make all timestamp-based computation unambiguous.</p>"},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/","title":"Valuations API Examples","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from datetime import date, timedelta\nfrom tqdm import tqdm\n\nimport requests\nimport json\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import PolyCollection\nimport numpy as np\nsns.set_theme()\nsns.set_style(\"whitegrid\")\n</pre> from datetime import date, timedelta from tqdm import tqdm  import requests import json import pandas as pd import seaborn as sns import matplotlib.pyplot as plt from matplotlib.collections import PolyCollection import numpy as np sns.set_theme() sns.set_style(\"whitegrid\") In\u00a0[3]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.vessels import VesselsAPI\n\nconnection = Connection(signal_ocean_api_key)\nvessels_api = VesselsAPI(connection)\n</pre> from signal_ocean import Connection from signal_ocean.vessels import VesselsAPI  connection = Connection(signal_ocean_api_key) vessels_api = VesselsAPI(connection) In\u00a0[4]: Copied! <pre>vessel_classes = [84, 85, 86, 87]\n\nvessel_class_vessels = {\n    vessel_class: [v.imo for v in vessels_api.get_vessels_by_vessel_class(vessel_class)] \n    for vessel_class in vessel_classes\n}\n</pre> vessel_classes = [84, 85, 86, 87]  vessel_class_vessels = {     vessel_class: [v.imo for v in vessels_api.get_vessels_by_vessel_class(vessel_class)]      for vessel_class in vessel_classes } In\u00a0[5]: Copied! <pre>from signal_ocean.vessel_valuations import VesselValuationsAPI\n\nvaluations_api = VesselValuationsAPI(connection)\n</pre> from signal_ocean.vessel_valuations import VesselValuationsAPI  valuations_api = VesselValuationsAPI(connection) In\u00a0[6]: Copied! <pre>vessel_valuations_list = []\n\nfor vc, imo_list in vessel_class_vessels.items():\n    # Get list of valuation objects for these vessel class\n    vessel_class_valuations = valuations_api.get_latest_valuations_for_list_of_vessels(imo_list)\n    # Cast vessel valuations to dict objects and add the vessel class key\n    vessel_class_valuations = [dict(valuation.to_dict(), **{'vesselClass':vc}) for valuation in vessel_class_valuations]\n    # Update the list of all vessels\n    vessel_valuations_list.extend(vessel_class_valuations)\n\nvaluations_df = pd.DataFrame.from_records(vessel_valuations_list)\n</pre> vessel_valuations_list = []  for vc, imo_list in vessel_class_vessels.items():     # Get list of valuation objects for these vessel class     vessel_class_valuations = valuations_api.get_latest_valuations_for_list_of_vessels(imo_list)     # Cast vessel valuations to dict objects and add the vessel class key     vessel_class_valuations = [dict(valuation.to_dict(), **{'vesselClass':vc}) for valuation in vessel_class_valuations]     # Update the list of all vessels     vessel_valuations_list.extend(vessel_class_valuations)  valuations_df = pd.DataFrame.from_records(vessel_valuations_list) In\u00a0[7]: Copied! <pre>def set_violins_transparency(violins, alpha):\n  for violin in violins.get_children():\n    if isinstance(violin, PolyCollection):\n      violin.set_alpha(alpha)\n</pre> def set_violins_transparency(violins, alpha):   for violin in violins.get_children():     if isinstance(violin, PolyCollection):       violin.set_alpha(alpha) In\u00a0[8]: Copied! <pre>plt.figure(figsize=(16,8))\nvaluations_df.sort_values('vesselClass', inplace=True)\n\nviolins = sns.violinplot(x='vesselClass', y='valuationPrice', data=valuations_df, color=\".0\")\n\nset_violins_transparency(violins, 0.3)\n\nsns.boxplot(x='vesselClass', y='valuationPrice', data=valuations_df)\nsns.stripplot(x='vesselClass', y='valuationPrice', data=valuations_df, color=\".25\")\n\nplt.ylabel(\"Valuation in million $\", fontsize=14)\nplt.xlabel(\"Vessel Class\", fontsize=14)\nplt.title(\"Valuation per Vessel Class\", fontsize=18)\nplt.show()\n</pre> plt.figure(figsize=(16,8)) valuations_df.sort_values('vesselClass', inplace=True)  violins = sns.violinplot(x='vesselClass', y='valuationPrice', data=valuations_df, color=\".0\")  set_violins_transparency(violins, 0.3)  sns.boxplot(x='vesselClass', y='valuationPrice', data=valuations_df) sns.stripplot(x='vesselClass', y='valuationPrice', data=valuations_df, color=\".25\")  plt.ylabel(\"Valuation in million $\", fontsize=14) plt.xlabel(\"Vessel Class\", fontsize=14) plt.title(\"Valuation per Vessel Class\", fontsize=18) plt.show() In\u00a0[9]: Copied! <pre>vessel_1 = 9453315\nvaluation_history = valuations_api.get_all_historical_valuations_by_imo(vessel_1)\nvessel_1_df = pd.DataFrame.from_records([valuation.to_dict() for valuation in valuation_history])\n\nvessel_2 = 9318084\nvaluation_history = valuations_api.get_all_historical_valuations_by_imo(vessel_2)\nvessel_2_df = pd.DataFrame.from_records([valuation.to_dict() for valuation in valuation_history])\n</pre> vessel_1 = 9453315 valuation_history = valuations_api.get_all_historical_valuations_by_imo(vessel_1) vessel_1_df = pd.DataFrame.from_records([valuation.to_dict() for valuation in valuation_history])  vessel_2 = 9318084 valuation_history = valuations_api.get_all_historical_valuations_by_imo(vessel_2) vessel_2_df = pd.DataFrame.from_records([valuation.to_dict() for valuation in valuation_history]) In\u00a0[10]: Copied! <pre>vessel_1_df['valueFrom'] = pd.to_datetime(vessel_1_df['valueFrom'])\nvessel_1_oldest_date, vessel_1_latest_date = vessel_1_df['valueFrom'].min(), vessel_1_df['valueFrom'].max()\n\nvessel_1_oldest_valuation = vessel_1_df[vessel_1_df['valueFrom']==vessel_1_oldest_date]['valuationPrice'].iloc[0]\nvessel_1_latest_valuation = vessel_1_df[vessel_1_df['valueFrom']==vessel_1_latest_date]['valuationPrice'].iloc[0]\n\nvessel_1_oldest_scrap = vessel_1_df[vessel_1_df['valueFrom']==vessel_1_oldest_date]['scrapPrice'].iloc[0]\nvessel_1_latest_scrap = vessel_1_df[vessel_1_df['valueFrom']==vessel_1_latest_date]['scrapPrice'].iloc[0]\n\n\nvessel_2_df['valueFrom'] = pd.to_datetime(vessel_2_df['valueFrom'])\nvessel_2_oldest_date, vessel_2_latest_date = vessel_2_df['valueFrom'].min(), vessel_2_df['valueFrom'].max()\n\nvessel_2_oldest_valuation = vessel_2_df[vessel_2_df['valueFrom']==vessel_2_oldest_date]['valuationPrice'].iloc[0]\nvessel_2_latest_valuation = vessel_2_df[vessel_2_df['valueFrom']==vessel_2_latest_date]['valuationPrice'].iloc[0]\n\nvessel_2_oldest_scrap = vessel_2_df[vessel_2_df['valueFrom']==vessel_2_oldest_date]['scrapPrice'].iloc[0]\nvessel_2_latest_scrap = vessel_2_df[vessel_2_df['valueFrom']==vessel_2_latest_date]['scrapPrice'].iloc[0]\n</pre> vessel_1_df['valueFrom'] = pd.to_datetime(vessel_1_df['valueFrom']) vessel_1_oldest_date, vessel_1_latest_date = vessel_1_df['valueFrom'].min(), vessel_1_df['valueFrom'].max()  vessel_1_oldest_valuation = vessel_1_df[vessel_1_df['valueFrom']==vessel_1_oldest_date]['valuationPrice'].iloc[0] vessel_1_latest_valuation = vessel_1_df[vessel_1_df['valueFrom']==vessel_1_latest_date]['valuationPrice'].iloc[0]  vessel_1_oldest_scrap = vessel_1_df[vessel_1_df['valueFrom']==vessel_1_oldest_date]['scrapPrice'].iloc[0] vessel_1_latest_scrap = vessel_1_df[vessel_1_df['valueFrom']==vessel_1_latest_date]['scrapPrice'].iloc[0]   vessel_2_df['valueFrom'] = pd.to_datetime(vessel_2_df['valueFrom']) vessel_2_oldest_date, vessel_2_latest_date = vessel_2_df['valueFrom'].min(), vessel_2_df['valueFrom'].max()  vessel_2_oldest_valuation = vessel_2_df[vessel_2_df['valueFrom']==vessel_2_oldest_date]['valuationPrice'].iloc[0] vessel_2_latest_valuation = vessel_2_df[vessel_2_df['valueFrom']==vessel_2_latest_date]['valuationPrice'].iloc[0]  vessel_2_oldest_scrap = vessel_2_df[vessel_2_df['valueFrom']==vessel_2_oldest_date]['scrapPrice'].iloc[0] vessel_2_latest_scrap = vessel_2_df[vessel_2_df['valueFrom']==vessel_2_latest_date]['scrapPrice'].iloc[0] In\u00a0[11]: Copied! <pre>plt.figure(figsize=(16,8))\n\nsns.lineplot(y='valuationPrice', x='valueFrom', data=vessel_1_df, label=f'Vessel Valuation: {vessel_1}', color='b')\nplt.scatter(x=vessel_1_oldest_date, y=vessel_1_oldest_valuation, color='b')\nplt.scatter(x=vessel_1_latest_date, y=vessel_1_latest_valuation, color='b')\nplt.annotate(str(round(vessel_1_oldest_valuation, 3)), xy=(vessel_1_oldest_date, vessel_1_oldest_valuation+1),weight='bold', fontsize=10)\nplt.annotate(str(round(vessel_1_latest_valuation, 3)), xy=(vessel_1_latest_date, vessel_1_latest_valuation+1),weight='bold', fontsize=10)\n\nsns.lineplot(y='scrapPrice', x='valueFrom', data=vessel_1_df, label=f'Scrap Valuation: {vessel_1}', color='orange')\nplt.scatter(x=vessel_1_oldest_date, y=vessel_1_oldest_scrap, color='orange')\nplt.scatter(x=vessel_1_latest_date, y=vessel_1_latest_scrap, color='orange')\nplt.annotate(str(round(vessel_1_oldest_scrap, 3)), xy=(vessel_1_oldest_date, vessel_1_oldest_scrap+1),weight='bold', fontsize=10)\nplt.annotate(str(round(vessel_1_latest_scrap, 3)), xy=(vessel_1_latest_date, vessel_1_latest_scrap+1),weight='bold', fontsize=10)\n\nsns.lineplot(y='valuationPrice', x='valueFrom', data=vessel_2_df, label=f'Vessel Valuation: {vessel_2}', color='g')\nplt.scatter(x=vessel_2_oldest_date, y=vessel_2_oldest_valuation, color='g')\nplt.scatter(x=vessel_2_latest_date, y=vessel_2_latest_valuation, color='g')\nplt.annotate(str(round(vessel_2_oldest_valuation, 3)), xy=(vessel_2_oldest_date, vessel_2_oldest_valuation+1),weight='bold', fontsize=10)\nplt.annotate(str(round(vessel_2_latest_valuation, 3)), xy=(vessel_2_latest_date, vessel_2_latest_valuation+1),weight='bold', fontsize=10)\n\nsns.lineplot(y='scrapPrice', x='valueFrom', data=vessel_2_df, label=f'Scrap Valuation: {vessel_2}', color='r')\nplt.scatter(x=vessel_1_oldest_date, y=vessel_2_oldest_scrap, color='r')\nplt.scatter(x=vessel_1_latest_date, y=vessel_2_latest_scrap, color='r')\nplt.annotate(str(round(vessel_2_oldest_scrap, 3)), xy=(vessel_2_oldest_date, vessel_2_oldest_scrap-2),weight='bold', fontsize=10)\nplt.annotate(str(round(vessel_2_latest_scrap, 3)), xy=(vessel_2_latest_date, vessel_2_latest_scrap-2),weight='bold', fontsize=10)\n\n\nplt.ylabel(\"Valuation in million $\", fontsize=14)\nplt.xlabel(\"Valuation Date\", fontsize=14)\nplt.show()\n</pre> plt.figure(figsize=(16,8))  sns.lineplot(y='valuationPrice', x='valueFrom', data=vessel_1_df, label=f'Vessel Valuation: {vessel_1}', color='b') plt.scatter(x=vessel_1_oldest_date, y=vessel_1_oldest_valuation, color='b') plt.scatter(x=vessel_1_latest_date, y=vessel_1_latest_valuation, color='b') plt.annotate(str(round(vessel_1_oldest_valuation, 3)), xy=(vessel_1_oldest_date, vessel_1_oldest_valuation+1),weight='bold', fontsize=10) plt.annotate(str(round(vessel_1_latest_valuation, 3)), xy=(vessel_1_latest_date, vessel_1_latest_valuation+1),weight='bold', fontsize=10)  sns.lineplot(y='scrapPrice', x='valueFrom', data=vessel_1_df, label=f'Scrap Valuation: {vessel_1}', color='orange') plt.scatter(x=vessel_1_oldest_date, y=vessel_1_oldest_scrap, color='orange') plt.scatter(x=vessel_1_latest_date, y=vessel_1_latest_scrap, color='orange') plt.annotate(str(round(vessel_1_oldest_scrap, 3)), xy=(vessel_1_oldest_date, vessel_1_oldest_scrap+1),weight='bold', fontsize=10) plt.annotate(str(round(vessel_1_latest_scrap, 3)), xy=(vessel_1_latest_date, vessel_1_latest_scrap+1),weight='bold', fontsize=10)  sns.lineplot(y='valuationPrice', x='valueFrom', data=vessel_2_df, label=f'Vessel Valuation: {vessel_2}', color='g') plt.scatter(x=vessel_2_oldest_date, y=vessel_2_oldest_valuation, color='g') plt.scatter(x=vessel_2_latest_date, y=vessel_2_latest_valuation, color='g') plt.annotate(str(round(vessel_2_oldest_valuation, 3)), xy=(vessel_2_oldest_date, vessel_2_oldest_valuation+1),weight='bold', fontsize=10) plt.annotate(str(round(vessel_2_latest_valuation, 3)), xy=(vessel_2_latest_date, vessel_2_latest_valuation+1),weight='bold', fontsize=10)  sns.lineplot(y='scrapPrice', x='valueFrom', data=vessel_2_df, label=f'Scrap Valuation: {vessel_2}', color='r') plt.scatter(x=vessel_1_oldest_date, y=vessel_2_oldest_scrap, color='r') plt.scatter(x=vessel_1_latest_date, y=vessel_2_latest_scrap, color='r') plt.annotate(str(round(vessel_2_oldest_scrap, 3)), xy=(vessel_2_oldest_date, vessel_2_oldest_scrap-2),weight='bold', fontsize=10) plt.annotate(str(round(vessel_2_latest_scrap, 3)), xy=(vessel_2_latest_date, vessel_2_latest_scrap-2),weight='bold', fontsize=10)   plt.ylabel(\"Valuation in million $\", fontsize=14) plt.xlabel(\"Valuation Date\", fontsize=14) plt.show()"},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#valuations-api-examples","title":"Valuations API Examples\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#use-case-1-average-valuation-per-vessel-class","title":"Use Case 1: Average valuation per vessel class.\u00b6","text":"<p>In this Use Case we will use Valuations API to get latest valuations for tanker vessels and visualize them by vessel class for  vessel classes 84, 85, 86, 87.</p>"},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#import-helpful-modules","title":"Import helpful modules\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#get-imo-numbers-for-the-vessel-classes-of-interest-using-vessel-api","title":"Get imo numbers for the vessel classes of interest using Vessel API.\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#initialize-vessels-api","title":"Initialize Vessels API\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#get-list-of-imo-numbers-per-vessel-class","title":"Get list of imo numbers per vessel class\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#initialize-vessels-api","title":"Initialize Vessels API\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#create-a-list-of-vessel-valuations-calling-valuations-api","title":"Create a list of Vessel Valuations calling Valuations API\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#visuals","title":"Visuals\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#create-box-plots-for-valuations-per-vessel-class","title":"Create box plots for valuations per vessel class\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#use-case-2-historical-and-current-vessel-valuation","title":"Use Case 2: Historical and Current Vessel Valuation.\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#get-historical-valuations-for-2-tanker-vessels-and-store-to-dataframes","title":"Get historical valuations for 2 tanker vessels and store to Dataframes\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#feature-engineering","title":"Feature Engineering\u00b6","text":"<p>Convert string date column to datetime and save oldest and latest date, valuation and scrap valuation for the 2 vessels</p>"},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#visuals","title":"Visuals\u00b6","text":""},{"location":"examples/jupyter/ValuationsAPI/ValuationsAPIUse-Cases/#plot-valuations-time-series","title":"Plot valuations time series.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/","title":"Vessel Emissions API Use Case","text":"In\u00a0[1]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <pre>Collecting signal-ocean\n  Downloading signal_ocean-13.3.0-py3-none-any.whl.metadata (2.2 kB)\nRequirement already satisfied: requests&lt;3,&gt;=2.23.0 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.32.3)\nRequirement already satisfied: python-dateutil&lt;3,&gt;=2.8.1 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.8.2)\nRequirement already satisfied: pandas&lt;3,&gt;=1.0.3 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.2.2)\nRequirement already satisfied: numpy&gt;=1.18.5 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (1.26.4)\nCollecting strictly-typed-pandas==0.1.4 (from signal-ocean)\n  Downloading strictly_typed_pandas-0.1.4-py3-none-any.whl.metadata (3.0 kB)\nCollecting typeguard&lt;3.0.0,&gt;=2.13.3 (from signal-ocean)\n  Downloading typeguard-2.13.3-py3-none-any.whl.metadata (3.6 kB)\nRequirement already satisfied: pandas-stubs in /usr/local/lib/python3.11/dist-packages (from strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2.2.2.240909)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil&lt;3,&gt;=2.8.1-&gt;signal-ocean) (1.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.4.1)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.3.0)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2025.1.31)\nRequirement already satisfied: types-pytz&gt;=2022.1.1 in /usr/local/lib/python3.11/dist-packages (from pandas-stubs-&gt;strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2025.1.0.20250204)\nDownloading signal_ocean-13.3.0-py3-none-any.whl (155 kB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 155.6/155.6 kB 2.7 MB/s eta 0:00:00\nDownloading strictly_typed_pandas-0.1.4-py3-none-any.whl (9.6 kB)\nDownloading typeguard-2.13.3-py3-none-any.whl (17 kB)\nInstalling collected packages: typeguard, strictly-typed-pandas, signal-ocean\n  Attempting uninstall: typeguard\n    Found existing installation: typeguard 4.4.2\n    Uninstalling typeguard-4.4.2:\n      Successfully uninstalled typeguard-4.4.2\nERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.\ninflect 7.5.0 requires typeguard&gt;=4.0.1, but you have typeguard 2.13.3 which is incompatible.\nSuccessfully installed signal-ocean-13.3.0 strictly-typed-pandas-0.1.4 typeguard-2.13.3\n</pre> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n\nfrom signal_ocean import Connection\nfrom signal_ocean.vessel_emissions import VesselEmissionsAPI\n\nconnection = Connection(signal_ocean_api_key)\nemissions_api = VesselEmissionsAPI(connection)\n</pre> signal_ocean_api_key = '' #replace with your subscription key  from signal_ocean import Connection from signal_ocean.vessel_emissions import VesselEmissionsAPI  connection = Connection(signal_ocean_api_key) emissions_api = VesselEmissionsAPI(connection) <pre>Requirement already satisfied: signal-ocean in /usr/local/lib/python3.11/dist-packages (13.3.0)\nRequirement already satisfied: requests&lt;3,&gt;=2.23.0 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.32.3)\nRequirement already satisfied: python-dateutil&lt;3,&gt;=2.8.1 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.8.2)\nRequirement already satisfied: pandas&lt;3,&gt;=1.0.3 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.2.2)\nRequirement already satisfied: numpy&gt;=1.18.5 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (1.26.4)\nRequirement already satisfied: strictly-typed-pandas==0.1.4 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (0.1.4)\nRequirement already satisfied: typeguard&lt;3.0.0,&gt;=2.13.3 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.13.3)\nRequirement already satisfied: pandas-stubs in /usr/local/lib/python3.11/dist-packages (from strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2.2.2.240909)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil&lt;3,&gt;=2.8.1-&gt;signal-ocean) (1.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.4.1)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.3.0)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2025.1.31)\nRequirement already satisfied: types-pytz&gt;=2022.1.1 in /usr/local/lib/python3.11/dist-packages (from pandas-stubs-&gt;strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2025.1.0.20250204)\n</pre> In\u00a0[3]: Copied! <pre>from datetime import date, timedelta\nfrom tqdm import tqdm\n\nimport requests\nimport json\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import PolyCollection\nimport numpy as np\nsns.set_theme()\nsns.set_style(\"whitegrid\")\n</pre> from datetime import date, timedelta from tqdm import tqdm  import requests import json import pandas as pd import seaborn as sns import matplotlib.pyplot as plt from matplotlib.collections import PolyCollection import numpy as np sns.set_theme() sns.set_style(\"whitegrid\") In\u00a0[4]: Copied! <pre>vessel_imos = [ 9299111, 9314193, 9411197, 9425526, 9440473, 9459096, 9461659, 9462354, 9486922, 9486934, 9487469, 9487471, 9487483, 9505819,\n               9524982, 9543536, 9580405, 9688336, 9688348, 9723007, 9726619, 9767340, 9773947, 9780251, 9783992, 9833723 ]\n</pre> vessel_imos = [ 9299111, 9314193, 9411197, 9425526, 9440473, 9459096, 9461659, 9462354, 9486922, 9486934, 9487469, 9487471, 9487483, 9505819,                9524982, 9543536, 9580405, 9688336, 9688348, 9723007, 9726619, 9767340, 9773947, 9780251, 9783992, 9833723 ] In\u00a0[5]: Copied! <pre>emissions_list = []\nmetrics_list = []\n\nfor imo in tqdm(vessel_imos):\n    vessel_emissions = emissions_api.get_emissions_by_imo(imo)\n    vessel_emissions = [emissions.to_dict() for emissions in vessel_emissions]\n    emissions_list.extend(vessel_emissions)\n    vessel_metrics = emissions_api.get_metrics_by_imo(imo)\n    vessel_metrics = [metrics.to_dict() for metrics in vessel_metrics]\n    metrics_list.extend(vessel_metrics)\n\nemissions_df = pd.json_normalize(emissions_list, sep='')\nemissions_df = emissions_df[emissions_df['StartDate'] &gt;= '2023']\nmetrics_df = pd.json_normalize(metrics_list, sep='')\nmetrics_df = metrics_df[metrics_df['Year'] &gt;= 2023]\n</pre> emissions_list = [] metrics_list = []  for imo in tqdm(vessel_imos):     vessel_emissions = emissions_api.get_emissions_by_imo(imo)     vessel_emissions = [emissions.to_dict() for emissions in vessel_emissions]     emissions_list.extend(vessel_emissions)     vessel_metrics = emissions_api.get_metrics_by_imo(imo)     vessel_metrics = [metrics.to_dict() for metrics in vessel_metrics]     metrics_list.extend(vessel_metrics)  emissions_df = pd.json_normalize(emissions_list, sep='') emissions_df = emissions_df[emissions_df['StartDate'] &gt;= '2023'] metrics_df = pd.json_normalize(metrics_list, sep='') metrics_df = metrics_df[metrics_df['Year'] &gt;= 2023] <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 26/26 [00:55&lt;00:00,  2.13s/it]\n</pre> In\u00a0[6]: Copied! <pre>emissions_df.groupby(\"VesselClass\")['EmissionsVoyageCO2InTons'].mean()\n</pre> emissions_df.groupby(\"VesselClass\")['EmissionsVoyageCO2InTons'].mean() Out[6]: EmissionsVoyageCO2InTons VesselClass Aframax 1432.394487 MR1 719.735044 MR2 605.297518 Panamax 850.613621 Suezmax 1671.113432 dtype: float64 In\u00a0[7]: Copied! <pre>emissions_per_vessel = emissions_df.groupby(\"VesselName\")['EmissionsVoyageCO2InTons'].mean().reset_index()\nplt.figure(figsize=(16,8))\nemissions_per_vessel.sort_values('EmissionsVoyageCO2InTons', inplace=True)\nsns.barplot(x='VesselName', y='EmissionsVoyageCO2InTons', data=emissions_per_vessel)\nplt.xticks(rotation=90)\nplt.title('CO2 Emitted per Vessel', fontsize=14)\nplt.show()\n</pre> emissions_per_vessel = emissions_df.groupby(\"VesselName\")['EmissionsVoyageCO2InTons'].mean().reset_index() plt.figure(figsize=(16,8)) emissions_per_vessel.sort_values('EmissionsVoyageCO2InTons', inplace=True) sns.barplot(x='VesselName', y='EmissionsVoyageCO2InTons', data=emissions_per_vessel) plt.xticks(rotation=90) plt.title('CO2 Emitted per Vessel', fontsize=14) plt.show() In\u00a0[8]: Copied! <pre>emissions_per_vessel_2023 = emissions_df[emissions_df['EndDate'] &lt; \"2024\"].groupby(\"VesselName\")['EmissionsVoyageCO2InTons'].mean().reset_index()\nplt.figure(figsize=(16,8))\nemissions_per_vessel_2023.sort_values('EmissionsVoyageCO2InTons', inplace=True)\nsns.barplot(x='VesselName', y='EmissionsVoyageCO2InTons', data=emissions_per_vessel_2023)\nplt.xticks(rotation=90)\nplt.title('CO2 Emitted per Vessel (2023)', fontsize=14)\nplt.show()\n</pre> emissions_per_vessel_2023 = emissions_df[emissions_df['EndDate'] &lt; \"2024\"].groupby(\"VesselName\")['EmissionsVoyageCO2InTons'].mean().reset_index() plt.figure(figsize=(16,8)) emissions_per_vessel_2023.sort_values('EmissionsVoyageCO2InTons', inplace=True) sns.barplot(x='VesselName', y='EmissionsVoyageCO2InTons', data=emissions_per_vessel_2023) plt.xticks(rotation=90) plt.title('CO2 Emitted per Vessel (2023)', fontsize=14) plt.show() In\u00a0[9]: Copied! <pre>emissions_per_vessel_2024 = emissions_df[emissions_df['EndDate'] &gt;= \"2024\"].groupby(\"VesselName\")['EmissionsVoyageCO2InTons'].mean().reset_index()\nplt.figure(figsize=(16,8))\nemissions_per_vessel_2024.sort_values('EmissionsVoyageCO2InTons', inplace=True)\nsns.barplot(x='VesselName', y='EmissionsVoyageCO2InTons', data=emissions_per_vessel_2024)\nplt.xticks(rotation=90)\nplt.title('CO2 Emitted per Vessel (2024)', fontsize=14)\nplt.show()\n</pre> emissions_per_vessel_2024 = emissions_df[emissions_df['EndDate'] &gt;= \"2024\"].groupby(\"VesselName\")['EmissionsVoyageCO2InTons'].mean().reset_index() plt.figure(figsize=(16,8)) emissions_per_vessel_2024.sort_values('EmissionsVoyageCO2InTons', inplace=True) sns.barplot(x='VesselName', y='EmissionsVoyageCO2InTons', data=emissions_per_vessel_2024) plt.xticks(rotation=90) plt.title('CO2 Emitted per Vessel (2024)', fontsize=14) plt.show() In\u00a0[10]: Copied! <pre>emissions_per_class = emissions_df.groupby(\"VesselName\").agg(\n    CO2_Emissions=(\"EmissionsVoyageCO2InTons\", \"mean\"), Number_of_Voyages=(\"VoyageNumber\",\"size\"), VesselClass=(\"VesselClass\", \"first\")).reset_index()\n</pre> emissions_per_class = emissions_df.groupby(\"VesselName\").agg(     CO2_Emissions=(\"EmissionsVoyageCO2InTons\", \"mean\"), Number_of_Voyages=(\"VoyageNumber\",\"size\"), VesselClass=(\"VesselClass\", \"first\")).reset_index() In\u00a0[11]: Copied! <pre>plt.figure(figsize=(16,8))\nemissions_per_class.sort_values('CO2_Emissions', inplace=True)\nax = sns.barplot(x='VesselName', y='CO2_Emissions', hue='VesselClass', data=emissions_per_class)\n# ax.bar_label(ax.containers[0], labels=emissions_per_vessel_2023['Number_of_Voyages'])\nplt.xticks(rotation=90)\nplt.title('CO2 Emitted per Vessel Class', fontsize=14)\nplt.show()\n</pre> plt.figure(figsize=(16,8)) emissions_per_class.sort_values('CO2_Emissions', inplace=True) ax = sns.barplot(x='VesselName', y='CO2_Emissions', hue='VesselClass', data=emissions_per_class) # ax.bar_label(ax.containers[0], labels=emissions_per_vessel_2023['Number_of_Voyages']) plt.xticks(rotation=90) plt.title('CO2 Emitted per Vessel Class', fontsize=14) plt.show() In\u00a0[12]: Copied! <pre>metrics_2023 = metrics_df[metrics_df['Year']==2023].copy()\n\nplt.figure(figsize=(16,8))\nmetrics_2023.sort_values('CiiValue', inplace=True)\nax = sns.barplot(x='IMO', y='CiiValue', hue='VesselClass', data=metrics_2023, order=metrics_2023.IMO)\nplt.xticks(rotation=90)\nplt.title('Cii per Vessel (2023)', fontsize=14)\nplt.show()\n</pre> metrics_2023 = metrics_df[metrics_df['Year']==2023].copy()  plt.figure(figsize=(16,8)) metrics_2023.sort_values('CiiValue', inplace=True) ax = sns.barplot(x='IMO', y='CiiValue', hue='VesselClass', data=metrics_2023, order=metrics_2023.IMO) plt.xticks(rotation=90) plt.title('Cii per Vessel (2023)', fontsize=14) plt.show() In\u00a0[13]: Copied! <pre>metrics_2024 = metrics_df[metrics_df['Year']==2024].copy()\n\nplt.figure(figsize=(16,8))\nmetrics_2024.sort_values('CiiValue', inplace=True)\nax = sns.barplot(x='IMO', y='CiiValue', hue='VesselClass', data=metrics_2024, order=metrics_2024.IMO)\nplt.xticks(rotation=90)\nplt.title('Cii per Vessel (2024)', fontsize=14)\nplt.show()\n</pre> metrics_2024 = metrics_df[metrics_df['Year']==2024].copy()  plt.figure(figsize=(16,8)) metrics_2024.sort_values('CiiValue', inplace=True) ax = sns.barplot(x='IMO', y='CiiValue', hue='VesselClass', data=metrics_2024, order=metrics_2024.IMO) plt.xticks(rotation=90) plt.title('Cii per Vessel (2024)', fontsize=14) plt.show()"},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#vessel-emissions-api-use-case","title":"Vessel Emissions API Use Case\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#carbon-analysis","title":"Carbon analysis\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#in-this-notebook-we-will-show-a-use-case-of-visualizing-carbon-emissions-and-metrics-for-a-fleet","title":"In this notebook, we will show a use case of visualizing carbon emissions and metrics for a fleet.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#we-will-choose-our-fleet-as-a-list-of-vessels-get-their-historical-voyage-emissions-using-signal-oceans-vessel-emissions-apin-and-plot-co2-emissions-and-cii-for-the-previous-and-current-year","title":"We will choose our fleet as a list of vessels, get their historical voyage emissions using Signal Ocean's Vessel Emissions APIn and plot CO2 emissions and CII for the previous and current year.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#initialize-vessel-emissions-api","title":"Initialize Vessel Emissions API\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#import-helpful-modules","title":"Import helpful modules\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#input-data","title":"Input Data\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#choose-a-fleet-as-list-of-imos","title":"Choose a fleet as list of IMOs.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#use-the-emissions-api-to-get-historical-emissions-and-metrics-data-for-the-list-of-selected-vessels-including-eu-emissions-we-will-store-the-data-as-pandas-dataframe-and-keep-only-data-from-2023-and-on","title":"Use the emissions api to get historical emissions and metrics data for the list of selected vessels, including EU emissions. We will store the data as pandas dataframe and keep only data from 2023 and on.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#in-the-next-plots-we-see-total-co2-emissions-per-vessel-for-the-previous-and-current-year-and-for-2023-and-2024-separately","title":"In the next plots we see total CO2 emissions per vessel for the previous and current year, and for 2023 and 2024 separately.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#we-can-also-color-our-plot-with-vessel-class","title":"We can also color our plot with vessel class.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/Carbon%20Analysis/#we-repeat-for-the-metrics-data-using-cii","title":"We repeat for the metrics data, using CII.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/","title":"Vessel Emissions API Use Case","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n\nfrom signal_ocean import Connection\nfrom signal_ocean.vessel_emissions import VesselEmissionsAPI\n\nconnection = Connection(signal_ocean_api_key)\nemissions_api = VesselEmissionsAPI(connection)\n</pre> signal_ocean_api_key = '' #replace with your subscription key  from signal_ocean import Connection from signal_ocean.vessel_emissions import VesselEmissionsAPI  connection = Connection(signal_ocean_api_key) emissions_api = VesselEmissionsAPI(connection) In\u00a0[2]: Copied! <pre>from datetime import date, timedelta\nfrom tqdm import tqdm\nimport pandas as pd\nimport datetime as dt\nimport numpy as np\n</pre> from datetime import date, timedelta from tqdm import tqdm import pandas as pd import datetime as dt import numpy as np In\u00a0[3]: Copied! <pre>vessel_imos = [ 9299111, 9314193, 9411197, 9425526, 9440473, 9459096, 9461659, 9462354, 9486922, 9486934, 9487469, 9487471, 9487483, 9505819, 9524982, 9543536, 9580405,\n9580417, 9688336, 9688348, 9723007, 9726619, 9767340, 9773947, 9780251, 9783992, 9833723 ]\n</pre> vessel_imos = [ 9299111, 9314193, 9411197, 9425526, 9440473, 9459096, 9461659, 9462354, 9486922, 9486934, 9487469, 9487471, 9487483, 9505819, 9524982, 9543536, 9580405, 9580417, 9688336, 9688348, 9723007, 9726619, 9767340, 9773947, 9780251, 9783992, 9833723 ] In\u00a0[4]: Copied! <pre>emissions_list = []\n\nfor imo in tqdm(vessel_imos):\n    vessel_emissions = emissions_api.get_emissions_by_imo(imo, include_eu_emissions=True)\n    vessel_emissions = [emissions.to_dict() for emissions in vessel_emissions]\n    emissions_list.extend(vessel_emissions)\n\nemissions_df = pd.json_normalize(emissions_list, sep='')\nemissions_df.describe()\n</pre> emissions_list = []  for imo in tqdm(vessel_imos):     vessel_emissions = emissions_api.get_emissions_by_imo(imo, include_eu_emissions=True)     vessel_emissions = [emissions.to_dict() for emissions in vessel_emissions]     emissions_list.extend(vessel_emissions)  emissions_df = pd.json_normalize(emissions_list, sep='') emissions_df.describe() <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 27/27 [00:15&lt;00:00,  1.78it/s]\n</pre> Out[4]: IMO VoyageNumber VesselTypeID VesselClassID Deadweight Quantity TransportWorkInMillionTonneMiles TransportWorkInMillionDwtMiles EmissionsVoyageCO2InTons EmissionsVoyageCOInTons ... EuropeanUnionRegulatedEmissionsPortCallSOxInTons EuropeanUnionRegulatedEmissionsPortCallPmInTons EuropeanUnionRegulatedEmissionsStopCO2InTons EuropeanUnionRegulatedEmissionsStopCOInTons EuropeanUnionRegulatedEmissionsStopCh4InTons EuropeanUnionRegulatedEmissionsStopN2OInTons EuropeanUnionRegulatedEmissionsStopNMVOCInTons EuropeanUnionRegulatedEmissionsStopNOxInTons EuropeanUnionRegulatedEmissionsStopSOxInTons EuropeanUnionRegulatedEmissionsStopPmInTons count 2.929000e+03 2929.000000 2929.0 2929.000000 2929.000000 2929.000000 2929.000000 2929.000000 2929.000000 2929.000000 ... 572.000000 572.000000 626.000000 626.000000 626.000000 626.000000 626.000000 626.000000 626.000000 626.000000 mean 9.562796e+06 126.784227 1.0 87.118129 75800.533971 56108.910891 163.953845 217.178833 1122.464010 0.988094 ... 0.102479 0.048364 72.304583 0.062734 0.001359 0.003442 0.069755 1.813836 0.113059 0.036320 std 1.399511e+05 58.187661 0.0 1.004282 28939.074146 23301.761359 236.048850 306.676472 1062.966930 0.935962 ... 0.114249 0.030793 202.221402 0.174937 0.003789 0.009510 0.194515 5.099325 0.496942 0.095695 min 9.299111e+06 1.000000 1.0 85.000000 37887.000000 24000.000000 0.118400 0.210267 192.858353 0.169537 ... 0.000880 0.006338 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 25% 9.462354e+06 86.000000 1.0 86.000000 49998.000000 35000.000000 28.452220 40.057118 430.472571 0.378935 ... 0.029326 0.014085 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 50% 9.505819e+06 123.000000 1.0 87.000000 74103.000000 55000.000000 58.804550 82.312392 688.415628 0.606231 ... 0.127079 0.061035 15.980352 0.013846 0.000300 0.000782 0.015396 0.422041 0.011419 0.009049 75% 9.688348e+06 163.000000 1.0 88.000000 104649.000000 80000.000000 218.748960 289.765112 1422.189508 1.249819 ... 0.127079 0.061035 60.219080 0.052393 0.001135 0.002851 0.058257 1.508939 0.056936 0.029599 max 9.833723e+06 277.000000 1.0 89.000000 149989.000000 148000.000000 3027.411400 3492.910834 10094.160506 8.861095 ... 2.443825 0.348220 2584.554489 2.233068 0.048370 0.120924 2.482978 70.337610 9.462714 1.366754 <p>8 rows \u00d7 88 columns</p> In\u00a0[5]: Copied! <pre>emissions_df['StartDate'] = pd.to_datetime(emissions_df['StartDate'], format='ISO8601')\nemissions_df['EndDate'] = pd.to_datetime(emissions_df['EndDate'], format='ISO8601') \nemissions_df['Year'] = emissions_df['EndDate'].dt.year\n</pre> emissions_df['StartDate'] = pd.to_datetime(emissions_df['StartDate'], format='ISO8601') emissions_df['EndDate'] = pd.to_datetime(emissions_df['EndDate'], format='ISO8601')  emissions_df['Year'] = emissions_df['EndDate'].dt.year In\u00a0[6]: Copied! <pre>imos = emissions_df.IMO.unique()\n\ngrouped_df = emissions_df.groupby(['IMO', 'Year']).agg(\n    VesselName=(\"VesselName\", \"first\"),\n    VesselClass=(\"VesselClass\", \"first\"),\n    Total_CO2_In_Tonnes=(\"EmissionsVoyageCO2InTons\", \"sum\"), \n    EU_CO2_In_Tonnes=(\"EuropeanUnionRegulatedEmissionsVoyageCO2InTons\", \"sum\"))#.reset_index()\n</pre> imos = emissions_df.IMO.unique()  grouped_df = emissions_df.groupby(['IMO', 'Year']).agg(     VesselName=(\"VesselName\", \"first\"),     VesselClass=(\"VesselClass\", \"first\"),     Total_CO2_In_Tonnes=(\"EmissionsVoyageCO2InTons\", \"sum\"),      EU_CO2_In_Tonnes=(\"EuropeanUnionRegulatedEmissionsVoyageCO2InTons\", \"sum\"))#.reset_index() In\u00a0[7]: Copied! <pre>grouped_df['EU_Emissions_Percentage'] = grouped_df['EU_CO2_In_Tonnes']/grouped_df['Total_CO2_In_Tonnes']\ngrouped_df['EUAs (40%)'] = grouped_df['EU_CO2_In_Tonnes'] * 0.4\ngrouped_df.head(5)\n</pre> grouped_df['EU_Emissions_Percentage'] = grouped_df['EU_CO2_In_Tonnes']/grouped_df['Total_CO2_In_Tonnes'] grouped_df['EUAs (40%)'] = grouped_df['EU_CO2_In_Tonnes'] * 0.4 grouped_df.head(5) Out[7]: VesselName VesselClass Total_CO2_In_Tonnes EU_CO2_In_Tonnes EU_Emissions_Percentage EUAs (40%) IMO Year 9299111 2018 Elka Apollon Aframax 24487.237390 5356.425477 0.218744 2142.570191 2019 Elka Apollon Aframax 12882.690209 3804.605036 0.295327 1521.842015 2020 Elka Apollon Aframax 15466.783677 4384.380411 0.283471 1753.752165 2021 Elka Apollon Aframax 12755.502182 7164.812591 0.561704 2865.925037 2022 Elka Apollon Aframax 22431.696629 2893.248478 0.128980 1157.299391 In\u00a0[8]: Copied! <pre>current_year = 2024\n\nyear_to_date_percentage = (dt.datetime.now() - dt.datetime(dt.datetime.now().year,1,1)).days/365\n\ngrouped_df['Estimated_end_of_year_CO2'] = np.nan\ngrouped_df['Estimated_end_of_year_EU_CO2'] = np.nan\ngrouped_df['Estimated_end_of_year_EUAs'] = 0\n\nfor imo in imos:\n    average_co2_across_years = grouped_df['Total_CO2_In_Tonnes'][imo].mean()\n    average_eu_co2_across_years = grouped_df['EU_CO2_In_Tonnes'][imo].mean()\n    percentage_of_avg_eu_co2 = average_eu_co2_across_years/average_co2_across_years\n    \n    projection_total = grouped_df['Total_CO2_In_Tonnes'][imo][current_year] / year_to_date_percentage\n    projection_eu = projection_total * percentage_of_avg_eu_co2\n    \n    grouped_df.loc[(imo, 2024), 'Estimated_end_of_year_CO2'] = projection_total\n    grouped_df.loc[(imo, 2024), 'Estimated_end_of_year_EU_CO2'] = projection_eu\n    grouped_df.loc[(imo, 2024), 'Estimated_end_of_year_EUAs'] = round(projection_eu * 0.4)\n</pre> current_year = 2024  year_to_date_percentage = (dt.datetime.now() - dt.datetime(dt.datetime.now().year,1,1)).days/365  grouped_df['Estimated_end_of_year_CO2'] = np.nan grouped_df['Estimated_end_of_year_EU_CO2'] = np.nan grouped_df['Estimated_end_of_year_EUAs'] = 0  for imo in imos:     average_co2_across_years = grouped_df['Total_CO2_In_Tonnes'][imo].mean()     average_eu_co2_across_years = grouped_df['EU_CO2_In_Tonnes'][imo].mean()     percentage_of_avg_eu_co2 = average_eu_co2_across_years/average_co2_across_years          projection_total = grouped_df['Total_CO2_In_Tonnes'][imo][current_year] / year_to_date_percentage     projection_eu = projection_total * percentage_of_avg_eu_co2          grouped_df.loc[(imo, 2024), 'Estimated_end_of_year_CO2'] = projection_total     grouped_df.loc[(imo, 2024), 'Estimated_end_of_year_EU_CO2'] = projection_eu     grouped_df.loc[(imo, 2024), 'Estimated_end_of_year_EUAs'] = round(projection_eu * 0.4) In\u00a0[9]: Copied! <pre>projected_emissions_for_current_year = grouped_df.loc[grouped_df.index.get_level_values(1)==current_year]\nprojected_emissions_for_current_year.head(10)\n</pre> projected_emissions_for_current_year = grouped_df.loc[grouped_df.index.get_level_values(1)==current_year] projected_emissions_for_current_year.head(10) Out[9]: VesselName VesselClass Total_CO2_In_Tonnes EU_CO2_In_Tonnes EU_Emissions_Percentage EUAs (40%) Estimated_end_of_year_CO2 Estimated_end_of_year_EU_CO2 Estimated_end_of_year_EUAs IMO Year 9299111 2024 Elka Apollon Aframax 11856.572240 0.000000 0.000000 0.000000 17105.331492 3432.097933 1373 9314193 2024 Dubai Gold Panamax 13900.358315 817.786967 0.058832 327.114787 20053.876621 1230.526045 492 9411197 2024 Asahi Princess Aframax 18612.543976 2740.002717 0.147213 1096.001087 26852.089136 2321.580055 929 9425526 2024 MP MR Tanker 2 MR2 16446.783554 0.000000 0.000000 0.000000 23727.573112 1043.193350 417 9440473 2024 Altesse Panamax 10742.458029 0.000000 0.000000 0.000000 15498.012571 1324.737525 530 9459096 2024 Nave Orion MR2 9165.163124 0.000000 0.000000 0.000000 13222.468538 187.828246 75 9461659 2024 Hafnia Pegasus MR2 14512.583470 0.000000 0.000000 0.000000 20937.126351 1185.199828 474 9462354 2024 Koi Panamax 9862.682237 0.000000 0.000000 0.000000 14228.770816 0.000000 0 9486922 2024 Alberta Aframax 11998.141262 2148.311226 0.179054 859.324490 17309.571385 1293.840240 518 9486934 2024 Samos Aframax 15615.181956 0.000000 0.000000 0.000000 22527.831676 1909.014500 764 In\u00a0[10]: Copied! <pre>sum(projected_emissions_for_current_year.Estimated_end_of_year_EUAs)\n</pre> sum(projected_emissions_for_current_year.Estimated_end_of_year_EUAs) Out[10]: <pre>30229</pre>"},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#vessel-emissions-api-use-case","title":"Vessel Emissions API Use Case\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#eua-analysis","title":"EUA analysis\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#in-this-notebook-we-will-show-a-use-case-of-estimating-the-number-of-euas-needed-for-a-fleet-for-the-current-year","title":"In this notebook, we will show a use case of estimating the number of EUAs needed for a fleet for the current year.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#we-will-choose-our-fleet-as-a-list-of-vessels-get-their-historical-voyage-emissions-using-signal-oceans-vessel-emissions-apin-and-use-linear-extrapolation-to-estimate-the-needed-euas-at-the-end-of-the-year","title":"We will choose our fleet as a list of vessels, get their historical voyage emissions using Signal Ocean's Vessel Emissions APIn and use linear extrapolation to estimate the needed EUAs at the end of the year.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#initialize-vessel-emissions-api","title":"Initialize Vessel Emissions API\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#import-helpful-modules","title":"Import helpful modules\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#input-data","title":"Input Data\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#choose-a-fleet-as-list-of-imos","title":"Choose a fleet as list of IMOs.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#use-the-emissions-api-to-get-historical-emissions-data-for-the-list-of-selected-vessels-including-eu-emissions-we-will-store-the-data-as-pandas-dataframe","title":"Use the emissions api to get historical emissions data for the list of selected vessels, including EU emissions. We will store the data as pandas dataframe.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#we-will-convert-the-date-columns-startdate-enddate-to-datetime-for-easier-manipulation-since-we-want-a-yearly-analysis-we-will-assign-a-year-label-to-each-voyage-which-we-will-get-from-the-enddate","title":"We will convert the date columns (StartDate, EndDate) to datetime for easier manipulation. Since we want a yearly analysis, we will assign a \"Year\" label to each voyage, which we will get from the EndDate.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#to-perform-our-analysis-we-group-our-data-per-imo-and-year-sum-the-values-that-we-need-ie-total-co2-emissions-and-eu-regulated-co2-emissions","title":"To perform our analysis, we group our data per IMO and Year sum the values that we need, i.e. Total CO2 Emissions and EU - regulated CO2 emissions.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#before-we-proceed-we-will-calculate-the-percentage-of-eu-regulated-emissions-per-year-as-well-as-the-euas-for-the-available-data","title":"Before we proceed, we will calculate the percentage of EU - regulated emissions per year, as well as the EUAs for the available data.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#finally-we-will-calculate-our-estimations-using-extrapolations-from-the-historical-data-we-calculate-the-year-to-date-percentage-for-the-date-of-the-analysis-as-well-as-the-the-average-yearly-percentage-of-eu-emissions-using-these-two-we-can-estimate-the-total-and-eu-emissions-at-the-end-of-the-current-year-and-the-number-of-euas-needed-for-the-estimated-emissions","title":"Finally, we will calculate our estimations using extrapolations from the historical data. We calculate the year to date percentage for the date of the analysis, as well as the the average yearly percentage of EU emissions.  Using these two we can estimate the total and EU emissions at the end of the current year, and the number of EUAs needed for the estimated emissions.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/EUA_Analysis/#to-get-the-total-number-of-euas-we-just-sum-the-last-column","title":"To get the total number of EUAs, we just sum the last column.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/","title":"Vessel Emissions API Use Case","text":"<p>In this notebook, we will show a use case of including Vessel Emissions API in your workflow. We will use Voyages API to get all voyages in MR and Panamax Tanker routes for the past two years and then use Vessel Emissions API to get the emissions for these voyages. Finally we will perform some Exploratory Data Analysis on the acquired emissions data and visualize our findings.</p> In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from datetime import date, timedelta\nfrom tqdm import tqdm\n\nimport requests\nimport json\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import PolyCollection\nimport numpy as np\nsns.set_theme()\nsns.set_style(\"whitegrid\")\n</pre> from datetime import date, timedelta from tqdm import tqdm  import requests import json import pandas as pd import seaborn as sns import matplotlib.pyplot as plt from matplotlib.collections import PolyCollection import numpy as np sns.set_theme() sns.set_style(\"whitegrid\") In\u00a0[3]: Copied! <pre>mr_panamax_tanker_routes = [\n    {\n        'Type': 'Clean',\n        'LoadArea': 'East Mediterranean',\n        'DischargeArea': 'Central Mediterranean',\n        'VesselClass': 'MR1',\n        'VesselClassID': 89,\n        'RouteID': 'MR1 - 1'\n    },\n    {\n        'Type': 'Clean',\n        'LoadArea': 'Baltic Sea Upper',\n        'DischargeArea': 'Continent',\n        'VesselClass': 'MR1',\n        'VesselClassID': 89,\n        'RouteID': 'MR1 - 2'\n    },\n    {\n        'Type': 'Clean',\n        'LoadArea': 'West Mediterranean',\n        'DischargeArea': 'Central Mediterranean',\n        'VesselClass': 'MR1',\n        'VesselClassID': 89,\n        'RouteID': 'MR1 - 3'\n    },\n    {\n        'Type': 'Clean',\n        'LoadArea': 'West Mediterranean',\n        'DischargeArea': 'Continent',\n        'VesselClass': 'MR1',\n        'VesselClassID': 89,\n        'RouteID': 'MR1 - 4'\n    },\n    {\n        'Type': 'Dirty',\n        'LoadArea': 'Continent',\n        'DischargeArea': 'Central Mediterranean',\n        'VesselClass': 'MR1',\n        'VesselClassID': 89,\n        'RouteID': 'MR1 - 5'\n    },\n    {\n        'Type': 'Dirty',\n        'LoadArea': 'Baltic Sea Upper',\n        'DischargeArea': 'Continent',\n        'VesselClass': 'MR1',\n        'VesselClassID': 89,\n        'RouteID': 'MR1 - 6'\n    },\n    {\n        'Type': 'Clean',\n        'LoadArea': 'Black Sea',\n        'DischargeArea': 'West Mediterranean',\n        'VesselClass': 'MR1',\n        'VesselClassID': 89,\n        'RouteID': 'MR1 - 7'\n    },\n    {\n        'Type': 'Clean',\n        'LoadArea': 'Continent',\n        'DischargeArea': 'East Mediterranean',\n        'VesselClass': 'MR1',\n        'VesselClassID': 89,\n        'RouteID': 'MR1 - 8'\n    },\n    {\n        'Type': 'Clean',\n        'LoadArea': 'Continent',\n        'DischargeArea': 'US Atlantic Coast',\n        'VesselClass': 'PanamaxTanker',\n        'VesselClassID': 87,\n        'RouteID': 'PT - 1'\n    },\n    {\n        'Type': 'Clean',\n        'LoadArea': 'Continent',\n        'DischargeArea': 'Africa Atlantic Coast',\n        'VesselClass': 'PanamaxTanker',\n        'VesselClassID': 87,\n        'RouteID': 'PT - 2'\n    },\n    {\n        'Type': 'Clean',\n        'LoadArea': 'West Mediterranean',\n        'DischargeArea': 'US Atlantic Coast',\n        'VesselClass': 'PanamaxTanker',\n        'VesselClassID': 87,\n        'RouteID': 'PT - 3'\n    }\n]\n\nmr_panamax_tanker_routes_df = pd.DataFrame.from_records(mr_panamax_tanker_routes)\n</pre> mr_panamax_tanker_routes = [     {         'Type': 'Clean',         'LoadArea': 'East Mediterranean',         'DischargeArea': 'Central Mediterranean',         'VesselClass': 'MR1',         'VesselClassID': 89,         'RouteID': 'MR1 - 1'     },     {         'Type': 'Clean',         'LoadArea': 'Baltic Sea Upper',         'DischargeArea': 'Continent',         'VesselClass': 'MR1',         'VesselClassID': 89,         'RouteID': 'MR1 - 2'     },     {         'Type': 'Clean',         'LoadArea': 'West Mediterranean',         'DischargeArea': 'Central Mediterranean',         'VesselClass': 'MR1',         'VesselClassID': 89,         'RouteID': 'MR1 - 3'     },     {         'Type': 'Clean',         'LoadArea': 'West Mediterranean',         'DischargeArea': 'Continent',         'VesselClass': 'MR1',         'VesselClassID': 89,         'RouteID': 'MR1 - 4'     },     {         'Type': 'Dirty',         'LoadArea': 'Continent',         'DischargeArea': 'Central Mediterranean',         'VesselClass': 'MR1',         'VesselClassID': 89,         'RouteID': 'MR1 - 5'     },     {         'Type': 'Dirty',         'LoadArea': 'Baltic Sea Upper',         'DischargeArea': 'Continent',         'VesselClass': 'MR1',         'VesselClassID': 89,         'RouteID': 'MR1 - 6'     },     {         'Type': 'Clean',         'LoadArea': 'Black Sea',         'DischargeArea': 'West Mediterranean',         'VesselClass': 'MR1',         'VesselClassID': 89,         'RouteID': 'MR1 - 7'     },     {         'Type': 'Clean',         'LoadArea': 'Continent',         'DischargeArea': 'East Mediterranean',         'VesselClass': 'MR1',         'VesselClassID': 89,         'RouteID': 'MR1 - 8'     },     {         'Type': 'Clean',         'LoadArea': 'Continent',         'DischargeArea': 'US Atlantic Coast',         'VesselClass': 'PanamaxTanker',         'VesselClassID': 87,         'RouteID': 'PT - 1'     },     {         'Type': 'Clean',         'LoadArea': 'Continent',         'DischargeArea': 'Africa Atlantic Coast',         'VesselClass': 'PanamaxTanker',         'VesselClassID': 87,         'RouteID': 'PT - 2'     },     {         'Type': 'Clean',         'LoadArea': 'West Mediterranean',         'DischargeArea': 'US Atlantic Coast',         'VesselClass': 'PanamaxTanker',         'VesselClassID': 87,         'RouteID': 'PT - 3'     } ]  mr_panamax_tanker_routes_df = pd.DataFrame.from_records(mr_panamax_tanker_routes) In\u00a0[4]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.vessel_emissions import VesselEmissionsAPI\n\nconnection = Connection(signal_ocean_api_key)\nemissions_api = VesselEmissionsAPI(connection)\n</pre> from signal_ocean import Connection from signal_ocean.vessel_emissions import VesselEmissionsAPI  connection = Connection(signal_ocean_api_key) emissions_api = VesselEmissionsAPI(connection) In\u00a0[5]: Copied! <pre>from signal_ocean.voyages import VoyagesAPI\n\nvoyages_api = VoyagesAPI(connection)\n</pre> from signal_ocean.voyages import VoyagesAPI  voyages_api = VoyagesAPI(connection) In\u00a0[6]: Copied! <pre>def get_voyage_load_port(voyage_events):\n    return next((e.port_name for e in voyage_events or [] if e.purpose=='Load'), None)\n\ndef get_voyage_discharge_port(voyage_events):\n    return next((e.port_name for e in reversed(voyage_events or []) if e.purpose=='Discharge'), None)\n\ndef get_voyage_load_area(voyage_events):\n    return next((e.area_name_level0 for e in voyage_events or [] if e.purpose=='Load'), None)\n\ndef get_voyage_discharge_area(voyage_events):\n    return next((e.area_name_level0 for e in reversed(voyage_events or []) if e.purpose=='Discharge'), None)\n\ndef get_voyage_load_area_id(voyage_events):\n    return next((e.area_idlevel0 for e in voyage_events or [] if e.purpose=='Load'), None)\n\ndef get_voyage_discharge_area_id(voyage_events):\n    return next((e.area_idlevel0 for e in reversed(voyage_events or []) if e.purpose=='Discharge'), None)\n\ndef convert_comma_separated_str_to_list(comma_str: str) -&gt; list:\n  return [item.strip() for item in comma_str.split(\",\")]\n</pre> def get_voyage_load_port(voyage_events):     return next((e.port_name for e in voyage_events or [] if e.purpose=='Load'), None)  def get_voyage_discharge_port(voyage_events):     return next((e.port_name for e in reversed(voyage_events or []) if e.purpose=='Discharge'), None)  def get_voyage_load_area(voyage_events):     return next((e.area_name_level0 for e in voyage_events or [] if e.purpose=='Load'), None)  def get_voyage_discharge_area(voyage_events):     return next((e.area_name_level0 for e in reversed(voyage_events or []) if e.purpose=='Discharge'), None)  def get_voyage_load_area_id(voyage_events):     return next((e.area_idlevel0 for e in voyage_events or [] if e.purpose=='Load'), None)  def get_voyage_discharge_area_id(voyage_events):     return next((e.area_idlevel0 for e in reversed(voyage_events or []) if e.purpose=='Discharge'), None)  def convert_comma_separated_str_to_list(comma_str: str) -&gt; list:   return [item.strip() for item in comma_str.split(\",\")] In\u00a0[8]: Copied! <pre>distinct_vessel_classes = np.unique([route.get('VesselClassID') for route in mr_panamax_tanker_routes])\n\ndate_from = date.today() - timedelta(days=2*365)\n\nvoyages = {}\nfor vessel_class_id in tqdm(distinct_vessel_classes):\n    voyages[vessel_class_id] = voyages_api.get_voyages(vessel_class_id=vessel_class_id, date_from=date_from)\n</pre> distinct_vessel_classes = np.unique([route.get('VesselClassID') for route in mr_panamax_tanker_routes])  date_from = date.today() - timedelta(days=2*365)  voyages = {} for vessel_class_id in tqdm(distinct_vessel_classes):     voyages[vessel_class_id] = voyages_api.get_voyages(vessel_class_id=vessel_class_id, date_from=date_from) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [02:47&lt;00:00, 83.61s/it]\n</pre> In\u00a0[9]: Copied! <pre>voyages_df = pd.DataFrame(v.__dict__ for vessel_class_voyages in voyages.values() for v in vessel_class_voyages)\n\nvoyages_df['load_port'] = voyages_df['events'].apply(get_voyage_load_port)\nvoyages_df['discharge_port'] = voyages_df['events'].apply(get_voyage_discharge_port)\n\nvoyages_df['load_area'] = voyages_df['events'].apply(get_voyage_load_area)\nvoyages_df['discharge_area'] = voyages_df['events'].apply(get_voyage_discharge_area)\n\nvoyages_df.loc[voyages_df['trade'] == 'Product', 'trade'] = 'Clean'\nvoyages_df.loc[voyages_df['trade'] == 'Crude', 'trade'] = 'Dirty'\n</pre> voyages_df = pd.DataFrame(v.__dict__ for vessel_class_voyages in voyages.values() for v in vessel_class_voyages)  voyages_df['load_port'] = voyages_df['events'].apply(get_voyage_load_port) voyages_df['discharge_port'] = voyages_df['events'].apply(get_voyage_discharge_port)  voyages_df['load_area'] = voyages_df['events'].apply(get_voyage_load_area) voyages_df['discharge_area'] = voyages_df['events'].apply(get_voyage_discharge_area)  voyages_df.loc[voyages_df['trade'] == 'Product', 'trade'] = 'Clean' voyages_df.loc[voyages_df['trade'] == 'Crude', 'trade'] = 'Dirty' In\u00a0[10]: Copied! <pre>from requests.exceptions import HTTPError\nfrom json import JSONDecodeError\n\nemissions_per_route = pd.DataFrame()\nfor route in mr_panamax_tanker_routes:\n    route_emissions = []\n    load_areas = convert_comma_separated_str_to_list(route.get('LoadArea'))\n    discharge_areas = convert_comma_separated_str_to_list(route.get('DischargeArea'))\n    vessel_class_id = route.get('VesselClassID')\n    trade = route.get('Type')\n\n    voyages_in_route = voyages_df[\n            (voyages_df['load_area'].isin(load_areas))\\\n            &amp; (voyages_df['discharge_area'].isin(discharge_areas))\\\n            &amp; (voyages_df['vessel_class_id']==vessel_class_id)\\\n            &amp; (voyages_df['trade']==trade)\n    ]\n\n    for voyage in tqdm(voyages_in_route.to_dict(orient='records')):\n        # Get emissions for all voyages_in_route\n        try:\n            voyage_emissions = emissions_api.get_emissions_by_imo_and_voyage_number(\n                imo=voyage.get('imo'),\n                voyage_number=voyage.get('voyage_number'),\n                include_distances=True,\n                include_efficiency_metrics=True\n          )\n            if voyage_emissions:\n                route_emissions.append(voyage_emissions.to_dict())\n        # except for those that have not been calculated yet\n        except (HTTPError, JSONDecodeError):\n            print(f\"Emissions for IMO: {voyage.get('imo')} Voyage Number: {voyage.get('voyage_number')} are not calculated yet\")\n\n    if len(route_emissions) &gt; 0:\n        route_emissions_df = pd.json_normalize(route_emissions, sep='')\n        route_emissions_df['RouteID'] = route.get('RouteID')\n        \n        emissions_per_route = pd.concat([emissions_per_route, route_emissions_df])\n</pre> from requests.exceptions import HTTPError from json import JSONDecodeError  emissions_per_route = pd.DataFrame() for route in mr_panamax_tanker_routes:     route_emissions = []     load_areas = convert_comma_separated_str_to_list(route.get('LoadArea'))     discharge_areas = convert_comma_separated_str_to_list(route.get('DischargeArea'))     vessel_class_id = route.get('VesselClassID')     trade = route.get('Type')      voyages_in_route = voyages_df[             (voyages_df['load_area'].isin(load_areas))\\             &amp; (voyages_df['discharge_area'].isin(discharge_areas))\\             &amp; (voyages_df['vessel_class_id']==vessel_class_id)\\             &amp; (voyages_df['trade']==trade)     ]      for voyage in tqdm(voyages_in_route.to_dict(orient='records')):         # Get emissions for all voyages_in_route         try:             voyage_emissions = emissions_api.get_emissions_by_imo_and_voyage_number(                 imo=voyage.get('imo'),                 voyage_number=voyage.get('voyage_number'),                 include_distances=True,                 include_efficiency_metrics=True           )             if voyage_emissions:                 route_emissions.append(voyage_emissions.to_dict())         # except for those that have not been calculated yet         except (HTTPError, JSONDecodeError):             print(f\"Emissions for IMO: {voyage.get('imo')} Voyage Number: {voyage.get('voyage_number')} are not calculated yet\")      if len(route_emissions) &gt; 0:         route_emissions_df = pd.json_normalize(route_emissions, sep='')         route_emissions_df['RouteID'] = route.get('RouteID')                  emissions_per_route = pd.concat([emissions_per_route, route_emissions_df]) <pre> 75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589          | 399/529 [02:45&lt;00:45,  2.87it/s]</pre> <pre>Emissions for IMO: 9538165 Voyage Number: 181 are not calculated yet\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 529/529 [03:31&lt;00:00,  2.50it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 348/348 [02:28&lt;00:00,  2.34it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 83/83 [00:31&lt;00:00,  2.63it/s]\n  1%|\u258f                                          | 1/186 [00:00&lt;01:02,  2.94it/s]</pre> <pre>Emissions for IMO: 9237008 Voyage Number: 222 are not calculated yet\n</pre> <pre> 27%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e                              | 50/186 [00:18&lt;00:50,  2.69it/s]</pre> <pre>Emissions for IMO: 9357559 Voyage Number: 244 are not calculated yet\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 186/186 [01:10&lt;00:00,  2.65it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 14/14 [00:05&lt;00:00,  2.55it/s]\n 74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589           | 49/66 [00:18&lt;00:06,  2.76it/s]</pre> <pre>Emissions for IMO: 9696565 Voyage Number: 166 are not calculated yet\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 66/66 [00:25&lt;00:00,  2.61it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 21/21 [00:08&lt;00:00,  2.49it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 29/29 [00:12&lt;00:00,  2.42it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 8/8 [00:03&lt;00:00,  2.61it/s]\n 43%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f                       | 73/169 [00:28&lt;00:37,  2.57it/s]</pre> <pre>Emissions for IMO: 9407847 Voyage Number: 133 are not calculated yet\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 169/169 [01:05&lt;00:00,  2.57it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00,  2.90it/s]\n</pre> In\u00a0[11]: Copied! <pre>emissions_per_route['TransportWork'] = emissions_per_route['DistancesVoyageDistanceTravelled'] * emissions_per_route['Deadweight']\naer_per_route = emissions_per_route.groupby('RouteID').agg({'EmissionsVoyageCO2InTons': np.sum, 'TransportWork': np.sum})\naer_per_route['AER'] = aer_per_route['EmissionsVoyageCO2InTons'] * 10 ** 6 / aer_per_route['TransportWork']\naer_per_route.reset_index(inplace=True)\n</pre> emissions_per_route['TransportWork'] = emissions_per_route['DistancesVoyageDistanceTravelled'] * emissions_per_route['Deadweight'] aer_per_route = emissions_per_route.groupby('RouteID').agg({'EmissionsVoyageCO2InTons': np.sum, 'TransportWork': np.sum}) aer_per_route['AER'] = aer_per_route['EmissionsVoyageCO2InTons'] * 10 ** 6 / aer_per_route['TransportWork'] aer_per_route.reset_index(inplace=True) In\u00a0[12]: Copied! <pre>plt.figure(figsize=(16,8))\naer_per_route.sort_values('RouteID', inplace=True)\nsns.barplot(x='RouteID', y='EmissionsVoyageCO2InTons', data=aer_per_route, palette='Reds')\nplt.xticks(rotation=90)\nplt.title('CO2 Emitted per route', fontsize=14)\nplt.show()\n</pre> plt.figure(figsize=(16,8)) aer_per_route.sort_values('RouteID', inplace=True) sns.barplot(x='RouteID', y='EmissionsVoyageCO2InTons', data=aer_per_route, palette='Reds') plt.xticks(rotation=90) plt.title('CO2 Emitted per route', fontsize=14) plt.show() In\u00a0[13]: Copied! <pre>plt.figure(figsize=(16,8))\naer_per_route.sort_values('RouteID', inplace=True)\nsns.barplot(x='RouteID', y='AER', data=aer_per_route, palette='Reds')\nplt.xticks(rotation=90)\nplt.title('Average Efficiency Ratio per route', fontsize=14)\nplt.show()\n</pre> plt.figure(figsize=(16,8)) aer_per_route.sort_values('RouteID', inplace=True) sns.barplot(x='RouteID', y='AER', data=aer_per_route, palette='Reds') plt.xticks(rotation=90) plt.title('Average Efficiency Ratio per route', fontsize=14) plt.show() In\u00a0[14]: Copied! <pre>def set_violins_transparency(violins, alpha):\n  for violin in violins.get_children():\n    if isinstance(violin, PolyCollection):\n      violin.set_alpha(alpha)\n</pre> def set_violins_transparency(violins, alpha):   for violin in violins.get_children():     if isinstance(violin, PolyCollection):       violin.set_alpha(alpha) In\u00a0[15]: Copied! <pre># Drop outlier values for visual purposes\nemissions_to_plot = emissions_per_route[emissions_per_route['EfficiencyMetricsCapacityEeoi'] &lt; emissions_per_route['EfficiencyMetricsCapacityEeoi'].quantile(.99)]\n</pre> # Drop outlier values for visual purposes emissions_to_plot = emissions_per_route[emissions_per_route['EfficiencyMetricsCapacityEeoi'] &lt; emissions_per_route['EfficiencyMetricsCapacityEeoi'].quantile(.99)] In\u00a0[16]: Copied! <pre>plt.figure(figsize=(16,8))\nemissions_per_route.sort_values('RouteID', inplace=True)\n\nviolins = sns.violinplot(x='RouteID', y='EfficiencyMetricsCapacityEeoi', data=emissions_to_plot, color=\".0\")\n\nset_violins_transparency(violins, 0.3)\n\nsns.boxplot(x='RouteID', y='EfficiencyMetricsCapacityEeoi', data=emissions_to_plot, palette=\"Reds\")\nsns.stripplot(x='RouteID', y='EfficiencyMetricsCapacityEeoi', data=emissions_to_plot, color=\".25\")\n\nplt.title(\"Capacity EEOI per Route\", fontsize=14)\nplt.xticks(rotation=90)\nplt.show()\n</pre> plt.figure(figsize=(16,8)) emissions_per_route.sort_values('RouteID', inplace=True)  violins = sns.violinplot(x='RouteID', y='EfficiencyMetricsCapacityEeoi', data=emissions_to_plot, color=\".0\")  set_violins_transparency(violins, 0.3)  sns.boxplot(x='RouteID', y='EfficiencyMetricsCapacityEeoi', data=emissions_to_plot, palette=\"Reds\") sns.stripplot(x='RouteID', y='EfficiencyMetricsCapacityEeoi', data=emissions_to_plot, color=\".25\")  plt.title(\"Capacity EEOI per Route\", fontsize=14) plt.xticks(rotation=90) plt.show() In\u00a0[17]: Copied! <pre>emissions_per_route['EndDate'] = pd.to_datetime(emissions_per_route['EndDate'], format='mixed')\nemissions_per_route['EndDateMonth'] = emissions_per_route['EndDate'].apply(lambda x: x.strftime('%Y-%m'))\nemissions_per_route['EndDateMonth'] = pd.to_datetime(emissions_per_route['EndDateMonth'])\n\nemissions_per_route = emissions_per_route.merge(mr_panamax_tanker_routes_df[['RouteID', 'LoadArea', 'DischargeArea']], how='left', on='RouteID')\n\nemissions_per_route['RouteInfo'] = emissions_per_route.apply(lambda x: f\"{x.VesselClass} - {x.LoadArea} --&gt; {x.DischargeArea}\", axis=1)\n\nroutes_to_compare = [\"MR1 - 1\", \"MR1 - 2\", \"PT - 2\"]\n\n# Drop outlier values for visual purposes\nemissions_to_plot = emissions_per_route[emissions_per_route['EfficiencyMetricsCapacityEeoi'] &lt; emissions_per_route['EfficiencyMetricsCapacityEeoi'].quantile(.99)]\n</pre> emissions_per_route['EndDate'] = pd.to_datetime(emissions_per_route['EndDate'], format='mixed') emissions_per_route['EndDateMonth'] = emissions_per_route['EndDate'].apply(lambda x: x.strftime('%Y-%m')) emissions_per_route['EndDateMonth'] = pd.to_datetime(emissions_per_route['EndDateMonth'])  emissions_per_route = emissions_per_route.merge(mr_panamax_tanker_routes_df[['RouteID', 'LoadArea', 'DischargeArea']], how='left', on='RouteID')  emissions_per_route['RouteInfo'] = emissions_per_route.apply(lambda x: f\"{x.VesselClass} - {x.LoadArea} --&gt; {x.DischargeArea}\", axis=1)  routes_to_compare = [\"MR1 - 1\", \"MR1 - 2\", \"PT - 2\"]  # Drop outlier values for visual purposes emissions_to_plot = emissions_per_route[emissions_per_route['EfficiencyMetricsCapacityEeoi'] &lt; emissions_per_route['EfficiencyMetricsCapacityEeoi'].quantile(.99)] In\u00a0[18]: Copied! <pre>plt.figure(figsize=(16,8))\n\nsns.lineplot(x=\"EndDateMonth\", y=\"EfficiencyMetricsCapacityEeoi\", hue=\"RouteInfo\", data=emissions_per_route[emissions_per_route['RouteID'].isin(routes_to_compare)])\nplt.show()\n</pre> plt.figure(figsize=(16,8))  sns.lineplot(x=\"EndDateMonth\", y=\"EfficiencyMetricsCapacityEeoi\", hue=\"RouteInfo\", data=emissions_per_route[emissions_per_route['RouteID'].isin(routes_to_compare)]) plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#vessel-emissions-api-use-case","title":"Vessel Emissions API Use Case\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#co2-co2-intensity-comparison-between-different-mr-and-panamax-tanker-routes","title":"CO2 &amp; CO2 Intensity comparison between different MR and Panamax Tanker routes\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#import-helpful-modules","title":"Import helpful modules\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#input-data","title":"Input Data\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#1-load-route-definitions-for-mr-and-panamax-tanker-vessels","title":"1. Load route definitions for MR and Panamax Tanker vessels\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#apis-initialization-and-definition-of-helper-functions-for-feature-engineering","title":"APIs initialization and definition of helper functions for feature engineering\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#initialize-vessel-emissions-api","title":"Initialize Vessel Emissions API\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#initialize-voyages-api","title":"Initialize Voyages API\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#define-helper-functions","title":"Define Helper functions\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#use-case-description","title":"Use Case Description\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#visualizing-co2-emissions-for-a-number-of-tanker-routes","title":"Visualizing CO2 Emissions for a number of Tanker routes\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#we-will-visually-explore","title":"We will visually explore:\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#1-co2-emissions-per-route","title":"1) CO2 Emissions per Route\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#2-average-efficiency-ratio-per-route","title":"2) Average Efficiency Ratio per Route\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#3-capacity-eeoi-per-route","title":"3) Capacity EEOI per Route\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#4-timeseries-comparions-of-capacity-eeoi-for-three-selected-routes","title":"4) Timeseries comparions of Capacity EEOI for three selected Routes\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#get-voyages-for-mr-and-panamax-tanker-routes-over-the-past-2-years","title":"Get voyages for MR and Panamax Tanker routes over the past 2 years\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#load-data-into-a-pandas-dataframe-and-apply-feature-engineering","title":"Load data into a pandas DataFrame and apply feature engineering\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#get-emisssions-for-the-selected-voyages","title":"Get emisssions for the selected voyages\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#visuals","title":"Visuals\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#1-co2-emissions-per-route","title":"1)  CO2 Emissions per Route\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#2-average-efficiency-ratios-per-route","title":"2) Average Efficiency Ratios per Route\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#3-capacity-eeois-per-route","title":"3) Capacity EEOIs per Route\u00b6","text":"<p>Capacity EEOI is the EEOI metric, considering the vessel is fully loaded (at capacity)</p>"},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI-UseCase/#4-timeseries-visualization-of-capacity-eeoi","title":"4) Timeseries visualization of Capacity EEOI\u00b6","text":"<p>Visualize Capacity EEOI per route, based on when the voyages end</p>"},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/","title":"Vessel Emissions API Example","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.vessel_emissions import VesselEmissionsAPI\n\nimport pandas as pd\n\nconnection = Connection(signal_ocean_api_key)\napi = VesselEmissionsAPI(connection)\n</pre> from signal_ocean import Connection from signal_ocean.vessel_emissions import VesselEmissionsAPI  import pandas as pd  connection = Connection(signal_ocean_api_key) api = VesselEmissionsAPI(connection) In\u00a0[3]: Copied! <pre>voyage_emissions = api.get_emissions_by_imo_and_voyage_number(imo=9412036, voyage_number=140)\nprint(\"Return type is: \", type(voyage_emissions), \"\\n\")\n</pre> voyage_emissions = api.get_emissions_by_imo_and_voyage_number(imo=9412036, voyage_number=140) print(\"Return type is: \", type(voyage_emissions), \"\\n\") <pre>Return type is:  &lt;class 'signal_ocean.vessel_emissions.models.EmissionsEstimation'&gt; \n\n</pre> In\u00a0[4]: Copied! <pre>voyage_emissions.to_dict().keys()\n</pre> voyage_emissions.to_dict().keys() Out[4]: <pre>dict_keys(['ID', 'IMO', 'VesselName', 'VoyageNumber', 'VesselTypeID', 'VesselClassID', 'StartDate', 'EndDate', 'Deadweight', 'Emissions', 'VesselType', 'VesselClass', 'Quantity', 'TransportWorkInMillionTonneMiles', 'TransportWorkInMillionDwtMiles', 'ContainsEuEmissions'])</pre> In\u00a0[5]: Copied! <pre>voyage_emissions = api.get_emissions_by_imo_and_voyage_number(imo=9412036, voyage_number=140,\n                                                              include_consumptions=True,\n                                                              include_distances=True,\n                                                              include_durations=True,\n                                                              include_speed_statistics=True\n                                                             )\n</pre> voyage_emissions = api.get_emissions_by_imo_and_voyage_number(imo=9412036, voyage_number=140,                                                               include_consumptions=True,                                                               include_distances=True,                                                               include_durations=True,                                                               include_speed_statistics=True                                                              ) In\u00a0[6]: Copied! <pre>voyage_emissions = api.get_emissions_by_imo_and_voyage_number(imo=9412036, voyage_number=140,\n                                                              include_efficiency_metrics=True\n                                                             )\n</pre> voyage_emissions = api.get_emissions_by_imo_and_voyage_number(imo=9412036, voyage_number=140,                                                               include_efficiency_metrics=True                                                              ) In\u00a0[7]: Copied! <pre>voyage_emissions = api.get_emissions_by_imo_and_voyage_number(imo=9412036, voyage_number=140,\n                                                              include_eu_emissions=True\n                                                             )\n</pre> voyage_emissions = api.get_emissions_by_imo_and_voyage_number(imo=9412036, voyage_number=140,                                                               include_eu_emissions=True                                                              ) In\u00a0[8]: Copied! <pre>imo = 9412036\nvessel_emissions = api.get_emissions_by_imo(imo=imo, include_distances=True, include_eu_emissions=True)\n\nprint(f\"Return type is: {type(vessel_emissions)}, of {type(vessel_emissions[0])}\")\n\nfirst, last = vessel_emissions[0], vessel_emissions[-1]\n\nprint(f\"\"\"Return objects consists of {len(vessel_emissions)} voyage emissions estimations for vessel {imo}, for Voyages #{first.voyage_number} to #{last.voyage_number}\"\"\" )\n</pre> imo = 9412036 vessel_emissions = api.get_emissions_by_imo(imo=imo, include_distances=True, include_eu_emissions=True)  print(f\"Return type is: {type(vessel_emissions)}, of {type(vessel_emissions[0])}\")  first, last = vessel_emissions[0], vessel_emissions[-1]  print(f\"\"\"Return objects consists of {len(vessel_emissions)} voyage emissions estimations for vessel {imo}, for Voyages #{first.voyage_number} to #{last.voyage_number}\"\"\" ) <pre>Return type is: &lt;class 'list'&gt;, of &lt;class 'signal_ocean.vessel_emissions.models.EmissionsEstimation'&gt;\nReturn objects consists of 71 voyage emissions estimations for vessel 9412036, for Voyages #106 to #176\n</pre> In\u00a0[9]: Copied! <pre>emissions_as_dicts = [emissions.to_dict() for emissions in vessel_emissions]\n</pre> emissions_as_dicts = [emissions.to_dict() for emissions in vessel_emissions] In\u00a0[10]: Copied! <pre>vessel_class_emissions = api.get_emissions_by_vessel_class_id(vessel_class_id=86)\nvessel_class_emissions_df = pd.json_normalize(vessel_class_emissions.to_dict()['Data'], sep='')\nvessel_class_emissions_df.head()\n</pre> vessel_class_emissions = api.get_emissions_by_vessel_class_id(vessel_class_id=86) vessel_class_emissions_df = pd.json_normalize(vessel_class_emissions.to_dict()['Data'], sep='') vessel_class_emissions_df.head() Out[10]: ID IMO VesselName VoyageNumber VesselTypeID VesselClassID StartDate EndDate Deadweight VesselType ... EmissionsPortCallSOxInTons EmissionsPortCallPmInTons EmissionsStopCO2InTons EmissionsStopCOInTons EmissionsStopCh4InTons EmissionsStopN2OInTons EmissionsStopNMVOCInTons EmissionsStopNOxInTons EmissionsStopSOxInTons EmissionsStopPmInTons 0 I92EA8CVEDE4C9900 9628300 Hilda Knutsen 183 1 86 2024-08-22T23:56:14 2024-09-10T23:06:37.484000 123166 Tanker ... 0.156405 0.075120 241.371325 0.208546 0.004517 0.011293 0.231885 6.169800 0.147191 0.070695 1 I8F414CVEDE250C00 9388364 Merbabu 181 1 86 2024-07-21T03:49:12 2024-11-12T09:30:00.792000 105746 Tanker ... 0.156405 0.106184 1383.738290 1.216410 0.026348 0.070262 1.352542 40.760697 0.858539 1.321780 2 I906053VED3547E00 9461843 Torm Gloria 58 1 86 2018-10-27T06:15:32 2019-06-03T07:51:23 119456 Tanker ... 3.910120 0.557153 4073.305629 3.622867 0.078474 0.209263 4.028314 114.022214 63.925290 9.108708 3 I8DEDABVEDE4C9900 9301419 Yuri Senkevich 307 1 86 2024-09-02T03:55:44 2024-09-15T12:22:59.041000 100869 Tanker ... 0.156405 0.075120 33.336873 0.029306 0.000635 0.001693 0.032585 0.982002 0.020684 0.031844 4 I95A928VEDE59C800 9808168 Green Aura 64 1 86 2024-08-31T23:45:55 2024-09-17T07:30:23.790000 113000 Tanker ... 0.096189 0.210047 76.735187 0.066300 0.001436 0.003590 0.073719 1.765197 0.001404 0.010114 <p>5 rows \u00d7 55 columns</p> <p>To get the next page, we repeat the same api call using the token that we got from the previous.</p> In\u00a0[11]: Copied! <pre>vessel_class_emissions_next_page = api.get_emissions_by_vessel_class_id(\n    vessel_class_id=86,\n    token=vessel_class_emissions.to_dict()['NextPageToken']\n)\npd.json_normalize(vessel_class_emissions_next_page.to_dict()['Data']).head()\n</pre> vessel_class_emissions_next_page = api.get_emissions_by_vessel_class_id(     vessel_class_id=86,     token=vessel_class_emissions.to_dict()['NextPageToken'] ) pd.json_normalize(vessel_class_emissions_next_page.to_dict()['Data']).head() Out[11]: ID IMO VesselName VoyageNumber VesselTypeID VesselClassID StartDate EndDate Deadweight VesselType ... Emissions.PortCall.SOxInTons Emissions.PortCall.PmInTons Emissions.Stop.CO2InTons Emissions.Stop.COInTons Emissions.Stop.Ch4InTons Emissions.Stop.N2OInTons Emissions.Stop.NMVOCInTons Emissions.Stop.NOxInTons Emissions.Stop.SOxInTons Emissions.Stop.PmInTons 0 I8A6CCAVED61C6800 9071818 Athina I 99 1 86 2020-04-18T07:12:38 2020-06-02T11:59:29 96001 Tanker ... 0.537641 0.827736 24.676837 0.021693 0.000470 0.001253 0.024120 0.726904 0.015311 0.023572 1 I8A6CCAVED643F500 9071818 Athina I 100 1 86 2020-06-02T11:59:29 2020-06-12T07:58:33 96001 Tanker ... 0.156405 0.240796 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 2 I8A6CCAVED66B8200 9071818 Athina I 101 1 86 2020-06-12T07:58:33 2020-08-03T15:57:16 96001 Tanker ... 0.185731 0.285945 4.296830 0.003777 0.000082 0.000218 0.004200 0.126571 0.002666 0.004104 3 I8A6CCAVED6930F00 9071818 Athina I 102 1 86 2020-08-03T15:57:16 2020-09-04T15:57:13 96001 Tanker ... 0.185731 0.285945 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 4 I8A6CCAVED6E22900 9071818 Athina I 103 1 86 2020-09-04T15:57:13 2020-10-03T19:54:35 96001 Tanker ... 0.185731 0.285945 2.549097 0.002241 0.000049 0.000129 0.002492 0.075089 0.001582 0.002435 <p>5 rows \u00d7 55 columns</p> In\u00a0[12]: Copied! <pre>vessel_metrics = api.get_metrics_by_imo(imo=9412036)\n\nprint(\"Return type is: \", type(vessel_metrics), \"of\", type(vessel_metrics[0]), \"\\n\")\n\nprint(\"Return objects is:\\n\", )\nvessel_metrics[0]\n</pre> vessel_metrics = api.get_metrics_by_imo(imo=9412036)  print(\"Return type is: \", type(vessel_metrics), \"of\", type(vessel_metrics[0]), \"\\n\")  print(\"Return objects is:\\n\", ) vessel_metrics[0] <pre>Return type is:  &lt;class 'list'&gt; of &lt;class 'signal_ocean.vessel_emissions.models.VesselMetrics'&gt; \n\nReturn objects is:\n\n</pre> Out[12]: <pre>VesselMetrics(imo=9412036, year=2018, vessel_type=Tanker, vessel_type_id=1, vessel_class=Aframax, vessel_class_id=86, eexi=Eexi(value=4.205015419201572, unit='g-CO2/ton mile', required=3.288153751950862), eiv=Eiv(value=4.69363738382239, unit='g-CO2/ton mile'), aer=Aer(value=4.370328069517782, unit='g-CO2/dwt mile', poseidon_principles_class='Oil Tanker 80000-119999 DWT', poseidon_principles_alignment_in_percentage=11.204276578060616, poseidon_principles_year_target=3.93), cii=Cii(value=4.247319824890369, unit='g-CO2/capacity mile', rating='C', target=4.264058648014019, target_year=2018))</pre> In\u00a0[13]: Copied! <pre>pd.json_normalize([metrics.to_dict() for metrics in vessel_metrics], sep='').head()\n</pre> pd.json_normalize([metrics.to_dict() for metrics in vessel_metrics], sep='').head() Out[13]: IMO Year VesselType VesselTypeID VesselClass VesselClassID EexiValue EexiUnit EexiRequired EivValue ... AerValue AerUnit AerPoseidonPrinciplesClass AerPoseidonPrinciplesAlignmentInPercentage AerPoseidonPrinciplesYearTarget CiiValue CiiUnit CiiRating CiiTarget CiiTargetYear 0 9412036 2018 Tanker 1 Aframax 86 4.205015 g-CO2/ton mile 3.288154 4.693637 ... 4.370328 g-CO2/dwt mile Oil Tanker 80000-119999 DWT 11.204277 3.93 4.247320 g-CO2/capacity mile C 4.264059 2018 1 9412036 2019 Tanker 1 Aframax 86 4.205015 g-CO2/ton mile 3.288154 4.693637 ... 3.578199 g-CO2/dwt mile Oil Tanker 80000-119999 DWT -6.817738 3.84 3.609029 g-CO2/capacity mile B 4.264059 2019 2 9412036 2020 Tanker 1 Aframax 86 4.205015 g-CO2/ton mile 3.288154 4.693637 ... 3.687948 g-CO2/dwt mile Oil Tanker 80000-119999 DWT -1.391768 3.74 3.676282 g-CO2/capacity mile B 4.221418 2020 3 9412036 2021 Tanker 1 Aframax 86 4.205015 g-CO2/ton mile 3.288154 4.693637 ... 4.081832 g-CO2/dwt mile Oil Tanker 80000-119999 DWT 12.138239 3.64 4.065335 g-CO2/capacity mile C 4.178777 2021 4 9412036 2022 Tanker 1 Aframax 86 4.205015 g-CO2/ton mile 3.288154 4.693637 ... 3.732896 g-CO2/dwt mile Oil Tanker 80000-119999 DWT 5.449053 3.54 3.732896 g-CO2/capacity mile B 4.136137 2022 <p>5 rows \u00d7 21 columns</p> In\u00a0[14]: Copied! <pre>vessel_metrics = api.get_metrics_by_imo(imo=9412036, year=2020)\n</pre> vessel_metrics = api.get_metrics_by_imo(imo=9412036, year=2020) In\u00a0[15]: Copied! <pre>vessel_class_metrics = api.get_metrics_by_vessel_class_id(vessel_class_id=86)\n</pre> vessel_class_metrics = api.get_metrics_by_vessel_class_id(vessel_class_id=86) In\u00a0[16]: Copied! <pre>vessel_class_metrics_2020 = api.get_metrics_by_vessel_class_id(vessel_class_id=86, year=2020)\n</pre> vessel_class_metrics_2020 = api.get_metrics_by_vessel_class_id(vessel_class_id=86, year=2020)"},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#vessel-emissions-api-example","title":"Vessel Emissions API Example\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#in-this-notebook-we-will-showcase-the-vessel-emissions-api-and-supported-methods-with-examples","title":"In this notebook, we will showcase the Vessel Emissions API and supported methods with examples.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#call-the-vessel-emissions-api","title":"Call the Vessel Emissions API\u00b6","text":"<p>The Vessel Emissions API retrieves information about voyage emissions, vessel emissions and metrics for a single vessel or a vessel class.</p>"},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#examples","title":"Examples\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#get-emissions-for-a-voyage","title":"Get Emissions for a voyage\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#note-that-this-function-returns-a-custom-object-to-get-a-dictionary-object-as-in-the-public-api-response-we-can-call-class-method-to_dict","title":"Note that this function returns a custom object. To get a dictionary object, as in the public API response, we can call class method to_dict().\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#include-consumptions-distances-durations-speed_statistics-in-the-response","title":"Include consumptions, distances, durations, speed_statistics in the response\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#include-efficiency-metrics-in-the-response","title":"Include efficiency metrics in the response\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#include-eu-regulated-emissions-in-the-response","title":"Include EU regulated emissions in the response\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#get-emissions-for-a-vessel","title":"Get Emissions for a vessel\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#note-that-this-function-returns-a-list-of-custom-objects-to-get-a-list-of-dictionary-objects-as-in-the-public-api-response-we-can-call-method-to_dict-in-a-list-comprehension","title":"Note that this function returns a list of custom objects. To get a list of dictionary objects, as in the public API response, we can call method to_dict() in a list comprehension.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#get-emissions-for-a-vessel-class","title":"Get Emissions for a vessel class.\u00b6","text":"<p>Again, we can get a dictionary, similar to the response of the public API by calling method to_dict(). This dict has two keys, 'NextPageToken' which can be used in the next api call and 'Data', where our emissions are stored as a list of dictionaries. We can apply the pandas DataFrame constructor to that list get our emissions in table format.</p>"},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#vessel-metrics","title":"Vessel Metrics\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#since-our-return-object-is-a-list-we-need-to-use-to_dict-method-and-list-comprehension-to-get-a-list-of-dictionaries-then-using-pddataframe-we-get-our-metrics-in-table-format","title":"Since our return object is a list, we need to use to_dict() method and list comprehension to get a list of dictionaries. Then, using pd.DataFrame we get our metrics in table format.\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#get-metrics-for-a-vessel-for-a-specific-year","title":"Get Metrics for a vessel for a specific year\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#get-metrics-for-a-vessel-class","title":"Get Metrics for a vessel class\u00b6","text":""},{"location":"examples/jupyter/VesselEmissionsAPI/VesselEmissionsAPI/#get-metrics-for-a-vessel-class-for-a-specific-year","title":"Get Metrics for a vessel class for a specific year\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/ExploreVessels/","title":"Vessels API Use Case - Explore Vessels","text":"Setup In\u00a0[\u00a0]: Copied! <pre>pip install seaborn\n</pre> pip install seaborn <p>Install the Signal Ocean SDK:</p> In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean <p>Import required libraries / APIs / packages:</p> Import Vessels API and some additional libraries In\u00a0[\u00a0]: Copied! <pre>from signal_ocean.vessels import VesselsAPI\nimport pandas as pd\nimport seaborn as sns\nfrom datetime import datetime\nfrom signal_ocean import Connection\n</pre> from signal_ocean.vessels import VesselsAPI import pandas as pd import seaborn as sns from datetime import datetime from signal_ocean import Connection <p>Fill in your personal SignalOcean API subscription key acquired here and open a connection:</p> In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key <p>Create a connection</p> In\u00a0[2]: Copied! <pre>connection = Connection(signal_ocean_api_key)\n</pre> connection = Connection(signal_ocean_api_key) In\u00a0[2]: Copied! <pre>api = VesselsAPI(connection)\n</pre> api = VesselsAPI(connection) In\u00a0[5]: Copied! <pre>vessels = api.get_vessels()\n</pre> vessels = api.get_vessels() <p>Extract the returned information into a dataframe</p> In\u00a0[6]: Copied! <pre>df = pd.DataFrame([x.__dict__ for x in vessels])\n</pre> df = pd.DataFrame([x.__dict__ for x in vessels]) In\u00a0[7]: Copied! <pre>df['vessel_age'] = df.apply(lambda r: datetime.now().year - r['year_built'], axis=1)\ndata = df[(pd.isnull(df['scrapped_date']))&amp;(df['vessel_class'].isin(['VLCC', 'Suezmax', 'Aframax']))]\n\nsns.set(rc={'figure.figsize':(9,6)})\nsns.kdeplot(data=data, x='vessel_age', hue='vessel_class', multiple=\"stack\", palette=\"crest\",\n   alpha=.7, linewidth=0.1);\n</pre> df['vessel_age'] = df.apply(lambda r: datetime.now().year - r['year_built'], axis=1) data = df[(pd.isnull(df['scrapped_date']))&amp;(df['vessel_class'].isin(['VLCC', 'Suezmax', 'Aframax']))]  sns.set(rc={'figure.figsize':(9,6)}) sns.kdeplot(data=data, x='vessel_age', hue='vessel_class', multiple=\"stack\", palette=\"crest\",    alpha=.7, linewidth=0.1); In\u00a0[8]: Copied! <pre>data = df[(pd.isnull(df['scrapped_date']))&amp;(df['vessel_class'].isin(['VLCC', 'Suezmax', 'Aframax']))]\n\nsns.pairplot(data, kind='kde', hue='vessel_class', vars=['deadweight', 'length_overall', 'breadth_extreme']);\n</pre> data = df[(pd.isnull(df['scrapped_date']))&amp;(df['vessel_class'].isin(['VLCC', 'Suezmax', 'Aframax']))]  sns.pairplot(data, kind='kde', hue='vessel_class', vars=['deadweight', 'length_overall', 'breadth_extreme']);"},{"location":"examples/jupyter/VesselsAPI/ExploreVessels/#vessels-api-use-case-explore-vessels","title":"Vessels API Use Case - Explore Vessels\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/ExploreVessels/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/ExploreVessels/#call-the-vessels-api","title":"Call the vessels API\u00b6","text":"<p>The Vessels API retrieves vessel information.</p>"},{"location":"examples/jupyter/VesselsAPI/ExploreVessels/#get-details-for-all-vessels","title":"Get details for all vessels\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/ExploreVessels/#visualize-fleet-age-by-vessel-class-for-vlcc-suezmax-and-aframax-tankers","title":"Visualize fleet age by vessel class for VLCC, Suezmax and Aframax Tankers\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/ExploreVessels/#visualize-pairwise-relationships-for-deadweight-length_overall-and-breadth_extreme-for-vlcc-suezmax-and-aframax-tankers","title":"Visualize pairwise relationships for deadweight, length_overall and breadth_extreme for VLCC, Suezmax and Aframax Tankers\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/","title":"Vessels API Example","text":"Setup <p>Install the Signal Ocean SDK:</p> In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean <p>Import required libraries / APIs / packages:</p> Import Vessels API and some additional libraries In\u00a0[1]: Copied! <pre>from signal_ocean.vessels import VesselsAPI\nimport pandas as pd\nfrom datetime import datetime\nfrom signal_ocean import Connection\n</pre> from signal_ocean.vessels import VesselsAPI import pandas as pd from datetime import datetime from signal_ocean import Connection <p>Fill in your personal SignalOcean API subscription key acquired here and open a connection:</p> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key <p>Create a connection</p> In\u00a0[3]: Copied! <pre>connection = Connection(signal_ocean_api_key)\n</pre> connection = Connection(signal_ocean_api_key) In\u00a0[4]: Copied! <pre>api = VesselsAPI(connection)\n</pre> api = VesselsAPI(connection) <p>Retrieve information on the various vessel classes</p> In\u00a0[5]: Copied! <pre>vessel_classes = api.get_vessel_classes()\n</pre> vessel_classes = api.get_vessel_classes() <p>Extract the returned information into a dataframe</p> In\u00a0[6]: Copied! <pre>pd.DataFrame([vc.__dict__ for vc in vessel_classes]).head()\n</pre> pd.DataFrame([vc.__dict__ for vc in vessel_classes]).head() Out[6]: id vessel_type_id from_size to_size name vessel_type defining_size size 0 -2 -2 0 0 Not set Not Set NotSet NotSet 1 -1 -1 0 0 Unknown Unknown Unknown Unknown 2 60 6 70001 250000 VLGC LPG CubicSize cbm 3 61 6 28001 70000 Midsize/LGC LPG CubicSize cbm 4 62 6 10001 28000 Handy LPG CubicSize cbm <p>Retrieve information on the various vessel types</p> In\u00a0[7]: Copied! <pre>vessel_types = api.get_vessel_types()\n</pre> vessel_types = api.get_vessel_types() <p>Extract the returned information into a dataframe</p> In\u00a0[8]: Copied! <pre>pd.DataFrame([vc.__dict__ for vc in vessel_types]).head(7)\n</pre> pd.DataFrame([vc.__dict__ for vc in vessel_types]).head(7) Out[8]: id name 0 -2 Not Set 1 -1 Unknown 2 6 LPG 3 3 Dry 4 4 Container 5 1 Tanker 6 5 LNG In\u00a0[9]: Copied! <pre>imo = 9436006\nv = api.get_vessel(imo)\nprint(f'{v.imo}: {v.vessel_name} ({v.vessel_class} / {v.commercial_operator})')\n</pre> imo = 9436006 v = api.get_vessel(imo) print(f'{v.imo}: {v.vessel_name} ({v.vessel_class} / {v.commercial_operator})') <pre>9436006: Samira (Aframax / Unknown)\n</pre> In\u00a0[10]: Copied! <pre>vessels = api.get_vessels()\n</pre> vessels = api.get_vessels() <p>Extract the returned information into a dataframe</p> In\u00a0[11]: Copied! <pre>df = pd.DataFrame([x.__dict__ for x in vessels])\n</pre> df = pd.DataFrame([x.__dict__ for x in vessels]) In\u00a0[12]: Copied! <pre>df[['imo', 'vessel_name', 'vessel_class']].sample(5)\n</pre> df[['imo', 'vessel_name', 'vessel_class']].sample(5) Out[12]: imo vessel_name vessel_class 21529 9121950 Ronika Small 39179 9468152 Diamond Sea Supramax 24506 9183843 Themsestern Small 43464 9566435 Sanctum Supramax 22524 9141302 San Diego Panamax In\u00a0[13]: Copied! <pre>df[pd.isnull(df['scrapped_date'])]['vessel_class'].value_counts().to_frame('vessel_count').head(10)\n</pre> df[pd.isnull(df['scrapped_date'])]['vessel_class'].value_counts().to_frame('vessel_count').head(10) Out[13]: vessel_count vessel_class Small 21886 Panamax 4487 Supramax 4179 Handysize 3565 MR2 2125 Post Panamax 1959 Capesize 1804 Feeder 1662 Aframax 1406 VLCC 1113 In\u00a0[14]: Copied! <pre>data = df[(df['vessel_class']=='Aframax')&amp;(pd.isnull(df['scrapped_date']))]\ndata['commercial_operator'].value_counts().head(10)\n</pre> data = df[(df['vessel_class']=='Aframax')&amp;(pd.isnull(df['scrapped_date']))] data['commercial_operator'].value_counts().head(10) Out[14]: <pre>commercial_operator\nUnknown                          302\nSovcomflot                        49\nTrafigura                         29\nShell                             29\nMaersk                            28\nScorpio Commercial Management     25\nTeekay Corp                       24\nCardiff Marine                    22\nAET                               22\nThenamaris                        22\nName: count, dtype: int64</pre> In\u00a0[15]: Copied! <pre>vessels = api.get_vessels('helen')\nlen(vessels)\n</pre> vessels = api.get_vessels('helen') len(vessels) Out[15]: <pre>39</pre> <p>Extract the returned information into a dataframe</p> In\u00a0[16]: Copied! <pre>df = pd.DataFrame([x.__dict__ for x in vessels])\ndf.head()\n</pre> df = pd.DataFrame([x.__dict__ for x in vessels]) df.head() Out[16]: imo vessel_type_id built_for_trade_id trade_id vessel_class_id commercial_operator_id deadweight breadth_extreme gross_rated_tonnage reduced_gross_tonnage ... empty_parallel_body_length stern_line yard_number design_model bow_to_center_manifold water_line_to_manifold deck_to_center_manifold rail_to_center_manifold bow_chain_stoppers_fitted sanctions_history 0 6716857 4 -1 -1 95 -1 1180 11 953 762 ... NaN None None None NaN NaN NaN NaN None None 1 7360083 1 1 1 84 -1 274333 52 133871 98338 ... NaN None None None NaN NaN NaN NaN None None 2 7915644 3 4 4 74 -1 69420 32 41644 33659 ... NaN None None None NaN NaN NaN NaN None None 3 8120571 3 4 4 77 -1 34913 28 20922 16169 ... NaN None None None NaN NaN NaN NaN None None 4 8671702 3 4 4 77 -1 26700 24 16490 16182 ... NaN None None None NaN NaN NaN NaN None None <p>5 rows \u00d7 115 columns</p> <p>You can get Vessel Name changes for all vessels or for a specific one</p> In\u00a0[17]: Copied! <pre>imo = 9436006\nvessels_names = api.get_vessels_name_history(imo)\n</pre> imo = 9436006 vessels_names = api.get_vessels_name_history(imo) In\u00a0[18]: Copied! <pre>df = pd.DataFrame([x.__dict__ for x in vessels_names[0].history[0].values])\n</pre> df = pd.DataFrame([x.__dict__ for x in vessels_names[0].history[0].values]) In\u00a0[19]: Copied! <pre>df\n</pre> df Out[19]: value begin_date end_date name 0 Stealth Chios 1900-01-01 00:00:00+00:00 2012-01-01 23:13:55+00:00 None 1 Signal Cheetah 2012-01-01 23:13:55+00:00 2021-02-25 23:56:31+00:00 None 2 Stealth Chios 2021-02-25 23:56:31+00:00 2021-05-01 07:41:09+00:00 None 3 Paramount 2021-05-01 07:41:09+00:00 2023-03-10 18:59:11+00:00 None 4 Samsun 2023-03-10 18:59:11+00:00 2025-05-18 11:24:57+00:00 None 5 Samira 2025-05-18 11:24:57+00:00 9999-12-31 23:59:59.999999+00:00 None <p>You can get Vessel comOpp changes for all vessels or for a specific one</p> In\u00a0[20]: Copied! <pre>imo = 9436006\nvessels_commOps = api.get_vessels_commOp_history(imo)\n</pre> imo = 9436006 vessels_commOps = api.get_vessels_commOp_history(imo) In\u00a0[21]: Copied! <pre>df = pd.DataFrame([x.__dict__ for x in vessels_commOps[0].history[0].values])\n</pre> df = pd.DataFrame([x.__dict__ for x in vessels_commOps[0].history[0].values]) In\u00a0[22]: Copied! <pre>df\n</pre> df Out[22]: value begin_date end_date name 0 1926 1900-01-01 00:00:00+00:00 2016-06-12 13:03:12+00:00 Signal Maritime 1 1713 2016-06-12 13:03:12+00:00 2016-06-13 13:03:12+00:00 Trafigura 2 1926 2016-06-13 13:03:12+00:00 2021-02-22 00:00:00+00:00 Signal Maritime 3 1597 2021-02-22 00:00:00+00:00 2025-01-09 14:59:56+00:00 Stealth Maritime Corp 4 -1 2025-01-09 14:59:56+00:00 9999-12-31 23:59:59.999999+00:00 Unknown <p>You can get Vessel Flag changes for all vessels or for a specific one</p> In\u00a0[23]: Copied! <pre>imo = 9436006\nvessels_flags = api.get_vessels_flag_history(imo)\n</pre> imo = 9436006 vessels_flags = api.get_vessels_flag_history(imo) In\u00a0[24]: Copied! <pre>df = pd.DataFrame([x.__dict__ for x in vessels_flags[0].history[0].values])\n</pre> df = pd.DataFrame([x.__dict__ for x in vessels_flags[0].history[0].values]) In\u00a0[25]: Copied! <pre>df\n</pre> df Out[25]: value begin_date end_date name 0 CY 1900-01-01 00:00:00+00:00 2009-05-07 10:46:24+00:00 Cyprus 1 MH 2009-05-07 10:46:24+00:00 2009-07-06 15:53:10+00:00 Marshall Islands 2 GR 2009-07-06 15:53:10+00:00 2014-04-28 11:44:52+00:00 Greece 3 MT 2014-04-28 11:44:52+00:00 2021-02-26 14:17:30.780000+00:00 Malta 4 MH 2021-02-26 14:17:30.780000+00:00 2023-03-22 16:23:00.150000+00:00 Marshall Islands 5 PA 2023-03-22 16:23:00.150000+00:00 2025-06-18 22:14:26.711006+00:00 Panama 6 KM 2025-06-18 22:14:26.711006+00:00 9999-12-31 23:59:59.999999+00:00 Comoros"},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#vessels-api-example","title":"Vessels API Example\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#call-the-vessels-api","title":"Call the vessels API\u00b6","text":"<p>The Vessels API retrieves vessel information.</p>"},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#get-vessel-classes","title":"Get vessel classes\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#get-vessel-types","title":"Get vessel types\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#get-details-for-a-specific-vessel","title":"Get details for a specific vessel\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#get-details-for-all-vessels","title":"Get details for all vessels\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#find-fleet-size-per-vessel-class-exclude-scrapped-vessels","title":"Find fleet size per vessel class - exclude scrapped vessels\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#find-the-commercial-operators-that-currently-operate-the-largest-aframax-fleets","title":"Find the commercial operators that currently operate the largest Aframax fleets\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#get-all-vessels-the-name-of-which-contains-the-term-helen","title":"Get all vessels the name of which contains the term helen\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#get-vessel-names-changes","title":"Get Vessel Names Changes\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#get-commercial-operator-changes","title":"Get Commercial Operator Changes\u00b6","text":""},{"location":"examples/jupyter/VesselsAPI/VesselsAPI/#get-flag-changes","title":"Get Flag Changes\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/","title":"Dry Bulk Flows","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nimport pandas as pd\nfrom datetime import date, datetime\nimport plotly.express as px\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI import pandas as pd from datetime import date, datetime import plotly.express as px In\u00a0[3]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) <p>Get vessel class ids for Dry  vessel classes</p> In\u00a0[4]: Copied! <pre>vessel_classes = api.get_vessel_classes()\nvessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes)\nvessel_classes_df[vessel_classes_df['vessel_type']=='Dry'].head(10)\n</pre> vessel_classes = api.get_vessel_classes() vessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes) vessel_classes_df[vessel_classes_df['vessel_type']=='Dry'].head(10) Out[4]: vessel_class_id vessel_class_name vessel_type_id vessel_type 4 69 VLOC 3 Dry 5 70 Capesize 3 Dry 6 72 Post Panamax 3 Dry 7 74 Panamax 3 Dry 8 75 Supramax 3 Dry 9 76 Handymax 3 Dry 10 77 Handysize 3 Dry 19 92 Small 3 Dry In\u00a0[5]: Copied! <pre>voyages = api.get_voyages_condensed(vessel_class_id=70, date_from=datetime.strptime(\"2021-09-01\", \"%Y-%m-%d\"))\nvoyages = pd.DataFrame([v.__dict__ for v in voyages])\nvoyages.tail(5)\n</pre> voyages = api.get_voyages_condensed(vessel_class_id=70, date_from=datetime.strptime(\"2021-09-01\", \"%Y-%m-%d\")) voyages = pd.DataFrame([v.__dict__ for v in voyages]) voyages.tail(5) Out[5]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... last_discharge_sailing_date last_discharge_country_id last_discharge_country_name last_discharge_area_id_level0 last_discharge_area_name_level0 repairs_ind storage_ind sts_load_ind sts_discharge_ind local_trade_ind 22314 9974084 3 3 70 1 1072.0 False None I98314446VEDD103100 2 ... 2024-03-29 01:31:24.704000+00:00 55.0 China None North China False False False False False 22315 9974096 1 3 70 1 NaN False None I98315046VEDC71FD00 2 ... 2024-02-14 19:45:07.773000+00:00 121.0 Japan None Japan Island True False False False False 22316 9974096 2 3 70 1 NaN False None I98315046VEDD37BE00 3 ... 2024-03-19 14:25:10.371000+00:00 55.0 China None North China False False False False False 22317 9978573 1 3 70 1 NaN False None I9842CD46VEDD37BE00 2 ... NaT NaN None None None True False False False True 22318 9980174 1 3 70 1 NaN False None I98490E46VEDD37BE00 2 ... NaT NaN None None None True False False False True <p>5 rows \u00d7 97 columns</p> <p>Convert Timestamp to datetime, drop voyages with first_load_sailing_date in the future (ongoing or future)</p> In\u00a0[6]: Copied! <pre>voyages['first_load_sailing_date'] = voyages['first_load_sailing_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None))\nvoyages=voyages[voyages['first_load_sailing_date']&lt;datetime.now()]\n</pre> voyages['first_load_sailing_date'] = voyages['first_load_sailing_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None)) voyages=voyages[voyages['first_load_sailing_date'] In\u00a0[7]: Copied! <pre>coal_exports_country_level = voyages[(voyages['first_load_sailing_date']&gt;\"2022-01-01\")&amp;(voyages['cargo_sub_group']=='Coal')] \\\n    .set_index('first_load_sailing_date') \\\n    .groupby(['first_load_country_name', 'last_discharge_country_name'])['quantity'] \\\n    .resample('MS') \\\n    .sum() \\\n    .reset_index() \\\n    .rename(columns={'first_load_sailing_date': 'Date'})\n</pre> coal_exports_country_level = voyages[(voyages['first_load_sailing_date']&gt;\"2022-01-01\")&amp;(voyages['cargo_sub_group']=='Coal')] \\     .set_index('first_load_sailing_date') \\     .groupby(['first_load_country_name', 'last_discharge_country_name'])['quantity'] \\     .resample('MS') \\     .sum() \\     .reset_index() \\     .rename(columns={'first_load_sailing_date': 'Date'}) <p>Drop intra country flows</p> In\u00a0[8]: Copied! <pre>coal_exports_country_level = coal_exports_country_level[coal_exports_country_level['first_load_country_name']!=coal_exports_country_level['last_discharge_country_name']]\ncoal_exports_country_level.head()\n</pre> coal_exports_country_level = coal_exports_country_level[coal_exports_country_level['first_load_country_name']!=coal_exports_country_level['last_discharge_country_name']] coal_exports_country_level.head() Out[8]: first_load_country_name last_discharge_country_name Date quantity 0 Australia Belgium 2022-04-01 131000.0 1 Australia Brazil 2022-01-01 315000.0 2 Australia Brazil 2022-02-01 0.0 3 Australia Brazil 2022-03-01 0.0 4 Australia Brazil 2022-04-01 0.0 <ul> <li>Keep only Australia exports</li> <li>Aggregate all exports monthly</li> <li>Drop unnecessary columns</li> </ul> In\u00a0[9]: Copied! <pre>australia_coal_exports = coal_exports_country_level[(coal_exports_country_level['first_load_country_name']=='Australia')].copy()\n\naustralia_coal_exports['TotalExports'] = australia_coal_exports['quantity'].groupby(australia_coal_exports['Date']).transform('sum')\naustralia_coal_exports.drop_duplicates(subset=['Date'], keep='last', inplace = True)\naustralia_coal_exports.drop(['last_discharge_country_name', 'quantity'], axis=1, inplace = True)\naustralia_coal_exports.head()\n</pre> australia_coal_exports = coal_exports_country_level[(coal_exports_country_level['first_load_country_name']=='Australia')].copy()  australia_coal_exports['TotalExports'] = australia_coal_exports['quantity'].groupby(australia_coal_exports['Date']).transform('sum') australia_coal_exports.drop_duplicates(subset=['Date'], keep='last', inplace = True) australia_coal_exports.drop(['last_discharge_country_name', 'quantity'], axis=1, inplace = True) australia_coal_exports.head() Out[9]: first_load_country_name Date TotalExports 383 Australia 2022-01-01 11198000.0 384 Australia 2022-02-01 10673000.0 385 Australia 2022-03-01 10345000.0 386 Australia 2022-04-01 9261000.0 387 Australia 2022-05-01 12362000.0 In\u00a0[10]: Copied! <pre>australia_coal_exports['Year'] = australia_coal_exports['Date'].apply(lambda date : date.year)\naustralia_coal_exports['Month'] = australia_coal_exports['Date'].apply(lambda date : date.month)\naustralia_coal_exports.sort_values(['Month', 'Year'], inplace = True)\naustralia_coal_exports['Month'] = australia_coal_exports['Date'].apply(lambda date : date.strftime(\"%b\"))\n\nfig = px.histogram(australia_coal_exports, x=\"Month\", y=\"TotalExports\", color='Year',\n             barmode='group', height=500, width=1000,\n             title='Australia Capesize Coal Exports',\n             color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"])\nfig.show()\n</pre> australia_coal_exports['Year'] = australia_coal_exports['Date'].apply(lambda date : date.year) australia_coal_exports['Month'] = australia_coal_exports['Date'].apply(lambda date : date.month) australia_coal_exports.sort_values(['Month', 'Year'], inplace = True) australia_coal_exports['Month'] = australia_coal_exports['Date'].apply(lambda date : date.strftime(\"%b\"))  fig = px.histogram(australia_coal_exports, x=\"Month\", y=\"TotalExports\", color='Year',              barmode='group', height=500, width=1000,              title='Australia Capesize Coal Exports',              color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"]) fig.show() In\u00a0[11]: Copied! <pre>voyages['last_discharge_arrival_date'] = voyages['last_discharge_arrival_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None))\nvoyages=voyages[voyages['last_discharge_arrival_date']&lt;datetime.now()]\nvoyages.head()\n</pre> voyages['last_discharge_arrival_date'] = voyages['last_discharge_arrival_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None)) voyages=voyages[voyages['last_discharge_arrival_date'] Out[11]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... last_discharge_sailing_date last_discharge_country_id last_discharge_country_name last_discharge_area_id_level0 last_discharge_area_name_level0 repairs_ind storage_ind sts_load_ind sts_discharge_ind local_trade_ind 0 9123180 69 3 70 1 832.0 False None I8B356CVED8BCC500 1 ... 2021-10-04 19:54:56+00:00 112.0 India None East Coast India False False False False False 1 9123180 70 3 70 1 832.0 False None I8B356CVED8E45200 1 ... 2021-11-27 23:58:17+00:00 112.0 India None East Coast India False False False False False 2 9123180 71 3 70 1 832.0 False None I8B356CVED9336C00 1 ... 2022-01-20 23:56:47+00:00 112.0 India None East Coast India False False False False False 3 9123180 72 3 70 1 832.0 False None I8B356CVED95AF900 1 ... 2022-01-31 19:57:54+00:00 112.0 India None East Coast India False False False False True 4 9123180 73 3 70 1 832.0 False None I8B356CVED9828600 1 ... 2022-02-11 19:57:47+00:00 112.0 India None East Coast India False False False False True <p>5 rows \u00d7 97 columns</p> <ul> <li>Keep only voyages with 'Iron Ore' as cargo group</li> <li>Group by origin and destination (first load, last discharge), and use last_discharge_arrival_date as date of flow</li> </ul> In\u00a0[12]: Copied! <pre>iron_ore_flows_country_level = voyages[(voyages['last_discharge_arrival_date']&gt;\"2022-01-01\")&amp;(voyages['cargo_sub_group']=='Iron Ore')] \\\n    .set_index('last_discharge_arrival_date') \\\n    .groupby(['first_load_country_name', 'last_discharge_country_name'])['quantity'] \\\n    .resample('MS') \\\n    .sum() \\\n    .reset_index() \\\n    .rename(columns={'last_discharge_arrival_date': 'Date'})\niron_ore_flows_country_level.head()\n</pre> iron_ore_flows_country_level = voyages[(voyages['last_discharge_arrival_date']&gt;\"2022-01-01\")&amp;(voyages['cargo_sub_group']=='Iron Ore')] \\     .set_index('last_discharge_arrival_date') \\     .groupby(['first_load_country_name', 'last_discharge_country_name'])['quantity'] \\     .resample('MS') \\     .sum() \\     .reset_index() \\     .rename(columns={'last_discharge_arrival_date': 'Date'}) iron_ore_flows_country_level.head() Out[12]: first_load_country_name last_discharge_country_name Date quantity 0 Australia Australia 2022-01-01 310000.0 1 Australia Australia 2022-02-01 164000.0 2 Australia Australia 2022-03-01 139000.0 3 Australia Australia 2022-04-01 420000.0 4 Australia Australia 2022-05-01 145000.0 <p>Keep only flows between Australia and China</p> In\u00a0[13]: Copied! <pre>china_australia_iron_ore_flows = iron_ore_flows_country_level[(iron_ore_flows_country_level['first_load_country_name']=='Australia')&amp;(iron_ore_flows_country_level['last_discharge_country_name']=='China')].copy()\nchina_australia_iron_ore_flows.head()\n</pre> china_australia_iron_ore_flows = iron_ore_flows_country_level[(iron_ore_flows_country_level['first_load_country_name']=='Australia')&amp;(iron_ore_flows_country_level['last_discharge_country_name']=='China')].copy() china_australia_iron_ore_flows.head() Out[13]: first_load_country_name last_discharge_country_name Date quantity 26 Australia China 2022-01-01 55255000.0 27 Australia China 2022-02-01 41381000.0 28 Australia China 2022-03-01 48940000.0 29 Australia China 2022-04-01 47581000.0 30 Australia China 2022-05-01 53061000.0 In\u00a0[14]: Copied! <pre>china_australia_iron_ore_flows['Year'] = china_australia_iron_ore_flows['Date'].apply(lambda date : date.year)\nchina_australia_iron_ore_flows['Month'] = china_australia_iron_ore_flows['Date'].apply(lambda date : date.month)\nchina_australia_iron_ore_flows.sort_values(['Month', 'Year'], inplace = True)\nchina_australia_iron_ore_flows['Month'] = china_australia_iron_ore_flows['Date'].apply(lambda date : date.strftime(\"%b\"))\n\nfig = px.histogram(china_australia_iron_ore_flows, x=\"Month\", y=\"quantity\", color='Year',\n             barmode='group', height=500, width=1000,\n             title='Australia to China Capesize Iron Ore Flows - Imports to China',\n             color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"])\nfig.show()\n</pre> china_australia_iron_ore_flows['Year'] = china_australia_iron_ore_flows['Date'].apply(lambda date : date.year) china_australia_iron_ore_flows['Month'] = china_australia_iron_ore_flows['Date'].apply(lambda date : date.month) china_australia_iron_ore_flows.sort_values(['Month', 'Year'], inplace = True) china_australia_iron_ore_flows['Month'] = china_australia_iron_ore_flows['Date'].apply(lambda date : date.strftime(\"%b\"))  fig = px.histogram(china_australia_iron_ore_flows, x=\"Month\", y=\"quantity\", color='Year',              barmode='group', height=500, width=1000,              title='Australia to China Capesize Iron Ore Flows - Imports to China',              color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"]) fig.show() <p>Get vessel class ids for Dry vessel classes</p> In\u00a0[15]: Copied! <pre>vessel_classes = api.get_vessel_classes()\nvessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes)\nvessel_classes_df[vessel_classes_df['vessel_type']=='Dry'].head(10)\n</pre> vessel_classes = api.get_vessel_classes() vessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes) vessel_classes_df[vessel_classes_df['vessel_type']=='Dry'].head(10) Out[15]: vessel_class_id vessel_class_name vessel_type_id vessel_type 4 69 VLOC 3 Dry 5 70 Capesize 3 Dry 6 72 Post Panamax 3 Dry 7 74 Panamax 3 Dry 8 75 Supramax 3 Dry 9 76 Handymax 3 Dry 10 77 Handysize 3 Dry 19 92 Small 3 Dry In\u00a0[16]: Copied! <pre>vessel_class_ids = (74, 75) # Get only voyages for Panamax and Supramax\ndate_from = datetime.strptime(\"2022-09-01\", \"%Y-%m-%d\")\n\nvoyages = []\nfor vessel_class_id in vessel_class_ids:    \n    voyages.append(api.get_voyages_condensed(vessel_class_id=vessel_class_id, date_from=date_from))\n    \nvoyages = pd.DataFrame([v.__dict__ for vc in voyages for v in vc])\nvoyages.tail(5)\n</pre> vessel_class_ids = (74, 75) # Get only voyages for Panamax and Supramax date_from = datetime.strptime(\"2022-09-01\", \"%Y-%m-%d\")  voyages = [] for vessel_class_id in vessel_class_ids:         voyages.append(api.get_voyages_condensed(vessel_class_id=vessel_class_id, date_from=date_from))      voyages = pd.DataFrame([v.__dict__ for vc in voyages for v in vc]) voyages.tail(5) Out[16]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... last_discharge_sailing_date last_discharge_country_id last_discharge_country_name last_discharge_area_id_level0 last_discharge_area_name_level0 repairs_ind storage_ind sts_load_ind sts_discharge_ind local_trade_ind 68442 9984900 50 3 75 1 NaN False None I985B844BVEDD44ED00 1 ... 2024-02-07 05:20:21.777000+00:00 55.0 China None Central China False False False False True 68443 9984900 51 3 75 1 NaN False None I985B844BVEDD521C00 2 ... 2024-02-15 21:53:37.775000+00:00 55.0 China None Central China False False False False True 68444 9990818 1 3 75 1 NaN False None I9872A24BVEDCE8A400 2 ... 2024-03-14 18:15:56.194000+00:00 184.0 Philippines None Philippines True False False False False 68445 9990832 1 3 75 1 NaN False None I9872B04BVEDD37BE00 2 ... NaT NaN None None None True False False False True 68446 9991513 1 3 75 1 NaN False None I9875594BVEDCE8A400 2 ... 2024-02-15 20:55:55.178000+00:00 55.0 China None Central China True False False False False <p>5 rows \u00d7 97 columns</p> <p>Date of flows will be based on the export date</p> <ul> <li>Convert Timestamp to datetime, drop voyages with first_load_sailing_date in the future (ongoing or future)</li> </ul> In\u00a0[17]: Copied! <pre>voyages['first_load_sailing_date'] = voyages['first_load_sailing_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None))\nvoyages=voyages[voyages['first_load_sailing_date']&lt;datetime.now()]\nvoyages.head()\n</pre> voyages['first_load_sailing_date'] = voyages['first_load_sailing_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None)) voyages=voyages[voyages['first_load_sailing_date'] Out[17]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... last_discharge_sailing_date last_discharge_country_id last_discharge_country_name last_discharge_area_id_level0 last_discharge_area_name_level0 repairs_ind storage_ind sts_load_ind sts_discharge_ind local_trade_ind 0 7514684 339 3 74 1 3968.0 False None I72AA3CVEDAA49000 1 ... 2022-09-14 11:54:21+00:00 240.0 United States None Great Lakes False False False False True 1 7514684 340 3 74 1 3968.0 False None I72AA3CVEDAB1BF00 1 ... 2022-09-21 23:54:51+00:00 240.0 United States None Great Lakes False False False False True 2 7514684 341 3 74 1 3968.0 False None I72AA3CVEDAB85680 1 ... 2022-10-19 23:54:55+00:00 240.0 United States None Great Lakes False False False False True 3 7514684 342 3 74 1 3968.0 False None I72AA3CVEDABEEE00 1 ... 2022-10-27 19:54:27+00:00 240.0 United States None Great Lakes False False False False True 4 7514684 343 3 74 1 3968.0 False None I72AA3CVEDAE67B00 1 ... 2022-11-06 11:57:15+00:00 240.0 United States None Great Lakes False False False False True <p>5 rows \u00d7 97 columns</p> In\u00a0[18]: Copied! <pre>voyages[(voyages['cargo_sub_group']=='Grains')&amp;(voyages['cargo_type']!='Grains')].drop_duplicates(subset=['cargo_group', 'cargo_type'], keep='last', inplace = False)[['cargo_sub_group', 'cargo_type']].head(10)\n</pre> voyages[(voyages['cargo_sub_group']=='Grains')&amp;(voyages['cargo_type']!='Grains')].drop_duplicates(subset=['cargo_group', 'cargo_type'], keep='last', inplace = False)[['cargo_sub_group', 'cargo_type']].head(10) Out[18]: cargo_sub_group cargo_type 68025 Grains Barley 68296 Grains Corn 68352 Grains Rice 68360 Grains Soybeans 68383 Grains Sorghum 68384 Grains Wheat In\u00a0[19]: Copied! <pre>voyages[(voyages['first_load_country_name']=='Brazil')&amp;(voyages['cargo_sub_group']=='Grains')]['cargo_type'].value_counts().head()\n</pre> voyages[(voyages['first_load_country_name']=='Brazil')&amp;(voyages['cargo_sub_group']=='Grains')]['cargo_type'].value_counts().head() Out[19]: <pre>Soybeans    1650\nCorn        1007\nWheat         38\nRice          14\nName: cargo_type, dtype: int64</pre> <ul> <li>Keep only voyages with 'Soybeans' and 'Corn' as cargo type</li> <li>Group by origin and destination (first load, last discharge) and cargo type</li> <li>Use last_discharge_arrival_date as date of flow</li> </ul> In\u00a0[20]: Copied! <pre>cargo_types_of_interest = ('Soybeans', 'Corn')\ncustom_flows_country_level = voyages[(voyages['first_load_sailing_date']&gt;\"2023-01-01\")&amp;(voyages['cargo_type'].isin(cargo_types_of_interest))] \\\n    .set_index('first_load_sailing_date') \\\n    .groupby(['first_load_country_name', 'last_discharge_country_name', 'cargo_type'])['quantity'] \\\n    .resample('MS') \\\n    .sum() \\\n    .reset_index() \\\n    .rename(columns={'first_load_sailing_date': 'Date'})\ncustom_flows_country_level.head()\n</pre> cargo_types_of_interest = ('Soybeans', 'Corn') custom_flows_country_level = voyages[(voyages['first_load_sailing_date']&gt;\"2023-01-01\")&amp;(voyages['cargo_type'].isin(cargo_types_of_interest))] \\     .set_index('first_load_sailing_date') \\     .groupby(['first_load_country_name', 'last_discharge_country_name', 'cargo_type'])['quantity'] \\     .resample('MS') \\     .sum() \\     .reset_index() \\     .rename(columns={'first_load_sailing_date': 'Date'}) custom_flows_country_level.head() Out[20]: first_load_country_name last_discharge_country_name cargo_type Date quantity 0 Algeria Colombia Corn 2023-01-01 40000.0 1 Algeria Colombia Corn 2023-02-01 0.0 2 Algeria Colombia Corn 2023-03-01 38000.0 3 Algeria Colombia Corn 2023-04-01 0.0 4 Algeria Colombia Corn 2023-05-01 0.0 In\u00a0[21]: Copied! <pre>import_countries = ('China', 'Korea, Republic of', 'Japan')\ncustom_flows = custom_flows_country_level[(custom_flows_country_level['first_load_country_name']=='Brazil')&amp;(custom_flows_country_level['last_discharge_country_name'].isin(import_countries))].copy()\ncustom_flows.head()\n</pre> import_countries = ('China', 'Korea, Republic of', 'Japan') custom_flows = custom_flows_country_level[(custom_flows_country_level['first_load_country_name']=='Brazil')&amp;(custom_flows_country_level['last_discharge_country_name'].isin(import_countries))].copy() custom_flows.head() Out[21]: first_load_country_name last_discharge_country_name cargo_type Date quantity 493 Brazil China Corn 2023-01-01 559000.0 494 Brazil China Corn 2023-02-01 0.0 495 Brazil China Corn 2023-03-01 0.0 496 Brazil China Corn 2023-04-01 114000.0 497 Brazil China Corn 2023-05-01 187000.0 In\u00a0[22]: Copied! <pre>custom_flows['Year'] = custom_flows['Date'].apply(lambda date : date.year)\ncustom_flows['Month'] = custom_flows['Date'].apply(lambda date : date.month)\ncustom_flows.sort_values(['Year', 'Month'], inplace = True)\n\ncustom_flows['Month'] = custom_flows['Date'].apply(lambda date : date.strftime(\"%b\"))\ncustom_flows['Year'] = custom_flows['Date'].apply(lambda date : date.strftime(\"%Y\"))\ncustom_flows['MonthYear'] = custom_flows['Month'].astype(str) + ' ' + custom_flows['Year'].astype(str)\n\nfig = px.histogram(custom_flows, x=\"MonthYear\", y=\"quantity\", color='cargo_type',\n            height=500, width=1000, title='custom Flows - Brazil Grain Exports to (China, South Korea, Japan)',\n             color_discrete_sequence=px.colors.qualitative.Pastel)\nfig.update_layout(bargap=0.2)\nfig.show()\n</pre> custom_flows['Year'] = custom_flows['Date'].apply(lambda date : date.year) custom_flows['Month'] = custom_flows['Date'].apply(lambda date : date.month) custom_flows.sort_values(['Year', 'Month'], inplace = True)  custom_flows['Month'] = custom_flows['Date'].apply(lambda date : date.strftime(\"%b\")) custom_flows['Year'] = custom_flows['Date'].apply(lambda date : date.strftime(\"%Y\")) custom_flows['MonthYear'] = custom_flows['Month'].astype(str) + ' ' + custom_flows['Year'].astype(str)  fig = px.histogram(custom_flows, x=\"MonthYear\", y=\"quantity\", color='cargo_type',             height=500, width=1000, title='custom Flows - Brazil Grain Exports to (China, South Korea, Japan)',              color_discrete_sequence=px.colors.qualitative.Pastel) fig.update_layout(bargap=0.2) fig.show()"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#dry-bulk-flows","title":"Dry Bulk Flows\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#call-the-voyages-api","title":"Call the Voyages API\u00b6","text":"<p>The Voyages API retrieves information about vessel voyages.</p>"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#get-voyages-for-capesize","title":"Get voyages for Capesize\u00b6","text":"<p>For Capesize we will use (vessel_class_id = 70) when calling the API</p>"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#examine-capesize-australia-capesize-coal-exports","title":"Examine Capesize Australia Capesize Coal Exports\u00b6","text":"<p>Group by origin and destination (first load, last discharge), and use first_load_sailing_date as date of export</p>"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#plot-australia-capesize-coal-exports","title":"Plot Australia Capesize Coal exports\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#examine-australia-to-china-capesize-iron-ore-flows-imports-to-china","title":"Examine Australia to China Capesize Iron Ore Flows - Imports to China\u00b6","text":"<p>Convert Timestamp to datetime, drop voyages with last_discharge_arrival_date in the future (ongoing or future voyages)</p>"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#plot-australia-to-china-capesize-iron-ore-flows-imports-to-china","title":"Plot Australia to China Capesize Iron Ore Flows - Imports to China\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#build-your-custom-flows-brazil-grain-exports-to-specific-countries-by-panamax-and-supramax","title":"Build your custom Flows - Brazil Grain Exports to specific countries by Panamax and Supramax\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#select-vessel-classes-of-interest","title":"Select Vessel Classes of interest\u00b6","text":"<p>Get voyages for selected vessel classes (Panamax and Supramax) starting from a given date</p>"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#select-cargo-types-of-interest","title":"Select cargo types of interest\u00b6","text":"<p>Examine different cargo types under the \"Grains\" cargo group</p>"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#select-flows-of-interest","title":"Select flows of interest\u00b6","text":"<p>Keep only flows between Brazil and (China, South Korea, Japan)</p>"},{"location":"examples/jupyter/VoyagesAPI/DryBulkFlows/#plot-custom-flows","title":"Plot custom flows\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Dry_Capes_Daily_List_Of_Vessels_In_Dry_dock/","title":"Daily List of Dry Capes in Dry Dock","text":"In\u00a0[2]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <pre>Requirement already satisfied: signal-ocean in /usr/local/lib/python3.11/dist-packages (13.3.0)\nRequirement already satisfied: requests&lt;3,&gt;=2.23.0 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.32.3)\nRequirement already satisfied: python-dateutil&lt;3,&gt;=2.8.1 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.8.2)\nRequirement already satisfied: pandas&lt;3,&gt;=1.0.3 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.2.2)\nRequirement already satisfied: numpy&gt;=1.18.5 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (1.26.4)\nRequirement already satisfied: strictly-typed-pandas==0.1.4 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (0.1.4)\nRequirement already satisfied: typeguard&lt;3.0.0,&gt;=2.13.3 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.13.3)\nRequirement already satisfied: pandas-stubs in /usr/local/lib/python3.11/dist-packages (from strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2.2.2.240909)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil&lt;3,&gt;=2.8.1-&gt;signal-ocean) (1.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.4.1)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.3.0)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2025.1.31)\nRequirement already satisfied: types-pytz&gt;=2022.1.1 in /usr/local/lib/python3.11/dist-packages (from pandas-stubs-&gt;strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2025.1.0.20250204)\n</pre> In\u00a0[3]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\noperations_to_display='Dry dock' #here you can filter for: Load, Discharge, Stop, Start, Dry dock\nsegment='Dry' #this could be either 'Dry', 'Tanker', 'LPG', 'LNG'\nvessels_class_to_filter='Capesize'    #Vessel class of our preference\nvoyages_start_from='2024-01-01'  #Voyages Strarting from the Date of our preference\n</pre> signal_ocean_api_key = '' #replace with your subscription key operations_to_display='Dry dock' #here you can filter for: Load, Discharge, Stop, Start, Dry dock segment='Dry' #this could be either 'Dry', 'Tanker', 'LPG', 'LNG' vessels_class_to_filter='Capesize'    #Vessel class of our preference voyages_start_from='2024-01-01'  #Voyages Strarting from the Date of our preference In\u00a0[4]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nimport pandas as pd\nfrom datetime import datetime\nimport plotly.express as px\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI import pandas as pd from datetime import datetime import plotly.express as px In\u00a0[5]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) In\u00a0[6]: Copied! <pre>vessel_classes = api.get_vessel_classes()\nvessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes)\nvessel_classes_df=vessel_classes_df[vessel_classes_df['vessel_type']==segment]\nvessel_classes_df=vessel_classes_df[vessel_classes_df['vessel_class_name']==vessels_class_to_filter]\nvessel_classes_df\n</pre> vessel_classes = api.get_vessel_classes() vessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes) vessel_classes_df=vessel_classes_df[vessel_classes_df['vessel_type']==segment] vessel_classes_df=vessel_classes_df[vessel_classes_df['vessel_class_name']==vessels_class_to_filter] vessel_classes_df Out[6]: vessel_class_id vessel_class_name vessel_type_id vessel_type 5 70 Capesize 3 Dry In\u00a0[7]: Copied! <pre>vessel_classes_df = vessel_classes_df.reset_index(drop=True)\nvessel_class_id_to_look_for = vessel_classes_df.loc[0, 'vessel_class_id']\n</pre> vessel_classes_df = vessel_classes_df.reset_index(drop=True) vessel_class_id_to_look_for = vessel_classes_df.loc[0, 'vessel_class_id'] In\u00a0[8]: Copied! <pre>voyages = api.get_voyages_by_advanced_search(vessel_class_id=vessel_class_id_to_look_for, start_date_from=datetime.strptime(voyages_start_from, \"%Y-%m-%d\"),event_purpose=operations_to_display)\nvoyages = pd.DataFrame([v.__dict__ for v in voyages])\npd.set_option('display.max_columns', None)\nvoyages.tail(2)\n</pre> voyages = api.get_voyages_by_advanced_search(vessel_class_id=vessel_class_id_to_look_for, start_date_from=datetime.strptime(voyages_start_from, \"%Y-%m-%d\"),event_purpose=operations_to_display) voyages = pd.DataFrame([v.__dict__ for v in voyages]) pd.set_option('display.max_columns', None) voyages.tail(2) Out[8]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id horizon latest_received_ais vessel_name pit_vessel_name vessel_type vessel_class trade trade_id vessel_status deadweight year_built commercial_operator start_date first_load_arrival_date end_date charterer_id charterer rate rate_type ballast_bonus ballast_bonus_type cargo_type_id cargo_type cargo_type_source_id cargo_type_source cargo_sub_type_id cargo_sub_type cargo_sub_type_source_id cargo_sub_type_source cargo_group_id cargo_group cargo_group_source_id cargo_group_source cargo_sub_group_id cargo_sub_group cargo_sub_group_source_id cargo_sub_group_source quantity quantity_unit_id quantity_unit quantity_in_barrels quantity_source_id quantity_source cubic_size laycan_from laycan_to fixture_status_id fixture_status fixture_date fixture_is_coa fixture_is_hold is_implied_by_ais has_manual_entries ballast_distance predicted_ballast_distance laden_distance predicted_laden_distance suez_crossing panama_crossing canakkale_crossing bosporus_crossing torres_strait_crossing magellan_strait_crossing great_belt_crossing 669 1028657 1 3 70 1 NaN False (VoyageEvent(id='IFB23146SEDF39E700', voyage_i... IFB23146VEDF39E700 2 Current 2025-02-21 05:04:16+00:00 Jmu Ariake 5303 None Dry Capesize Bulk 4 Voyage 181000 2025 None 2025-02-19 01:39:24+00:00 NaT 9999-12-31 23:59:59+00:00 NaN None NaN None None None NaN None NaN None NaN None NaN None NaN None NaN None NaN None NaN None NaN NaN None None NaN None 151408.0 NaT NaT NaN None NaT None None None None NaN NaN NaN NaN None None None None None None None 670 1032268 1 3 70 1 1109.0 False (VoyageEvent(id='IFC04C46SEDEC34000', voyage_i... IFC04C46VEDEC34000 2 Current 2025-02-24 14:59:52+00:00 SG Aquamarine None Dry Capesize Bulk 4 Voyage 180000 2024 NYK Line 2024-11-12 03:10:46+00:00 2025-01-24 19:55:49+00:00 2025-03-08 19:20:17.256000+00:00 NaN None NaN None None None 5258.0 Iron Ore Fines 10.0 EstimatedHigh NaN None NaN None 5644.0 Ores and Rocks 10.0 EstimatedHigh 28.0 Iron Ore 10.0 EstimatedHigh 174000.0 1.0 MetricTonnes None 1.0 Estimated NaN NaT NaT -2.0 NotSet NaT False False None None 11958.04 NaN 7053.49 1409.67 None None None None None None None In\u00a0[9]: Copied! <pre>voyages = voyages[voyages['voyage_number']!=1][['id','imo', 'vessel_class','vessel_name', 'year_built', 'events']].copy() #here we exclude vessels in their first voyage\nvoyages.rename(columns={'id': 'v_id'}, inplace = True)\n</pre> voyages = voyages[voyages['voyage_number']!=1][['id','imo', 'vessel_class','vessel_name', 'year_built', 'events']].copy() #here we exclude vessels in their first voyage voyages.rename(columns={'id': 'v_id'}, inplace = True) In\u00a0[10]: Copied! <pre>voyages\n</pre> voyages Out[10]: v_id imo vessel_class vessel_name year_built events 0 I8CABCCVEDEEACD00 9219020 Capesize Cape Qingdao 2002 (VoyageEvent(id='I8CABCCSEDEEACD00', voyage_id... 1 I8CBA4AVEDDD5F200 9222730 Capesize Smoke 2001 (VoyageEvent(id='I8CBA4ASEDDD5F200', voyage_id... 2 I8CBA56VEDE742600 9222742 Capesize Gaia I 2001 (VoyageEvent(id='I8CBA56SEDE742600', voyage_id... 3 I8CC224VEDD86D800 9224740 Capesize Cape Zhoushan 2003 (VoyageEvent(id='I8CC224SEDD86D800', voyage_id... 4 I8CC224VEDEEACD00 9224740 Capesize Cape Zhoushan 2003 (VoyageEvent(id='I8CC224SEDEEACD00', voyage_id... ... ... ... ... ... ... ... 631 I976457VEDE9BB300 9921623 Capesize Star Shibumi 2021 (VoyageEvent(id='I976457SEDE9BB300', voyage_id... 632 I976883VEDEC34000 9922691 Capesize First Penguin 2021 (VoyageEvent(id='I976883SEDEC34000', voyage_id... 633 I9774A946VEDEEACD00 9925801 Capesize Yunagi 2022 (VoyageEvent(id='I9774A946SEDEEACD00', voyage_... 634 I9777DFVEDE742600 9926623 Capesize GCL Dunkirk 2022 (VoyageEvent(id='I9777DFSEDE742600', voyage_id... 635 I979F1A46VEDDAE6500 9936666 Capesize Ubuntu Harmony 2022 (VoyageEvent(id='I979F1A46SEDDAE6500', voyage_... <p>636 rows \u00d7 6 columns</p> <p>explode dataframe to create 1 row per event and extract event info into columns</p> In\u00a0[11]: Copied! <pre>voyages=voyages.explode('events')\nvoyages['events'] = voyages['events'].apply(lambda x: x.__dict__)\nvoyages=pd.concat([voyages.drop(['events'], axis=1), voyages['events'].apply(pd.Series)], axis=1)\n</pre> voyages=voyages.explode('events') voyages['events'] = voyages['events'].apply(lambda x: x.__dict__) voyages=pd.concat([voyages.drop(['events'], axis=1), voyages['events'].apply(pd.Series)], axis=1) <p>Keep only DryDock events and drop some columns</p> In\u00a0[12]: Copied! <pre>voyages=voyages[(voyages['purpose']==operations_to_display)].sort_values(by='arrival_date')\n\nexpanded_rows = []\nfor _, row in voyages.iterrows():\n    date_range = pd.date_range(start=row['arrival_date'], end=row['sailing_date'])\n    for single_date in date_range:\n        expanded_rows.append([row['imo'], row['vessel_name'], row['vessel_class'], row['year_built'], single_date])\n\n\n# Create a new DataFrame with expanded rows\nexpanded_df = pd.DataFrame(expanded_rows, columns=['imo', 'vessel_name', 'vessel_class','year_built', 'date'])\n\n# Sort the DataFrame by date and vessel for better readability\ndaily_list_df = expanded_df.sort_values(by=['date', 'imo']).reset_index(drop=True)\n\n#Limit the data to today\ntoday = pd.to_datetime(datetime.now().date()).tz_localize('UTC')\n# Date to filter on\nstart_date = pd.Timestamp('2015-01-01').tz_localize('UTC')\n\n# Filter the dataframe for rows where the date is between start_date and today\ndaily_list_df = daily_list_df[daily_list_df['date'] &lt;= today]\ndaily_list_df = daily_list_df[daily_list_df['date'] &gt;= start_date]\n</pre> voyages=voyages[(voyages['purpose']==operations_to_display)].sort_values(by='arrival_date')  expanded_rows = [] for _, row in voyages.iterrows():     date_range = pd.date_range(start=row['arrival_date'], end=row['sailing_date'])     for single_date in date_range:         expanded_rows.append([row['imo'], row['vessel_name'], row['vessel_class'], row['year_built'], single_date])   # Create a new DataFrame with expanded rows expanded_df = pd.DataFrame(expanded_rows, columns=['imo', 'vessel_name', 'vessel_class','year_built', 'date'])  # Sort the DataFrame by date and vessel for better readability daily_list_df = expanded_df.sort_values(by=['date', 'imo']).reset_index(drop=True)  #Limit the data to today today = pd.to_datetime(datetime.now().date()).tz_localize('UTC') # Date to filter on start_date = pd.Timestamp('2015-01-01').tz_localize('UTC')  # Filter the dataframe for rows where the date is between start_date and today daily_list_df = daily_list_df[daily_list_df['date'] &lt;= today] daily_list_df = daily_list_df[daily_list_df['date'] &gt;= start_date]  In\u00a0[13]: Copied! <pre>file_path = 'daily_list_of_vessels_in_repair.xlsx'\n# Ensure datetimes are timezone-unaware\ndaily_list_df['date'] = daily_list_df['date'].dt.tz_localize(None)\ndaily_list_df = daily_list_df.sort_values(by='date',ascending=False)\ndaily_list_df.to_excel(file_path, index=False)\n</pre> file_path = 'daily_list_of_vessels_in_repair.xlsx' # Ensure datetimes are timezone-unaware daily_list_df['date'] = daily_list_df['date'].dt.tz_localize(None) daily_list_df = daily_list_df.sort_values(by='date',ascending=False) daily_list_df.to_excel(file_path, index=False)"},{"location":"examples/jupyter/VoyagesAPI/Dry_Capes_Daily_List_Of_Vessels_In_Dry_dock/#daily-list-of-dry-capes-in-dry-dock","title":"Daily List of Dry Capes in Dry Dock\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Dry_Capes_Daily_List_Of_Vessels_In_Dry_dock/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":"<p>APIs Used: Voyages API</p> <p>Description:</p> <p>The goal of this example is to generate a daily list of all dry docks for Dry Capesizes, after a Date of our preference. We are using the Voyages API and filtering the voyage Purpose to be equal to \"Dry Dock\"</p> <p>Output: Daily List of all Dry Docks- Excel File</p>"},{"location":"examples/jupyter/VoyagesAPI/Dry_Capes_Daily_List_Of_Vessels_In_Dry_dock/#install-the-sdk-and-set-necessary-parameters","title":"Install the SDK and set necessary parameters\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Dry_Capes_Daily_List_Of_Vessels_In_Dry_dock/#call-the-voyages-api","title":"Call the Voyages API\u00b6","text":"<p>The Voyages API retrieves information about vessel voyages.</p>"},{"location":"examples/jupyter/VoyagesAPI/Dry_Capes_Daily_List_Of_Vessels_In_Dry_dock/#get-voyages-data","title":"Get voyages data\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Dry_Capes_Daily_List_Of_Vessels_In_Dry_dock/#export-data-to-excel","title":"Export Data to Excel\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/","title":"Fixture Count Example","text":"<ul> <li>Get your personal Signal Ocean API subscription key (acquired here) and replace it below:</li> </ul> In\u00a0[1]: Copied! <pre>signal_ocean_api_key = \"\"  # replace with your subscription key\n</pre> signal_ocean_api_key = \"\"  # replace with your subscription key <ul> <li>Install the Signal Ocean SDK and import all required modules:</li> </ul> In\u00a0[3]: Copied! <pre>%%capture\n!pip install signal-ocean\n\nfrom signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nfrom signal_ocean.voyages import VesselClass, VesselClassFilter\nimport pandas as pd\nfrom datetime import date, timedelta, datetime\nfrom dateutil.relativedelta import relativedelta\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import figure\nfrom collections import OrderedDict\n\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport plotly.express as px\nimport numpy as np\nimport math\n\n# Initialize the voyage api\nconnection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n\n#set up the grouped areas\narea_mapping = {\n    'Arabian Gulf':'AG',\n    'Red Sea':'AG',\n    'Singapore / Malaysia':'AG',\n    'Canada Atlantic Coast':'Caribs',\n    'Caribs':'Caribs',\n    'US Atlantic Coast':'Caribs',\n    'East Coast Mexico':'USG',\n    'US Gulf':'USG',\n    'Africa Atlantic Coast':'WAF',\n    'Argentina &amp; Uruguay':'WAF',\n    'Brazil':'WAF'\n}\n</pre> %%capture !pip install signal-ocean  from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI from signal_ocean.voyages import VesselClass, VesselClassFilter import pandas as pd from datetime import date, timedelta, datetime from dateutil.relativedelta import relativedelta import matplotlib.pyplot as plt from matplotlib.pyplot import figure from collections import OrderedDict  from plotly.subplots import make_subplots import plotly.graph_objects as go import plotly.express as px import numpy as np import math  # Initialize the voyage api connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection)  #set up the grouped areas area_mapping = {     'Arabian Gulf':'AG',     'Red Sea':'AG',     'Singapore / Malaysia':'AG',     'Canada Atlantic Coast':'Caribs',     'Caribs':'Caribs',     'US Atlantic Coast':'Caribs',     'East Coast Mexico':'USG',     'US Gulf':'USG',     'Africa Atlantic Coast':'WAF',     'Argentina &amp; Uruguay':'WAF',     'Brazil':'WAF' } <ul> <li>set  the vessel class</li> </ul> In\u00a0[4]: Copied! <pre>vessel_class_name_like = 'vlcc'\n</pre> vessel_class_name_like = 'vlcc' <ul> <li>set the year and month from when you want to count fixtures</li> </ul> In\u00a0[5]: Copied! <pre>year, month = 2021, 8\n</pre> year, month = 2021, 8 <ul> <li>get the voyages data using Voyage API</li> <li>we extract the voyages which have start after 2 months before the fixture date</li> <li>from the Voyage Events we extract the Area Level 0, which will be used to create the area groups for fixtures</li> </ul> In\u00a0[6]: Copied! <pre>def get_voyages(vcn, year, month):\n    def get_voyage_load_area(voyage_events):\n        return next((e.area_name_level0 for e in voyage_events or [] if e.purpose=='Load'), None)\n    def get_voyage_port_id(voyage_events):\n        return next((e.port_id for e in voyage_events or [] if e.purpose=='Load'), None)\n\n    #calculate the voyage start date (2 month before)\n    months_back = 2\n    fixture_date_from = date(year=year, month=month,day=1)\n    date_from = fixture_date_from - relativedelta(months=+months_back)\n\n    # get the vessel class id\n    vc = api.get_vessel_classes(VesselClassFilter(vcn))[0]\n    vessel_class_id = vc.vessel_class_id\n\n    data = api.get_voyages(vessel_class_id=vessel_class_id, date_from=date_from)\n    voyages = pd.DataFrame([v.__dict__ for v in data])\n    voyages['Level0AreaName_load'] = voyages['events'].apply(get_voyage_load_area)\n    voyages['port_id'] = voyages['events'].apply(get_voyage_port_id)\n    voyages.rename(columns={'vessel_class_id': 'VesselClassID'}, inplace=True)\n    return voyages\n</pre> def get_voyages(vcn, year, month):     def get_voyage_load_area(voyage_events):         return next((e.area_name_level0 for e in voyage_events or [] if e.purpose=='Load'), None)     def get_voyage_port_id(voyage_events):         return next((e.port_id for e in voyage_events or [] if e.purpose=='Load'), None)      #calculate the voyage start date (2 month before)     months_back = 2     fixture_date_from = date(year=year, month=month,day=1)     date_from = fixture_date_from - relativedelta(months=+months_back)      # get the vessel class id     vc = api.get_vessel_classes(VesselClassFilter(vcn))[0]     vessel_class_id = vc.vessel_class_id      data = api.get_voyages(vessel_class_id=vessel_class_id, date_from=date_from)     voyages = pd.DataFrame([v.__dict__ for v in data])     voyages['Level0AreaName_load'] = voyages['events'].apply(get_voyage_load_area)     voyages['port_id'] = voyages['events'].apply(get_voyage_port_id)     voyages.rename(columns={'vessel_class_id': 'VesselClassID'}, inplace=True)     return voyages <ul> <li>We use the area_mapping dictionary we group the level 0 areas</li> <li>In order a voyage to be fixed, the laycan_from field should not be null</li> <li>We keep the voyages which has laycan_from is greater than the selected date</li> <li>The final Step is to group the data by year, month, area, and decate and calculate the fixture count for each group</li> </ul> In\u00a0[7]: Copied! <pre>def preprocess(data,area_mapping):\n\n    # Keep only the dirty\n    voyages = data.copy()\n    voyages = voyages[voyages.trade_id == 1]\n\n    # merge with the area_mapping on area_level0_name and vessel_class_id\n    voyages['Area'] = voyages.Level0AreaName_load.map(lambda x: area_mapping[x] \n                                                    if x in area_mapping \n                                                    else None)\n    voyages_df = voyages[[\"imo\",\"voyage_number\",\"VesselClassID\",\n                        \"Level0AreaName_load\",\"Area\",\"laycan_from\",\"port_id\"]]\n\n    # filter with laycan from is not null\n    voyages_df = voyages_df[~voyages_df.laycan_from.isna()]\n\n    # filter with laycan from\n    filtered_voyages = voyages_df[voyages_df.laycan_from.dt.date &gt;= \n                                date(year=year, month=month, day=1)]\n\n    # split the laycan from to month, date, year and create the decade\n    final_df = filtered_voyages.copy()\n    final_df['day'] = final_df['laycan_from'].dt.day\n    final_df['month'] = final_df['laycan_from'].dt.month\n    final_df['year'] = final_df['laycan_from'].dt.year\n\n    choices = [1,2,3]\n    conditions = [\n        (final_df['day'] &lt;= 10), \n        ((final_df['day'] &gt; 10) &amp; (final_df['day'] &lt;= 20)),\n        (final_df['day'] &gt; 20) ]\n    final_df['decade'] = np.select(conditions, choices, default=np.nan)\n    final_df['decade'] = final_df['decade'].astype(int)\n\n    # Remove nan load areas\n    final_df = final_df[~final_df.Area.isna()]\n\n    fixture_counts_df = (\n    final_df\n    .groupby(['month','year','Area','decade'])\n    .size()\n    .rename('fixture_counts')\n    .reset_index()    \n    )\n\n    # this step is to help us visualize the Area with 0 fixtures \n    month_groups = set(fixture_counts_df.groupby(['year','month']) \\\n                                        .groups.keys())\n    area_groups = set(area_mapping.values())\n    area_month_groups = []\n    for area in area_groups:\n        for period in month_groups:\n            area_month_groups.append((period[0],period[1],area))\n    decate_areas = []\n    for area_month in area_month_groups:\n        decate_areas.append((1,area_month[0],area_month[1],area_month[2]))\n        decate_areas.append((2,area_month[0],area_month[1],area_month[2]))\n        decate_areas.append((3,area_month[0],area_month[1],area_month[2]))\n    decate_per_area = pd.DataFrame(decate_areas, columns=['decade', \n                                                        'year','month',\n                                                        'Area'])\n    fixture_counts_df = pd.merge(fixture_counts_df,decate_per_area,\n                               on=['decade','year','month','Area'],\n                               how='right').fillna(0)\n    # calculate the total fixtures\n    fixture_counts_df['Area Total'] = (\n    fixture_counts_df\n    .groupby(['year','month','Area'])\n    .fixture_counts\n    .transform('sum')    \n    )\n\n    # sort the the fixture counts\n    fixture_counts_df = fixture_counts_df.sort_values(\n        ['year','month','Area Total','Area','decade'],\n        ascending=[False,False,True,True,True,]) \n    return fixture_counts_df\n</pre> def preprocess(data,area_mapping):      # Keep only the dirty     voyages = data.copy()     voyages = voyages[voyages.trade_id == 1]      # merge with the area_mapping on area_level0_name and vessel_class_id     voyages['Area'] = voyages.Level0AreaName_load.map(lambda x: area_mapping[x]                                                      if x in area_mapping                                                      else None)     voyages_df = voyages[[\"imo\",\"voyage_number\",\"VesselClassID\",                         \"Level0AreaName_load\",\"Area\",\"laycan_from\",\"port_id\"]]      # filter with laycan from is not null     voyages_df = voyages_df[~voyages_df.laycan_from.isna()]      # filter with laycan from     filtered_voyages = voyages_df[voyages_df.laycan_from.dt.date &gt;=                                  date(year=year, month=month, day=1)]      # split the laycan from to month, date, year and create the decade     final_df = filtered_voyages.copy()     final_df['day'] = final_df['laycan_from'].dt.day     final_df['month'] = final_df['laycan_from'].dt.month     final_df['year'] = final_df['laycan_from'].dt.year      choices = [1,2,3]     conditions = [         (final_df['day'] &lt;= 10),          ((final_df['day'] &gt; 10) &amp; (final_df['day'] &lt;= 20)),         (final_df['day'] &gt; 20) ]     final_df['decade'] = np.select(conditions, choices, default=np.nan)     final_df['decade'] = final_df['decade'].astype(int)      # Remove nan load areas     final_df = final_df[~final_df.Area.isna()]      fixture_counts_df = (     final_df     .groupby(['month','year','Area','decade'])     .size()     .rename('fixture_counts')     .reset_index()         )      # this step is to help us visualize the Area with 0 fixtures      month_groups = set(fixture_counts_df.groupby(['year','month']) \\                                         .groups.keys())     area_groups = set(area_mapping.values())     area_month_groups = []     for area in area_groups:         for period in month_groups:             area_month_groups.append((period[0],period[1],area))     decate_areas = []     for area_month in area_month_groups:         decate_areas.append((1,area_month[0],area_month[1],area_month[2]))         decate_areas.append((2,area_month[0],area_month[1],area_month[2]))         decate_areas.append((3,area_month[0],area_month[1],area_month[2]))     decate_per_area = pd.DataFrame(decate_areas, columns=['decade',                                                          'year','month',                                                         'Area'])     fixture_counts_df = pd.merge(fixture_counts_df,decate_per_area,                                on=['decade','year','month','Area'],                                how='right').fillna(0)     # calculate the total fixtures     fixture_counts_df['Area Total'] = (     fixture_counts_df     .groupby(['year','month','Area'])     .fixture_counts     .transform('sum')         )      # sort the the fixture counts     fixture_counts_df = fixture_counts_df.sort_values(         ['year','month','Area Total','Area','decade'],         ascending=[False,False,True,True,True,])      return fixture_counts_df In\u00a0[8]: Copied! <pre>def plot_results(fixture_counts_df):\n\n    def get_trace(name,color,decate,show_legend):\n        return go.Bar(\n                    name=name,\n                    x=data[data.decade==decate][\"fixture_counts\"],\n                    y=data[data.decade==decate][\"Area\"],\n                    orientation='h',\n                    showlegend=show_legend,\n                    marker={'color': color},\n                    text=data[data.decade==decate][\"fixture_counts\"]\n                )\n\n    group_plots = fixture_counts_df.groupby(['year','month']).groups.keys()\n    sorted_groups = sorted(group_plots, \n                         key=lambda element: (element[0], element[1]),\n                         reverse=True)\n    figures = []\n    titles = []\n    for i,group in enumerate(sorted_groups):\n        data = fixture_counts_df[\n                                 (fixture_counts_df.year==group[0])&amp;\n                                 (fixture_counts_df.month==group[1])\n                                 ]\n        titles.append(\n            date(group[0], group[1], 1).strftime('%B') + \" \" + str(group[0])\n            )\n        show_legend = True if i == 0 else False\n        fig = go.Figure(\n              data=[\n                get_trace(\"First decade (1st - 10th)\", 'green', 1, show_legend),\n                get_trace(\"Second decade (10th - 20th)\", 'blue', 2, show_legend),\n                get_trace(\"Third decade (20th - 30th)\", 'red', 3, show_legend)\n              ],\n            )\n        figures.append(fig)\n        \n    no_rows = math.ceil(len(sorted_groups)/2)\n    specs = [[{}, {}] for _ in range(no_rows)]\n    fig_subplots = make_subplots(\n        rows=no_rows, cols=2,\n        specs=specs,\n        x_title='Fixture Counts',\n        y_title='Areas',\n        subplot_titles=tuple(titles),\n    )\n\n    for i,f in enumerate(figures):\n        for t in f.data:\n            fig_subplots.append_trace(t, row=(i//2)+1, col=(i%2)+1)\n\n    fig_subplots['layout'].update(\n      height=300*no_rows, \n      width=1400, \n      title='Fixture Counts',\n      barmode='stack',\n      legend_traceorder='reversed')\n    fig_subplots.show()\n</pre> def plot_results(fixture_counts_df):      def get_trace(name,color,decate,show_legend):         return go.Bar(                     name=name,                     x=data[data.decade==decate][\"fixture_counts\"],                     y=data[data.decade==decate][\"Area\"],                     orientation='h',                     showlegend=show_legend,                     marker={'color': color},                     text=data[data.decade==decate][\"fixture_counts\"]                 )      group_plots = fixture_counts_df.groupby(['year','month']).groups.keys()     sorted_groups = sorted(group_plots,                           key=lambda element: (element[0], element[1]),                          reverse=True)     figures = []     titles = []     for i,group in enumerate(sorted_groups):         data = fixture_counts_df[                                  (fixture_counts_df.year==group[0])&amp;                                  (fixture_counts_df.month==group[1])                                  ]         titles.append(             date(group[0], group[1], 1).strftime('%B') + \" \" + str(group[0])             )         show_legend = True if i == 0 else False         fig = go.Figure(               data=[                 get_trace(\"First decade (1st - 10th)\", 'green', 1, show_legend),                 get_trace(\"Second decade (10th - 20th)\", 'blue', 2, show_legend),                 get_trace(\"Third decade (20th - 30th)\", 'red', 3, show_legend)               ],             )         figures.append(fig)              no_rows = math.ceil(len(sorted_groups)/2)     specs = [[{}, {}] for _ in range(no_rows)]     fig_subplots = make_subplots(         rows=no_rows, cols=2,         specs=specs,         x_title='Fixture Counts',         y_title='Areas',         subplot_titles=tuple(titles),     )      for i,f in enumerate(figures):         for t in f.data:             fig_subplots.append_trace(t, row=(i//2)+1, col=(i%2)+1)      fig_subplots['layout'].update(       height=300*no_rows,        width=1400,        title='Fixture Counts',       barmode='stack',       legend_traceorder='reversed')     fig_subplots.show() In\u00a0[9]: Copied! <pre># Get voyages\nvoyages = get_voyages(vessel_class_name_like, year, month)\n</pre> # Get voyages voyages = get_voyages(vessel_class_name_like, year, month) In\u00a0[10]: Copied! <pre># Preprocess fixtures\npreprocessed_voyages = preprocess(voyages, area_mapping)\n</pre> # Preprocess fixtures preprocessed_voyages = preprocess(voyages, area_mapping) In\u00a0[11]: Copied! <pre># Plot the results\nplot_results(preprocessed_voyages)\n</pre> # Plot the results plot_results(preprocessed_voyages)"},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#fixture-count-example","title":"Fixture Count Example\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#setup","title":"Setup\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#import-libraries-and-set-default-values","title":"Import libraries and set default values\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#set-parameters","title":"Set parameters\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#calculate-fixture-count","title":"Calculate Fixture Count\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#get-fixtures","title":"Get fixtures\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#preprocess-fixtures","title":"Preprocess Fixtures\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#plot-fixture-counts","title":"Plot Fixture Counts\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FixtureCount/#results","title":"Results\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/","title":"Flows From V4","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nimport pandas as pd\nfrom datetime import datetime\nimport plotly.express as px\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI import pandas as pd from datetime import datetime import plotly.express as px In\u00a0[3]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) <p>Get vessel class id for VLCCs</p> In\u00a0[4]: Copied! <pre>vessel_classes = api.get_vessel_classes()\nvessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes)\nvessel_classes_df[vessel_classes_df['vessel_type']=='Tanker'].head(10)\n</pre> vessel_classes = api.get_vessel_classes() vessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes) vessel_classes_df[vessel_classes_df['vessel_type']=='Tanker'].head(10) Out[4]: vessel_class_id vessel_class_name vessel_type_id vessel_type 11 84 VLCC 1 Tanker 12 85 Suezmax 1 Tanker 13 86 Aframax 1 Tanker 14 87 Panamax 1 Tanker 15 88 MR2 1 Tanker 16 89 MR1 1 Tanker 17 90 Small 1 Tanker <p>We will use vessel_class_id = 84 as above when calling the API</p> In\u00a0[5]: Copied! <pre>voyages = api.get_voyages(vessel_class_id=84, date_from=datetime.strptime(\"2021-09-01\", \"%Y-%m-%d\"))\nvoyages = pd.DataFrame([v.__dict__ for v in voyages])\nvoyages.tail(2)\n</pre> voyages = api.get_voyages(vessel_class_id=84, date_from=datetime.strptime(\"2021-09-01\", \"%Y-%m-%d\")) voyages = pd.DataFrame([v.__dict__ for v in voyages]) voyages.tail(2) Out[5]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... is_implied_by_ais has_manual_entries ballast_distance predicted_ballast_distance laden_distance predicted_laden_distance suez_crossing panama_crossing canakkale_crossing bosporus_crossing 10358 9943748 4 1 84 1 558.0 False (VoyageEvent(id='I97BAC454SEDD103100', port_id... I97BAC454VEDD103100 2 ... None None 6151.11 NaN 6195.45 385.69 None None None None 10359 9946673 1 1 84 1 1441.0 False (VoyageEvent(id='I97C63154SEDB84AF00', port_id... I97C63154VEDB84AF00 2 ... None None 5266.17 NaN NaN NaN None None None None <p>2 rows \u00d7 69 columns</p> <p>Keep only historical voyages and drop some columns</p> <ul> <li>Note 1: Voyages Data API has information on all levels of the Cargo Tree taxonomy, from cargo group down to cargo sub type (grade). For this first example we will use cargo_sub_group that is the corresponding taxonomy of Crude</li> <li>Note 2: Voyages Data API also provides quantity in barrels that we will use in this example</li> </ul> In\u00a0[6]: Copied! <pre>voyages = voyages[voyages['horizon']=='Historical'][['id', 'quantity_in_barrels', 'cargo_sub_group', 'events']].copy()\nvoyages.rename(columns={'quantity_in_barrels': 'voyage_quantity_in_barrels', 'id': 'v_id'}, inplace = True)\n</pre> voyages = voyages[voyages['horizon']=='Historical'][['id', 'quantity_in_barrels', 'cargo_sub_group', 'events']].copy() voyages.rename(columns={'quantity_in_barrels': 'voyage_quantity_in_barrels', 'id': 'v_id'}, inplace = True) <p>explode dataframe to create 1 row per event and extract event info into columns</p> In\u00a0[7]: Copied! <pre>voyages=voyages.explode('events')\nvoyages['events'] = voyages['events'].apply(lambda x: x.__dict__)\nvoyages=pd.concat([voyages.drop(['events'], axis=1), voyages['events'].apply(pd.Series)], axis=1)\n</pre> voyages=voyages.explode('events') voyages['events'] = voyages['events'].apply(lambda x: x.__dict__) voyages=pd.concat([voyages.drop(['events'], axis=1), voyages['events'].apply(pd.Series)], axis=1) <p>Keep only Load/Discharge events and drop some columns</p> In\u00a0[8]: Copied! <pre>voyages=voyages[(voyages['purpose']=='Discharge')|(voyages['purpose']=='Load')][[ 'v_id', 'voyage_quantity_in_barrels', 'cargo_sub_group', \n                                                                                 'purpose', 'arrival_date', 'sailing_date', 'port_name', \n                                                                                 'country', 'quantity', 'quantity_in_barrels']]\n</pre> voyages=voyages[(voyages['purpose']=='Discharge')|(voyages['purpose']=='Load')][[ 'v_id', 'voyage_quantity_in_barrels', 'cargo_sub_group',                                                                                   'purpose', 'arrival_date', 'sailing_date', 'port_name',                                                                                   'country', 'quantity', 'quantity_in_barrels']] <p>Combine Load and Discharge operations of the same voyage to create flows</p> In\u00a0[9]: Copied! <pre>flows=voyages[voyages['purpose']=='Load'].merge(voyages[voyages['purpose']=='Discharge'], on = ['v_id', 'voyage_quantity_in_barrels', 'cargo_sub_group'], suffixes=['_load','_discharge'])\n</pre> flows=voyages[voyages['purpose']=='Load'].merge(voyages[voyages['purpose']=='Discharge'], on = ['v_id', 'voyage_quantity_in_barrels', 'cargo_sub_group'], suffixes=['_load','_discharge']) <p>Calculate quantity for each elementary flow</p> In\u00a0[10]: Copied! <pre>flows['flow_quantity_in_barrels'] = flows['quantity_in_barrels_load']*flows['quantity_in_barrels_discharge']/flows['voyage_quantity_in_barrels']\n</pre> flows['flow_quantity_in_barrels'] = flows['quantity_in_barrels_load']*flows['quantity_in_barrels_discharge']/flows['voyage_quantity_in_barrels'] <p>Convert Timestamp to datetime</p> In\u00a0[11]: Copied! <pre>flows['sailing_date_load'] = flows['sailing_date_load'].apply(lambda d : pd.to_datetime(d).tz_localize(None))\n</pre> flows['sailing_date_load'] = flows['sailing_date_load'].apply(lambda d : pd.to_datetime(d).tz_localize(None)) In\u00a0[12]: Copied! <pre>US_China_crude = flows[(flows['sailing_date_load']&gt;\"2022-01-01\")&amp;(flows['cargo_sub_group']=='Crude')] \\\n    .set_index('sailing_date_load') \\\n    .groupby(['country_load', 'country_discharge'])['flow_quantity_in_barrels'] \\\n    .resample('MS') \\\n    .sum() \\\n    .reset_index() \\\n    .rename(columns={'sailing_date_load': 'Date'})\n</pre> US_China_crude = flows[(flows['sailing_date_load']&gt;\"2022-01-01\")&amp;(flows['cargo_sub_group']=='Crude')] \\     .set_index('sailing_date_load') \\     .groupby(['country_load', 'country_discharge'])['flow_quantity_in_barrels'] \\     .resample('MS') \\     .sum() \\     .reset_index() \\     .rename(columns={'sailing_date_load': 'Date'}) <ul> <li>Keep only US to China flows</li> </ul> In\u00a0[13]: Copied! <pre>US_China_crude = US_China_crude[(US_China_crude['country_load']=='United States')&amp;(US_China_crude['country_discharge']=='China')]\n</pre> US_China_crude = US_China_crude[(US_China_crude['country_load']=='United States')&amp;(US_China_crude['country_discharge']=='China')] <ul> <li>Aggregate all exports monthly</li> <li>Drop unnecessary columns</li> </ul> In\u00a0[14]: Copied! <pre>US_China_crude['TotalExports'] = US_China_crude['flow_quantity_in_barrels'].groupby(US_China_crude['Date']).transform('sum')\nUS_China_crude.drop_duplicates(subset=['Date'], keep='last', inplace = True)\nUS_China_crude.drop(['country_discharge', 'flow_quantity_in_barrels'], axis=1, inplace = True)\nUS_China_crude.head()\n</pre> US_China_crude['TotalExports'] = US_China_crude['flow_quantity_in_barrels'].groupby(US_China_crude['Date']).transform('sum') US_China_crude.drop_duplicates(subset=['Date'], keep='last', inplace = True) US_China_crude.drop(['country_discharge', 'flow_quantity_in_barrels'], axis=1, inplace = True) US_China_crude.head() Out[14]: country_load Date TotalExports 4443 United States 2022-01-01 5516656.0 4444 United States 2022-02-01 3801507.0 4445 United States 2022-03-01 8482108.0 4446 United States 2022-04-01 6956842.0 4447 United States 2022-05-01 1830122.0 In\u00a0[15]: Copied! <pre>US_China_crude['Year'] = US_China_crude['Date'].apply(lambda date : date.year)\nUS_China_crude['Month'] = US_China_crude['Date'].apply(lambda date : date.month)\nUS_China_crude.sort_values(['Month', 'Year'], inplace = True)\nUS_China_crude['Month'] = US_China_crude['Date'].apply(lambda date : date.strftime(\"%b\"))\n\nfig = px.histogram(US_China_crude, x=\"Month\", y=\"TotalExports\", color='Year',\n             barmode='group', height=500, width=1000,\n             title='US to China VLCC Crude (MT)',\n             color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"])\nfig.show()\n</pre> US_China_crude['Year'] = US_China_crude['Date'].apply(lambda date : date.year) US_China_crude['Month'] = US_China_crude['Date'].apply(lambda date : date.month) US_China_crude.sort_values(['Month', 'Year'], inplace = True) US_China_crude['Month'] = US_China_crude['Date'].apply(lambda date : date.strftime(\"%b\"))  fig = px.histogram(US_China_crude, x=\"Month\", y=\"TotalExports\", color='Year',              barmode='group', height=500, width=1000,              title='US to China VLCC Crude (MT)',              color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"]) fig.show() <p>Extract vessel class ids for Panamaxes</p> In\u00a0[16]: Copied! <pre>vessel_classes_df[vessel_classes_df['vessel_type']=='Dry'].head(10)\n</pre> vessel_classes_df[vessel_classes_df['vessel_type']=='Dry'].head(10) Out[16]: vessel_class_id vessel_class_name vessel_type_id vessel_type 4 69 VLOC 3 Dry 5 70 Capesize 3 Dry 6 72 Post Panamax 3 Dry 7 74 Panamax 3 Dry 8 75 Supramax 3 Dry 9 76 Handymax 3 Dry 10 77 Handysize 3 Dry 19 92 Small 3 Dry In\u00a0[17]: Copied! <pre>vessel_class_ids = (72, 74)\ndate_from = datetime.strptime(\"2022-09-01\", \"%Y-%m-%d\")\n\nvoyages = []\nfor vessel_class_id in vessel_class_ids:    \n    voyages.append(api.get_voyages(vessel_class_id=vessel_class_id, date_from=date_from))\n\nvoyages = pd.DataFrame([v.__dict__ for vc in voyages for v in vc])\nvoyages.tail(2)\n</pre> vessel_class_ids = (72, 74) date_from = datetime.strptime(\"2022-09-01\", \"%Y-%m-%d\")  voyages = [] for vessel_class_id in vessel_class_ids:         voyages.append(api.get_voyages(vessel_class_id=vessel_class_id, date_from=date_from))  voyages = pd.DataFrame([v.__dict__ for vc in voyages for v in vc]) voyages.tail(2) Out[17]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... is_implied_by_ais has_manual_entries ballast_distance predicted_ballast_distance laden_distance predicted_laden_distance suez_crossing panama_crossing canakkale_crossing bosporus_crossing 34619 9991680 2 3 74 1 NaN False (VoyageEvent(id='I9876004ASEDD37BE00', port_id... I9876004AVEDD37BE00 1 ... None None 780.03 NaN 791.47 NaN None None None None 34620 9991680 3 3 74 1 NaN False (VoyageEvent(id='I9876004ASEDD521C00', port_id... I9876004AVEDD521C00 2 ... True None 175.35 571.09 NaN 1419.93 None None None None <p>2 rows \u00d7 69 columns</p> <p>Keep only voyages with Cargo Type Thermal Coal</p> In\u00a0[18]: Copied! <pre>voyages = voyages[(voyages['horizon']=='Historical')&amp;(voyages['cargo_type']=='Thermal Coal')][['id', 'quantity', 'cargo_type', 'events']].copy()\nvoyages.rename(columns={'quantity': 'voyage_quantity', 'id': 'v_id'}, inplace = True)\n</pre> voyages = voyages[(voyages['horizon']=='Historical')&amp;(voyages['cargo_type']=='Thermal Coal')][['id', 'quantity', 'cargo_type', 'events']].copy() voyages.rename(columns={'quantity': 'voyage_quantity', 'id': 'v_id'}, inplace = True) <p>explode dataframe to create 1 row per event and extract event info into columns</p> In\u00a0[19]: Copied! <pre>voyages=voyages.explode('events')\nvoyages['events'] = voyages['events'].apply(lambda x: x.__dict__)\nvoyages=pd.concat([voyages.drop(['events'], axis=1), voyages['events'].apply(pd.Series)], axis=1)\n</pre> voyages=voyages.explode('events') voyages['events'] = voyages['events'].apply(lambda x: x.__dict__) voyages=pd.concat([voyages.drop(['events'], axis=1), voyages['events'].apply(pd.Series)], axis=1) <p>Keep only Load/Discharge events and drop some columns</p> <ul> <li>Note: Voyages Data API has information on all levels of Cargo Tree taxonomy, from cargo group, down to cargo sub type (grade). For this example we will use cargo_type corresponding to the taxonomy of Thermal Coal</li> </ul> In\u00a0[20]: Copied! <pre>voyages=voyages[(voyages['purpose']=='Discharge')|(voyages['purpose']=='Load')][[ 'v_id', 'voyage_quantity', 'purpose', 'arrival_date', 'cargo_type',\n                                                                                 'sailing_date', 'port_name', 'country', 'quantity']]\n</pre> voyages=voyages[(voyages['purpose']=='Discharge')|(voyages['purpose']=='Load')][[ 'v_id', 'voyage_quantity', 'purpose', 'arrival_date', 'cargo_type',                                                                                  'sailing_date', 'port_name', 'country', 'quantity']] <p>Combine Load and Discharge operations of the same voyage to create flows</p> In\u00a0[21]: Copied! <pre>flows=voyages[voyages['purpose']=='Load'].merge(voyages[voyages['purpose']=='Discharge'], on = ['v_id', 'voyage_quantity', 'cargo_type'], suffixes=['_load','_discharge'])\n</pre> flows=voyages[voyages['purpose']=='Load'].merge(voyages[voyages['purpose']=='Discharge'], on = ['v_id', 'voyage_quantity', 'cargo_type'], suffixes=['_load','_discharge']) In\u00a0[22]: Copied! <pre>flows['flow_quantity'] = flows['quantity_load']*flows['quantity_discharge']/flows['voyage_quantity']\n</pre> flows['flow_quantity'] = flows['quantity_load']*flows['quantity_discharge']/flows['voyage_quantity'] <p>Convert Timestamp to datetime</p> In\u00a0[23]: Copied! <pre>flows['sailing_date_load'] = flows['sailing_date_load'].apply(lambda d : pd.to_datetime(d).tz_localize(None))\n</pre> flows['sailing_date_load'] = flows['sailing_date_load'].apply(lambda d : pd.to_datetime(d).tz_localize(None)) In\u00a0[24]: Copied! <pre>Newcastle_Japan_coal = flows[(flows['sailing_date_load']&gt;\"2023-01-01\")] \\\n    .set_index('sailing_date_load') \\\n    .groupby(['port_name_load', 'country_discharge'])['flow_quantity'] \\\n    .resample('MS') \\\n    .sum() \\\n    .reset_index() \\\n    .rename(columns={'sailing_date_load': 'Date'})\n</pre> Newcastle_Japan_coal = flows[(flows['sailing_date_load']&gt;\"2023-01-01\")] \\     .set_index('sailing_date_load') \\     .groupby(['port_name_load', 'country_discharge'])['flow_quantity'] \\     .resample('MS') \\     .sum() \\     .reset_index() \\     .rename(columns={'sailing_date_load': 'Date'}) <ul> <li>Keep only Newcastle to Japan flows</li> </ul> In\u00a0[25]: Copied! <pre>Newcastle_Japan_coal = Newcastle_Japan_coal[(Newcastle_Japan_coal['port_name_load']=='Newcastle')&amp;(Newcastle_Japan_coal['country_discharge']=='Japan')]\n</pre> Newcastle_Japan_coal = Newcastle_Japan_coal[(Newcastle_Japan_coal['port_name_load']=='Newcastle')&amp;(Newcastle_Japan_coal['country_discharge']=='Japan')] <ul> <li>Aggregate all exports monthly</li> <li>Drop unnecessary columns</li> </ul> In\u00a0[26]: Copied! <pre>Newcastle_Japan_coal['TotalExports'] = Newcastle_Japan_coal['flow_quantity'].groupby(Newcastle_Japan_coal['Date']).transform('sum')\nNewcastle_Japan_coal.drop_duplicates(subset=['Date'], keep='last', inplace = True)\nNewcastle_Japan_coal.drop(['country_discharge', 'flow_quantity'], axis=1, inplace = True)\nNewcastle_Japan_coal.head()\n</pre> Newcastle_Japan_coal['TotalExports'] = Newcastle_Japan_coal['flow_quantity'].groupby(Newcastle_Japan_coal['Date']).transform('sum') Newcastle_Japan_coal.drop_duplicates(subset=['Date'], keep='last', inplace = True) Newcastle_Japan_coal.drop(['country_discharge', 'flow_quantity'], axis=1, inplace = True) Newcastle_Japan_coal.head() Out[26]: port_name_load Date TotalExports 1950 Newcastle 2023-01-01 4407000.0 1951 Newcastle 2023-02-01 3623000.0 1952 Newcastle 2023-03-01 4003000.0 1953 Newcastle 2023-04-01 1959000.0 1954 Newcastle 2023-05-01 2703000.0 In\u00a0[27]: Copied! <pre>Newcastle_Japan_coal['Year'] = Newcastle_Japan_coal['Date'].apply(lambda date : date.year)\nNewcastle_Japan_coal['Month'] = Newcastle_Japan_coal['Date'].apply(lambda date : date.month)\nNewcastle_Japan_coal.sort_values(['Month', 'Year'], inplace = True)\nNewcastle_Japan_coal['Month'] = Newcastle_Japan_coal['Date'].apply(lambda date : date.strftime(\"%b\"))\n\nfig = px.histogram(Newcastle_Japan_coal, x=\"Month\", y=\"TotalExports\", color='Year',\n             barmode='group', height=500, width=1000,\n             title='Newcastle to Japan Panamaxes Thermal Coal (MT)',\n             color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"])\nfig.show()\n</pre> Newcastle_Japan_coal['Year'] = Newcastle_Japan_coal['Date'].apply(lambda date : date.year) Newcastle_Japan_coal['Month'] = Newcastle_Japan_coal['Date'].apply(lambda date : date.month) Newcastle_Japan_coal.sort_values(['Month', 'Year'], inplace = True) Newcastle_Japan_coal['Month'] = Newcastle_Japan_coal['Date'].apply(lambda date : date.strftime(\"%b\"))  fig = px.histogram(Newcastle_Japan_coal, x=\"Month\", y=\"TotalExports\", color='Year',              barmode='group', height=500, width=1000,              title='Newcastle to Japan Panamaxes Thermal Coal (MT)',              color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"]) fig.show()"},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#flows-from-v4","title":"Flows From V4\u00b6","text":"<p>(powered by v4)</p> <p>V4 brings a complete revision and expansion of the whole CargoTracking module to serve all commodity tracking needs at vessel-per-vessel level.</p> <ul> <li>Quantity estimated at event level (so for each StS operation and load/discharge) in addition to the voyage level and for Tanker, provided both in tonnes and in barrels.<ul> <li>More accurate flows that go beyond the FirstLoad/LastDischarge approximation.</li> </ul> </li> <li>More cargo fields from the Cargo Grade level up to the Cargo Group one.</li> <li>A source for each cargo to specify what market data backed that cargo up.</li> <li>Confidence levels about our model estimation (High/Medium/Low).</li> </ul>"},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#call-the-voyages-api","title":"Call the Voyages API\u00b6","text":"<p>The Voyages API retrieves information about vessel voyages.</p>"},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#example-1-tankers-vlcc-crude-flows-from-us-to-china-at-port-call-level-powered-by-v4","title":"Example 1, Tankers: VLCC Crude flows from US to China (at Port Call level, powered by V4)\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#get-voyages-for-vlccs","title":"Get voyages for VLCCs\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#converting-events-to-flows","title":"Converting events to flows\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#group-flows-by-origin-country-and-destination-and-use-sailing_date_load-as-date-of-export","title":"Group flows by origin country and destination, and use sailing_date_load as date of export\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#plot-the-flows","title":"Plot the flows\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#example-2-dry-panamaxes-thermal-coal-flows-from-newcastle-to-japan-at-port-call-level-powered-by-v4","title":"Example 2 - Dry: Panamaxes Thermal Coal Flows from Newcastle to Japan (at Port Call level, powered by V4)\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#get-voyages-for-selected-vessel-classes-post-panamax-and-panamax-after-a-given-date","title":"Get voyages for selected vessel classes (Post Panamax and Panamax) after a given date\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#converting-events-to-flows","title":"Converting events to flows\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#group-flows-by-origin-port-and-destination-country-and-use-sailing_date_load-as-date-of-export","title":"Group flows by origin port and destination country and use sailing_date_load as date of export\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/FlowsFromV4/#plot-the-flows","title":"Plot the flows\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/","title":"Get available vessel types, vessel classes, vessels","text":"<p>Get your personal Signal Ocean API subscription key (acquired here) and replace it below:</p> In\u00a0[15]: Copied! <pre>signal_ocean_api_key = '' # replace with your subscription key\n</pre> signal_ocean_api_key = '' # replace with your subscription key In\u00a0[4]: Copied! <pre>%%capture\n!pip install signal-ocean\nfrom signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nfrom signal_ocean.voyages import Vessel, VesselFilter\nfrom signal_ocean.voyages import VesselType, VesselTypeFilter\nfrom signal_ocean.voyages import VesselClass, VesselClassFilter\nimport pandas as pd\n</pre> %%capture !pip install signal-ocean from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI from signal_ocean.voyages import Vessel, VesselFilter from signal_ocean.voyages import VesselType, VesselTypeFilter from signal_ocean.voyages import VesselClass, VesselClassFilter import pandas as pd In\u00a0[6]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) In\u00a0[2]: Copied! <pre>def get_vessel_types(name_like = None):\n    \n    if name_like:\n        vessel_types = api.get_vessel_types(VesselTypeFilter(name_like))\n    else:\n        vessel_types = api.get_vessel_types()\n    return pd.DataFrame(v.__dict__ for v in vessel_types) \n\ndef get_vessel_classes(name_like = None):\n    \n    if name_like:\n        vessel_classes = api.get_vessel_classes(VesselClassFilter(name_like))\n    else:\n        vessel_classes = api.get_vessel_classes()\n    return pd.DataFrame(v.__dict__ for v in vessel_classes) \n\ndef get_vessels(name_like = None):\n    \n    if name_like:\n        vessels = api.get_imos(VesselFilter(name_like))\n    else:\n        vessels = api.get_imos()\n    return pd.DataFrame(v.__dict__ for v in vessels) \n</pre> def get_vessel_types(name_like = None):          if name_like:         vessel_types = api.get_vessel_types(VesselTypeFilter(name_like))     else:         vessel_types = api.get_vessel_types()     return pd.DataFrame(v.__dict__ for v in vessel_types)   def get_vessel_classes(name_like = None):          if name_like:         vessel_classes = api.get_vessel_classes(VesselClassFilter(name_like))     else:         vessel_classes = api.get_vessel_classes()     return pd.DataFrame(v.__dict__ for v in vessel_classes)   def get_vessels(name_like = None):          if name_like:         vessels = api.get_imos(VesselFilter(name_like))     else:         vessels = api.get_imos()     return pd.DataFrame(v.__dict__ for v in vessels)  In\u00a0[3]: Copied! <pre>get_vessel_types()\n</pre> get_vessel_types() Out[3]: vessel_type_id vessel_type 0 1 Tanker 1 3 Dry 2 5 LNG 3 6 LPG In\u00a0[4]: Copied! <pre>get_vessel_types('Tank')\n</pre> get_vessel_types('Tank') Out[4]: vessel_type_id vessel_type 0 1 Tanker In\u00a0[5]: Copied! <pre>get_vessel_classes()\n</pre> get_vessel_classes() Out[5]: vessel_class_id vessel_class_name vessel_type_id vessel_type 0 60 VLGC 6 LPG 1 61 Midsize/LGC 6 LPG 2 62 Handy 6 LPG 3 63 Small 6 LPG 4 69 VLOC 3 Dry 5 70 Capesize 3 Dry 6 72 Post Panamax 3 Dry 7 74 Panamax 3 Dry 8 75 Supramax 3 Dry 9 76 Handymax 3 Dry 10 77 Handysize 3 Dry 11 84 VLCC 1 Tanker 12 85 Suezmax 1 Tanker 13 86 Aframax 1 Tanker 14 87 Panamax 1 Tanker 15 88 MR2 1 Tanker 16 89 MR1 1 Tanker 17 90 Small 1 Tanker 18 91 LNG 5 LNG 19 92 Small 3 Dry In\u00a0[6]: Copied! <pre>get_vessel_classes('max')\n</pre> get_vessel_classes('max') Out[6]: vessel_class_id vessel_class_name vessel_type_id vessel_type 0 72 Post Panamax 3 Dry 1 74 Panamax 3 Dry 2 75 Supramax 3 Dry 3 76 Handymax 3 Dry 4 85 Suezmax 1 Tanker 5 86 Aframax 1 Tanker 6 87 Panamax 1 Tanker In\u00a0[7]: Copied! <pre>get_vessel_classes('Afra')\n</pre> get_vessel_classes('Afra') Out[7]: vessel_class_id vessel_class_name vessel_type_id vessel_type 0 86 Aframax 1 Tanker In\u00a0[8]: Copied! <pre>get_vessels()\n</pre> get_vessels() Out[8]: imo vessel_name 0 1013391 Hyundai Vietnam S560 1 1013638 Imabari Saijo 8256 2 1013781 Eems Boxer 3 1013793 Eems Bulldog 4 1013808 Eems Balder ... ... ... 49820 9999802 Tsuneishi Zhoushan Ss-364 49821 9999814 Tsuneishi Zhoushan Ss-375 49822 9999826 Tsuneishi Zhoushan Ss-376 49823 9999981 Yard: Hyundai Samho Hull: 8206 49824 9999993 French Warship <p>49825 rows \u00d7 2 columns</p> In\u00a0[10]: Copied! <pre>get_vessels('First')\n</pre> get_vessels('First') Out[10]: imo vessel_name 0 7601451 Firstec 1 8204406 First Clarity 2 8307404 Firstsea 3 8608353 Medelin First 4 8711007 PSU First 5 9071727 First Kasih 6 9115690 Guofeng First 7 9124108 First  Ai 8 9151242 Firstec 9 9197129 First Bridge 10 9266140 First Brother 11 9330056 Star First 12 9357901 First Angel 13 9473119 Harbour First 14 9520728 Shagangfirst Star 15 9567752 First Lion 16 9713909 Glory First 17 9767405 PSU First 18 9772864 RGL First 19 9782247 First Sky 20 9856139 BLC First 21 9864083 First Angelus 22 9871775 First Phoenix 23 9908243 New First 24 9911422 First Dyquem 25 9920667 First Eternity 26 9922691 First Penguin 27 9933250 First Margaux 28 9956159 Apollo First 29 9974084 First Falcon 30 9982665 Emc First"},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#get-available-vessel-types-vessel-classes-vessels","title":"Get available vessel types, vessel classes, vessels\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#setup","title":"Setup\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#vessel-filter-functions","title":"Vessel Filter Functions\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#results","title":"Results\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#vesseltypes","title":"VesselTypes\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#get-all-avalable-vessel-types","title":"Get all avalable vessel types\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#get-avalable-vessel-types-using-vesseltypefilter","title":"Get avalable vessel types using VesselTypeFilter\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#vesselclasses","title":"VesselClasses\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#get-all-avalable-vessel-classes","title":"Get all avalable vessel classes\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#get-avalable-vessel-classes-using-vesselclassfilter","title":"Get avalable vessel classes using VesselClassFilter\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#vessels","title":"Vessels\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#get-all-avalable-vessels","title":"Get all avalable vessels\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Get%20available%20vessel%20types%2C%20vessel%20classes%2C%20vessels/#get-avalable-vessels-using-vesselfilter","title":"Get avalable vessels using VesselFilter\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/OilFlows/","title":"Oil Flows","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nimport pandas as pd\nfrom datetime import date, datetime\nimport plotly.express as px\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI import pandas as pd from datetime import date, datetime import plotly.express as px In\u00a0[3]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) <p>Get vessel class id for VLCCsTankers</p> In\u00a0[4]: Copied! <pre>vessel_classes = api.get_vessel_classes()\nvessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes)\nvessel_classes_df[vessel_classes_df['vessel_type']=='Tanker'].head(7)\n</pre> vessel_classes = api.get_vessel_classes() vessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes) vessel_classes_df[vessel_classes_df['vessel_type']=='Tanker'].head(7) Out[4]: vessel_class_id vessel_class_name vessel_type_id vessel_type 11 84 VLCC 1 Tanker 12 85 Suezmax 1 Tanker 13 86 Aframax 1 Tanker 14 87 Panamax 1 Tanker 15 88 MR2 1 Tanker 16 89 MR1 1 Tanker 17 90 Small 1 Tanker <p>For VLCCs we will use (vessel_class_id = 84) when calling the API</p> In\u00a0[5]: Copied! <pre>voyages = api.get_voyages_condensed(vessel_class_id=84, date_from=datetime.strptime(\"2021-09-01\", \"%Y-%m-%d\"))\nvoyages = pd.DataFrame([v.__dict__ for v in voyages])\nvoyages.tail()\n</pre> voyages = api.get_voyages_condensed(vessel_class_id=84, date_from=datetime.strptime(\"2021-09-01\", \"%Y-%m-%d\")) voyages = pd.DataFrame([v.__dict__ for v in voyages]) voyages.tail() Out[5]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... last_discharge_sailing_date last_discharge_country_id last_discharge_country_name last_discharge_area_id_level0 last_discharge_area_name_level0 repairs_ind storage_ind sts_load_ind sts_discharge_ind local_trade_ind 10341 9943748 1 1 84 1 1645.0 False None I97BAC454VEDBD3C900 1 ... 2023-08-19 19:57:33+00:00 173.0 Netherlands None Continent True False True False False 10342 9943748 2 1 84 1 1645.0 False None I97BAC454VEDC71FD00 1 ... 2023-11-12 03:58:16+00:00 112.0 India None Pakistan / West Coast India False False True False False 10343 9943748 3 1 84 1 1645.0 False None I97BAC454VEDCC11700 1 ... 2023-12-20 23:54:35+00:00 55.0 China None Central China False False False False False 10344 9943748 4 1 84 1 558.0 False None I97BAC454VEDD103100 2 ... 2024-02-17 15:42:08.398000+00:00 55.0 China None North China False False False False False 10345 9946673 1 1 84 1 1441.0 False None I97C63154VEDB84AF00 2 ... NaT NaN None None None False False False False True <p>5 rows \u00d7 97 columns</p> <p>Convert Timestamp to datetime, drop voyages with first_load_sailing_date in the future (ongoing or future)</p> In\u00a0[6]: Copied! <pre>voyages['first_load_sailing_date'] = voyages['first_load_sailing_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None))\nvoyages=voyages[voyages['first_load_sailing_date']&lt;datetime.now()]\n</pre> voyages['first_load_sailing_date'] = voyages['first_load_sailing_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None)) voyages=voyages[voyages['first_load_sailing_date'] In\u00a0[7]: Copied! <pre>dirty_exports_country_level = voyages[(voyages['first_load_sailing_date']&gt;\"2022-01-01\")&amp;(voyages['cargo_group']=='Dirty')] \\\n    .set_index('first_load_sailing_date') \\\n    .groupby(['first_load_country_name', 'last_discharge_country_name'])['quantity'] \\\n    .resample('MS') \\\n    .sum() \\\n    .reset_index() \\\n    .rename(columns={'first_load_sailing_date': 'Date'})\n</pre> dirty_exports_country_level = voyages[(voyages['first_load_sailing_date']&gt;\"2022-01-01\")&amp;(voyages['cargo_group']=='Dirty')] \\     .set_index('first_load_sailing_date') \\     .groupby(['first_load_country_name', 'last_discharge_country_name'])['quantity'] \\     .resample('MS') \\     .sum() \\     .reset_index() \\     .rename(columns={'first_load_sailing_date': 'Date'}) In\u00a0[8]: Copied! <pre>dirty_exports_country_level.head()\n</pre> dirty_exports_country_level.head() Out[8]: first_load_country_name last_discharge_country_name Date quantity 0 Angola Benin 2023-04-01 192000.0 1 Angola Brazil 2022-11-01 260000.0 2 Angola Caribs 2023-12-01 246000.0 3 Angola China 2022-01-01 2601000.0 4 Angola China 2022-02-01 3171000.0 <p>Drop intra country flows</p> In\u00a0[9]: Copied! <pre>dirty_exports_country_level = dirty_exports_country_level[dirty_exports_country_level['first_load_country_name']!=dirty_exports_country_level['last_discharge_country_name']]\n</pre> dirty_exports_country_level = dirty_exports_country_level[dirty_exports_country_level['first_load_country_name']!=dirty_exports_country_level['last_discharge_country_name']] <ul> <li>Keep only US exports</li> <li>Aggregate all exports monthly</li> <li>Drop unnecessary columns</li> </ul> In\u00a0[10]: Copied! <pre>us_dirty_exports = dirty_exports_country_level[(dirty_exports_country_level['first_load_country_name']=='United States')].copy()\n\nus_dirty_exports['TotalExports'] = us_dirty_exports['quantity'].groupby(us_dirty_exports['Date']).transform('sum')\nus_dirty_exports.drop_duplicates(subset=['Date'], keep='last', inplace = True)\nus_dirty_exports.drop(['last_discharge_country_name', 'quantity'], axis=1, inplace = True)\nus_dirty_exports.head()\n</pre> us_dirty_exports = dirty_exports_country_level[(dirty_exports_country_level['first_load_country_name']=='United States')].copy()  us_dirty_exports['TotalExports'] = us_dirty_exports['quantity'].groupby(us_dirty_exports['Date']).transform('sum') us_dirty_exports.drop_duplicates(subset=['Date'], keep='last', inplace = True) us_dirty_exports.drop(['last_discharge_country_name', 'quantity'], axis=1, inplace = True) us_dirty_exports.head() Out[10]: first_load_country_name Date TotalExports 4276 United States 2022-01-01 6661000.0 4277 United States 2022-02-01 4330000.0 4301 United States 2024-02-01 1956000.0 4302 United States 2022-03-01 5702000.0 4303 United States 2022-04-01 5561000.0 In\u00a0[11]: Copied! <pre>us_dirty_exports['Year'] = us_dirty_exports['Date'].apply(lambda date : date.year)\nus_dirty_exports['Month'] = us_dirty_exports['Date'].apply(lambda date : date.month)\nus_dirty_exports.sort_values(['Month', 'Year'], inplace = True)\nus_dirty_exports['Month'] = us_dirty_exports['Date'].apply(lambda date : date.strftime(\"%b\"))\n\nfig = px.histogram(us_dirty_exports, x=\"Month\", y=\"TotalExports\", color='Year',\n             barmode='group', height=500, width=1000,\n             title='US VLCC Dirty Exports (MT)',\n             color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"])\nfig.show()\n</pre> us_dirty_exports['Year'] = us_dirty_exports['Date'].apply(lambda date : date.year) us_dirty_exports['Month'] = us_dirty_exports['Date'].apply(lambda date : date.month) us_dirty_exports.sort_values(['Month', 'Year'], inplace = True) us_dirty_exports['Month'] = us_dirty_exports['Date'].apply(lambda date : date.strftime(\"%b\"))  fig = px.histogram(us_dirty_exports, x=\"Month\", y=\"TotalExports\", color='Year',              barmode='group', height=500, width=1000,              title='US VLCC Dirty Exports (MT)',              color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"]) fig.show() Examine China VLCC Dirty Imports Convert Timestamp to datetime, drop uncompleted voyages (with last_discharge_arrival_date in the future)    In\u00a0[12]: Copied! <pre>voyages['last_discharge_arrival_date'] = voyages['last_discharge_arrival_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None))\nvoyages=voyages[voyages['last_discharge_arrival_date']&lt;datetime.now()]\n</pre> voyages['last_discharge_arrival_date'] = voyages['last_discharge_arrival_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None)) voyages=voyages[voyages['last_discharge_arrival_date'] <p>Group by origin and destination (first load, last discharge), and use last_discharge_arrival_date as date of import</p> In\u00a0[13]: Copied! <pre>dirty_imports_country_level = voyages[(voyages['last_discharge_arrival_date']&gt;\"2022-01-01\")&amp;(voyages['cargo_group']=='Dirty')] \\\n    .set_index('last_discharge_arrival_date') \\\n    .groupby(['first_load_country_name', 'last_discharge_country_name'])['quantity'] \\\n    .resample('MS') \\\n    .sum() \\\n    .reset_index() \\\n    .rename(columns={'last_discharge_arrival_date': 'Date'})\n</pre> dirty_imports_country_level = voyages[(voyages['last_discharge_arrival_date']&gt;\"2022-01-01\")&amp;(voyages['cargo_group']=='Dirty')] \\     .set_index('last_discharge_arrival_date') \\     .groupby(['first_load_country_name', 'last_discharge_country_name'])['quantity'] \\     .resample('MS') \\     .sum() \\     .reset_index() \\     .rename(columns={'last_discharge_arrival_date': 'Date'}) <p>Drop intra country flows</p> In\u00a0[14]: Copied! <pre>dirty_imports_country_level = dirty_imports_country_level[dirty_imports_country_level['first_load_country_name']!=dirty_imports_country_level['last_discharge_country_name']]\ndirty_imports_country_level.head()\n</pre> dirty_imports_country_level = dirty_imports_country_level[dirty_imports_country_level['first_load_country_name']!=dirty_imports_country_level['last_discharge_country_name']] dirty_imports_country_level.head() Out[14]: first_load_country_name last_discharge_country_name Date quantity 0 Angola Benin 2023-05-01 192000.0 1 Angola Brazil 2022-12-01 260000.0 2 Angola Caribs 2024-01-01 246000.0 3 Angola China 2022-01-01 2346000.0 4 Angola China 2022-02-01 2333000.0 <ul> <li>Keep only China imports</li> <li>Aggregate all exports monthly</li> <li>Drop unnecessary columns</li> </ul> In\u00a0[15]: Copied! <pre>china_dirty_imports = dirty_imports_country_level[(dirty_imports_country_level['last_discharge_country_name']=='China')].copy()\n\nchina_dirty_imports['TotalImports'] = china_dirty_imports['quantity'].groupby(china_dirty_imports['Date']).transform('sum')\nchina_dirty_imports.drop_duplicates(subset=['Date'], keep='last', inplace = True)\nchina_dirty_imports.drop(['first_load_country_name', 'quantity'], axis=1, inplace = True)\nchina_dirty_imports.head()\n</pre> china_dirty_imports = dirty_imports_country_level[(dirty_imports_country_level['last_discharge_country_name']=='China')].copy()  china_dirty_imports['TotalImports'] = china_dirty_imports['quantity'].groupby(china_dirty_imports['Date']).transform('sum') china_dirty_imports.drop_duplicates(subset=['Date'], keep='last', inplace = True) china_dirty_imports.drop(['first_load_country_name', 'quantity'], axis=1, inplace = True) china_dirty_imports.head() Out[15]: last_discharge_country_name Date TotalImports 3825 China 2022-01-01 29399000.0 3826 China 2022-02-01 26518000.0 3850 China 2024-02-01 9693000.0 4249 China 2022-12-01 33871000.0 4250 China 2023-01-01 29848000.0 In\u00a0[16]: Copied! <pre>china_dirty_imports['Year'] = china_dirty_imports['Date'].apply(lambda date : date.year)\nchina_dirty_imports['Month'] = china_dirty_imports['Date'].apply(lambda date : date.month)\nchina_dirty_imports.sort_values(['Month', 'Year'], inplace = True)\nchina_dirty_imports['Month'] = china_dirty_imports['Date'].apply(lambda date : date.strftime(\"%b\"))\n\nfig = px.histogram(china_dirty_imports, x=\"Month\", y=\"TotalImports\", color='Year',\n             barmode='group', height=500, width=1000,\n             title='China VLCC dirty Imports',\n             color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"])\nfig.show()\n</pre> china_dirty_imports['Year'] = china_dirty_imports['Date'].apply(lambda date : date.year) china_dirty_imports['Month'] = china_dirty_imports['Date'].apply(lambda date : date.month) china_dirty_imports.sort_values(['Month', 'Year'], inplace = True) china_dirty_imports['Month'] = china_dirty_imports['Date'].apply(lambda date : date.strftime(\"%b\"))  fig = px.histogram(china_dirty_imports, x=\"Month\", y=\"TotalImports\", color='Year',              barmode='group', height=500, width=1000,              title='China VLCC dirty Imports',              color_discrete_sequence=[\"lightgray\", \"gray\", \"lightblue\"]) fig.show() <p>Get vessel class ids for Tanker vessel classes</p> In\u00a0[17]: Copied! <pre>vessel_classes = api.get_vessel_classes()\nvessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes)\nvessel_classes_df[vessel_classes_df['vessel_type']=='Tanker'].head(10)\n</pre> vessel_classes = api.get_vessel_classes() vessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes) vessel_classes_df[vessel_classes_df['vessel_type']=='Tanker'].head(10) Out[17]: vessel_class_id vessel_class_name vessel_type_id vessel_type 11 84 VLCC 1 Tanker 12 85 Suezmax 1 Tanker 13 86 Aframax 1 Tanker 14 87 Panamax 1 Tanker 15 88 MR2 1 Tanker 16 89 MR1 1 Tanker 17 90 Small 1 Tanker In\u00a0[18]: Copied! <pre>vessel_class_ids = (87, 88) # Get only voyages for Aframax, Panamax and MR2\ndate_from = datetime.strptime(\"2022-09-01\", \"%Y-%m-%d\")\n\nvoyages = []\nfor vessel_class_id in vessel_class_ids:    \n    voyages.append(api.get_voyages_condensed(vessel_class_id=vessel_class_id, date_from=date_from))\n    \nvoyages = pd.DataFrame([v.__dict__ for vc in voyages for v in vc])\nvoyages.tail(5)\n</pre> vessel_class_ids = (87, 88) # Get only voyages for Aframax, Panamax and MR2 date_from = datetime.strptime(\"2022-09-01\", \"%Y-%m-%d\")  voyages = [] for vessel_class_id in vessel_class_ids:         voyages.append(api.get_voyages_condensed(vessel_class_id=vessel_class_id, date_from=date_from))      voyages = pd.DataFrame([v.__dict__ for vc in voyages for v in vc]) voyages.tail(5) Out[18]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... last_discharge_sailing_date last_discharge_country_id last_discharge_country_name last_discharge_area_id_level0 last_discharge_area_name_level0 repairs_ind storage_ind sts_load_ind sts_discharge_ind local_trade_ind 36728 9970363 2 1 88 1 NaN False None I9822BB58VEDCE8A400 2 ... 2024-02-17 04:22:33.820000+00:00 240.0 United States None US Atlantic Coast False False False False False 36729 9970375 1 1 88 1 NaN False None I9822C758VEDC998A00 2 ... 2024-02-28 21:48:29.342000+00:00 38.0 Brazil None Brazil True False False False False 36730 9973913 1 1 88 1 NaN False None I98309958VEDD37BE00 2 ... NaT NaN None None None True False False False True 36731 9974981 1 1 88 1 NaN False None I9834C558VEDD103100 2 ... NaT NaN None None None True False False False True 36732 9983889 1 1 88 1 1216.0 False None I98579158VEDD37BE00 2 ... NaT NaN None None None True False False False True <p>5 rows \u00d7 97 columns</p> <p>Date of flows will be based on the export date</p> <ul> <li>Convert Timestamp to datetime, drop voyages with first_load_sailing_date in the future (ongoing or future)</li> </ul> In\u00a0[19]: Copied! <pre>voyages['first_load_sailing_date'] = voyages['first_load_sailing_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None))\nvoyages=voyages[voyages['first_load_sailing_date']&lt;datetime.now()]\nvoyages.head()\n</pre> voyages['first_load_sailing_date'] = voyages['first_load_sailing_date'].apply(lambda d : pd.to_datetime(d).tz_localize(None)) voyages=voyages[voyages['first_load_sailing_date'] Out[19]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... last_discharge_sailing_date last_discharge_country_id last_discharge_country_name last_discharge_area_id_level0 last_discharge_area_name_level0 repairs_ind storage_ind sts_load_ind sts_discharge_ind local_trade_ind 0 9063108 207 1 87 1 356.0 False None I8A4AC4VEDA976100 1 ... 2022-09-16 04:50:52+00:00 55.0 China None South China False False False False True 1 9063108 208 1 87 1 356.0 False None I8A4AC4VEDAB1BF00 1 ... 2022-10-06 23:01:32.800000+00:00 55.0 China None South China False False False False True 2 9063108 209 1 87 1 356.0 False None I8A4AC4VEDABEEE00 1 ... 2022-10-24 03:57:34+00:00 55.0 China None South China False False False False True 3 9063108 210 1 87 1 356.0 False None I8A4AC4VEDAE67B00 1 ... 2022-11-09 03:33:00+00:00 55.0 China None South China False False False False True 4 9063108 211 1 87 1 356.0 False None I8A4AC4VEDAF3AA00 1 ... 2022-12-05 07:47:48+00:00 55.0 China None South China False False False False True <p>5 rows \u00d7 97 columns</p> In\u00a0[20]: Copied! <pre>voyages[voyages['cargo_group']=='Clean'].drop_duplicates(subset=['cargo_group', 'cargo_type'], keep='last')[['cargo_group', 'cargo_type']].head()\n</pre> voyages[voyages['cargo_group']=='Clean'].drop_duplicates(subset=['cargo_group', 'cargo_type'], keep='last')[['cargo_group', 'cargo_type']].head() Out[20]: cargo_group cargo_type 36029 Clean Mixed Aromatics 36410 Clean Clean Condensate 36614 Clean Intermediate 36647 Clean Gasoline Blending Component 36697 Clean Jet In\u00a0[21]: Copied! <pre>voyages[(voyages['first_load_country_name']=='United States')&amp;(voyages['cargo_group']=='Clean')]['cargo_type'].value_counts().head(10)\n</pre> voyages[(voyages['first_load_country_name']=='United States')&amp;(voyages['cargo_group']=='Clean')]['cargo_type'].value_counts().head(10) Out[21]: <pre>Gasoline                       2319\nDiesel                         1932\nGasoil                          354\nJet                             334\nNaphtha                         270\nGasoline Blending Component     120\nIntermediate                     15\nMixed Aromatics                   4\nClean Condensate                  2\nName: cargo_type, dtype: int64</pre> <ul> <li>Keep cargo types of interest</li> <li>Group by origin and destination (first load, last discharge) and cargo type</li> <li>Use last_discharge_arrival_date as date of flow</li> </ul> In\u00a0[22]: Copied! <pre>cargo_types_of_interest = ('Gasoline', 'Diesel', 'Ultra Low Sulphur Diesel', 'Gasoil', 'Naphtha', 'Unleaded Motor Spirit', 'Jet')\n\ncustom_flows_country_level = voyages[(voyages['first_load_sailing_date']&gt;\"2023-01-01\")&amp;(voyages['cargo_type'].isin(cargo_types_of_interest))] \\\n    .set_index('first_load_sailing_date') \\\n    .groupby(['first_load_country_name', 'last_discharge_country_name', 'cargo_type'])['quantity'] \\\n    .resample('MS') \\\n    .sum() \\\n    .reset_index() \\\n    .rename(columns={'first_load_sailing_date': 'Date'})\ncustom_flows_country_level.head()\n</pre> cargo_types_of_interest = ('Gasoline', 'Diesel', 'Ultra Low Sulphur Diesel', 'Gasoil', 'Naphtha', 'Unleaded Motor Spirit', 'Jet')  custom_flows_country_level = voyages[(voyages['first_load_sailing_date']&gt;\"2023-01-01\")&amp;(voyages['cargo_type'].isin(cargo_types_of_interest))] \\     .set_index('first_load_sailing_date') \\     .groupby(['first_load_country_name', 'last_discharge_country_name', 'cargo_type'])['quantity'] \\     .resample('MS') \\     .sum() \\     .reset_index() \\     .rename(columns={'first_load_sailing_date': 'Date'}) custom_flows_country_level.head() Out[22]: first_load_country_name last_discharge_country_name cargo_type Date quantity 0 Albania Slovenia Diesel 2023-08-01 30000.0 1 Algeria Belgium Gasoline 2023-04-01 37000.0 2 Algeria Belgium Jet 2023-02-01 37000.0 3 Algeria Belgium Naphtha 2023-02-01 146000.0 4 Algeria Belgium Naphtha 2023-03-01 37000.0 In\u00a0[23]: Copied! <pre>import_countries = ('Mexico', 'Brazil', 'Argentina')\ncustom_flows = custom_flows_country_level[(custom_flows_country_level['first_load_country_name']=='United States')&amp;(custom_flows_country_level['last_discharge_country_name'].isin(import_countries))].copy()\ncustom_flows.head()\n</pre> import_countries = ('Mexico', 'Brazil', 'Argentina') custom_flows = custom_flows_country_level[(custom_flows_country_level['first_load_country_name']=='United States')&amp;(custom_flows_country_level['last_discharge_country_name'].isin(import_countries))].copy() custom_flows.head() Out[23]: first_load_country_name last_discharge_country_name cargo_type Date quantity 12798 United States Argentina Diesel 2023-01-01 76000.0 12799 United States Argentina Diesel 2023-02-01 97000.0 12800 United States Argentina Diesel 2023-03-01 60000.0 12801 United States Argentina Diesel 2023-04-01 98000.0 12802 United States Argentina Diesel 2023-05-01 108000.0 In\u00a0[24]: Copied! <pre>custom_flows['Year'] = custom_flows['Date'].apply(lambda date : date.year)\ncustom_flows['Month'] = custom_flows['Date'].apply(lambda date : date.month)\ncustom_flows.sort_values(['Year', 'Month'], inplace = True)\n\ncustom_flows['Month'] = custom_flows['Date'].apply(lambda date : date.strftime(\"%b\"))\ncustom_flows['Year'] = custom_flows['Date'].apply(lambda date : date.strftime(\"%Y\"))\ncustom_flows['MonthYear'] = custom_flows['Month'].astype(str) + ' ' + custom_flows['Year'].astype(str)\n\nfig = px.histogram(custom_flows, x=\"MonthYear\", y=\"quantity\", color='cargo_type',\n            height=500, width=1000, title='custom Flows - US Clean Exports to (Mexico, Brazil and Argentina)',\n             color_discrete_sequence=px.colors.qualitative.Pastel)\nfig.update_layout(bargap=0.2)\nfig.show()\n</pre> custom_flows['Year'] = custom_flows['Date'].apply(lambda date : date.year) custom_flows['Month'] = custom_flows['Date'].apply(lambda date : date.month) custom_flows.sort_values(['Year', 'Month'], inplace = True)  custom_flows['Month'] = custom_flows['Date'].apply(lambda date : date.strftime(\"%b\")) custom_flows['Year'] = custom_flows['Date'].apply(lambda date : date.strftime(\"%Y\")) custom_flows['MonthYear'] = custom_flows['Month'].astype(str) + ' ' + custom_flows['Year'].astype(str)  fig = px.histogram(custom_flows, x=\"MonthYear\", y=\"quantity\", color='cargo_type',             height=500, width=1000, title='custom Flows - US Clean Exports to (Mexico, Brazil and Argentina)',              color_discrete_sequence=px.colors.qualitative.Pastel) fig.update_layout(bargap=0.2) fig.show()"},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#oil-flows","title":"Oil Flows\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#call-the-voyages-api","title":"Call the Voyages API\u00b6","text":"<p>The Voyages API retrieves information about vessel voyages.</p>"},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#get-voyages-for-vlccs","title":"Get voyages for VLCCs\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#examine-us-vlcc-dirty-exports","title":"Examine US VLCC Dirty Exports\u00b6","text":"<p>Group by origin and destination (first load, last discharge), and use first_load_sailing_date as date of export</p>"},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#plot-us-vlcc-dirty-exports","title":"Plot US VLCC Dirty exports\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#plot-china-vlcc-dirty-imports","title":"Plot China VLCC Dirty Imports\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#build-your-custom-flows-us-clean-exports-to-specific-countries-by-panamax-and-mr2","title":"Build your custom Flows - US Clean Exports to specific countries by Panamax and MR2\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#select-the-vessel-classes-of-interest","title":"Select the vessel classes of interest\u00b6","text":"<p>Get voyages for selected vessel classes (Panamax and MR2) after a given date</p>"},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#select-the-cargo-types-of-interest","title":"Select the cargo types of interest\u00b6","text":"<p>Examine different cargo types under the \"Clean\" cargo group</p>"},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#select-flows-of-interest","title":"Select flows of interest\u00b6","text":"<p>Keep only flows between US and (Mexico, Brazil, Argentina)</p>"},{"location":"examples/jupyter/VoyagesAPI/OilFlows/#plot-custom-flows-us-clean-exports-to-specific-countries","title":"Plot custom flows - US Clean Exports to specific countries\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-FloatingStorages/","title":"Voyages API - Floating Storages","text":"<p>       Floating Storages are laden vessels that remain stopped, instead of directly proceeding with the laden part of the voyage and the discharge of the cargo. This is usually performed for trading reasons. The minimum duaration for a stop to be classified as a Floating Storage is 7 days for concluded Stops and 3 days for ongoing ones.  </p> <p>      Very often arises the need of conducting an analysis of the total quantity of the quantity of oil that remains in floating storages, either globally or in a specific area/port and for a given time window. This is accommodated by the VoyagesData API. </p> <p>Both <code>get_voyages_by_advanced_search</code> and <code>get_voyages_flat_by_advanced_search</code> of the Signal SDK facilititate this need. In this example, we will be constructing a dataframe with all the floating storage events of interest, from which a time series of total stored quantitites will be derived.</p> In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nfrom signal_ocean.voyages import VesselClass, VesselClassFilter\nimport pandas as pd\nfrom datetime import date\nfrom dateutil.relativedelta import relativedelta\nimport matplotlib.pyplot as plt\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI from signal_ocean.voyages import VesselClass, VesselClassFilter import pandas as pd from datetime import date from dateutil.relativedelta import relativedelta import matplotlib.pyplot as plt In\u00a0[3]: Copied! <pre>pd.set_option('display.max_columns', None)\n</pre> pd.set_option('display.max_columns', None) In\u00a0[4]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) <p>For this tutorial we will retrieve the voyages of VLCC vessels that have ended after January 2020, including those still ongoing. To add other vessel classes like Suezmaxes or Aframaxes, you can retrieve the corresponding VesselClassIDs and add them to the list</p> In\u00a0[5]: Copied! <pre>#get vessel class id for vlcc\nvc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0]\nvlcc_id = vc.vessel_class_id\n</pre> #get vessel class id for vlcc vc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0] vlcc_id = vc.vessel_class_id In\u00a0[6]: Copied! <pre>end_date_from = date(2019, 9, 1)\n</pre> end_date_from = date(2019, 9, 1) In\u00a0[7]: Copied! <pre>vc_list = [vlcc_id]\n</pre> vc_list = [vlcc_id] In\u00a0[8]: Copied! <pre>%%time\nvoyages_api = api.get_voyages_by_advanced_search(\n    vessel_class_ids = [*vc_list],\n    end_date_from = end_date_from\n)\n</pre> %%time voyages_api = api.get_voyages_by_advanced_search(     vessel_class_ids = [*vc_list],     end_date_from = end_date_from ) <pre>Wall time: 3min 24s\n</pre> <p>We will now extract the voyages in a data frame format.</p> In\u00a0[9]: Copied! <pre>voyages_df = pd.DataFrame(v.__dict__ for v in voyages_api)\n</pre> voyages_df = pd.DataFrame(v.__dict__ for v in voyages_api) <p>Here we split the voyages into seagoing vessels and storage vessels. We can either include or exclude storage vessels by setting the approproate flag. There are some edge cases wherein the calculated cargo and quantity are null. We treat this case separately by assigning $80\\%$ of their deadweight.</p> In\u00a0[10]: Copied! <pre>exclude_storage_vessels = False\n\n# extracting floating storage events\nfloating_storage_events_data = []\n\nfor iVoyage, r in voyages_df.iterrows():\n    imo = r['imo']\n    voyage_number = r['voyage_number']\n    vessel_class = r['vessel_class']\n    cargo_group = r['cargo_group']\n    cargo_type_id = r['cargo_type_id']\n    cargo_type = r['cargo_type']\n    quantity = r['quantity']\n    if not quantity:\n        quantity = r['deadweight'] * 0.8\n        cargo_group = 'Dirty'\n        cargo_type_id = 19\n        cargo_type = 'Crude Oil'\n\n    events = r['events']\n    \n    for event in events:\n        if not event.event_details:\n            continue\n        if exclude_storage_vessels and e.purpose == 'StorageVessel':\n            continue\n        port_name = event.port_name\n        country = event.country\n        area_name_level0 = event.area_name_level0\n        \n        for event_detail in event.event_details:\n            if not event_detail.floating_storage_start_date:\n                continue\n            floating_storage_start_date = event_detail.floating_storage_start_date\n            floating_storage_duration = event_detail.floating_storage_duration\n            \n            floating_storage_events_data.append([\n                imo, voyage_number, vessel_class,cargo_group,cargo_type,cargo_type_id,area_name_level0, quantity,\n                port_name, country, floating_storage_start_date, \n                floating_storage_duration\n            ])\n            \nfloating_storage_events_df = pd.DataFrame(floating_storage_events_data, \n                                           columns=['imo', 'voyage_number', 'vessel_class','cargo_group', 'cargo_type',\n                                                    'cargo_type_id','area_name_level0',\n                                                    'quantity', 'port_name', 'country','floating_storage_start_date', \n                                                    'floating_storage_duration'\n                                                   ])\n</pre> exclude_storage_vessels = False  # extracting floating storage events floating_storage_events_data = []  for iVoyage, r in voyages_df.iterrows():     imo = r['imo']     voyage_number = r['voyage_number']     vessel_class = r['vessel_class']     cargo_group = r['cargo_group']     cargo_type_id = r['cargo_type_id']     cargo_type = r['cargo_type']     quantity = r['quantity']     if not quantity:         quantity = r['deadweight'] * 0.8         cargo_group = 'Dirty'         cargo_type_id = 19         cargo_type = 'Crude Oil'      events = r['events']          for event in events:         if not event.event_details:             continue         if exclude_storage_vessels and e.purpose == 'StorageVessel':             continue         port_name = event.port_name         country = event.country         area_name_level0 = event.area_name_level0                  for event_detail in event.event_details:             if not event_detail.floating_storage_start_date:                 continue             floating_storage_start_date = event_detail.floating_storage_start_date             floating_storage_duration = event_detail.floating_storage_duration                          floating_storage_events_data.append([                 imo, voyage_number, vessel_class,cargo_group,cargo_type,cargo_type_id,area_name_level0, quantity,                 port_name, country, floating_storage_start_date,                  floating_storage_duration             ])              floating_storage_events_df = pd.DataFrame(floating_storage_events_data,                                             columns=['imo', 'voyage_number', 'vessel_class','cargo_group', 'cargo_type',                                                     'cargo_type_id','area_name_level0',                                                     'quantity', 'port_name', 'country','floating_storage_start_date',                                                      'floating_storage_duration'                                                    ]) <p>Signal uses default thresholds in days after which an event is considered a floating storage event. However, we can also implement custom, stricter thresholds. Here the user can set a higher threshold for a Stop to be considered as a Floating Storage. In this example, we use 20 days.</p> In\u00a0[11]: Copied! <pre># define the threshold in days to filter floating_storage_duration\nlower_threshold = 20  \nfloating_storage_events_df = floating_storage_events_df.query(\"floating_storage_duration &gt;= @lower_threshold\")\n</pre> # define the threshold in days to filter floating_storage_duration lower_threshold = 20   floating_storage_events_df = floating_storage_events_df.query(\"floating_storage_duration &gt;= @lower_threshold\") <p>We extract only the date from the datetime object floating_storage_start_date, since the duration is given in days and, thus, the exact time is not relevant.</p> In\u00a0[12]: Copied! <pre>floating_storage_events_df.loc[:, 'floating_storage_start_date'] = floating_storage_events_df.floating_storage_start_date.apply(lambda x: x.date())\n</pre> floating_storage_events_df.loc[:, 'floating_storage_start_date'] = floating_storage_events_df.floating_storage_start_date.apply(lambda x: x.date()) <p>If you want to exclude a specific range of cargoes like fueloils, we add them in an \"excluded\" list. This is mostly revelant for classes smaller than VLCCs.</p> In\u00a0[13]: Copied! <pre>dirty_cargoes = list(floating_storage_events_df[(floating_storage_events_df.cargo_group == 'Dirty')].cargo_type.unique())\n</pre> dirty_cargoes = list(floating_storage_events_df[(floating_storage_events_df.cargo_group == 'Dirty')].cargo_type.unique()) In\u00a0[14]: Copied! <pre>fueloils = [cargo for cargo in dirty_cargoes if 'fueloil' in cargo.lower().split()]\nexcluded = [*fueloils]\n</pre> fueloils = [cargo for cargo in dirty_cargoes if 'fueloil' in cargo.lower().split()] excluded = [*fueloils] In\u00a0[15]: Copied! <pre>floating_storage_events_df = floating_storage_events_df[(floating_storage_events_df.cargo_group == 'Dirty') &amp;\n                                                        (~floating_storage_events_df.cargo_type.isin(excluded))\n                                                       ].copy()\n</pre> floating_storage_events_df = floating_storage_events_df[(floating_storage_events_df.cargo_group == 'Dirty') &amp;                                                         (~floating_storage_events_df.cargo_type.isin(excluded))                                                        ].copy() <p>We create the new column floating_storage_end_date base on floating_storage_start_date and the duration.</p> In\u00a0[16]: Copied! <pre>floating_storage_events_df['floating_storage_end_date'] = floating_storage_events_df.apply(\n    lambda r: r['floating_storage_start_date'] + relativedelta(days=r['floating_storage_duration']), axis=1)\n</pre> floating_storage_events_df['floating_storage_end_date'] = floating_storage_events_df.apply(     lambda r: r['floating_storage_start_date'] + relativedelta(days=r['floating_storage_duration']), axis=1) <p>Next, we transform the column names to CamelCase and select the desired columns from the dataframe.</p> In\u00a0[17]: Copied! <pre>def snake_to_camel(word):\n    return ''.join(x.capitalize() or '_' for x in word.split('_'))\n</pre> def snake_to_camel(word):     return ''.join(x.capitalize() or '_' for x in word.split('_')) In\u00a0[18]: Copied! <pre>floating_storage_events_df.columns = [*map(snake_to_camel, floating_storage_events_df.columns)]\nfloating_storage_events_df = floating_storage_events_df[['Imo', 'VoyageNumber', 'VesselClass', 'CargoType', 'Quantity',\n                                                         'AreaNameLevel0',\n                                                         'PortName', 'Country', 'FloatingStorageStartDate',\n                                                         'FloatingStorageEndDate'\n                                                        ]].copy()\nfloating_storage_events_df.head(2)\n</pre> floating_storage_events_df.columns = [*map(snake_to_camel, floating_storage_events_df.columns)] floating_storage_events_df = floating_storage_events_df[['Imo', 'VoyageNumber', 'VesselClass', 'CargoType', 'Quantity',                                                          'AreaNameLevel0',                                                          'PortName', 'Country', 'FloatingStorageStartDate',                                                          'FloatingStorageEndDate'                                                         ]].copy() floating_storage_events_df.head(2) Out[18]: Imo VoyageNumber VesselClass CargoType Quantity AreaNameLevel0 PortName Country FloatingStorageStartDate FloatingStorageEndDate 8 9043029 1 VLCC Crude Oil 241000.0 Indonesia Gagak Rimang FSO Indonesia 2014-12-31 2023-07-20 10 9078359 1 VLCC Cameroon Crude Oil 215000.0 Arabian Gulf Ras Laffan Qatar 2020-03-20 2020-05-21 <p>Here we set the date range under consideration for the plots. For the first plot, we focus on the Red Sea area, during 2023.</p> In\u00a0[19]: Copied! <pre># min and max dates for consideration\ndate_min = date(2023, 1, 1)\ndate_max = date(2023, 7, 1)\n\ndelta = (date_max - date_min).days\n</pre> # min and max dates for consideration date_min = date(2023, 1, 1) date_max = date(2023, 7, 1)  delta = (date_max - date_min).days In\u00a0[20]: Copied! <pre>red_sea_events_df = floating_storage_events_df[floating_storage_events_df.AreaNameLevel0 == 'Red Sea'].copy()\n</pre> red_sea_events_df = floating_storage_events_df[floating_storage_events_df.AreaNameLevel0 == 'Red Sea'].copy() <p>We convert the quantity from MT (QMT) to kilo barrels (QKB), using the formula $QKB = \\frac{(QMT/1000) \\times (APIGravity + 131.5)}{141.5\\times 0.159}$. For now we use the API Gravity of Crude Oil, which is 28, but the Cargo API has the exact value.</p> In\u00a0[21]: Copied! <pre>floating_oil_daily_data = []\n\nfor iDay in range(delta):\n    curr_date = date_min + relativedelta(days=iDay)\n    events_on_curr_date = red_sea_events_df[(red_sea_events_df.FloatingStorageStartDate &lt;= curr_date) &amp;\n                                                   (red_sea_events_df.FloatingStorageEndDate &gt;= curr_date)\n                                                  ].copy()\n    if events_on_curr_date.empty:\n        quantity_on_water = 0\n    else:\n        quantity_on_water =  events_on_curr_date.apply(lambda r: \n                                    r['Quantity'] * (28 + 131.5) / (141.5 * 0.159) / 1_000_000, axis=1).sum()\n    floating_oil_daily_data.append([curr_date, quantity_on_water])\n</pre> floating_oil_daily_data = []  for iDay in range(delta):     curr_date = date_min + relativedelta(days=iDay)     events_on_curr_date = red_sea_events_df[(red_sea_events_df.FloatingStorageStartDate &lt;= curr_date) &amp;                                                    (red_sea_events_df.FloatingStorageEndDate &gt;= curr_date)                                                   ].copy()     if events_on_curr_date.empty:         quantity_on_water = 0     else:         quantity_on_water =  events_on_curr_date.apply(lambda r:                                      r['Quantity'] * (28 + 131.5) / (141.5 * 0.159) / 1_000_000, axis=1).sum()     floating_oil_daily_data.append([curr_date, quantity_on_water])  In\u00a0[22]: Copied! <pre>floating_oil_series = pd.DataFrame(floating_oil_daily_data, columns=['Date', 'Quantity'])\n</pre> floating_oil_series = pd.DataFrame(floating_oil_daily_data, columns=['Date', 'Quantity']) In\u00a0[23]: Copied! <pre>fig1 = plt.figure(figsize=(6, 3))\naxes1 = fig1.add_axes([0, 0, 1, 1])\naxes1.plot(floating_oil_series.Date, floating_oil_series.Quantity)\n\naxes1.set_title('Floating Storage quantity in Red Sea between January and June, 2023.')\naxes1.set_xlabel('Date')\naxes1.set_ylabel('Quantity (\u039cBBL)')\nplt.xticks(rotation = 90)\nplt.show()\n</pre> fig1 = plt.figure(figsize=(6, 3)) axes1 = fig1.add_axes([0, 0, 1, 1]) axes1.plot(floating_oil_series.Date, floating_oil_series.Quantity)  axes1.set_title('Floating Storage quantity in Red Sea between January and June, 2023.') axes1.set_xlabel('Date') axes1.set_ylabel('Quantity (\u039cBBL)') plt.xticks(rotation = 90) plt.show() <p>For the second plot, we will show the global monthly trend during 2020, the year the global COVID-19 pandemic broke out.</p> In\u00a0[24]: Copied! <pre># min and max dates for consideration\ndate_min = date(2020, 1, 1)\ndate_max = date(2021, 7, 1)\n\ndelta = (date_max - date_min).days\n</pre> # min and max dates for consideration date_min = date(2020, 1, 1) date_max = date(2021, 7, 1)  delta = (date_max - date_min).days In\u00a0[25]: Copied! <pre>floating_oil_daily_data = []\n\nfor iDay in range(delta):\n    curr_date = date_min + relativedelta(days=iDay)\n    events_on_curr_date = floating_storage_events_df[(floating_storage_events_df.FloatingStorageStartDate &lt;= curr_date) &amp;\n                                                   (floating_storage_events_df.FloatingStorageEndDate &gt;= curr_date)\n                                                  ].copy()\n    if events_on_curr_date.empty:\n        quantity_on_water = 0\n    else:\n        quantity_on_water =  events_on_curr_date.apply(lambda r: \n                                    r['Quantity'] * (28 + 131.5) / (141.5 * 0.159) / 1_000_000, axis=1).sum()\n    floating_oil_daily_data.append([curr_date, quantity_on_water])\n</pre> floating_oil_daily_data = []  for iDay in range(delta):     curr_date = date_min + relativedelta(days=iDay)     events_on_curr_date = floating_storage_events_df[(floating_storage_events_df.FloatingStorageStartDate &lt;= curr_date) &amp;                                                    (floating_storage_events_df.FloatingStorageEndDate &gt;= curr_date)                                                   ].copy()     if events_on_curr_date.empty:         quantity_on_water = 0     else:         quantity_on_water =  events_on_curr_date.apply(lambda r:                                      r['Quantity'] * (28 + 131.5) / (141.5 * 0.159) / 1_000_000, axis=1).sum()     floating_oil_daily_data.append([curr_date, quantity_on_water])  In\u00a0[26]: Copied! <pre>floating_oil_series = pd.DataFrame(floating_oil_daily_data, columns=['Date', 'Quantity'])\nfloating_oil_series['Date'] = pd.to_datetime(floating_oil_series['Date'])\n</pre> floating_oil_series = pd.DataFrame(floating_oil_daily_data, columns=['Date', 'Quantity']) floating_oil_series['Date'] = pd.to_datetime(floating_oil_series['Date']) <p>We take the average quantity of each month to be the month quantity</p> In\u00a0[27]: Copied! <pre>floating_oil_monthly_series = floating_oil_series.resample('M', on='Date').mean().reset_index()\nfloating_oil_monthly_series.head(2)\n</pre> floating_oil_monthly_series = floating_oil_series.resample('M', on='Date').mean().reset_index() floating_oil_monthly_series.head(2) Out[27]: Date Quantity 0 2020-01-31 63.642799 1 2020-02-29 62.781919 In\u00a0[28]: Copied! <pre>fig2 = plt.figure(figsize=(7, 3))\naxes2 = fig2.add_axes([0, 0, 1, 1])\naxes2.plot(floating_oil_monthly_series.Date, floating_oil_monthly_series.Quantity)\n\naxes2.set_title('Floating Storage Quantity globally during 2020.')\naxes2.set_xlabel('Date')\naxes2.set_ylabel('Quantity (\u039cBBL)')\nplt.xticks(rotation = 90)\nplt.show()\n</pre> fig2 = plt.figure(figsize=(7, 3)) axes2 = fig2.add_axes([0, 0, 1, 1]) axes2.plot(floating_oil_monthly_series.Date, floating_oil_monthly_series.Quantity)  axes2.set_title('Floating Storage Quantity globally during 2020.') axes2.set_xlabel('Date') axes2.set_ylabel('Quantity (\u039cBBL)') plt.xticks(rotation = 90) plt.show()"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-FloatingStorages/#voyages-api-floating-storages","title":"Voyages API - Floating Storages\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-FloatingStorages/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-FloatingStorages/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-FloatingStorages/#get-voyages","title":"Get voyages\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/","title":"Voyages API Use Cases","text":"In\u00a0[1]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[\u00a0]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nfrom signal_ocean.voyages import Vessel, VesselFilter\nfrom signal_ocean.voyages import VesselType, VesselTypeFilter\nfrom signal_ocean.voyages import VesselClass, VesselClassFilter\nimport pandas as pd\nimport numpy as np\nfrom datetime import date, timedelta\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set_theme()\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI from signal_ocean.voyages import Vessel, VesselFilter from signal_ocean.voyages import VesselType, VesselTypeFilter from signal_ocean.voyages import VesselClass, VesselClassFilter import pandas as pd import numpy as np from datetime import date, timedelta import seaborn as sns import matplotlib.pyplot as plt sns.set_theme() In\u00a0[\u00a0]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) <p>Declare helper functions</p> In\u00a0[3]: Copied! <pre>def get_voyage_load_area(voyage_events):\n    return next((e.area_name_level0 for e in voyage_events or [] if e.purpose=='Load'), None)\n\ndef get_voyage_discharge_country(voyage_events):\n    return next((e.country for e in reversed(voyage_events or []) if e.purpose=='Discharge'), None)\n\ndef get_voyage_load_country(voyage_events):\n    return next((e.country for e in voyage_events or [] if e.purpose=='Load'), None)\n</pre> def get_voyage_load_area(voyage_events):     return next((e.area_name_level0 for e in voyage_events or [] if e.purpose=='Load'), None)  def get_voyage_discharge_country(voyage_events):     return next((e.country for e in reversed(voyage_events or []) if e.purpose=='Discharge'), None)  def get_voyage_load_country(voyage_events):     return next((e.country for e in voyage_events or [] if e.purpose=='Load'), None) In\u00a0[4]: Copied! <pre># get vessel class id for vlcc\nvessel_class = api.get_vessel_classes(VesselClassFilter('vlcc'))\nvlcc_id = vessel_class[0].vessel_class_id\nvlcc_id\n</pre> # get vessel class id for vlcc vessel_class = api.get_vessel_classes(VesselClassFilter('vlcc')) vlcc_id = vessel_class[0].vessel_class_id vlcc_id Out[4]: <pre>84</pre> In\u00a0[5]: Copied! <pre>date_from = date.today() - timedelta(days=180)\n</pre> date_from = date.today() - timedelta(days=180) In\u00a0[6]: Copied! <pre>voyages = api.get_voyages(vessel_class_id=vlcc_id, date_from=date_from)\n</pre> voyages = api.get_voyages(vessel_class_id=vlcc_id, date_from=date_from) In\u00a0[7]: Copied! <pre>voyages = pd.DataFrame(v.__dict__ for v in voyages)\nevents = pd.DataFrame(e.__dict__ for voyage_events in voyages['events'].dropna() for e in voyage_events)\nhistorical_events = events[events['event_horizon']=='Historical']\n</pre> voyages = pd.DataFrame(v.__dict__ for v in voyages) events = pd.DataFrame(e.__dict__ for voyage_events in voyages['events'].dropna() for e in voyage_events) historical_events = events[events['event_horizon']=='Historical'] In\u00a0[8]: Copied! <pre>voyages['load_area'] = voyages['events'].apply(get_voyage_load_area)\nvoyages['discharge_country'] = voyages['events'].apply(get_voyage_discharge_country)\nvoyages['load_country'] = voyages['events'].apply(get_voyage_load_country)\n</pre> voyages['load_area'] = voyages['events'].apply(get_voyage_load_area) voyages['discharge_country'] = voyages['events'].apply(get_voyage_discharge_country) voyages['load_country'] = voyages['events'].apply(get_voyage_load_country) In\u00a0[9]: Copied! <pre>voyages_exports_usg = voyages[(voyages['load_area']=='US Gulf')&amp;(voyages['discharge_country']!='United States')]\n</pre> voyages_exports_usg = voyages[(voyages['load_area']=='US Gulf')&amp;(voyages['discharge_country']!='United States')] In\u00a0[10]: Copied! <pre>voyages_exports_usg.shape[0]\n</pre> voyages_exports_usg.shape[0] Out[10]: <pre>198</pre> In\u00a0[11]: Copied! <pre>voyages_exports_usg['discharge_country'].value_counts()\n</pre> voyages_exports_usg['discharge_country'].value_counts() Out[11]: <pre>Korea, Republic of    46\nChina                 37\nNetherlands           29\nTaiwan                17\nIndia                 16\nGermany               12\nSingapore              9\nFrance                 8\nThailand               7\nUnited Kingdom         6\nMalaysia               4\nJapan                  2\nBahamas                1\nPanama                 1\nSweden                 1\nNorway                 1\nItaly                  1\nName: discharge_country, dtype: int64</pre> In\u00a0[12]: Copied! <pre>discharges_china = historical_events[(historical_events['country']=='China')&amp;(historical_events['purpose']=='Discharge')].copy()\ndischarges_china['duration'] =  discharges_china['sailing_date'] - discharges_china['arrival_date']\n</pre> discharges_china = historical_events[(historical_events['country']=='China')&amp;(historical_events['purpose']=='Discharge')].copy() discharges_china['duration'] =  discharges_china['sailing_date'] - discharges_china['arrival_date'] In\u00a0[13]: Copied! <pre>discharges_china['duration'].describe()\n</pre> discharges_china['duration'].describe() Out[13]: <pre>count                          645\nmean     4 days 17:15:01.378294573\nstd      3 days 19:24:41.541664624\nmin                0 days 23:50:45\n25%                2 days 15:50:59\n50%                3 days 12:00:49\n75%                5 days 11:57:42\nmax               48 days 12:15:40\nName: duration, dtype: object</pre> In\u00a0[14]: Copied! <pre>discharges_china['duration_in_hours'] = discharges_china['duration'] / np.timedelta64(1, 'h')\n</pre> discharges_china['duration_in_hours'] = discharges_china['duration'] / np.timedelta64(1, 'h') In\u00a0[15]: Copied! <pre>common_discharge_ports_china = discharges_china['port_name'].value_counts().head(8)\ncommon_port_discharges_china = discharges_china[discharges_china['port_name'].isin(common_discharge_ports_china.index)]\nsns.catplot(x=\"port_name\", y=\"duration_in_hours\", kind=\"box\", data=common_port_discharges_china, aspect=2);\n</pre> common_discharge_ports_china = discharges_china['port_name'].value_counts().head(8) common_port_discharges_china = discharges_china[discharges_china['port_name'].isin(common_discharge_ports_china.index)] sns.catplot(x=\"port_name\", y=\"duration_in_hours\", kind=\"box\", data=common_port_discharges_china, aspect=2); In\u00a0[16]: Copied! <pre>discharges_china['arrival_month'] = discharges_china['arrival_date'].dt.tz_localize(None).dt.to_period('M').dt.to_timestamp()\nsns.lineplot(data=discharges_china, x='arrival_month', y='duration_in_hours')\nplt.xticks(rotation=90);\n</pre> discharges_china['arrival_month'] = discharges_china['arrival_date'].dt.tz_localize(None).dt.to_period('M').dt.to_timestamp() sns.lineplot(data=discharges_china, x='arrival_month', y='duration_in_hours') plt.xticks(rotation=90); In\u00a0[17]: Copied! <pre>discharge_destinations_brazil = voyages[voyages['load_country']=='Brazil'].dropna(subset=['discharge_country'])\n</pre> discharge_destinations_brazil = voyages[voyages['load_country']=='Brazil'].dropna(subset=['discharge_country']) In\u00a0[18]: Copied! <pre>discharge_destinations_brazil['discharge_country'].value_counts()\n</pre> discharge_destinations_brazil['discharge_country'].value_counts() Out[18]: <pre>China                 70\nKorea, Republic of     6\nUnited States          6\nPortugal               4\nNetherlands            4\nMalaysia               2\nBrazil                 2\nUnited Kingdom         1\nFrance                 1\nGreece                 1\nName: discharge_country, dtype: int64</pre> In\u00a0[19]: Copied! <pre>sns.displot(discharge_destinations_brazil, x=\"start_date\", hue=\"discharge_country\", aspect=2);\n</pre> sns.displot(discharge_destinations_brazil, x=\"start_date\", hue=\"discharge_country\", aspect=2); <p>This use-case demonstrates how to utilise the advanced search endpoint to extract historical voyages by <code>vessel_class_id</code>, <code>first_load_arrival_date</code> and a specific <code>event_purpose</code>. The voyages with the provided purpose can then be merged and filtered with a specific <code>load_area</code> and <code>discharge_country</code> in order to visualize the vessel flows into the specified country.</p> In\u00a0[20]: Copied! <pre># get vessel class id for vlcc\nvessel_class = api.get_vessel_classes(VesselClassFilter('vlcc'))\nvlcc_id = vessel_class[0].vessel_class_id\nvlcc_id\n</pre> # get vessel class id for vlcc vessel_class = api.get_vessel_classes(VesselClassFilter('vlcc')) vlcc_id = vessel_class[0].vessel_class_id vlcc_id Out[20]: <pre>84</pre> In\u00a0[21]: Copied! <pre>date_from = date.today() - timedelta(days=60)\nload_area = 'Arabian Gulf'\ndischarge_country = 'Japan'\n</pre> date_from = date.today() - timedelta(days=60) load_area = 'Arabian Gulf' discharge_country = 'Japan' <p>In the following cell we extract the voyages with an <code>event_purpose=\"Discharge\"</code>, which essentially looks up for all the voyages with at least one discharge event. This implies, due to the nature of the shipping pipeline, that load events are also included in the discharge call and can therefore be omitted.</p> In\u00a0[22]: Copied! <pre>voyages = api.get_voyages_by_advanced_search(vessel_class_id=vlcc_id, first_load_arrival_date_from=date_from,\n                                                              event_horizon='Historical', event_purpose='Discharge')\n\nvoyages = pd.DataFrame(v.__dict__ for v in voyages)\n</pre> voyages = api.get_voyages_by_advanced_search(vessel_class_id=vlcc_id, first_load_arrival_date_from=date_from,                                                               event_horizon='Historical', event_purpose='Discharge')  voyages = pd.DataFrame(v.__dict__ for v in voyages) In\u00a0[23]: Copied! <pre>voyages['load_area'] = voyages['events'].apply(get_voyage_load_area)\nvoyages['load_country'] = voyages['events'].apply(get_voyage_load_country)\nvoyages['discharge_country'] = voyages['events'].apply(get_voyage_discharge_country)\n</pre> voyages['load_area'] = voyages['events'].apply(get_voyage_load_area) voyages['load_country'] = voyages['events'].apply(get_voyage_load_country) voyages['discharge_country'] = voyages['events'].apply(get_voyage_discharge_country) In\u00a0[24]: Copied! <pre>voyages_filtered = voyages.loc[(voyages['load_area'] == load_area) &amp; (voyages['discharge_country'] == discharge_country)].reset_index(drop=True)\n</pre> voyages_filtered = voyages.loc[(voyages['load_area'] == load_area) &amp; (voyages['discharge_country'] == discharge_country)].reset_index(drop=True) In\u00a0[25]: Copied! <pre>fig, _ = plt.subplots(figsize=(12, 5))\nax = sns.countplot(x='load_country', data=voyages_filtered)\n\nax.set_title(f'Vessel Flows ({discharge_country})', fontsize=14)\nax.set_xlabel('Load Countries', fontsize=12)\nax.set_ylabel('Vessel Counts', fontsize=12);\n</pre> fig, _ = plt.subplots(figsize=(12, 5)) ax = sns.countplot(x='load_country', data=voyages_filtered)  ax.set_title(f'Vessel Flows ({discharge_country})', fontsize=14) ax.set_xlabel('Load Countries', fontsize=12) ax.set_ylabel('Vessel Counts', fontsize=12);"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#voyages-api-use-cases","title":"Voyages API Use Cases\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#voyages-api-use-cases","title":"Voyages API Use Cases\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#get-voyages","title":"Get voyages\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#number-of-exporting-voyages","title":"Number of exporting voyages\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#port-delays","title":"Port Delays\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#discharge-destinations","title":"Discharge destinations\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-UseCases/#advanced-voyage-search-discharge-origins","title":"Advanced Voyage Search: Discharge origins\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-VoyagesDataLike/","title":"Voyages API Voyages Data Like Use Case","text":"<p>A Voyage is defined as a sequence of Load operations followed by a sequence of Discharges. Users of Signal Ocean Platform interface with the concept of a voyage in different levels of detail. For example in the Voyages tab of Vessels Data (https://app.signalocean.com/vessels) users can see  all the operations of a voyage even at jetty level. However very often arises the need of conducting an analysis of the voyages for a specific vessel class for a specific time window. This need is accommodated by the  Voyages Data Dashboard (https://app.signalocean.com/reportsindex/voyagesdatalive).</p> <p>The level of detail provided by the Voyages Data Dashboard has been tailored, having in mind the neccessary information needed to carry out such an analysis without being overwhelmed by the full data provided by Signal Ocean Platform regarding the voyages of the vessels.</p> <p>While both <code>get_voyages</code> and <code>get_voyages_flat</code> functions of the Signal SDK return the full low level data available, in this example we are going to construct a dataframe that resembles the form of Voyages Data Dashboard</p> In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[\u00a0]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[\u00a0]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nfrom signal_ocean.voyages import VesselClass, VesselClassFilter\nimport pandas as pd\nimport numpy as np\nfrom datetime import date, timedelta, datetime, timezone\nfrom dateutil.relativedelta import relativedelta\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI from signal_ocean.voyages import VesselClass, VesselClassFilter import pandas as pd import numpy as np from datetime import date, timedelta, datetime, timezone from dateutil.relativedelta import relativedelta In\u00a0[\u00a0]: Copied! <pre>pd.set_option('display.max_columns', None)\n</pre> pd.set_option('display.max_columns', None) In\u00a0[\u00a0]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) <p>For this tutorial we will retrieve the voyages of VLCC vessels that have started during the last semester of 2021.</p> In\u00a0[6]: Copied! <pre>#get vessel class id for vlcc\nvc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0]\nvlcc_id = vc.vessel_class_id\nvlcc_id\n</pre> #get vessel class id for vlcc vc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0] vlcc_id = vc.vessel_class_id vlcc_id Out[6]: <pre>84</pre> In\u00a0[7]: Copied! <pre>start_date_to = date(2021,12,31)\nstart_date_from = start_date_to - relativedelta(months=6)\n</pre> start_date_to = date(2021,12,31) start_date_from = start_date_to - relativedelta(months=6) In\u00a0[8]: Copied! <pre>voyages = api.get_voyages_by_advanced_search(\n    vessel_class_id=vlcc_id, \n    start_date_from=start_date_from,\n    start_date_to = start_date_to\n)\n</pre> voyages = api.get_voyages_by_advanced_search(     vessel_class_id=vlcc_id,      start_date_from=start_date_from,     start_date_to = start_date_to ) In\u00a0[9]: Copied! <pre>voyages = pd.DataFrame(v.__dict__ for v in voyages)\nevents = pd.DataFrame(e.__dict__ for voyage_events in voyages['events'].dropna() for e in voyage_events)\n</pre> voyages = pd.DataFrame(v.__dict__ for v in voyages) events = pd.DataFrame(e.__dict__ for voyage_events in voyages['events'].dropna() for e in voyage_events) In\u00a0[10]: Copied! <pre># we filter out voyages that have no actual load and discharge port calls\n# (current voyages for ballast unfixed vessels)\nvoyages.end_date = pd.to_datetime(voyages.end_date, errors = 'coerce', utc = True)\nvoyages.dropna(subset = ['end_date'], inplace = True)\n</pre> # we filter out voyages that have no actual load and discharge port calls # (current voyages for ballast unfixed vessels) voyages.end_date = pd.to_datetime(voyages.end_date, errors = 'coerce', utc = True) voyages.dropna(subset = ['end_date'], inplace = True) In\u00a0[11]: Copied! <pre>def get_open_load_discharge_events(voyage_events):\n    open_event = next((e.__dict__ for e in voyage_events or [] if e.purpose=='Start'), None)\n    load_event = next((e.__dict__ for e in voyage_events or [] if e.purpose=='Load'), None)\n    discharge_event = next((e.__dict__ for e in reversed(voyage_events) or [] if e.purpose=='Discharge'), None)\n    return pd.Series((open_event,load_event, discharge_event))\n    \nvoyages[['open_event','load_event','discharge_event']] = voyages['events'].apply(get_open_load_discharge_events)\n</pre> def get_open_load_discharge_events(voyage_events):     open_event = next((e.__dict__ for e in voyage_events or [] if e.purpose=='Start'), None)     load_event = next((e.__dict__ for e in voyage_events or [] if e.purpose=='Load'), None)     discharge_event = next((e.__dict__ for e in reversed(voyage_events) or [] if e.purpose=='Discharge'), None)     return pd.Series((open_event,load_event, discharge_event))      voyages[['open_event','load_event','discharge_event']] = voyages['events'].apply(get_open_load_discharge_events) In\u00a0[12]: Copied! <pre>mapping_dict = {'port_name':['starting_port','first_load_port','last_discharge_port'],\n                'area_name_level0':['starting_area','first_load_area','last_discharge_area'], \n                'country':['starting_country','first_load_country','last_discharge_country'],\n                'arrival_date':['open_port_arrival_date','first_load_port_arrival_date','last_discharge_port_arrival_date'],\n                'sailing_date':['open_port_sailing_date','first_load_port_sailing_date','last_discharge_port_sailing_date'], \n                }\n\nevents = {0:'open_event',1:'load_event',2:'discharge_event'}\n</pre> mapping_dict = {'port_name':['starting_port','first_load_port','last_discharge_port'],                 'area_name_level0':['starting_area','first_load_area','last_discharge_area'],                  'country':['starting_country','first_load_country','last_discharge_country'],                 'arrival_date':['open_port_arrival_date','first_load_port_arrival_date','last_discharge_port_arrival_date'],                 'sailing_date':['open_port_sailing_date','first_load_port_sailing_date','last_discharge_port_sailing_date'],                  }  events = {0:'open_event',1:'load_event',2:'discharge_event'} In\u00a0[13]: Copied! <pre>for feature,targets in mapping_dict.items():\n    for num,target in enumerate(targets):\n        voyages[target] = voyages[events[num]].apply(lambda e: e[feature] if isinstance(e,dict) else None)\n</pre> for feature,targets in mapping_dict.items():     for num,target in enumerate(targets):         voyages[target] = voyages[events[num]].apply(lambda e: e[feature] if isinstance(e,dict) else None) In\u00a0[14]: Copied! <pre>def get_start_time_of_operation(event):\n    if (event['event_type'] == 'PortCall') and (event['event_horizon'] != 'Future'):\n        next_event_detail = next((ed.__dict__ for ed in event['event_details'] or []), None)\n        return next_event_detail['start_time_of_operation']\n</pre> def get_start_time_of_operation(event):     if (event['event_type'] == 'PortCall') and (event['event_horizon'] != 'Future'):         next_event_detail = next((ed.__dict__ for ed in event['event_details'] or []), None)         return next_event_detail['start_time_of_operation'] In\u00a0[15]: Copied! <pre>voyages.loc[voyages.load_event.notna(),'first_load_port_start_time_of_operation'] = (\n   voyages.loc[voyages.load_event.notna()].load_event.apply(get_start_time_of_operation)\n)\nvoyages.loc[voyages.load_event.notna(),'last_discharge_port_start_time_of_operation'] = (\n   voyages.loc[voyages.discharge_event.notna()].discharge_event.apply(get_start_time_of_operation)\n)\n\nvoyages.first_load_port_start_time_of_operation = pd.to_datetime(voyages.first_load_port_start_time_of_operation)\nvoyages.last_discharge_port_start_time_of_operation = pd.to_datetime(voyages.last_discharge_port_start_time_of_operation)\n</pre> voyages.loc[voyages.load_event.notna(),'first_load_port_start_time_of_operation'] = (    voyages.loc[voyages.load_event.notna()].load_event.apply(get_start_time_of_operation) ) voyages.loc[voyages.load_event.notna(),'last_discharge_port_start_time_of_operation'] = (    voyages.loc[voyages.discharge_event.notna()].discharge_event.apply(get_start_time_of_operation) )  voyages.first_load_port_start_time_of_operation = pd.to_datetime(voyages.first_load_port_start_time_of_operation) voyages.last_discharge_port_start_time_of_operation = pd.to_datetime(voyages.last_discharge_port_start_time_of_operation) In\u00a0[16]: Copied! <pre>def get_sts_load_ind(load_event):\n    return next((True for d in load_event[\"event_details\"] or [] if d.event_detail_type =='StS'), False)\n\ndef get_sts_discharge_ind(discharge_event):\n    return next((True for d in discharge_event[\"event_details\"] or [] if d.event_detail_type =='StS'), False)\n\n\nvoyages.loc[voyages.discharge_event.notna(),'sts_discharge_ind'] = \\\nvoyages.loc[voyages.discharge_event.notna(),'discharge_event'].apply(get_sts_discharge_ind)\nvoyages.loc[voyages.load_event.notna(),'sts_load_ind'] = \\\nvoyages.loc[voyages.load_event.notna(),'load_event'].apply(get_sts_load_ind)\n</pre> def get_sts_load_ind(load_event):     return next((True for d in load_event[\"event_details\"] or [] if d.event_detail_type =='StS'), False)  def get_sts_discharge_ind(discharge_event):     return next((True for d in discharge_event[\"event_details\"] or [] if d.event_detail_type =='StS'), False)   voyages.loc[voyages.discharge_event.notna(),'sts_discharge_ind'] = \\ voyages.loc[voyages.discharge_event.notna(),'discharge_event'].apply(get_sts_discharge_ind) voyages.loc[voyages.load_event.notna(),'sts_load_ind'] = \\ voyages.loc[voyages.load_event.notna(),'load_event'].apply(get_sts_load_ind) In\u00a0[17]: Copied! <pre>def get_repairs_ind(events):\n    for ev in events:\n        if ev.purpose == 'Dry dock':\n            return True\n    return False\n</pre> def get_repairs_ind(events):     for ev in events:         if ev.purpose == 'Dry dock':             return True     return False In\u00a0[18]: Copied! <pre>voyages['repairs_ind'] = voyages.events.apply(get_repairs_ind)\n</pre> voyages['repairs_ind'] = voyages.events.apply(get_repairs_ind) In\u00a0[19]: Copied! <pre>def get_storage_ind(events):\n    for ev in events:\n        if ev.purpose == 'StorageVessel':\n            return True\n    return False\n</pre> def get_storage_ind(events):     for ev in events:         if ev.purpose == 'StorageVessel':             return True     return False In\u00a0[20]: Copied! <pre>voyages['storage_ind'] = voyages.events.apply(get_storage_ind)\n</pre> voyages['storage_ind'] = voyages.events.apply(get_storage_ind) In\u00a0[21]: Copied! <pre>voyages['local_trade_ind'] = voyages.apply(\n    lambda row: row['first_load_country'] == row['last_discharge_country'],\n    axis = 1\n)\n</pre> voyages['local_trade_ind'] = voyages.apply(     lambda row: row['first_load_country'] == row['last_discharge_country'],     axis = 1 ) In\u00a0[22]: Copied! <pre>vessel_status_dict = {\n    1:\"Voyage\", 2:\"Breaking\", 3:\"Domestic Trade\", 4:\"FPSO\", 5:\"FPSO Conversion\", \n    6:\"Inactive\", 7:\"Storage Vessel\", 9:\"Conversion\"\n}\nvoyages['vessel_status'] = voyages.vessel_status_id.replace(vessel_status_dict)\n</pre> vessel_status_dict = {     1:\"Voyage\", 2:\"Breaking\", 3:\"Domestic Trade\", 4:\"FPSO\", 5:\"FPSO Conversion\",      6:\"Inactive\", 7:\"Storage Vessel\", 9:\"Conversion\" } voyages['vessel_status'] = voyages.vessel_status_id.replace(vessel_status_dict) In\u00a0[23]: Copied! <pre>commercial_status_dict = {\n    0:\"OnSubs\", 1:\"FullyFixed\", 2:\"Failed\", 3:\"Cancelled\", 4:\"Available\", \n    -1:\"Unknown\", -2:\"NotSet\"\n}\nvoyages['commercial_status'] = voyages.fixture_status_id.replace(commercial_status_dict)\n</pre> commercial_status_dict = {     0:\"OnSubs\", 1:\"FullyFixed\", 2:\"Failed\", 3:\"Cancelled\", 4:\"Available\",      -1:\"Unknown\", -2:\"NotSet\" } voyages['commercial_status'] = voyages.fixture_status_id.replace(commercial_status_dict) In\u00a0[24]: Copied! <pre>wanted_columns = ['vessel_name',\n                  'imo',\n                  'vessel_class',\n                  'commercial_operator',\n                  'voyage_number',\n                  'start_date',\n                  'end_date',\n                  'starting_port',\n                  'first_load_port',\n                  'last_discharge_port',\n                  'first_load_port_arrival_date',\n                  'first_load_port_start_time_of_operation',\n                  'first_load_port_sailing_date',\n                  'last_discharge_port_arrival_date',\n                  'last_discharge_port_start_time_of_operation',\n                  'last_discharge_port_sailing_date',\n                  'charterer',\n                  'rate',\n                  'rate_type',\n                  'laycan_from',\n                  'laycan_to',\n                  'quantity',\n                  'cargo_group',\n                  'cargo_type',\n                  'cargo_type_source',\n                  'fixture_is_coa',\n                  'fixture_is_hold',\n                  'fixture_date',\n                  'trade',\n                  'vessel_status',\n                  'commercial_status',\n                  'starting_country',\n                  'starting_area',\n                  'first_load_country',\n                  'first_load_area',\n                  'last_discharge_country',\n                  'last_discharge_area',\n                  'sts_load_ind',\n                  'sts_discharge_ind',\n                  'storage_ind',\n                  'repairs_ind',\n                  'is_implied_by_ais',\n                  'local_trade_ind',\n                  'has_manual_entries',\n                  'ballast_distance',\n                  'laden_distance'\n                 ]\n\nvoyages = voyages[wanted_columns]\n</pre> wanted_columns = ['vessel_name',                   'imo',                   'vessel_class',                   'commercial_operator',                   'voyage_number',                   'start_date',                   'end_date',                   'starting_port',                   'first_load_port',                   'last_discharge_port',                   'first_load_port_arrival_date',                   'first_load_port_start_time_of_operation',                   'first_load_port_sailing_date',                   'last_discharge_port_arrival_date',                   'last_discharge_port_start_time_of_operation',                   'last_discharge_port_sailing_date',                   'charterer',                   'rate',                   'rate_type',                   'laycan_from',                   'laycan_to',                   'quantity',                   'cargo_group',                   'cargo_type',                   'cargo_type_source',                   'fixture_is_coa',                   'fixture_is_hold',                   'fixture_date',                   'trade',                   'vessel_status',                   'commercial_status',                   'starting_country',                   'starting_area',                   'first_load_country',                   'first_load_area',                   'last_discharge_country',                   'last_discharge_area',                   'sts_load_ind',                   'sts_discharge_ind',                   'storage_ind',                   'repairs_ind',                   'is_implied_by_ais',                   'local_trade_ind',                   'has_manual_entries',                   'ballast_distance',                   'laden_distance'                  ]  voyages = voyages[wanted_columns] In\u00a0[25]: Copied! <pre>import re\n\ndef snake_to_camel(word):\n    return ''.join(x.capitalize() or '_' for x in word.split('_'))\n</pre> import re  def snake_to_camel(word):     return ''.join(x.capitalize() or '_' for x in word.split('_')) In\u00a0[26]: Copied! <pre>voyages.columns = [*map(snake_to_camel, voyages.columns)]\nvoyages\n</pre> voyages.columns = [*map(snake_to_camel, voyages.columns)] voyages Out[26]: VesselName Imo VesselClass CommercialOperator VoyageNumber StartDate EndDate StartingPort FirstLoadPort LastDischargePort ... LastDischargeArea StsLoadInd StsDischargeInd StorageInd RepairsInd IsImpliedByAis LocalTradeInd HasManualEntries BallastDistance LadenDistance 0 Artemis III 9102241 VLCC Bahri 132 2021-09-27 13:22:23.500000+00:00 2023-04-20 19:56:09+00:00 Dongjiangkou Singapore Singapore ... Singapore / Malaysia False False False False None True None 1650.51 14979.22 1 FT Island 9166675 VLCC None 43 2021-08-25 01:41:55+00:00 2023-04-18 15:58:33+00:00 Huangpu Singapore Tanjung Pelepas ... Singapore / Malaysia False True False True None False None 9911.22 920.89 2 Lisa 9174397 VLCC None 47 2021-12-20 20:04:34+00:00 2022-12-14 03:56:21+00:00 Qingdao Malongo Tianjin ... North China False False False False None False None 18788.49 10730.73 3 Destiny 9177155 VLCC NITC 26 2021-11-19 15:55:24+00:00 2023-05-04 13:45:06+00:00 Tranmere Pazflor Oil Field Cotonou ... Africa Atlantic Coast False False False False None False None 4502.32 1068.07 4 Roma 9182291 VLCC New Shipping 67 2021-07-28 15:59:44+00:00 2021-09-25 01:50:26+00:00 Tanjung Pelepas Fujairah Tanjung Pelepas ... Singapore / Malaysia False True False False None False None 3322.17 3204.19 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 1881 Tateshina 9910117 VLCC None 1 2021-10-27 01:04:54+00:00 2022-01-09 07:55:52+00:00 Qushan Island Ruwais Rotterdam ... Continent False False False True None False None 6216.48 6651.49 1882 Towa Maru 9910181 VLCC None 1 2021-11-14 23:57:53+00:00 2022-03-15 19:57:27+00:00 Kure, Hiroshima Fujairah Yokkaichi ... Japan Island False False False True None False None 7393.28 7276.41 1883 Julius Caesar 9912244 VLCC None 1 2021-12-17 06:20:23+00:00 2022-03-16 15:58:35+00:00 Ulsan Vizhinjam Lome ... Africa Atlantic Coast True True False True None False None 5536.30 7239.92 1884 Grand Bonanza 9915569 VLCC Koch 1 2021-10-20 05:16:43+00:00 2022-02-24 05:29:45+00:00 Okpo/Geoje Ruwais Lome ... Africa Atlantic Coast False True False True None False None 7651.64 7965.27 1885 Mpf3 9919436 VLCC None 1 2021-12-12 12:46:01+00:00 2023-08-06 16:18:08+00:00 Shanghai Galang Island Oil Field Rotterdam ... Continent False False False True None False None 2270.15 6359.17 <p>1881 rows \u00d7 46 columns</p> In\u00a0[27]: Copied! <pre>datetime_columns = voyages.select_dtypes(include=['datetime64[ns, UTC]']).columns\n\nvoyages.loc[:,datetime_columns] = (\n    voyages\n    .select_dtypes(\n        include=['datetime64[ns, UTC]']\n    ).apply(lambda column: column.dt.tz_localize(None),\n        axis = 0\n    )\n)\n</pre> datetime_columns = voyages.select_dtypes(include=['datetime64[ns, UTC]']).columns  voyages.loc[:,datetime_columns] = (     voyages     .select_dtypes(         include=['datetime64[ns, UTC]']     ).apply(lambda column: column.dt.tz_localize(None),         axis = 0     ) ) In\u00a0[28]: Copied! <pre>voyages.to_excel('voyages_data.xlsx', index = False)\n</pre> voyages.to_excel('voyages_data.xlsx', index = False)"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-VoyagesDataLike/#voyages-api-voyages-data-like-use-case","title":"Voyages API Voyages Data Like Use Case\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-VoyagesDataLike/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-VoyagesDataLike/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI-VoyagesDataLike/#get-voyages","title":"Get voyages\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/","title":"Voyages API Example","text":"In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean In\u00a0[1]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nfrom signal_ocean.voyages import Vessel, VesselFilter\nfrom signal_ocean.voyages import VesselType, VesselTypeFilter\nfrom signal_ocean.voyages import VesselClass, VesselClassFilter\nimport pandas as pd\nfrom datetime import date, timedelta\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI from signal_ocean.voyages import Vessel, VesselFilter from signal_ocean.voyages import VesselType, VesselTypeFilter from signal_ocean.voyages import VesselClass, VesselClassFilter import pandas as pd from datetime import date, timedelta In\u00a0[3]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) In\u00a0[4]: Copied! <pre># get the imo by using the vessel name\nvessel = api.get_imos(VesselFilter('Blint'))[0]\nvessel\n</pre> # get the imo by using the vessel name vessel = api.get_imos(VesselFilter('Blint'))[0] vessel Out[4]: <pre>Vessel(imo=9293002, vessel_name='Blint')</pre> In\u00a0[5]: Copied! <pre>vessel_voyages = api.get_voyages(imo=9293002)\n</pre> vessel_voyages = api.get_voyages(imo=9293002) In\u00a0[6]: Copied! <pre>vessel_voyages_df = pd.DataFrame([v.__dict__ for v in vessel_voyages])\nvessel_voyages_df.tail(5)\n</pre> vessel_voyages_df = pd.DataFrame([v.__dict__ for v in vessel_voyages]) vessel_voyages_df.tail(5) Out[6]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... predicted_ballast_distance laden_distance predicted_laden_distance suez_crossing panama_crossing canakkale_crossing bosporus_crossing torres_strait_crossing magellan_strait_crossing great_belt_crossing 125 9293002 126 1 86 1 1597.0 False (VoyageEvent(id='I8DCCCASEDE4C9900', voyage_id... I8DCCCAVEDE4C9900 1 ... None 7915.09 NaN BallastHistorical, LadenHistorical None None None None None LadenHistorical 126 9293002 127 1 86 1 1597.0 False (VoyageEvent(id='I8DCCCASEDE9BB300', voyage_id... I8DCCCAVEDE9BB300 1 ... None 7956.52 NaN BallastHistorical, LadenHistorical None None None None None LadenHistorical 127 9293002 128 1 86 1 1597.0 False (VoyageEvent(id='I8DCCCASEDF125A00', voyage_id... I8DCCCAVEDF125A00 1 ... None 7961.28 NaN BallastHistorical, LadenHistorical None None None None None LadenHistorical 128 9293002 129 1 86 1 NaN False (VoyageEvent(id='I8DCCCASEDF617400', voyage_id... I8DCCCAVEDF617400 1 ... None 5931.72 NaN BallastHistorical, LadenHistorical None None None None None LadenHistorical 129 9293002 130 1 86 1 NaN False (VoyageEvent(id='I8DCCCASEDFD81B00', voyage_id... I8DCCCAVEDFD81B00 2 ... None 63.37 726.43 None None None None None None None <p>5 rows \u00d7 75 columns</p> In\u00a0[7]: Copied! <pre>vessel_events_df = pd.DataFrame(e.__dict__ for voyage_events in vessel_voyages_df['events'] for e in voyage_events)\nvessel_events_df.tail(5)\n</pre> vessel_events_df = pd.DataFrame(e.__dict__ for voyage_events in vessel_voyages_df['events'] for e in voyage_events) vessel_events_df.tail(5) Out[7]: id voyage_id event_type_id event_type event_horizon_id event_horizon purpose event_date arrival_date sailing_date ... area_idlevel2 area_name_level2 area_idlevel3 area_name_level3 low_ais_density quantity quantity_unit_id quantity_unit quantity_in_barrels event_details 724 I8DCCCATEDFDC0F80 None 0 Stop 0 Historical Stop NaT 2025-06-12 19:59:10+00:00 2025-06-21 19:59:47+00:00 ... 103 Red Sea 84 East None NaN NaN None NaN (VoyageEventDetail(id='I8DCCCALEDFDC0F80', eve... 725 I8DCCCATEDFE54A00 None 1 PortCall 0 Historical Discharge NaT 2025-06-24 03:59:17+00:00 2025-06-24 06:55:48+00:00 ... 103 Red Sea 84 East None 102000.0 1.0 MetricTonnes 723115.0 (VoyageEventDetail(id='I8DCCCALEDFE54A00', eve... 726 I8DCCCASEDFD81B00 None 2 VoyageStart 0 Historical Start 2025-06-24 06:55:48+00:00 NaT NaT ... 103 Red Sea 84 East None NaN NaN None NaN None 727 I8DCCCATEDFF27900 None 1 PortCall 1 Current Load NaT 2025-07-02 03:52:30+00:00 2025-07-11 17:02:33.745000+00:00 ... 25023 India / Pakistan 84 East None 100000.0 1.0 MetricTonnes 724493.0 (VoyageEventDetail(id='I8DCCCALEDFF27900', eve... 728 I8DCCCATEDFFFA800 None 1 PortCall 2 Future Discharge NaT 2025-07-14 06:09:17.754000+00:00 2025-07-16 21:40:59.243000+00:00 ... 25023 India / Pakistan 84 East True 100000.0 1.0 MetricTonnes 724493.0 None <p>5 rows \u00d7 33 columns</p> In\u00a0[8]: Copied! <pre>vessel_event_details_df = pd.DataFrame(e.__dict__ for event_details in vessel_events_df['event_details'] for e in event_details or [])\nvessel_event_details_df.tail(5)\n</pre> vessel_event_details_df = pd.DataFrame(e.__dict__ for event_details in vessel_events_df['event_details'] for e in event_details or []) vessel_event_details_df.tail(5) Out[8]: id event_id event_detail_type arrival_date sailing_date start_time_of_operation end_time_of_operation sts_id geo_asset_id geo_asset_name latitude longitude other_vessel_imo other_vessel_name floating_storage_start_date floating_storage_duration 622 I8DCCCALEDFBDBD00 None Stop 2025-05-26 11:45:23+00:00 2025-05-26 15:59:20+00:00 NaT NaT None 4116 Paldiski Anchorage 59.1670 21.4375 NaN None NaT NaN 623 I8DCCCALEDFD81B00 None Stop 2025-06-11 11:55:25+00:00 2025-06-12 03:59:00+00:00 NaT NaT None 14573 Port Said Anchorage 31.4698 32.3213 NaN None NaT NaN 624 I8DCCCALEDFDC0F80 None Stop 2025-06-12 19:59:10+00:00 2025-06-21 19:59:47+00:00 NaT NaT None 14489 Suez Anchorage 29.7230 32.6030 NaN None 2025-06-12 19:59:10+00:00 9.0 625 I8DCCCALEDFE54A00 None StS 2025-06-24 03:59:17+00:00 2025-06-24 06:55:48+00:00 2025-06-24 03:59:17+00:00 2025-06-24 06:55:48+00:00 8CFD778DCCCA8DDB2D37D821880 4160 Marsa Barshayer Anchorage 19.3839 38.4933 9239927.0 Daffodil NaT NaN 626 I8DCCCALEDFF27900 None Stop 2025-07-02 03:52:30+00:00 2025-07-09 09:41:36+00:00 NaT NaT None 5113 Jamnagar Refinery (Reliance) 22.6507 69.9005 NaN None NaT NaN In\u00a0[9]: Copied! <pre>#get vessel class id for vlcc\nvc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0]\nvlcc_id = vc.vessel_class_id\nvlcc_id\n</pre> #get vessel class id for vlcc vc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0] vlcc_id = vc.vessel_class_id vlcc_id Out[9]: <pre>84</pre> In\u00a0[10]: Copied! <pre>date_from = date.today() - timedelta(days=30)\nrecent_vlcc_voyages = api.get_voyages(vessel_class_id=vlcc_id, date_from=date_from)\n</pre> date_from = date.today() - timedelta(days=30) recent_vlcc_voyages = api.get_voyages(vessel_class_id=vlcc_id, date_from=date_from) In\u00a0[11]: Copied! <pre>recent_vlcc_voyages = pd.DataFrame([v.__dict__ for v in recent_vlcc_voyages])\nrecent_vlcc_voyages.tail(5)\n</pre> recent_vlcc_voyages = pd.DataFrame([v.__dict__ for v in recent_vlcc_voyages]) recent_vlcc_voyages.tail(5) Out[11]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id ... predicted_ballast_distance laden_distance predicted_laden_distance suez_crossing panama_crossing canakkale_crossing bosporus_crossing torres_strait_crossing magellan_strait_crossing great_belt_crossing 395 9933652 15 1 84 1 558.0 False (VoyageEvent(id='I97935454SEDFD81B00', voyage_... I97935454VEDFD81B00 2 ... 2267.48 NaN 9624.93 None None None None None None None 396 9937799 7 1 84 1 1031.0 False (VoyageEvent(id='I97A38754SEDFD81B00', voyage_... I97A38754VEDFD81B00 2 ... NaN NaN NaN None None None None None BallastHistorical None 397 9941673 15 1 84 1 2236.0 False (VoyageEvent(id='I97B2A954SEDFD81B00', voyage_... I97B2A954VEDFD81B00 2 ... NaN 8.8 6475.67 None None None None None None None 398 9988695 1 1 84 1 NaN False (VoyageEvent(id='I986A5754SEDFD81B00', voyage_... I986A5754VEDFD81B00 2 ... NaN NaN NaN None None None None None None None 399 1037048 1 1 84 1 435.0 False (VoyageEvent(id='IFD2F854SEDFD81B00', voyage_i... IFD2F854VEDFD81B00 2 ... 45.68 NaN NaN None None None None None None None <p>5 rows \u00d7 75 columns</p> In\u00a0[12]: Copied! <pre># get the imo by using the vessel name\nvessel = api.get_imos(VesselFilter('Sea'))[0]\nvessel\n</pre> # get the imo by using the vessel name vessel = api.get_imos(VesselFilter('Sea'))[0] vessel Out[12]: <pre>Vessel(imo=1013494, vessel_name='Sea Energy')</pre> In\u00a0[13]: Copied! <pre>vessel_voyages_flat = api.get_voyages_flat(imo=vessel.imo)\n</pre> vessel_voyages_flat = api.get_voyages_flat(imo=vessel.imo) In\u00a0[14]: Copied! <pre>vessel_voyages_df = pd.DataFrame(v.__dict__ for v in vessel_voyages_flat.voyages)\nvessel_voyages_df.tail(5)\n</pre> vessel_voyages_df = pd.DataFrame(v.__dict__ for v in vessel_voyages_flat.voyages) vessel_voyages_df.tail(5) Out[14]: In\u00a0[15]: Copied! <pre>vessel_events_df = pd.DataFrame(v.__dict__ for v in vessel_voyages_flat.events)\nvessel_events_df.tail(5)\n</pre> vessel_events_df = pd.DataFrame(v.__dict__ for v in vessel_voyages_flat.events) vessel_events_df.tail(5) Out[15]: In\u00a0[16]: Copied! <pre>vessel_event_details_df = pd.DataFrame(v.__dict__ for v in vessel_voyages_flat.event_details)\nvessel_event_details_df.tail(5)\n</pre> vessel_event_details_df = pd.DataFrame(v.__dict__ for v in vessel_voyages_flat.event_details) vessel_event_details_df.tail(5) Out[16]: In\u00a0[17]: Copied! <pre>vessel_voyages_geos_df = pd.DataFrame(v.__dict__ for v in vessel_voyages_flat.geos)\nvessel_voyages_geos_df.tail(5)\n</pre> vessel_voyages_geos_df = pd.DataFrame(v.__dict__ for v in vessel_voyages_flat.geos) vessel_voyages_geos_df.tail(5) Out[17]: In\u00a0[18]: Copied! <pre>#get vessel class id for vlcc\nvc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0]\nvlcc_id = vc.vessel_class_id\n\ndate_from = date.today() - timedelta(days=30)\nrecent_vlcc_voyages_flat = api.get_voyages_flat(vessel_class_id=vlcc_id, date_from=date_from)\n</pre> #get vessel class id for vlcc vc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0] vlcc_id = vc.vessel_class_id  date_from = date.today() - timedelta(days=30) recent_vlcc_voyages_flat = api.get_voyages_flat(vessel_class_id=vlcc_id, date_from=date_from) In\u00a0[19]: Copied! <pre>print('Voyages:', len(recent_vlcc_voyages_flat.voyages))\nprint('Events:', len(recent_vlcc_voyages_flat.events))\nprint('EventDetails:', len(recent_vlcc_voyages_flat.event_details))\nprint('Geos:', len(recent_vlcc_voyages_flat.geos))\n</pre> print('Voyages:', len(recent_vlcc_voyages_flat.voyages)) print('Events:', len(recent_vlcc_voyages_flat.events)) print('EventDetails:', len(recent_vlcc_voyages_flat.event_details)) print('Geos:', len(recent_vlcc_voyages_flat.geos)) <pre>Voyages: 400\nEvents: 1357\nEventDetails: 483\nGeos: 288\n</pre> <p>Initial requests retrieves voyages mathcing the query criteria and a query token that can be used in the subsequent request.</p> In\u00a0[20]: Copied! <pre># get the imo by using the vessel name\nvessel = api.get_imos(VesselFilter('XIN YONG YANG'))[0]\nvessel\n</pre> # get the imo by using the vessel name vessel = api.get_imos(VesselFilter('XIN YONG YANG'))[0] vessel Out[20]: <pre>Vessel(imo=9416642, vessel_name='Xin Yong Yang')</pre> In\u00a0[21]: Copied! <pre>vessel_voyages, next_request_token = api.get_incremental_voyages(imo=vessel.imo)\nlen(vessel_voyages)\n</pre> vessel_voyages, next_request_token = api.get_incremental_voyages(imo=vessel.imo) len(vessel_voyages) Out[21]: <pre>92</pre> <p>Provided the token retrieved for the previous request, the subsequent request retrieves only voyages that have been updated since the previous request.</p> In\u00a0[22]: Copied! <pre>incremental_voyages, next_request_token = api.get_incremental_voyages(imo=9416642, incremental_token=next_request_token)\nlen(incremental_voyages)\n</pre> incremental_voyages, next_request_token = api.get_incremental_voyages(imo=9416642, incremental_token=next_request_token) len(incremental_voyages) Out[22]: <pre>0</pre> <p>The retrieved information is used to replace any modify voyages from the dataset. Note that returned voyages marked as deleted are only used to filter out voyages.</p> In\u00a0[23]: Copied! <pre>updated_voyage_ids = set(v.id for v in incremental_voyages)\nvessel_voyages = [v for v in vessel_voyages if v.id not in updated_voyage_ids]\nnew_vessel_voyages = [v for v in incremental_voyages if not v.deleted]\nvessel_voyages = sorted(vessel_voyages + new_vessel_voyages, key= lambda v: v.voyage_number)\nlen(vessel_voyages)\n</pre> updated_voyage_ids = set(v.id for v in incremental_voyages) vessel_voyages = [v for v in vessel_voyages if v.id not in updated_voyage_ids] new_vessel_voyages = [v for v in incremental_voyages if not v.deleted] vessel_voyages = sorted(vessel_voyages + new_vessel_voyages, key= lambda v: v.voyage_number) len(vessel_voyages) Out[23]: <pre>92</pre> <p>Voyages for vessel class are retieved and updated in the same way incrementally.</p> In\u00a0[24]: Copied! <pre>#get vessel class id for vlcc\nvc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0]\nvessel_class_id = vc.vessel_class_id\nvessel_class_id\n</pre> #get vessel class id for vlcc vc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0] vessel_class_id = vc.vessel_class_id vessel_class_id Out[24]: <pre>84</pre> In\u00a0[25]: Copied! <pre>date_from = date.today() - timedelta(days=30)\n</pre> date_from = date.today() - timedelta(days=30) In\u00a0[26]: Copied! <pre>voyages, next_request_token = api.get_incremental_voyages(vessel_class_id=vessel_class_id, date_from=date_from)\nlen(voyages)\n</pre> voyages, next_request_token = api.get_incremental_voyages(vessel_class_id=vessel_class_id, date_from=date_from) len(voyages) Out[26]: <pre>400</pre> In\u00a0[27]: Copied! <pre>incremental_voyages, next_request_token = api.get_incremental_voyages(vessel_class_id=vessel_class_id, date_from=date_from, incremental_token=next_request_token)\nlen(incremental_voyages)\n</pre> incremental_voyages, next_request_token = api.get_incremental_voyages(vessel_class_id=vessel_class_id, date_from=date_from, incremental_token=next_request_token) len(incremental_voyages) Out[27]: <pre>0</pre> In\u00a0[28]: Copied! <pre>updated_voyage_ids = set(v.id for v in incremental_voyages)\nvoyages = [v for v in voyages if v.id not in updated_voyage_ids and not v.deleted]\nnew_voyages = [v for v in incremental_voyages if not v.deleted]\nvoyages = sorted(voyages + new_voyages, key= lambda v: (v.imo, v.voyage_number))\nlen(voyages)\n</pre> updated_voyage_ids = set(v.id for v in incremental_voyages) voyages = [v for v in voyages if v.id not in updated_voyage_ids and not v.deleted] new_voyages = [v for v in incremental_voyages if not v.deleted] voyages = sorted(voyages + new_voyages, key= lambda v: (v.imo, v.voyage_number)) len(voyages) Out[28]: <pre>400</pre> <p>Voyages may be retrieved and updated incrementally in the flat format.</p> In\u00a0[29]: Copied! <pre>#get vessel class id for vlcc\nvc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0]\nvessel_class_id = vc.vessel_class_id\nvessel_class_id\n</pre> #get vessel class id for vlcc vc = api.get_vessel_classes(VesselClassFilter('vlcc'))[0] vessel_class_id = vc.vessel_class_id vessel_class_id Out[29]: <pre>84</pre> In\u00a0[30]: Copied! <pre>date_from = date.today() - timedelta(days=30)\n</pre> date_from = date.today() - timedelta(days=30) In\u00a0[31]: Copied! <pre>voyages_flat, next_request_token = api.get_incremental_voyages_flat(vessel_class_id=vessel_class_id, date_from=date_from)\n</pre> voyages_flat, next_request_token = api.get_incremental_voyages_flat(vessel_class_id=vessel_class_id, date_from=date_from) In\u00a0[32]: Copied! <pre>voyages = voyages_flat.voyages\nevents = voyages_flat.events\nevent_details = voyages_flat.event_details\ngeos = voyages_flat.geos\n</pre> voyages = voyages_flat.voyages events = voyages_flat.events event_details = voyages_flat.event_details geos = voyages_flat.geos In\u00a0[33]: Copied! <pre>len(voyages), len(events), len(event_details), len(geos)\n</pre> len(voyages), len(events), len(event_details), len(geos) Out[33]: <pre>(400, 1357, 483, 288)</pre> In\u00a0[34]: Copied! <pre>incremental_voyages_flat, next_request_token = api.get_incremental_voyages_flat(vessel_class_id=vessel_class_id, date_from=date_from, incremental_token=next_request_token)\n</pre> incremental_voyages_flat, next_request_token = api.get_incremental_voyages_flat(vessel_class_id=vessel_class_id, date_from=date_from, incremental_token=next_request_token) In\u00a0[35]: Copied! <pre>len(incremental_voyages_flat.voyages)\n</pre> len(incremental_voyages_flat.voyages) Out[35]: <pre>0</pre> <p>In this case the update step is applied to voyages, events, event details and geos datasets.</p> In\u00a0[36]: Copied! <pre>updated_voyage_ids = set(v.id for v in incremental_voyages_flat.voyages)\nvoyages = [v for v in voyages if v.id not in updated_voyage_ids and not v.deleted]\nnew_voyages = [v for v in incremental_voyages_flat.voyages if not v.deleted]\nvoyages = sorted(voyages + new_voyages, key= lambda v: (v.imo, v.voyage_number))\nlen(voyages)\n</pre> updated_voyage_ids = set(v.id for v in incremental_voyages_flat.voyages) voyages = [v for v in voyages if v.id not in updated_voyage_ids and not v.deleted] new_voyages = [v for v in incremental_voyages_flat.voyages if not v.deleted] voyages = sorted(voyages + new_voyages, key= lambda v: (v.imo, v.voyage_number)) len(voyages) Out[36]: <pre>400</pre> In\u00a0[37]: Copied! <pre>updated_event_ids = set(e.id for e in events if e.voyage_id in updated_voyage_ids)\nevents = [e for e in events if e.id not in updated_event_ids]\nevents = sorted(events + list(incremental_voyages_flat.events), key= lambda e: e.id)\nlen(events)\n</pre> updated_event_ids = set(e.id for e in events if e.voyage_id in updated_voyage_ids) events = [e for e in events if e.id not in updated_event_ids] events = sorted(events + list(incremental_voyages_flat.events), key= lambda e: e.id) len(events) Out[37]: <pre>1357</pre> In\u00a0[38]: Copied! <pre>event_details = [e for e in event_details if e.id not in updated_event_ids]\nevent_details = sorted(event_details + list(incremental_voyages_flat.event_details), key= lambda e: e.id)\nlen(event_details)\n</pre> event_details = [e for e in event_details if e.id not in updated_event_ids] event_details = sorted(event_details + list(incremental_voyages_flat.event_details), key= lambda e: e.id) len(event_details) Out[38]: <pre>483</pre> In\u00a0[39]: Copied! <pre>updated_geo_ids = set(g.id for g in incremental_voyages_flat.geos)\ngeos = [g for g in geos if g.id not in updated_geo_ids] + list(incremental_voyages_flat.geos)\nlen(geos)\n</pre> updated_geo_ids = set(g.id for g in incremental_voyages_flat.geos) geos = [g for g in geos if g.id not in updated_geo_ids] + list(incremental_voyages_flat.geos) len(geos) Out[39]: <pre>288</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#voyages-api-example","title":"Voyages API Example\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#call-the-voyages-api","title":"Call the Voyages API\u00b6","text":"<p>The Voyages API retrieves information about vessel voyages.</p>"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#get-voyages-for-vessel","title":"Get voyages for vessel\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#get-voyages-for-vessel-class","title":"Get voyages for vessel class\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#get-voyages-for-vessel-in-flat-format","title":"Get voyages for vessel in flat format\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#get-voyages-for-vessel-class-in-the-flat-format","title":"Get voyages for vessel class in the flat format\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#get-voyages-for-vessel-incrementally","title":"Get voyages for vessel incrementally\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#get-voyages-for-vessel-class-incrementally","title":"Get voyages for vessel class incrementally\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI/#get-voyages-for-vessel-class-incrementally-in-the-flat-format","title":"Get voyages for vessel class incrementally in the flat format\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/","title":"Capesize Discharges to China","text":"<p>Install the Signal Ocean package:</p> In\u00a0[1]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <pre>Collecting signal-ocean\n  Downloading signal_ocean-13.3.0-py3-none-any.whl.metadata (2.2 kB)\nRequirement already satisfied: requests&lt;3,&gt;=2.23.0 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.32.3)\nRequirement already satisfied: python-dateutil&lt;3,&gt;=2.8.1 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.8.2)\nRequirement already satisfied: pandas&lt;3,&gt;=1.0.3 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.2.2)\nRequirement already satisfied: numpy&gt;=1.18.5 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (1.26.4)\nCollecting strictly-typed-pandas==0.1.4 (from signal-ocean)\n  Downloading strictly_typed_pandas-0.1.4-py3-none-any.whl.metadata (3.0 kB)\nCollecting typeguard&lt;3.0.0,&gt;=2.13.3 (from signal-ocean)\n  Downloading typeguard-2.13.3-py3-none-any.whl.metadata (3.6 kB)\nRequirement already satisfied: pandas-stubs in /usr/local/lib/python3.11/dist-packages (from strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2.2.2.240909)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil&lt;3,&gt;=2.8.1-&gt;signal-ocean) (1.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.4.1)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.3.0)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2025.1.31)\nRequirement already satisfied: types-pytz&gt;=2022.1.1 in /usr/local/lib/python3.11/dist-packages (from pandas-stubs-&gt;strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2025.1.0.20250204)\nDownloading signal_ocean-13.3.0-py3-none-any.whl (155 kB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 155.6/155.6 kB 3.0 MB/s eta 0:00:00\nDownloading strictly_typed_pandas-0.1.4-py3-none-any.whl (9.6 kB)\nDownloading typeguard-2.13.3-py3-none-any.whl (17 kB)\nInstalling collected packages: typeguard, strictly-typed-pandas, signal-ocean\n  Attempting uninstall: typeguard\n    Found existing installation: typeguard 4.4.2\n    Uninstalling typeguard-4.4.2:\n      Successfully uninstalled typeguard-4.4.2\nERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.\ninflect 7.5.0 requires typeguard&gt;=4.0.1, but you have typeguard 2.13.3 which is incompatible.\nSuccessfully installed signal-ocean-13.3.0 strictly-typed-pandas-0.1.4 typeguard-2.13.3\n</pre> <p>Import the required Dependencies:</p> In\u00a0[2]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI\nimport pandas as pd\nfrom datetime import datetime, timedelta\nimport plotly.express as px\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI import pandas as pd from datetime import datetime, timedelta import plotly.express as px In\u00a0[3]: Copied! <pre>signal_ocean_api_key = '' # Replace with your subscription key\n\noperations_to_display = 'Discharge' # Here you can filter for: Load, Discharge, Stop, Start, Dry dock\n\ncountry_to_filter = 'China' # The country that we want the discharges of\n\nsegment = 'Dry' # This could be either 'Dry', 'Tanker', 'LPG', 'LNG'\nvessels_class_to_filter = 'Capesize' # Value from the set\n                                     # ('Handysize', 'Handymax', 'Supramax', 'Panamax', 'Capesize','VLOC')\n\nvoyages_first_load_from = (datetime.today() - timedelta(365)).strftime(\"%Y-%m-%d\") # We pick the start of the first load date as our time window\n</pre> signal_ocean_api_key = '' # Replace with your subscription key  operations_to_display = 'Discharge' # Here you can filter for: Load, Discharge, Stop, Start, Dry dock  country_to_filter = 'China' # The country that we want the discharges of  segment = 'Dry' # This could be either 'Dry', 'Tanker', 'LPG', 'LNG' vessels_class_to_filter = 'Capesize' # Value from the set                                      # ('Handysize', 'Handymax', 'Supramax', 'Panamax', 'Capesize','VLOC')  voyages_first_load_from = (datetime.today() - timedelta(365)).strftime(\"%Y-%m-%d\") # We pick the start of the first load date as our time window <p>Get your personal Signal Ocean API subscription key (acquired here) and use it to create a <code>Connection</code>:</p> In\u00a0[4]: Copied! <pre>connection = Connection(signal_ocean_api_key)\n</pre> connection = Connection(signal_ocean_api_key) <p>The Voyages API retrieves information about vessel voyages.</p> In\u00a0[5]: Copied! <pre>api = VoyagesAPI(connection)\n</pre> api = VoyagesAPI(connection) <p>For more information, see the Voyages API section.</p> <p>Get vessel class id for Capesizes</p> In\u00a0[6]: Copied! <pre>vessel_classes = api.get_vessel_classes() # retrieval of all available Vessel Classes\nvessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes) # Load into DataFrame for processing\nvessel_classes_df = vessel_classes_df[vessel_classes_df['vessel_type']==segment] # Filter only Dry Vessel Classes\nvessel_classes_df = vessel_classes_df[vessel_classes_df['vessel_class_name']==vessels_class_to_filter] # Return id of desired vessel Class\nvessel_classes_df\n</pre> vessel_classes = api.get_vessel_classes() # retrieval of all available Vessel Classes vessel_classes_df = pd.DataFrame(v.__dict__ for v in vessel_classes) # Load into DataFrame for processing vessel_classes_df = vessel_classes_df[vessel_classes_df['vessel_type']==segment] # Filter only Dry Vessel Classes vessel_classes_df = vessel_classes_df[vessel_classes_df['vessel_class_name']==vessels_class_to_filter] # Return id of desired vessel Class vessel_classes_df Out[6]: vessel_class_id vessel_class_name vessel_type_id vessel_type 5 70 Capesize 3 Dry In\u00a0[7]: Copied! <pre>vessel_classes_df = vessel_classes_df.reset_index(drop=True)\nvessel_class_id_to_look_for = vessel_classes_df.loc[0, 'vessel_class_id']\n</pre> vessel_classes_df = vessel_classes_df.reset_index(drop=True) vessel_class_id_to_look_for = vessel_classes_df.loc[0, 'vessel_class_id'] In\u00a0[8]: Copied! <pre>voyages = api.get_voyages_by_advanced_search(vessel_class_id = vessel_class_id_to_look_for,first_load_arrival_date_from = voyages_first_load_from, event_purpose = operations_to_display)\n# We call the API to fetch data based on the parameters that we want, in this case for Discharges of Capes for Voyages, having first load one year ago\n\nvoyages = pd.DataFrame([v.__dict__ for v in voyages]) # We load the result to a DataFrame\npd.set_option('display.max_columns', None)\nvoyages.tail(2) # Display 2 most recent for educational purposes\n</pre> voyages = api.get_voyages_by_advanced_search(vessel_class_id = vessel_class_id_to_look_for,first_load_arrival_date_from = voyages_first_load_from, event_purpose = operations_to_display) # We call the API to fetch data based on the parameters that we want, in this case for Discharges of Capes for Voyages, having first load one year ago  voyages = pd.DataFrame([v.__dict__ for v in voyages]) # We load the result to a DataFrame pd.set_option('display.max_columns', None) voyages.tail(2) # Display 2 most recent for educational purposes Out[8]: imo voyage_number vessel_type_id vessel_class_id vessel_status_id commercial_operator_id deleted events id horizon_id horizon latest_received_ais vessel_name pit_vessel_name vessel_type vessel_class trade trade_id vessel_status deadweight year_built commercial_operator start_date first_load_arrival_date end_date charterer_id charterer rate rate_type ballast_bonus ballast_bonus_type cargo_type_id cargo_type cargo_type_source_id cargo_type_source cargo_sub_type_id cargo_sub_type cargo_sub_type_source_id cargo_sub_type_source cargo_group_id cargo_group cargo_group_source_id cargo_group_source cargo_sub_group_id cargo_sub_group cargo_sub_group_source_id cargo_sub_group_source quantity quantity_unit_id quantity_unit quantity_in_barrels quantity_source_id quantity_source cubic_size laycan_from laycan_to fixture_status_id fixture_status fixture_date fixture_is_coa fixture_is_hold is_implied_by_ais has_manual_entries ballast_distance predicted_ballast_distance laden_distance predicted_laden_distance suez_crossing panama_crossing canakkale_crossing bosporus_crossing torres_strait_crossing magellan_strait_crossing great_belt_crossing 9611 1019709 1 3 70 1 441.0 False (VoyageEvent(id='IF8F3D46SEDEEACD00', voyage_i... IF8F3D46VEDEEACD00 2 Current 2025-02-24 15:36:45+00:00 Mount Anjin None Dry Capesize Bulk 4 Voyage 211500 2025 Eastern Pacific Shipping 2025-01-08 06:36:25+00:00 2025-02-24 17:59:54.635000+00:00 2025-03-20 02:33:57.244000+00:00 NaN None NaN None NaN None 5258 Iron Ore Fines 8 EstimatedLow NaN None NaN None 5644 Ores and Rocks 8 EstimatedLow 28 Iron Ore 8 EstimatedLow 169000.0 1 MetricTonnes None 1 Estimated NaN NaT NaT 5.0 PossFixed 2025-02-10 23:54:22+00:00 False False True None 5190.99 31.82 NaN 3820.94 None None None None None None None 9612 1032268 1 3 70 1 1109.0 False (VoyageEvent(id='IFC04C46SEDEC34000', voyage_i... IFC04C46VEDEC34000 2 Current 2025-02-24 15:15:25+00:00 SG Aquamarine None Dry Capesize Bulk 4 Voyage 180000 2024 NYK Line 2024-11-12 03:10:46+00:00 2025-01-24 19:55:49+00:00 2025-03-08 19:51:51.715000+00:00 NaN None NaN None NaN None 5258 Iron Ore Fines 10 EstimatedHigh NaN None NaN None 5644 Ores and Rocks 10 EstimatedHigh 28 Iron Ore 10 EstimatedHigh 174000.0 1 MetricTonnes None 1 Estimated NaN NaT NaT -2.0 NotSet NaT False False None None 11958.04 NaN 7056.57 1410.78 None None None None None None None In\u00a0[9]: Copied! <pre>selected_columns = ['id','imo', 'voyage_number','vessel_name',# Voyages API returns a lot of info regarding a voyage\n                    'vessel_class','cargo_sub_group',         # So it is a good idea to choose the columns that we\n                    'cargo_type','start_date','events']       # are most interested for\n\n\nvoyages_new = voyages[selected_columns].copy() # copy the selected columns to a new dataframe\n\nvoyages_new.rename(columns={'id': 'voyage_id','start_date':'voyage_start_date'}, inplace = True)\n\nvoyages_new.head(5) # Display format\n</pre> selected_columns = ['id','imo', 'voyage_number','vessel_name',# Voyages API returns a lot of info regarding a voyage                     'vessel_class','cargo_sub_group',         # So it is a good idea to choose the columns that we                     'cargo_type','start_date','events']       # are most interested for   voyages_new = voyages[selected_columns].copy() # copy the selected columns to a new dataframe  voyages_new.rename(columns={'id': 'voyage_id','start_date':'voyage_start_date'}, inplace = True)  voyages_new.head(5) # Display format Out[9]: voyage_id imo voyage_number vessel_name vessel_class cargo_sub_group cargo_type voyage_start_date events 0 I10210046VEDE250C00 1057024 1 Granitz Capesize Coal Thermal Coal 2024-08-10 20:51:47+00:00 (VoyageEvent(id='I10210046SEDE250C00', voyage_... 1 I8BDAC0VEDD5F4B00 9165504 125 Lady Cedros Capesize Minerals Salt 2024-02-22 19:56:46+00:00 (VoyageEvent(id='I8BDAC0SEDD5F4B00', voyage_id... 2 I8BDAC0VEDDAE6500 9165504 126 Lady Cedros Capesize Minerals Salt 2024-04-24 19:59:54+00:00 (VoyageEvent(id='I8BDAC0SEDDAE6500', voyage_id... 3 I8BDAC0VEDDFD7F00 9165504 127 Lady Cedros Capesize Minerals Salt 2024-06-20 23:47:08+00:00 (VoyageEvent(id='I8BDAC0SEDDFD7F00', voyage_id... 4 I8BDAC0VEDE4C9900 9165504 128 Lady Cedros Capesize Minerals Salt 2024-08-15 03:56:28+00:00 (VoyageEvent(id='I8BDAC0SEDE4C9900', voyage_id... <p>Explode 'events' column values to create 1 row per event and extract event info into columns</p> In\u00a0[10]: Copied! <pre>events = voyages_new.explode('events')\nevents['events'] = events['events'].apply(lambda x: x.__dict__)\nevents = pd.concat([events.drop(['events'], axis=1), events['events'].apply(pd.Series)], axis=1)\nevents.head(2)\n</pre> events = voyages_new.explode('events') events['events'] = events['events'].apply(lambda x: x.__dict__) events = pd.concat([events.drop(['events'], axis=1), events['events'].apply(pd.Series)], axis=1) events.head(2) Out[10]: voyage_id imo voyage_number vessel_name vessel_class cargo_sub_group cargo_type voyage_start_date id voyage_id event_type_id event_type event_horizon_id event_horizon purpose event_date arrival_date sailing_date latitude longitude geo_asset_id geo_asset_name port_id port_name port_unlocode country_id country area_idlevel0 area_name_level0 area_idlevel1 area_name_level1 area_idlevel2 area_name_level2 area_idlevel3 area_name_level3 low_ais_density quantity quantity_unit_id quantity_unit quantity_in_barrels event_details 0 I10210046VEDE250C00 1057024 1 Granitz Capesize Coal Thermal Coal 2024-08-10 20:51:47+00:00 I10210046SEDE250C00 None 2 VoyageStart 0 Historical Start 2024-08-10 20:51:47+00:00 NaT NaT 10.3608 -75.5102 6822 Mammonal Shipyard 3324 Mamonal CO MAM 56 Colombia 24746 Caribs 9 Caribs 25019 Atlantic America 25028 West None NaN NaN None None None 0 I10210046VEDE250C00 1057024 1 Granitz Capesize Coal Thermal Coal 2024-08-10 20:51:47+00:00 I10210046TEDE250C00 None 1 PortCall 1 Current Load NaT 2024-08-10 23:58:47+00:00 2024-08-30 00:10:32.300000+00:00 10.3608 -75.5102 6822 Mammonal Shipyard 3324 Mamonal CO MAM 56 Colombia 24746 Caribs 9 Caribs 25019 Atlantic America 25028 West True 138000.0 1.0 MetricTonnes None (VoyageEventDetail(id='I10210046LEDE250C00', e... In\u00a0[11]: Copied! <pre>if not country_to_filter:  # This checks for both None and empty string\n  print(\"The string is null or empty\")\nelse:\n  events = events[(events['country'] == country_to_filter)] # keep only the events that have to do with China\n\n  events = events[(events['purpose'] == operations_to_display)] # keep only the discharges from these events\n\n\n  events.drop(columns = ['port_id', 'voyage_id','event_date','geo_asset_id',\n                         'country_id','area_idlevel0','area_idlevel1',\n                         'area_idlevel2','area_idlevel3','quantity_unit_id',\n                         'quantity_in_barrels','quantity_unit_id','event_details'], inplace=True)\n</pre> if not country_to_filter:  # This checks for both None and empty string   print(\"The string is null or empty\") else:   events = events[(events['country'] == country_to_filter)] # keep only the events that have to do with China    events = events[(events['purpose'] == operations_to_display)] # keep only the discharges from these events     events.drop(columns = ['port_id', 'voyage_id','event_date','geo_asset_id',                          'country_id','area_idlevel0','area_idlevel1',                          'area_idlevel2','area_idlevel3','quantity_unit_id',                          'quantity_in_barrels','quantity_unit_id','event_details'], inplace=True) In\u00a0[12]: Copied! <pre>df = events.copy() # copy the output to a new dataframe\ndf = df.sort_values(by='arrival_date') # sort the datarame by the vessel arrival date\n</pre> df = events.copy() # copy the output to a new dataframe df = df.sort_values(by='arrival_date') # sort the datarame by the vessel arrival date In\u00a0[13]: Copied! <pre>file_path = segment + '-' + vessels_class_to_filter + '-' + operations_to_display + ' for ' + country_to_filter+'.xlsx' # Name of the exported excel file\n\n# Ensure datetimes are timezone-unaware\ndf['voyage_start_date'] = df['voyage_start_date'].dt.tz_localize(None)\ndf['arrival_date'] = df['arrival_date'].dt.tz_localize(None)\ndf['sailing_date'] = df['sailing_date'].dt.tz_localize(None)\ndf.to_excel(file_path, index=False)\n</pre> file_path = segment + '-' + vessels_class_to_filter + '-' + operations_to_display + ' for ' + country_to_filter+'.xlsx' # Name of the exported excel file  # Ensure datetimes are timezone-unaware df['voyage_start_date'] = df['voyage_start_date'].dt.tz_localize(None) df['arrival_date'] = df['arrival_date'].dt.tz_localize(None) df['sailing_date'] = df['sailing_date'].dt.tz_localize(None) df.to_excel(file_path, index=False)"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#capesize-discharges-to-china","title":"Capesize Discharges to China\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":"<p>APIs Used : Voyages API</p> <p>Description :</p> <p>The main goal of this notebook is to retrieve a dataset containing the voyages of Capesizes that discharged / will discharge / currently discharging to China from a year before onwards.</p> <p>The script walks though the installation of the signal ocean SDK and import of the required dependencies used for the processing of the data. Also the parameters <code>operations_to_display, country_to_filter, segment, vessel_class_to_filter, voyages_first_load_from</code> are initialized, in order to be used to achieve the desired output.</p> <p>Next the Voyages API is called to fetch the corresponding data to our query.</p> <p>After that, we expand the Voyages events to perform a Data cleaning operation and retrieve only the Data fit to our criteria and the most relevant columns from the dataset.</p> <p>Lastly, an Excel file is made and exported to a downloadable format.</p> <p>Output : Excel file containing the resulting Table.</p>"},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#setup","title":"Setup\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#parametrisation","title":"Parametrisation\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#main-codeblock","title":"Main CodeBlock\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#call-the-voyages-api","title":"Call the Voyages API\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#calling-the-voyages-api-to-get-the-data-create-one-dataframe-by-linking-voyages-with-their-events","title":"Calling the Voyages API to get the data, create one dataframe by linking Voyages with their events\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#filter-events-based-on-the-desired-output-and-drop-columns-that-are-not-needed-for-this-analysis","title":"Filter events based on the desired output and drop columns that are not needed for this analysis\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/VoyagesAPI_Dry_Last_year_Capesize_Discharges_To_China/#export-the-data-to-an-excel-file","title":"Export the data to an Excel file\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Voyages_Metrics_Top_3_Loading_Locations_Discharge_Locations_Cargo_Types/","title":"Voyages Metrics - Top 3 Loading Locations, Discharge Locations, Cargo Types","text":"In\u00a0[1]: Copied! <pre>!pip install signal-ocean\n</pre> !pip install signal-ocean <pre>Collecting signal-ocean\n  Downloading signal_ocean-13.3.0-py3-none-any.whl.metadata (2.2 kB)\nRequirement already satisfied: requests&lt;3,&gt;=2.23.0 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.32.3)\nRequirement already satisfied: python-dateutil&lt;3,&gt;=2.8.1 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.8.2)\nRequirement already satisfied: pandas&lt;3,&gt;=1.0.3 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (2.2.2)\nRequirement already satisfied: numpy&gt;=1.18.5 in /usr/local/lib/python3.11/dist-packages (from signal-ocean) (1.26.4)\nCollecting strictly-typed-pandas==0.1.4 (from signal-ocean)\n  Downloading strictly_typed_pandas-0.1.4-py3-none-any.whl.metadata (3.0 kB)\nCollecting typeguard&lt;3.0.0,&gt;=2.13.3 (from signal-ocean)\n  Downloading typeguard-2.13.3-py3-none-any.whl.metadata (3.6 kB)\nRequirement already satisfied: pandas-stubs in /usr/local/lib/python3.11/dist-packages (from strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2.2.2.240909)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.11/dist-packages (from pandas&lt;3,&gt;=1.0.3-&gt;signal-ocean) (2025.1)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil&lt;3,&gt;=2.8.1-&gt;signal-ocean) (1.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.4.1)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2.3.0)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.11/dist-packages (from requests&lt;3,&gt;=2.23.0-&gt;signal-ocean) (2025.1.31)\nRequirement already satisfied: types-pytz&gt;=2022.1.1 in /usr/local/lib/python3.11/dist-packages (from pandas-stubs-&gt;strictly-typed-pandas==0.1.4-&gt;signal-ocean) (2025.1.0.20250204)\nDownloading signal_ocean-13.3.0-py3-none-any.whl (155 kB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 155.6/155.6 kB 2.7 MB/s eta 0:00:00\nDownloading strictly_typed_pandas-0.1.4-py3-none-any.whl (9.6 kB)\nDownloading typeguard-2.13.3-py3-none-any.whl (17 kB)\nInstalling collected packages: typeguard, strictly-typed-pandas, signal-ocean\n  Attempting uninstall: typeguard\n    Found existing installation: typeguard 4.4.2\n    Uninstalling typeguard-4.4.2:\n      Successfully uninstalled typeguard-4.4.2\nERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.\ninflect 7.5.0 requires typeguard&gt;=4.0.1, but you have typeguard 2.13.3 which is incompatible.\nSuccessfully installed signal-ocean-13.3.0 strictly-typed-pandas-0.1.4 typeguard-2.13.3\n</pre> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key In\u00a0[3]: Copied! <pre>from signal_ocean import Connection\nfrom signal_ocean.voyages import VoyagesAPI, VesselClass, VesselClassFilter\nimport pandas as pd\nimport pandas as pd\nfrom datetime import date, timedelta\nimport matplotlib.pyplot as plt\n</pre> from signal_ocean import Connection from signal_ocean.voyages import VoyagesAPI, VesselClass, VesselClassFilter import pandas as pd import pandas as pd from datetime import date, timedelta import matplotlib.pyplot as plt In\u00a0[4]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesAPI(connection) <p>We need to specify the following parameters for our queries:</p> <ol> <li><p>startingArea - The Starting Area of our Voyages</p> </li> <li><p>vesselClass - the class of queried vessels.</p> </li> <li><p>dateFrom - The starting date of queried voyages.</p> </li> </ol> In\u00a0[5]: Copied! <pre>startingArea = 'Arabian Gulf'\nvesselClass = 'Aframax'\ndateFrom = date(2024, 6, 1) # Define a specific date as the minimum Starting Voyage Date  (e.g., \"2024-01-01\")\n</pre> startingArea = 'Arabian Gulf' vesselClass = 'Aframax' dateFrom = date(2024, 6, 1) # Define a specific date as the minimum Starting Voyage Date  (e.g., \"2024-01-01\") <p>Declare helper functions</p> In\u00a0[6]: Copied! <pre>def get_voyage_start_area(voyage_events):\n    return next((e.area_name_level0 for e in voyage_events or [] if e.event_type =='VoyageStart' ), None)\n\ndef get_voyage_discharge_countries(voyage_events):  # Returns a list of all discharge countries from voyage events.\n    return [e.country for e in reversed(voyage_events or []) if e.purpose == 'Discharge']\n\ndef get_voyage_load_countries(voyage_events):   #  Returns a list of all load countries from voyage events.\n    return [e.country for e in voyage_events or [] if e.purpose == 'Load']\n</pre> def get_voyage_start_area(voyage_events):     return next((e.area_name_level0 for e in voyage_events or [] if e.event_type =='VoyageStart' ), None)  def get_voyage_discharge_countries(voyage_events):  # Returns a list of all discharge countries from voyage events.     return [e.country for e in reversed(voyage_events or []) if e.purpose == 'Discharge']  def get_voyage_load_countries(voyage_events):   #  Returns a list of all load countries from voyage events.     return [e.country for e in voyage_events or [] if e.purpose == 'Load']  In\u00a0[7]: Copied! <pre>vesselClass = api.get_vessel_classes(VesselClassFilter(vesselClass))\naframaxId = vesselClass[0].vessel_class_id\naframaxId\n</pre> vesselClass = api.get_vessel_classes(VesselClassFilter(vesselClass)) aframaxId = vesselClass[0].vessel_class_id aframaxId Out[7]: <pre>86</pre> <p>Calling Voyages API for the Vessel Class &amp; the dates of our preference</p> In\u00a0[8]: Copied! <pre>#Calling the API for the Vessel Class and after a specifc Starting Voyage Date\nvoyages = api.get_voyages_by_advanced_search(vessel_class_id=aframaxId, start_date_from=dateFrom)\nvoyages = pd.DataFrame(v.__dict__ for v in voyages)\n</pre> #Calling the API for the Vessel Class and after a specifc Starting Voyage Date voyages = api.get_voyages_by_advanced_search(vessel_class_id=aframaxId, start_date_from=dateFrom) voyages = pd.DataFrame(v.__dict__ for v in voyages) In\u00a0[9]: Copied! <pre>voyages['discharge_country'] = voyages['events'].apply(get_voyage_discharge_countries)\nvoyages['load_country'] = voyages['events'].apply(get_voyage_load_countries)\n</pre>  voyages['discharge_country'] = voyages['events'].apply(get_voyage_discharge_countries) voyages['load_country'] = voyages['events'].apply(get_voyage_load_countries) In\u00a0[10]: Copied! <pre>voyages['start_area']= voyages['events'].apply(get_voyage_start_area)\n# Filter voyages in Starting Area\nvoyagesStartingArea = voyages[voyages['start_area'] == startingArea]\n</pre>  voyages['start_area']= voyages['events'].apply(get_voyage_start_area) # Filter voyages in Starting Area voyagesStartingArea = voyages[voyages['start_area'] == startingArea] <p>Creating a chart for the top 3 Load Countries</p> In\u00a0[11]: Copied! <pre># Get value counts for load countries\nflattened_load_countries = [country for sublist in voyagesStartingArea['load_country'] for country in sublist]\nload_counts = pd.Series(flattened_load_countries).value_counts()\nload_percentages = ((load_counts / load_counts.sum()) * 100).round(2)\n\n# Get the top 3 load countries by percentage\ntop_3_load_countries = load_percentages.head(3)\n\n# Plot a bar chart\nplt.figure(figsize=(8, 5))\ntop_3_load_countries.plot(kind='bar', color=['#76c7c0', '#ff6f61', '#ffa07a'], edgecolor='black')\n\n# Add chart details\nplt.title('Top 3 Load Countries (Percent of Total)', fontsize=14, fontweight='bold')\nplt.ylabel('Percentage (%)', fontsize=12)\nplt.xlabel('Load Country', fontsize=12)\nplt.xticks(rotation=45, ha='right', fontsize=10)\nplt.yticks(fontsize=10)\n\n# Show percentage values on top of bars\nfor index, value in enumerate(top_3_load_countries):\n    plt.text(index, value + 1, f'{value}%', ha='center', fontsize=10, color='black')\n\nplt.tight_layout()\nplt.show()\n</pre> # Get value counts for load countries flattened_load_countries = [country for sublist in voyagesStartingArea['load_country'] for country in sublist] load_counts = pd.Series(flattened_load_countries).value_counts() load_percentages = ((load_counts / load_counts.sum()) * 100).round(2)  # Get the top 3 load countries by percentage top_3_load_countries = load_percentages.head(3)  # Plot a bar chart plt.figure(figsize=(8, 5)) top_3_load_countries.plot(kind='bar', color=['#76c7c0', '#ff6f61', '#ffa07a'], edgecolor='black')  # Add chart details plt.title('Top 3 Load Countries (Percent of Total)', fontsize=14, fontweight='bold') plt.ylabel('Percentage (%)', fontsize=12) plt.xlabel('Load Country', fontsize=12) plt.xticks(rotation=45, ha='right', fontsize=10) plt.yticks(fontsize=10)  # Show percentage values on top of bars for index, value in enumerate(top_3_load_countries):     plt.text(index, value + 1, f'{value}%', ha='center', fontsize=10, color='black')  plt.tight_layout() plt.show() <p>Creating a chart for the top 3 Discharge Countries</p> In\u00a0[12]: Copied! <pre># Get value counts for discharge countries\nflattened_discharge_countries = [country for sublist in voyagesStartingArea['discharge_country'] for country in sublist]\ndischarge_counts = pd.Series(flattened_discharge_countries).value_counts()\ndischarge_percentages = ((discharge_counts / discharge_counts.sum()) * 100).round(2)\n\n# Get the top 3 discharge countries by percentage\ntop_3_discharge_countries = discharge_percentages.head(3)\n\n# Plot a bar chart\nplt.figure(figsize=(8, 5))\ntop_3_discharge_countries.plot(kind='bar', color=['#76c7c0', '#ff6f61', '#ffa07a'], edgecolor='black')\n\n# Add chart details\nplt.title('Top 3 Discharge Countries (Percent of Total)', fontsize=14, fontweight='bold')\nplt.ylabel('Percentage (%)', fontsize=12)\nplt.xlabel('Discharge Country', fontsize=12)\nplt.xticks(rotation=45, ha='right', fontsize=10)\nplt.yticks(fontsize=10)\n\n# Show percentage values on top of bars\nfor index, value in enumerate(top_3_discharge_countries):\n    plt.text(index, value + 1, f'{value}%', ha='center', fontsize=10, color='black')\n\nplt.tight_layout()\nplt.show()\n</pre> # Get value counts for discharge countries flattened_discharge_countries = [country for sublist in voyagesStartingArea['discharge_country'] for country in sublist] discharge_counts = pd.Series(flattened_discharge_countries).value_counts() discharge_percentages = ((discharge_counts / discharge_counts.sum()) * 100).round(2)  # Get the top 3 discharge countries by percentage top_3_discharge_countries = discharge_percentages.head(3)  # Plot a bar chart plt.figure(figsize=(8, 5)) top_3_discharge_countries.plot(kind='bar', color=['#76c7c0', '#ff6f61', '#ffa07a'], edgecolor='black')  # Add chart details plt.title('Top 3 Discharge Countries (Percent of Total)', fontsize=14, fontweight='bold') plt.ylabel('Percentage (%)', fontsize=12) plt.xlabel('Discharge Country', fontsize=12) plt.xticks(rotation=45, ha='right', fontsize=10) plt.yticks(fontsize=10)  # Show percentage values on top of bars for index, value in enumerate(top_3_discharge_countries):     plt.text(index, value + 1, f'{value}%', ha='center', fontsize=10, color='black')  plt.tight_layout() plt.show()  <p>Creating a chart for the top 3 Cargo Types</p> In\u00a0[13]: Copied! <pre># Get value counts for cargo types\ncargo_types_counts = voyagesStartingArea['cargo_type'].value_counts()\ncargo_types_percentages = ((cargo_types_counts / cargo_types_counts.sum()) * 100).round(2)\n\n# Get the top 3 load cargo types\ntop_3_cargo_types = cargo_types_percentages.head(3)\n\n# Plot a bar chart\nplt.figure(figsize=(8, 5))\ntop_3_cargo_types.plot(kind='bar', color=['#76c7c0', '#ff6f61', '#ffa07a'], edgecolor='black')\n\n# Add chart details\nplt.title('Top 3 Cargo Types (Percent of Total)', fontsize=14, fontweight='bold')\nplt.ylabel('Percentage (%)', fontsize=12)\nplt.xlabel('Cargo Type', fontsize=12)\nplt.xticks(rotation=45, ha='right', fontsize=10)\nplt.yticks(fontsize=10)\n\n# Show percentage values on top of bars\nfor index, value in enumerate(top_3_cargo_types):\n    plt.text(index, value + 1, f'{value}%', ha='center', fontsize=10, color='black')\n\nplt.tight_layout()\nplt.show()\n</pre> # Get value counts for cargo types cargo_types_counts = voyagesStartingArea['cargo_type'].value_counts() cargo_types_percentages = ((cargo_types_counts / cargo_types_counts.sum()) * 100).round(2)  # Get the top 3 load cargo types top_3_cargo_types = cargo_types_percentages.head(3)  # Plot a bar chart plt.figure(figsize=(8, 5)) top_3_cargo_types.plot(kind='bar', color=['#76c7c0', '#ff6f61', '#ffa07a'], edgecolor='black')  # Add chart details plt.title('Top 3 Cargo Types (Percent of Total)', fontsize=14, fontweight='bold') plt.ylabel('Percentage (%)', fontsize=12) plt.xlabel('Cargo Type', fontsize=12) plt.xticks(rotation=45, ha='right', fontsize=10) plt.yticks(fontsize=10)  # Show percentage values on top of bars for index, value in enumerate(top_3_cargo_types):     plt.text(index, value + 1, f'{value}%', ha='center', fontsize=10, color='black')  plt.tight_layout() plt.show()"},{"location":"examples/jupyter/VoyagesAPI/Voyages_Metrics_Top_3_Loading_Locations_Discharge_Locations_Cargo_Types/#voyages-metrics-top-3-loading-locations-discharge-locations-cargo-types","title":"Voyages Metrics - Top 3 Loading Locations, Discharge Locations, Cargo Types\u00b6","text":""},{"location":"examples/jupyter/VoyagesAPI/Voyages_Metrics_Top_3_Loading_Locations_Discharge_Locations_Cargo_Types/#run-this-example-in-colab","title":"Run this example in Colab.\u00b6","text":"<p>APIs Used: Voyages</p> <p>Description:</p> <p>The goal of this example is to create key metrics using the Voyages API. We retrieve data for a specified time period and vessel class. After selecting a Starting Area, we generate charts showcasing the top 3 Loading Countries, Discharge Countries, and Cargo Types based on voyage data.</p> <p>Output: Charts By loading Country, Discharge Country, Cargo Type</p>"},{"location":"examples/jupyter/VoyagesAPI/Voyages_Metrics_Top_3_Loading_Locations_Discharge_Locations_Cargo_Types/#setup","title":"Setup\u00b6","text":"<p>Install the Signal Ocean SDK:</p> <pre><code>pip install signal-ocean\n</code></pre> <p>Set your subscription key acquired here: https://apis.signalocean.com/profile</p>"},{"location":"examples/jupyter/VoyagesAPI/Voyages_Metrics_Top_3_Loading_Locations_Discharge_Locations_Cargo_Types/#get-voyages","title":"Get voyages\u00b6","text":""},{"location":"examples/jupyter/VoyagesMarketDataAPI/FixtureStatus/","title":"Fixtures Status","text":"<p>This example plots the number of fixtures per month, grouped by status for Very Large Crude Carriers (VLCCs)</p> Setup <p>Install the Signal Ocean SDK:</p> In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean <p>Import required libraries / APIs / packages:</p> Import Voyages Market Data API and some additional libraries In\u00a0[1]: Copied! <pre>import pandas as pd\nimport plotly.express as px\nfrom datetime import date, timedelta, datetime\n\nfrom signal_ocean import Connection\nfrom signal_ocean.voyages_market_data import VoyagesMarketDataAPI\n</pre> import pandas as pd import plotly.express as px from datetime import date, timedelta, datetime  from signal_ocean import Connection from signal_ocean.voyages_market_data import VoyagesMarketDataAPI <p>Fill in your personal SignalOcean API subscription key acquired here and open a connection:</p> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key <p>Create a connection</p> In\u00a0[3]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesMarketDataAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesMarketDataAPI(connection) Call the API to Get market data In\u00a0[4]: Copied! <pre>result = api.get_voyage_market_data(vessel_class_id=84, include_fixtures = True, include_matched_fixture = True, include_labels = True)\n</pre> result = api.get_voyage_market_data(vessel_class_id=84, include_fixtures = True, include_matched_fixture = True, include_labels = True) <p>Get data into a dataframe</p> In\u00a0[5]: Copied! <pre>voyages_market_data = pd.DataFrame([r.__dict__ for r in result])\n</pre> voyages_market_data = pd.DataFrame([r.__dict__ for r in result]) <p>Extract date info from matched fixture</p> In\u00a0[6]: Copied! <pre>voyages_market_data = voyages_market_data[voyages_market_data['matched_fixture'].notna()]\nvoyages_market_data['Date'] = voyages_market_data['matched_fixture'].apply(lambda mf: mf.laycan_from)\n</pre> voyages_market_data = voyages_market_data[voyages_market_data['matched_fixture'].notna()] voyages_market_data['Date'] = voyages_market_data['matched_fixture'].apply(lambda mf: mf.laycan_from) Transform Data <p>Drop rows that have no date</p> In\u00a0[7]: Copied! <pre>voyages_market_data = voyages_market_data[voyages_market_data.Date.map(lambda d: isinstance(d,datetime))]\n</pre> voyages_market_data = voyages_market_data[voyages_market_data.Date.map(lambda d: isinstance(d,datetime))] <p>Expand the dataframe to have one row per fixture and extract fixture_status</p> In\u00a0[8]: Copied! <pre>voyages_market_data=voyages_market_data.explode('fixtures').reset_index(drop=True)\nvoyages_market_data['fixture_status'] = voyages_market_data['fixtures'].apply(lambda f: f.fixture_status)\n</pre> voyages_market_data=voyages_market_data.explode('fixtures').reset_index(drop=True) voyages_market_data['fixture_status'] = voyages_market_data['fixtures'].apply(lambda f: f.fixture_status) <p>Keep only rows with fixture_status info</p> In\u00a0[9]: Copied! <pre>voyages_market_data = voyages_market_data[voyages_market_data['fixture_status'].notna()][['Date', 'fixture_status', 'voyage_id']]\n</pre> voyages_market_data = voyages_market_data[voyages_market_data['fixture_status'].notna()][['Date', 'fixture_status', 'voyage_id']] <p>Keep one fixture report for each status per voyage</p> In\u00a0[10]: Copied! <pre>voyages_market_data = voyages_market_data.drop_duplicates(subset=['voyage_id', 'fixture_status'], keep='last')\nvoyages_market_data.head()\n</pre> voyages_market_data = voyages_market_data.drop_duplicates(subset=['voyage_id', 'fixture_status'], keep='last') voyages_market_data.head() Out[10]: Date fixture_status voyage_id 62 2011-07-09 00:00:00+00:00 FullyFixed I8818E7VEC5455F00 67 2011-08-28 00:00:00+00:00 FullyFixed I8818E7VEC5BC0600 74 2011-10-10 00:00:00+00:00 FullyFixed I8818E7VEC60B2000 77 2012-01-25 00:00:00+00:00 OnSubs I8818E7VEC681C700 81 2012-03-05 00:00:00+00:00 FullyFixed I8818E7VEC6D0E100 <p>Keep only Month and year info on Date</p> In\u00a0[11]: Copied! <pre>voyages_market_data['Date'] = pd.to_datetime(voyages_market_data['Date'], utc=True).dt.to_period('M')\nvoyages_market_data.head()\n</pre> voyages_market_data['Date'] = pd.to_datetime(voyages_market_data['Date'], utc=True).dt.to_period('M') voyages_market_data.head() <pre>C:\\Users\\l.kolonis\\Anaconda3\\envs\\python38\\lib\\site-packages\\pandas\\core\\arrays\\datetimes.py:1143: UserWarning: Converting to PeriodArray/Index representation will drop timezone information.\n  warnings.warn(\n</pre> Out[11]: Date fixture_status voyage_id 62 2011-07 FullyFixed I8818E7VEC5455F00 67 2011-08 FullyFixed I8818E7VEC5BC0600 74 2011-10 FullyFixed I8818E7VEC60B2000 77 2012-01 OnSubs I8818E7VEC681C700 81 2012-03 FullyFixed I8818E7VEC6D0E100 Group and plot In\u00a0[12]: Copied! <pre>voyages_market_data_grouped = voyages_market_data.groupby(['Date', 'fixture_status']).size().reset_index(name=\"Count\")\nvoyages_market_data_grouped.sort_values(['Date'], ascending = True, inplace = True)\nvoyages_market_data_grouped.tail()\n</pre> voyages_market_data_grouped = voyages_market_data.groupby(['Date', 'fixture_status']).size().reset_index(name=\"Count\") voyages_market_data_grouped.sort_values(['Date'], ascending = True, inplace = True) voyages_market_data_grouped.tail() Out[12]: Date fixture_status Count 467 2022-08 FullyFixed 58 466 2022-08 Failed 5 468 2022-08 OnSubs 110 469 2022-09 FullyFixed 3 470 2022-09 OnSubs 7 In\u00a0[13]: Copied! <pre>voyages_market_data_grouped=voyages_market_data_grouped[voyages_market_data_grouped['Date']&gt;='2020-01']\nvoyages_market_data_grouped['Date'] = voyages_market_data_grouped['Date'].astype(str)\n</pre> voyages_market_data_grouped=voyages_market_data_grouped[voyages_market_data_grouped['Date']&gt;='2020-01'] voyages_market_data_grouped['Date'] = voyages_market_data_grouped['Date'].astype(str) In\u00a0[14]: Copied! <pre>fig = px.bar(voyages_market_data_grouped, x=\"Date\", y=\"Count\", color='fixture_status', orientation='v',\n             barmode='group', height=500, width=1000,\n             title='VLCC Fixture Status over time',\n             color_discrete_sequence=px.colors.qualitative.Vivid)\nfig.show()\n</pre> fig = px.bar(voyages_market_data_grouped, x=\"Date\", y=\"Count\", color='fixture_status', orientation='v',              barmode='group', height=500, width=1000,              title='VLCC Fixture Status over time',              color_discrete_sequence=px.colors.qualitative.Vivid) fig.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/jupyter/VoyagesMarketDataAPI/FixtureStatus/#fixtures-status","title":"Fixtures Status\u00b6","text":""},{"location":"examples/jupyter/VoyagesMarketDataAPI/FixtureStatus/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VoyagesMarketDataAPI/RateTrend/","title":"Rate Trend","text":"<p>This example calculates the Crude Oil Tanker Freight Rates For Very Large Crude Carriers (VLCCs) From The Arabian Gulf To China</p> Setup <p>Install the Signal Ocean SDK:</p> In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean <p>Import required libraries / APIs / packages:</p> Import Voyages Market Data API and some additional libraries In\u00a0[1]: Copied! <pre>import pandas as pd\nimport seaborn as sns\n\nfrom signal_ocean import Connection\nfrom signal_ocean.voyages_market_data import VoyagesMarketDataAPI\n</pre> import pandas as pd import seaborn as sns  from signal_ocean import Connection from signal_ocean.voyages_market_data import VoyagesMarketDataAPI <p>Fill in your personal SignalOcean API subscription key acquired here and open a connection:</p> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key <p>Create a connection</p> In\u00a0[3]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesMarketDataAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesMarketDataAPI(connection) Call the API to get market data In\u00a0[2]: Copied! <pre>result = api.get_voyage_market_data(vessel_class_id=84, include_matched_fixture = True, filter_by_matched_fixture = True,\n        include_labels = True)\n</pre> result = api.get_voyage_market_data(vessel_class_id=84, include_matched_fixture = True, filter_by_matched_fixture = True,         include_labels = True) <p>Get matched fixtures into a dataframe</p> In\u00a0[3]: Copied! <pre>fixtures = pd.DataFrame([r.matched_fixture.__dict__ for r in result])\n</pre> fixtures = pd.DataFrame([r.matched_fixture.__dict__ for r in result]) Transform Data <p>Keep columns with rate info and rate type in WS (World Scale)</p> In\u00a0[4]: Copied! <pre>fixtures = fixtures[(~fixtures['rate'].isnull())&amp;(fixtures['rate_type']=='WS')]\n</pre> fixtures = fixtures[(~fixtures['rate'].isnull())&amp;(fixtures['rate_type']=='WS')] <p>Keep columns with info on the desired itinerary: Arabian Gulf to China</p> In\u00a0[5]: Copied! <pre>fixtures = fixtures[(fixtures['load_name'] == 'Arabian Gulf')&amp;(fixtures['discharge_name'] == 'China')]\n</pre> fixtures = fixtures[(fixtures['load_name'] == 'Arabian Gulf')&amp;(fixtures['discharge_name'] == 'China')] <p>Convert to datetime to use in aggregations</p> In\u00a0[6]: Copied! <pre>fixtures['laycan_from'] = pd.to_datetime(fixtures['laycan_from'], errors='coerce', utc=True)\nfixtures.sort_values('laycan_from', inplace = True)\n</pre> fixtures['laycan_from'] = pd.to_datetime(fixtures['laycan_from'], errors='coerce', utc=True) fixtures.sort_values('laycan_from', inplace = True) <p>set date as index and calculate a the 7 days moving average - we use the lacan from as date</p> In\u00a0[7]: Copied! <pre>fixtures.set_index('laycan_from', inplace = True, drop=False)\nfixtures['7_days_moving_average'] = fixtures['rate'].rolling('7D').mean()\n</pre> fixtures.set_index('laycan_from', inplace = True, drop=False) fixtures['7_days_moving_average'] = fixtures['rate'].rolling('7D').mean() <p>extract the day and keep only last done per day</p> In\u00a0[8]: Copied! <pre>fixtures['Date'] = fixtures['laycan_from'].dt.tz_localize(None).dt.to_period('D').dt.to_timestamp()\nfixtures = fixtures.drop_duplicates(subset=['Date'], keep='last')\n</pre> fixtures['Date'] = fixtures['laycan_from'].dt.tz_localize(None).dt.to_period('D').dt.to_timestamp() fixtures = fixtures.drop_duplicates(subset=['Date'], keep='last') Plot the rate moving average and last done In\u00a0[9]: Copied! <pre>sns.set(rc = {'figure.figsize':(15,8)})\n\nstart_date = '2022-01-01'\n\nsns.lineplot(data=fixtures[fixtures['Date']&gt;start_date], x='Date', color='red', y='7_days_moving_average').set_title(\"Rate moving average and last done\")\nsns.scatterplot(data=fixtures[fixtures['Date']&gt;start_date], x='Date', y='rate')\n</pre> sns.set(rc = {'figure.figsize':(15,8)})  start_date = '2022-01-01'  sns.lineplot(data=fixtures[fixtures['Date']&gt;start_date], x='Date', color='red', y='7_days_moving_average').set_title(\"Rate moving average and last done\") sns.scatterplot(data=fixtures[fixtures['Date']&gt;start_date], x='Date', y='rate') Out[9]: <pre>&lt;AxesSubplot:title={'center':'Rate moving average and last done'}, xlabel='Date', ylabel='7_days_moving_average'&gt;</pre>"},{"location":"examples/jupyter/VoyagesMarketDataAPI/RateTrend/#rate-trend","title":"Rate Trend\u00b6","text":""},{"location":"examples/jupyter/VoyagesMarketDataAPI/RateTrend/#run-this-example-in-colab","title":"Run this example in Colab\u00b6","text":""},{"location":"examples/jupyter/VoyagesMarketDataAPI/VoyagesMarketDataAPIExample/","title":"VoyagesMarketDataAPIExample","text":"Voyages Market Data API Example  Run this example in : <p>Colab</p> <p>This Notbook demonstrates some examples of calling the basic API endpoints and the advanced endpoint that provides advanced filtering options.</p> <p>For the basic endpoints, you can use one of the following :</p> <ul> <li>a specific imo</li> <li>a specific voyage_id</li> <li>a specific vessel_class_id</li> <li>a specific vessel_type_id</li> </ul> <p>and use the following (optional) parameters : include_vessel_details, include_fixtures, include_lineups, include_positions, include_matched_fixture, include_labels</p> <p>The advanced endpoint provides you with more options, like :</p> <ul> <li>imos: provide a list of IMOs</li> <li>voyage_ids: provide a list of voyage IDs</li> <li>vessel_class_ids: provide a list of vessel class IDs</li> <li>trade_id</li> <li>fixture_date_from, fixture_date_to, laycan_date_from, laycan_date_to: return market data for the given dates</li> <li>charterer_ids_include, charterer_ids_exclude: include/exclude specific charterer IDs</li> <li>cargo_type_ids_include, cargo_type_ids_exclude: include/exclude specific cargoes</li> <li>sources_include, sources_exclude: include/exclude specific sources</li> <li>include_vessel_details, include_fixtures, include_lineups, include_positions, include_matched_fixture, include_labels</li> </ul> Setup <p>Install the Signal Ocean SDK:</p> In\u00a0[\u00a0]: Copied! <pre>pip install signal-ocean\n</pre> pip install signal-ocean <p>Import Voyages Market Data API and some additional libraries</p> In\u00a0[1]: Copied! <pre>import pandas as pd\nimport seaborn as sns\n\nfrom signal_ocean import Connection\nfrom signal_ocean.voyages_market_data import VoyagesMarketDataAPI\n</pre> import pandas as pd import seaborn as sns  from signal_ocean import Connection from signal_ocean.voyages_market_data import VoyagesMarketDataAPI <p>Fill in your personal SignalOcean API subscription key acquired here and open a connection:</p> In\u00a0[2]: Copied! <pre>signal_ocean_api_key = '' #replace with your subscription key\n</pre> signal_ocean_api_key = '' #replace with your subscription key <p>Create a connection</p> In\u00a0[3]: Copied! <pre>connection = Connection(signal_ocean_api_key)\napi = VoyagesMarketDataAPI(connection)\n</pre> connection = Connection(signal_ocean_api_key) api = VoyagesMarketDataAPI(connection) Get market data including matched fixtures for a given vessel class (VLCCs) In\u00a0[2]: Copied! <pre>result = api.get_voyage_market_data(vessel_class_id=84, include_matched_fixture = True, include_vessel_details = True, include_labels = True, filter_by_matched_fixture = True)\n</pre> result = api.get_voyage_market_data(vessel_class_id=84, include_matched_fixture = True, include_vessel_details = True, include_labels = True, filter_by_matched_fixture = True) In\u00a0[3]: Copied! <pre>## Get return data into a dataframe\nvoyages_market_data = pd.DataFrame([r.__dict__ for r in result])\nvoyages_market_data.head()\n</pre> ## Get return data into a dataframe voyages_market_data = pd.DataFrame([r.__dict__ for r in result]) voyages_market_data.head() Out[3]: id voyage_id imo voyage_number vessel_name vessel_type_id vessel_type vessel_class_id vessel_class trade_id trade commercial_operator_id commercial_operator deadweight year_built matched_fixture fixtures 0 MI8A2F75VED1A16F00 I8A2F75VED1A16F00 9056117 50 Symeon II 1 Tanker 84 VLCC 1 Crude 1299.0 Polembros Shipping 277095 1994 MatchedFixture(fixture_status_id=1, fixture_st... None 1 MI8B5F18VED1A16F00 I8B5F18VED1A16F00 9133848 69 S Tajimare 1 Tanker 84 VLCC 1 Crude 435.0 Dynacom Tankers 265539 1996 MatchedFixture(fixture_status_id=1, fixture_st... None 2 MI8B98DBVED179E200 I8B98DBVED179E200 9148635 34 DS Velvet 1 Tanker 84 VLCC 1 Crude 510.0 Nayara 301438 1999 MatchedFixture(fixture_status_id=1, fixture_st... None 3 MI8BC5FEVED1944000 I8BC5FEVED1944000 9160190 41 Kym 1 Tanker 84 VLCC 1 Crude 1906.0 Embiricos Group 298324 1998 MatchedFixture(fixture_status_id=1, fixture_st... None 4 MI8BC5FEVED1C8FC00 I8BC5FEVED1C8FC00 9160190 42 Kym 1 Tanker 84 VLCC 1 Crude 1906.0 Embiricos Group 298324 1998 MatchedFixture(fixture_status_id=1, fixture_st... None In\u00a0[4]: Copied! <pre>## Get matched fixtures seperately into a dataframe\nmatched_fixtures = pd.DataFrame([r.matched_fixture.__dict__ for r in result])\nmatched_fixtures.head()\n</pre> ## Get matched fixtures seperately into a dataframe matched_fixtures = pd.DataFrame([r.matched_fixture.__dict__ for r in result]) matched_fixtures.head() Out[4]: fixture_status_id fixture_status charter_type_id charter_type fixture_date charterer_id charterer laycan_from laycan_to load_geo_id ... redelivery_to_taxonomy_id redelivery_to_taxonomy user_entries full_fixtures partial_fixtures is_coa is_owners_option is_hold is_fio sources 0 1 FullyFixed 0 Voyage 2017-11-24 18:43:41.780000+00:00 180.0 Bharat Oman Refineries 2017-11-28 00:00:00+00:00 2017-11-28 23:59:59+00:00 24777.0 ... None None 0 2 0 None None None None (TI app,) 1 1 FullyFixed 0 Voyage 2018-01-09 16:31:15.390000+00:00 718.0 Indian Oil 2018-01-16 00:00:00+00:00 2018-01-17 23:59:59+00:00 24777.0 ... None None 0 8 0 None None None None (TI app,) 2 1 FullyFixed 0 Voyage 2017-12-15 00:00:00+00:00 2108.0 Mangalore Refinery and Petrochemicals 2017-12-27 00:00:00+00:00 2017-12-28 23:59:59+00:00 24777.0 ... None None 0 1 0 None None None None (TI app,) 3 1 FullyFixed 0 Voyage 2017-11-17 00:00:00+00:00 180.0 Bharat Oman Refineries 2017-12-03 00:00:00+00:00 2017-12-03 23:59:59+00:00 24777.0 ... None None 0 2 0 None None None None (TI app,) 4 1 FullyFixed 0 Voyage 2017-12-08 12:34:17.167000+00:00 180.0 Bharat Oman Refineries 2017-12-29 00:00:00+00:00 2017-12-29 23:59:59+00:00 24777.0 ... None None 0 8 0 None None None None (TI app,) <p>5 rows \u00d7 57 columns</p> Get market data including fixtures for a given vessel class (VLCCs) In\u00a0[5]: Copied! <pre>result = api.get_voyage_market_data(vessel_class_id=84, include_fixtures = True, include_vessel_details = True,\n        include_labels = True)\n</pre> result = api.get_voyage_market_data(vessel_class_id=84, include_fixtures = True, include_vessel_details = True,         include_labels = True) In\u00a0[6]: Copied! <pre>## Get return data into a dataframe\nvoyages_market_data = pd.DataFrame([r.__dict__ for r in result])\nvoyages_market_data.head()\n</pre> ## Get return data into a dataframe voyages_market_data = pd.DataFrame([r.__dict__ for r in result]) voyages_market_data.head() Out[6]: id voyage_id imo voyage_number vessel_name vessel_type_id vessel_type vessel_class_id vessel_class trade_id trade commercial_operator_id commercial_operator deadweight year_built matched_fixture fixtures 0 MI8A2F75VED1A16F00 I8A2F75VED1A16F00 9056117 50 Symeon II 1 Tanker 84 VLCC 1 Crude 1299.0 Polembros Shipping 277095 1994 None (Fixture(fixture_id=3546721, is_matched=True, ... 1 MI8B5F18VED1A16F00 I8B5F18VED1A16F00 9133848 69 S Tajimare 1 Tanker 84 VLCC 1 Crude 435.0 Dynacom Tankers 265539 1996 None (Fixture(fixture_id=6250780, is_matched=True, ... 2 MI8B98DBVED179E200 I8B98DBVED179E200 9148635 34 DS Velvet 1 Tanker 84 VLCC 1 Crude 510.0 Nayara 301438 1999 None (Fixture(fixture_id=6285170, is_matched=True, ... 3 MI8B98DBVED1C8FC00 I8B98DBVED1C8FC00 9148635 35 DS Velvet 1 Tanker 84 VLCC 1 Crude 248.0 Carl F Peters 301438 1999 None (Fixture(fixture_id=6353657, is_matched=None, ... 4 MI8BC5FEVED1944000 I8BC5FEVED1944000 9160190 41 Kym 1 Tanker 84 VLCC 1 Crude 1906.0 Embiricos Group 298324 1998 None (Fixture(fixture_id=3533624, is_matched=True, ... In\u00a0[7]: Copied! <pre>## Get fixtures seperately into a dataframe\nfixtures = pd.DataFrame(f.__dict__ for fixtures in voyages_market_data['fixtures'].dropna() for f in fixtures)\nfixtures.head()\n</pre> ## Get fixtures seperately into a dataframe fixtures = pd.DataFrame(f.__dict__ for fixtures in voyages_market_data['fixtures'].dropna() for f in fixtures) fixtures.head() Out[7]: fixture_id is_matched is_load_matched is_discharge_matched fixture_status_id fixture_status 0 3546721 True True True NaN None 1 4151663 True True True NaN None 2 6250780 True True True 0.0 OnSubs 3 6251766 True True True 0.0 OnSubs 4 6253238 True True True 0.0 OnSubs In\u00a0[8]: Copied! <pre># Expand the dataframe to have one row per fixture\nvoyages_market_data=voyages_market_data.explode('fixtures').reset_index(drop=True)\nvoyages_market_data.head()\n</pre> # Expand the dataframe to have one row per fixture voyages_market_data=voyages_market_data.explode('fixtures').reset_index(drop=True) voyages_market_data.head() Out[8]: id voyage_id imo voyage_number vessel_name vessel_type_id vessel_type vessel_class_id vessel_class trade_id trade commercial_operator_id commercial_operator deadweight year_built matched_fixture fixtures 0 MI8A2F75VED1A16F00 I8A2F75VED1A16F00 9056117 50 Symeon II 1 Tanker 84 VLCC 1 Crude 1299.0 Polembros Shipping 277095 1994 None Fixture(fixture_id=3546721, is_matched=True, i... 1 MI8A2F75VED1A16F00 I8A2F75VED1A16F00 9056117 50 Symeon II 1 Tanker 84 VLCC 1 Crude 1299.0 Polembros Shipping 277095 1994 None Fixture(fixture_id=4151663, is_matched=True, i... 2 MI8B5F18VED1A16F00 I8B5F18VED1A16F00 9133848 69 S Tajimare 1 Tanker 84 VLCC 1 Crude 435.0 Dynacom Tankers 265539 1996 None Fixture(fixture_id=6250780, is_matched=True, i... 3 MI8B5F18VED1A16F00 I8B5F18VED1A16F00 9133848 69 S Tajimare 1 Tanker 84 VLCC 1 Crude 435.0 Dynacom Tankers 265539 1996 None Fixture(fixture_id=6251766, is_matched=True, i... 4 MI8B5F18VED1A16F00 I8B5F18VED1A16F00 9133848 69 S Tajimare 1 Tanker 84 VLCC 1 Crude 435.0 Dynacom Tankers 265539 1996 None Fixture(fixture_id=6253238, is_matched=True, i... Get market data for a given Vessel In\u00a0[9]: Copied! <pre>result = api.get_voyage_market_data(imo = 9890965, include_fixtures = True, include_matched_fixture = True, include_labels = True)\n</pre> result = api.get_voyage_market_data(imo = 9890965, include_fixtures = True, include_matched_fixture = True, include_labels = True) In\u00a0[10]: Copied! <pre>## Get return data into a dataframe\nvoyages_market_data = pd.DataFrame([r.__dict__ for r in result])\n</pre> ## Get return data into a dataframe voyages_market_data = pd.DataFrame([r.__dict__ for r in result]) Get market data using the advanced endpoint In\u00a0[11]: Copied! <pre># Get market data for vessels classes [84, 85], with laycan date from '2023-01-01'\nresult = api.get_voyage_market_data_advanced(vessel_class_ids = [84, 85], include_vessel_details = True,\n        include_fixtures = True, include_lineups = True, include_positions = True, include_matched_fixture = True,\n        include_labels = True, laycan_date_from = '2023-01-01')\n</pre> # Get market data for vessels classes [84, 85], with laycan date from '2023-01-01' result = api.get_voyage_market_data_advanced(vessel_class_ids = [84, 85], include_vessel_details = True,         include_fixtures = True, include_lineups = True, include_positions = True, include_matched_fixture = True,         include_labels = True, laycan_date_from = '2023-01-01') In\u00a0[12]: Copied! <pre>voyages_market_data = pd.DataFrame([r.__dict__ for r in result])\nvoyages_market_data.head()\n</pre> voyages_market_data = pd.DataFrame([r.__dict__ for r in result]) voyages_market_data.head() Out[12]: id voyage_id imo voyage_number vessel_name vessel_type_id vessel_type vessel_class_id vessel_class trade_id trade commercial_operator_id commercial_operator deadweight year_built matched_fixture fixtures 0 MI8C9C3CVEDB359500 I8C9C3CVEDB359500 9215036 142 Chafa 1 Tanker 85 Suezmax 1 Crude 2386 LMCS Maritime 150678 2001 MatchedFixture(fixture_status_id=1, fixture_st... (Fixture(fixture_id=104321600, is_matched=True... 1 MI8C9C3CVEDB5D2200 I8C9C3CVEDB5D2200 9215036 143 Chafa 1 Tanker 85 Suezmax 1 Crude 2386 LMCS Maritime 150678 2001 MatchedFixture(fixture_status_id=1, fixture_st... (Fixture(fixture_id=105207913, is_matched=True... 2 MI8D1456VEDB359500 I8D1456VEDB359500 9245782 78 Cosglory Lake 1 Tanker 84 VLCC 1 Crude 356 COSCO 299145 2003 MatchedFixture(fixture_status_id=1, fixture_st... (Fixture(fixture_id=105504298, is_matched=True... 3 MI8D1E99VEDB359500 I8D1E99VEDB359500 9248409 83 Seoul Spirit 1 Tanker 85 Suezmax 1 Crude 1663 Teekay Corp 159966 2005 MatchedFixture(fixture_status_id=1, fixture_st... (Fixture(fixture_id=105311802, is_matched=True... 4 MI8D40BDVEDB0E0800 I8D40BDVEDB0E0800 9257149 75 Elizabeth I.A. 1 Tanker 84 VLCC 1 Crude 917 Maran Tankers Management 306229 2004 MatchedFixture(fixture_status_id=1, fixture_st... (Fixture(fixture_id=104633101, is_matched=True... In\u00a0[13]: Copied! <pre>matched_fixtures = pd.DataFrame([r.matched_fixture.__dict__ for r in result])\nmatched_fixtures.head()\n</pre> matched_fixtures = pd.DataFrame([r.matched_fixture.__dict__ for r in result]) matched_fixtures.head() Out[13]: fixture_status_id fixture_status charter_type_id charter_type fixture_date charterer_id charterer laycan_from laycan_to load_geo_id ... redelivery_to_taxonomy_id redelivery_to_taxonomy user_entries full_fixtures partial_fixtures is_coa is_owners_option is_hold is_fio sources 0 1 FullyFixed 0 Voyage 2022-12-19 17:00:42+00:00 180.0 Bharat Oman Refineries 2023-01-05 00:00:00+00:00 2023-01-05 00:00:00+00:00 3778 ... None None 0 8 0 None None None None (galbraiths.co.uk, ssysin.com.sg, ssy.co.uk, s... 1 1 FullyFixed 0 Voyage 2023-01-06 14:40:33+00:00 718.0 Indian Oil 2023-01-26 00:00:00+00:00 2023-01-26 00:00:00+00:00 3778 ... None None 0 10 0 None None None None (southportmaritime.com, ssy.co.uk, galbraiths.... 2 1 FullyFixed 0 Voyage 2023-01-10 16:57:45+00:00 NaN None 2023-01-23 00:00:00+00:00 2023-01-23 00:00:00+00:00 24777 ... None None 0 2 0 None None None None (galbraiths.co.uk, Signal Ocean) 3 1 FullyFixed 0 Voyage 2023-01-09 09:59:01+00:00 1237.0 Petraco 2023-01-25 00:00:00+00:00 2023-01-25 00:00:00+00:00 9763 ... None None 0 4 8 None None None None (southportmaritime.com, ssy.co.uk, Signal Ocea... 4 1 FullyFixed 0 Voyage 2022-12-22 18:03:02+00:00 1928.0 Unipec 2023-01-04 00:00:00+00:00 2023-01-04 00:00:00+00:00 24777 ... None None 0 2 0 None None None None (Signal Ocean, southportmaritime.com) <p>5 rows \u00d7 57 columns</p>"},{"location":"releases/Version%201.0.1.b6/","title":"v1.0.1b6","text":"<p>Download here:</p> <p></p>"},{"location":"releases/Version%201.0.1.b6/#voyages-api-package","title":"Voyages API package","text":""},{"location":"releases/Version%201.0.1.b6/#added-first_load_arrival_date-event_date-fields","title":"Added first_load_arrival_date / event_date fields","text":"<p>Two new fields exposed through the VoyageData API:</p> <p><code>first_load_arrival_date</code>: The arrival date of the first load has been added to the root level to easily calculate ballast leg of the voyage. <code>event_date</code>: The timestamp of the specific event, for instantaneous events e.g. VoyageStart</p>"},{"location":"releases/Version%201.0.1.b6/#adding-extra-information-about-voyage-on-the-response","title":"Adding extra information about voyage on the response","text":"<p><code>HasManualEntries</code>: Boolean. True if the fused matched fixture on a voyage contains at least one (partial or full) fixture input by a user. It indicates that there is additional information input by a user in addition to what received through market reports only</p> <p><code>BallastDistance</code>: Travelled distance in nautical miles between the last discharge port of the previous voyage and the first load port of the current voyage. It is computed based on AIS data. It includes the whole period between the two port calls and non operational stops as well. Accuracy depends on AIS coverage.</p> <p><code>LadenDistance</code>: Travelled distance in nautical miles between the first load port and the last discharge port of the same voyage. It is computed based on AIS data. Accuracy depends on AIS coverage.</p>"},{"location":"releases/Version%201.0.1.b6/#distances-api-package","title":"Distances API package","text":""},{"location":"releases/Version%201.0.1.b6/#add-minimize_seca-restriction","title":"Add minimize_seca restriction","text":"<p><code>minimize_seca</code>: Determines whether or not to minimize distance travelled through SECA areas.</p>"},{"location":"releases/Version%201.0.1.b6/#historical-api-package","title":"Historical API package","text":""},{"location":"releases/Version%201.0.1.b6/#split-large-htl-date-ranges-into-multiple-calls","title":"Split large HTL date ranges into multiple calls","text":"<p>Split calls that fetch data from more than a year to smaller chunks to avoid network timeouts.</p>"},{"location":"releases/Version%201.0.1.b6/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.0.2/","title":"v1.0.2","text":"<p>Download here: </p> <ul> <li> <p>New api integration: Market Rates API package</p> <ul> <li> <p>Added get_market_rates method Exposed the corresponding endpoint of MarketRates API which provides market rates for a given day or period and a route or vessel class.</p> </li> <li> <p>Added get_routes method Exposed the corresponding endpoint of MarketRates API which fetches all routes or the ones matching a given vessel class ID.</p> </li> </ul> </li> <li> <p>All notebook examples available on Colab</p> <p>All notebook examples can now run on Colab.</p> <p>Only thing needed is to provide your subcription key and you can connect through github and run a specific example.</p> </li> </ul>"},{"location":"releases/Version%201.0.2/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.0.3/","title":"v1.0.3","text":"<p>Download here: </p> <ul> <li> <p>New function on voyages data sdk - advanced search:     Utilize the voyages data api to recall data from the advanced search endpoint</p> </li> <li> <p>New examples added</p> <p>Complex example for supply trend generation through our HTL and Market rates APIs.</p> <p>Complex example for comparing 2 different dates in HTL.</p> <p>VoyagesAPI-UseCases.ipynb enhanced with advanced search example.</p> </li> </ul>"},{"location":"releases/Version%201.0.3/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.0.4/","title":"v1.0.4","text":"<p>Download here: </p> <ul> <li> <p>New api integration: Freight Rates API package</p> <ul> <li> <p>Added get_freight_pricing method: Exposed the corresponding endpoint of FreightRates API which provides freight rate given a load port, a discharge port and vessel class.</p> </li> <li> <p>Added get_ports method: Exposed the corresponding endpoint of FreightRates API which fetches all available ports for which we can provide freight rates.</p> </li> <li> <p>Added get_vessel_classes method: Added helper method that returns all available vessel classes for which we can provide freight rates.</p> </li> </ul> </li> <li> <p>Live Tonnage list available under renamed Tonnage List API</p> <ul> <li>Historical Tonnage List API is renamed to Tonnage List API. Old API libraries are deprecated and replacable 1-1 with the new api. Users can now recall data from Signal Ocean Tonnage List in a live format for any time of the day they want to.</li> </ul> </li> <li> <p>Deprecation of Historical Tonnage List API</p> <ul> <li>Users should switch to the new Tonnage List API which replaces 100% the old Historical Tonnage List API.</li> </ul> </li> </ul>"},{"location":"releases/Version%201.0.4/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.0.5/","title":"v1.0.5","text":"<p>Download here: </p> <ul> <li> <p>New api integration: OilX Cargo Tracking API package</p> <ul> <li>Added get_oilx_cargoes method: Exposed the corresponding endpoint of OilX Cargo Tracking API which provides OilX Cargoes given a vessel class.</li> </ul> </li> </ul>"},{"location":"releases/Version%201.0.5/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.0.6/","title":"v1.0.6","text":"<p>Download here: </p>"},{"location":"releases/Version%201.0.6/#voyages-api-package","title":"Voyages API package","text":""},{"location":"releases/Version%201.0.6/#added-horizon-latest_received_ais-predicted_ballast_distance-predicted_laden_distance-fields","title":"Added horizon / latest_received_ais / predicted_ballast_distance / predicted_laden_distance fields","text":"<p>Four new fields exposed through the VoyageData API:</p> <p><code>horizon</code>: It can take \"Historic\", \"Current\" or \"Future\" values, depending on whether the voyage event is in the past (StartDate and EndDate both in the past), is current (StartDate in the past and EndDate in the future) \\ or future (both StartDate and EndDate in the future). Note: the notions of \"past\", \"current\" and \"future\" are not derived by the current date, but by the comparison between the voyage dates and the latest received AIS for that specific vessel.</p> <p><code>latest_received_ais</code>: The most recent AIS update for the vessel. It is used to define the horizon of a voyage and its events.</p> <p><code>predicted_ballast_distance</code>: Computed distance of the ballast leg based on our distance model, in nautical miles. For current voyage, when vessel is ballast, it is the remaining distance between the vessel position and the first load port. For historical legs PredictedBallastDistance is empty.</p> <p><code>predicted_laden_distance</code>: Computed distance of the laden leg based on our distance model, in nautical miles. For current voyage, when vessel is laden, it is the remaining distance between the vessel position and the last discharge port. For historical legs PredictedLadenDistance is empty.</p>"},{"location":"releases/Version%201.0.6/#notebook-examples-additions","title":"Notebook examples additions","text":""},{"location":"releases/Version%201.0.6/#geo-api","title":"Geo API","text":"<p>Added a simple notebook example how to use the library and generate the Geo hierarchy</p>"},{"location":"releases/Version%201.0.6/#freight-rates-api","title":"Freight rates API","text":"<p>Display freight instead of flat rate in freight pricing notebook example</p>"},{"location":"releases/Version%201.0.6/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.0.8/","title":"v1.0.8","text":"<p>Download here: </p>"},{"location":"releases/Version%201.0.8/#voyages-api-package","title":"Voyages API package","text":""},{"location":"releases/Version%201.0.8/#added-get_vessel_classes-get_vessel_types-get_imos-methods","title":"Added get_vessel_classes / get_vessel_types / get_imos methods","text":"<p>Three new methods exposed through the VoyageData API:</p> <p><code>get_vessel_classes</code>: The purpose of this method is to retrieve all available vessel classes. It can be called also using the newly added VesselClassFilter, which allows filtering the response based on a string.</p> <p><code>get_vessel_types</code>: The purpose of this method is to retrieve all available vessel types. It can be called also using the newly added VesselTypeFilter, which allows filtering the response based on a string.</p> <p><code>get_imos</code>: The purpose of this method is to retrieve all available vessels. It can be called also using the newly added VesselFilter, which allows filtering vessel names based on a string.</p>"},{"location":"releases/Version%201.0.8/#notebook-examples-additions","title":"Notebook examples additions","text":""},{"location":"releases/Version%201.0.8/#get-available-vessel-types-vessel-classes-vessels","title":"Get available vessel types, vessel classes, vessels","text":"<p>Added a simple notebook example how to use the aforementioned methods.</p>"},{"location":"releases/Version%201.0.8/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.0.9/","title":"v1.0.9","text":"<p>Download here: </p>"},{"location":"releases/Version%201.0.9/#added-port-congestion-package","title":"Added Port Congestion package","text":"<p>One derivative of the voyages data is the calculation of various metrics regarding Port Congestion. We have added a new package that retrieves voyages data from Signal's Voyages Data API and calculates the following: - Number of vessels in ports/areas of interest over time  - Waiting time of vessels in ports/areas of interest over time - Live Port Congestion in ports/areas of interest  </p>"},{"location":"releases/Version%201.0.9/#added-get_port_congestion-method","title":"Added get_port_congestion method","text":"<p>Method to retrive congestion data. It returns the following:</p> <p><code>VesselsCongestionData</code>: A DataFrame that stems from preprocessing the voyages data. It is used as a basis dataset, which is then manipulated to calculate the congestion.</p> <p><code>NumberOfVesselsOverTime</code>: DataFrame that holds information about the number of vessels at port point in time.</p> <p><code>WaitingTimeOverTime</code>: DataFrame that holds information about the average waiting time of vessels at port point in time.</p> <p><code>LiveCongestion</code>: DataFrame that describes the current situation regarding waiting and operatin vessels.</p>"},{"location":"releases/Version%201.0.9/#notebook-examples-update","title":"Notebook examples update","text":""},{"location":"releases/Version%201.0.9/#port_congestion_in_china_capes","title":"Port_Congestion_in_China_(Capes)","text":"<p>Updated the notebook to consume the Port Congestion Package</p>"},{"location":"releases/Version%201.0.9/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.0/","title":"v1.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.0/#removed-oilx-cargo-tracking-api-package","title":"Removed OilX Cargo Tracking API Package","text":""},{"location":"releases/Version%201.1.0/#added-scraped-fixtures-api","title":"Added Scraped Fixtures API","text":"<p>The goal of Scraped Fixtures API is to collect and return the fixtures by the given filters.  </p>"},{"location":"releases/Version%201.1.0/#added-get_fixtures","title":"Added get_fixtures","text":"<p>Method to retrieve the fixtures data.  The required parameters of this function are:</p> <p><code>received_date_from</code>: The received fixtures should have received date greater than this date </p> <p><code>vessel_type</code>: The vessel type of the vessels</p> <p>Also, the user can request fixtures for a specific vessel class or/and using a port id. The deleted fixtures are excluded from the results</p> <p>The funtion returns a list of Scraped Fixtures. The fields of Scraped fixtures  are defined in models file </p>"},{"location":"releases/Version%201.1.0/#notebook-examples-update","title":"Notebook examples update","text":""},{"location":"releases/Version%201.1.0/#scrapedfixturesapi","title":"ScrapedFixturesAPI","text":"<p>Example which describes how the user can extract the fixtures for VLCC in the last 7 days.</p>"},{"location":"releases/Version%201.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.1/","title":"v1.1.1","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.1/#updated-freight-rates-api","title":"Updated Freight Rates API","text":""},{"location":"releases/Version%201.1.1/#updated-get_freight_pricing-response-model","title":"Updated get_freight_pricing response model","text":"<p>Added field <code>other_port_expenses</code> under <code>costs</code>.</p>"},{"location":"releases/Version%201.1.1/#notebook-examples-update","title":"Notebook examples update","text":""},{"location":"releases/Version%201.1.1/#freightratesapi","title":"FreightRatesAPI","text":"<p>Updated the example of getting freight rates for specific ports to include <code>other_port_expenses</code> field.</p>"},{"location":"releases/Version%201.1.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.2/","title":"v1.1.2","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.2/#updated-scraped-fixtures-api","title":"Updated Scraped Fixtures API","text":""},{"location":"releases/Version%201.1.2/#updated-get_fixtures-function","title":"Updated get_fixtures function","text":"<p>Change data type for field <code>received_date_from</code> from date to datetime. Set field <code>received_date_from</code> Optional. Set field <code>vessel_type</code> Optional. Change data type for field <code>received_date_to</code> from date to datetime. Change data type for field <code>updated_date_from</code> from date to datetime. Change data type for field <code>updated_date_to</code> from date to datetime.</p>"},{"location":"releases/Version%201.1.2/#updated-scraped-fixtures-model","title":"Updated Scraped Fixtures model","text":"<p>Rename field <code>charterer_type</code> to <code>charter_type</code></p>"},{"location":"releases/Version%201.1.2/#notebook-examples-update","title":"Notebook examples update","text":""},{"location":"releases/Version%201.1.2/#update-scraped-fixtures-api-example","title":"Update Scraped Fixtures API Example","text":"<p>Updated the example by using datetime instead of date for <code>received_date_to</code> field</p>"},{"location":"releases/Version%201.1.2/#add-new-example-latest-received-scraped-fixtures","title":"Add new example (Latest Received Scraped Fixtures)","text":"<p>This example uses the Scraped Fixture API in order to get the latest fixtures for tanker and dry. The final results are exported to csv files.</p>"},{"location":"releases/Version%201.1.2/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.3/","title":"v1.1.3","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.3/#updated-setuppy","title":"Updated setup.py","text":"<p>Added <code>numpy</code> and <code>strictly-typed-pandas</code> packages as required dependencies on signal-ocean library. </p>"},{"location":"releases/Version%201.1.3/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.4/","title":"v1.1.4","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.4/#updated-setuppy","title":"Updated setup.py","text":"<p>Added <code>typeguard</code> package as a required dependency on signal-ocean library. </p>"},{"location":"releases/Version%201.1.4/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.5/","title":"v1.1.5","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.5/#updated-freight-rates-api","title":"Updated Freight Rates API","text":""},{"location":"releases/Version%201.1.5/#updated-get_ports-response-model","title":"Updated get_ports response model","text":"<p>Fill in fields <code>country</code> and <code>area</code> of <code>Port</code> model.</p>"},{"location":"releases/Version%201.1.5/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.6/","title":"v1.1.6","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.6/#removed-vessels-api","title":"Removed Vessels API","text":""},{"location":"releases/Version%201.1.6/#updated-voyages-api-models","title":"Updated Voyages API models.","text":"<p>Added deadweight attribute in Voyage class.</p>"},{"location":"releases/Version%201.1.6/#notebook-updates","title":"Notebook updates","text":""},{"location":"releases/Version%201.1.6/#cargoflows","title":"CargoFlows","text":"<p>Removed Vessels API dependency</p>"},{"location":"releases/Version%201.1.6/#toncharts","title":"TonCharts","text":"<p>Removed Vessels API dependency</p>"},{"location":"releases/Version%201.1.6/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.7/","title":"v1.1.7","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.7/#updated-voyages-api-models","title":"Updated Voyages API models.","text":"<p>Added new attributes in Voyage class: <code>horizon_id, pit_vessel_name, year_built, suez_crossing, panama_crossing, canakkale_crossing, bosporus_crossing</code>. Also added new attribute in VoyageEventDetail class: <code>sts_id</code>.</p>"},{"location":"releases/Version%201.1.7/#added-new-voyagecondensed-model","title":"Added new VoyageCondensed model.","text":"<p>Contains information about a single voyage of a vessel and details the events that took place during the voyage.</p>"},{"location":"releases/Version%201.1.7/#added-new-voyages-api-methods","title":"Added new Voyages API methods.","text":"<p>New methods: <code>get_voyages_condensed, get_incremental_voyages_condensed, get_voyages_flat_by_advanced_search, get_voyages_condensed_by_advanced_search</code>.</p>"},{"location":"releases/Version%201.1.7/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.8/","title":"v1.1.8","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.8/#updated-voyages-api-models","title":"Updated Voyages API models.","text":"<p>Add attribute <code>quantity_source</code> in Voyage class.</p>"},{"location":"releases/Version%201.1.8/#update-voyages-api-functions","title":"Update Voyages API functions.","text":"<p>Add parameters in advanced endpoint <code>imos, voyage-keys, event_horizons, event_purposes, vessel_class_ids, port_id, port_ids, voyage_horizons</code>.  </p>"},{"location":"releases/Version%201.1.8/#updated-voyages-documentation","title":"Updated Voyages Documentation","text":"<p>Fixed an issue, made some additional changes and reactivated voyage api documentation.</p>"},{"location":"releases/Version%201.1.8/#updated-voyage-api-documentation","title":"Updated Voyage API documentation.","text":"<p>Fixed an issue that was blocking the build of voyages_api documentation. Made some additional changes to improve clarity.</p>"},{"location":"releases/Version%201.1.8/#updated-voyage-models-documentation","title":"Updated Voyage models documentation.","text":"<p>Fixed identation warnings.</p>"},{"location":"releases/Version%201.1.8/#reactivated-voyages_api-documentation","title":"Reactivated voyages_api documentation","text":""},{"location":"releases/Version%201.1.8/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.1.9/","title":"v1.1.9","text":"<p>Download here: </p>"},{"location":"releases/Version%201.1.9/#new-api-integration-voyage-market-data-api-package","title":"New api integration: Voyage Market Data API package","text":"<p>Created the SDK for Voyage Market Data API</p>"},{"location":"releases/Version%201.1.9/#added-get_voyage_market_data-method","title":"Added get_voyage_market_data method.","text":"<p>Exposed the corresponding endpoint of Voyage Market Data API.</p>"},{"location":"releases/Version%201.1.9/#two-examples-added","title":"Two examples added.","text":"<p>VLCC Market rate calculation between A.Gulf and China Number of fixtures per month, grouped by status for VLCCs</p>"},{"location":"releases/Version%201.1.9/#updated-helper-function-request_helperspy","title":"Updated helper function request_helpers.py","text":"<p>Added Optional argument for nested data info on response</p>"},{"location":"releases/Version%201.1.9/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.2.0/","title":"v1.2.0","text":"<p>Download here: </p>"},{"location":"releases/Version%201.2.0/#added-scraped-cargoes-api","title":"Added Scraped Cargoes API","text":""},{"location":"releases/Version%201.2.0/#scraped-cargoes-api-methods","title":"Scraped Cargoes API Methods","text":"<ul> <li><code>get_cargoes</code>: Retrieve cargoes within specific date range.</li> <li><code>get_cargoes_by_cargo_ids</code>: Retrieve cargoes by <code>cargo_ids</code>.</li> </ul>"},{"location":"releases/Version%201.2.0/#added-scraped-positions-api","title":"Added Scraped Positions API","text":""},{"location":"releases/Version%201.2.0/#scraped-positions-api-methods","title":"Scraped Positions API Methods","text":"<ul> <li><code>get_positions</code>: Retrieve positions for specific date range and/or specific IMOs.</li> <li><code>get_positions_by_position_ids</code>: Retrieve positions by <code>position_ids</code>.</li> </ul>"},{"location":"releases/Version%201.2.0/#updated-scraped-fixtures-api","title":"Updated Scraped Fixtures API","text":""},{"location":"releases/Version%201.2.0/#updated-scraped-fixtures-api-models","title":"Updated Scraped Fixtures API models","text":"<ul> <li>Added attribute <code>delivery_taxonomy</code> in <code>ScrapedFixture</code> class.</li> <li>Renamed attribute <code>scraped_year_build</code> to <code>scraped_year_built</code> in <code>ScrapedFixture</code> class.</li> <li>Renamed attribute <code>year_build</code> to <code>year_built</code> in <code>ScrapedFixture</code> class.</li> <li>Removed attribute <code>reported_fixture_date</code> from <code>ScrapedFixture</code> class.</li> <li>Added <code>ScrapedFixturesResponse</code> class.</li> </ul>"},{"location":"releases/Version%201.2.0/#updated-scraped-fixtures-api-methods","title":"Updated Scraped Fixtures API Methods","text":"<ul> <li>Added parameter in <code>get_fixtures</code> method <code>imos</code>.</li> <li>Renamed parameter <code>include_fixture_details</code> to <code>include_details</code>.</li> <li>Removed parameters <code>vessel_class_id</code>, <code>port_id</code>.</li> <li>Added method <code>get_fixtures_by_fixture_ids</code> to retrieve fixtures by <code>fixture_ids</code>.</li> </ul>"},{"location":"releases/Version%201.2.0/#updated-notebook-examples","title":"Updated Notebook Examples","text":"<ul> <li>Removed LatestReceivedScrapedFixtures example.</li> <li>Updated Scraped Fixtures API Example to present the whole functionality.</li> </ul>"},{"location":"releases/Version%201.2.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.2.1/","title":"v1.2.1","text":"<p>Download here: </p>"},{"location":"releases/Version%201.2.1/#new-api-integration-vessels-api-package","title":"New api integration: Vessels API package","text":"<p>Created the SDK for Vessels API</p>"},{"location":"releases/Version%201.2.1/#added-get_vessels-method","title":"Added get_vessels method.","text":"<p>Exposed the corresponding endpoint of Vessels API.</p>"},{"location":"releases/Version%201.2.1/#example-added","title":"Example added.","text":"<p>Explore Vessel Particulars</p>"},{"location":"releases/Version%201.2.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.2.2/","title":"v1.2.2","text":"<p>Download here: </p>"},{"location":"releases/Version%201.2.2/#added-scraped-lineups-api","title":"Added Scraped Lineups API","text":""},{"location":"releases/Version%201.2.2/#scraped-lineups-api-methods","title":"Scraped Lineups API Methods","text":"<ul> <li><code>get_lineups</code>: Retrieve lineups for specific date range and/or specific IMOs.</li> <li><code>get_lineups_by_lineup_ids</code>: Retrieve lineups by <code>lineup_ids</code>.</li> </ul>"},{"location":"releases/Version%201.2.2/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.2.3/","title":"v1.2.3","text":"<p>Download here: </p>"},{"location":"releases/Version%201.2.3/#scraped-lineups-api","title":"Scraped Lineups API","text":"<ul> <li>Added attribute <code>scraped_imo</code> in <code>ScrapedLineup</code></li> <li>Updated Scraped Lineups API Example notebook</li> </ul>"},{"location":"releases/Version%201.2.3/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.2.4/","title":"v1.2.4","text":"<p>Download here: </p>"},{"location":"releases/Version%201.2.4/#changed-examples-of-voyages-api","title":"Changed Examples of Voyages API","text":"<ul> <li>Removed CargoFlows Example</li> <li>Added Oil Flows Example</li> <li>Added Dry Bulk Flows Example</li> </ul>"},{"location":"releases/Version%201.2.4/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%201.2.5/","title":"v1.2.5","text":"<p>Download here: </p>"},{"location":"releases/Version%201.2.5/#market-rates-api","title":"Market Rates API","text":"<ul> <li>Add is_clean as parameter in get_market_rates function</li> <li>Add is_clean to  the supply trend with market rates example </li> </ul>"},{"location":"releases/Version%201.2.5/#example-jupyter-notebooks","title":"Example Jupyter Notebooks","text":"<ul> <li>Updated Scraped Cargoes API Example notebook</li> <li>Updated Scraped Fixtures API Example notebook</li> <li>Updated Scraped Lineups API Example notebook</li> <li>Updated Scraped Positions API Example notebook</li> </ul>"},{"location":"releases/Version%201.2.5/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2010.0.0/","title":"v10.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2010.0.0/#vessels-api","title":"Vessels API","text":"<ul> <li>Update with new endpoints of v2</li> <li>Addition of new field in Vessel model</li> <li>Remove the optional parameter point_in_time from get_vessels_by_vessel_class()</li> </ul>"},{"location":"releases/Version%2010.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2010.1.0/","title":"v10.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2010.1.0/#voyagesdata-api","title":"VoyagesData API","text":"<ul> <li>Update to VoyagesData v4</li> </ul>"},{"location":"releases/Version%2010.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2010.2.0/","title":"v10.2.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2010.2.0/#voyagesmarketdata-api","title":"VoyagesMarketData API","text":"<ul> <li>Add 'filter_by_matched_fixture' paramter to endpoints</li> </ul>"},{"location":"releases/Version%2010.2.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2010.3.0/","title":"v10.3.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2010.3.0/#voyagesdata-api","title":"VoyagesData API","text":"<ul> <li>Fix bug for users with access only to v4</li> </ul>"},{"location":"releases/Version%2010.3.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2010.4.0/","title":"v10.4.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2010.4.0/#vessels-api","title":"Vessels API","text":"<ul> <li>Add fields to Vessels (Minimum Temperature, Maximum Pressure, Ammonia, VCM, Ethylene)</li> </ul>"},{"location":"releases/Version%2010.4.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2010.5.0/","title":"v10.5.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2010.5.0/#vessels-api","title":"Vessels API","text":"<ul> <li>Add fields to Vessels (BallastParallelBodyLength, EmptyParallelBodyLength, SternLine,YardNumber,DesignModel ,BowToCenterManifold,WaterLineToManifold,DeckToCenterManifold,RailToCenterManifold).</li> </ul>"},{"location":"releases/Version%2010.5.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2010.6.0/","title":"v10.6.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2010.6.0/#tonnage-list-api","title":"Tonnage List API","text":"<ul> <li>Fixed wrong mapping of current_vessel_sub_type field</li> </ul>"},{"location":"releases/Version%2010.6.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2010.7.0/","title":"v10.7.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2010.7.0/#voyages-data-api","title":"Voyages Data API","text":"<ul> <li>Fix filtering with start_date_from</li> </ul>"},{"location":"releases/Version%2010.7.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2011.0.0/","title":"v11.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2011.0.0/#scraped-data-api","title":"Scraped Data API","text":"<ul> <li>Upgrade version to v6.0 for all 4 APIs</li> <li>Add low_confidence field in contracts</li> <li>Merge get_data_by_entity_ids under get_data function</li> <li>Update example notebooks</li> <li>Introduce incremental endpoints</li> </ul>"},{"location":"releases/Version%2011.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2011.1.0/","title":"v11.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2011.1.0/#voyages-data-api","title":"Voyages Data API","text":"<ul> <li>Added missing fields and updated descriptions<ul> <li>Voyage: <code>cargo_group_source_id, cargo_group_source, torres_strait_crossing, magellan_strait_crossing, great_belt_crossing</code></li> <li>VoyageEvent: <code>event_type_id, event_horizon_id, port_unlocode</code></li> <li>VoyageCondenced: <code>starting_port_unlocode, first_load_port_unlocode, last_discharge_port_unlocode</code></li> </ul> </li> </ul>"},{"location":"releases/Version%2011.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2012.0.0/","title":"v12.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2012.0.0/#vessels-api","title":"Vessels API","text":"<ul> <li>Added missing fields <code>BowChainStopperDetailsAsStr, BowChainStoppersFitted,NumberOfBowChainStoppers, NumberOfCranes, NumberOfGrabs, NumberOfHatches</code></li> <li>Fix mapping of fields <code>IMOType1, IMOType2, IMOType3</code> so they can load data</li> <li>Rename <code>te_u14</code> to <code>teu14</code> (Breaking Change)</li> </ul>"},{"location":"releases/Version%2012.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2012.1.0/","title":"v12.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2012.1.0/#geos-api","title":"Geos API","text":"<ul> <li>Added new fields for GeoAssets: <code>GeoAssetTypeID, GeoAssetTypeName, VesselClassAssociations</code></li> <li>Added new field for Ports: <code>VesselClassAssociations</code></li> <li>Updated field descriptions</li> </ul>"},{"location":"releases/Version%2012.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2012.1.1/","title":"v12.1.1","text":"<p>Download here: </p>"},{"location":"releases/Version%2012.1.1/#vessel-emissions-api","title":"Vessel Emissions API","text":"<ul> <li>Updated/added example jupyter notebooks.</li> </ul>"},{"location":"releases/Version%2012.1.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2012.1.2/","title":"v12.1.2","text":"<p>Download here: </p>"},{"location":"releases/Version%2012.1.2/#vessel-emissions-api","title":"Vessel Emissions API","text":"<ul> <li>Fixed broken URLs in jupyter examples.</li> </ul>"},{"location":"releases/Version%2012.1.2/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2012.1.3/","title":"v12.1.3","text":"<p>Download here: </p>"},{"location":"releases/Version%2012.1.3/#vessel-emissions-api","title":"Vessel Emissions API","text":"<ul> <li>Added signal-ocean installation step and fixed paths in mkdocs.yml</li> </ul>"},{"location":"releases/Version%2012.1.3/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2012.1.4/","title":"v12.1.4","text":"<p>Download here: </p>"},{"location":"releases/Version%2012.1.4/#voyages-data-api","title":"Voyages Data API","text":"<ul> <li>Fixed broken Colab Floating Storages example.</li> </ul>"},{"location":"releases/Version%2012.1.4/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2013.0.0/","title":"v13.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.0.0/#port-congestion-api","title":"Port Congestion API","text":"<ul> <li>Deprecated API removal.</li> </ul>"},{"location":"releases/Version%2013.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2013.1.0/","title":"v13.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.1.0/#companies-api","title":"Companies API","text":"<ul> <li>Add Seller and Buyer VesselTypes on response</li> </ul>"},{"location":"releases/Version%2013.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2013.2.0/","title":"v13.2.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.2.0/#voyages-api","title":"Voyages API","text":"<ul> <li>Ensure in VoyagesFlat the Geos are distinct</li> </ul>"},{"location":"releases/Version%2013.2.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%2013.2.1/","title":"v13.2.1","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.2.1/#combined-examples","title":"Combined Examples","text":"<ul> <li>Add 2 new examples displaying how to make Suppply trends using tonnage List API and comparing them with the Market Rates.     Notebooks:<ul> <li>MR2 ARA Supply versus Market Rates</li> <li>VLCCs MEG-China Supply Trend versus Market Rates with Filtering</li> </ul> </li> </ul>"},{"location":"releases/Version%2013.3.0/","title":"v13.3.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.3.0/#package-requirements","title":"Package Requirements","text":"<ul> <li>Changed the minimum required version of <code>pandas</code> to 1.0.3.</li> </ul>"},{"location":"releases/Version%2013.3.1/","title":"v13.3.1","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.3.1/#add-new-python-sdk-examples-a-minor-fix","title":"Add New Python SDK Examples &amp; a minor fix","text":"<ol> <li>Add 3 new Voyages API examples.</li> <li>Add 1 new Scraped Cargoes API example.</li> <li>Apply a minor fix in the Vessel Emissions API example (third example) by uncommenting the pip install signal-ocean line as shown in the provided link.</li> </ol>"},{"location":"releases/Version%2013.3.2/","title":"v13.3.2","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.3.2/#voyages-api","title":"Voyages API","text":""},{"location":"releases/Version%2013.3.2/#added-new-field-vesselsanctionedby-in-voyages-api","title":"Added new field VesselSanctionedBy in Voyages API.","text":"<pre><code>String, includes overlapping sanctions from different organizations that were active during the voyage period. The organizations that sanctioned the vessel are listed as comma-separated values (e.g., \"OFAC, OFSI, UN\").\n</code></pre>"},{"location":"releases/Version%2013.4.0/","title":"v13.4.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.4.0/#vessels-api","title":"Vessels API","text":"<ul> <li>Update Vessels to ingest Vessels API v3</li> <li>Inlcude Sanctions History</li> </ul>"},{"location":"releases/Version%2013.4.1/","title":"v13.4.1","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.4.1/#examples-section-scraped-cargoes","title":"Examples section &gt; Scraped Cargoes","text":"<ul> <li>Added a refreshed iteration of Scraped Cargoes API Geos API Tanker Historical Cargo Distribution in a Level 1 Area. Notebook: <ul> <li>Historical Cargo Distribution in a Level 1 Area</li> </ul> </li> </ul>"},{"location":"releases/Version%2013.4.2/","title":"v13.4.2","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.4.2/#voyages-data-api","title":"Voyages Data API","text":"<ul> <li>Remove Example on Ton Charts</li> </ul>"},{"location":"releases/Version%2013.5.0/","title":"v13.5.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.5.0/#vessels-api","title":"Vessels API","text":"<ul> <li>Add function to get vessels flag history <code>get_vessels_flag_history</code></li> </ul>"},{"location":"releases/Version%2013.6.0/","title":"v13.6.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.6.0/#vessels-api","title":"Vessels API","text":"<ul> <li>Add fields <code>PropulsionType, GasContainmentType, NumberOfBowThrusters</code></li> </ul>"},{"location":"releases/Version%2013.7.0/","title":"v13.7.0","text":"<p>Download here: </p>"},{"location":"releases/Version%2013.7.0/#scraped-fixtures-api","title":"Scraped Fixtures API","text":"<ul> <li>Added fields <code>Note, BrokerID, Broker, DemurrageRateValue, DemurrageRateType</code></li> </ul>"},{"location":"releases/Version%202.0.0/","title":"v2.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%202.0.0/#market-rates-api","title":"Market Rates API","text":"<ul> <li>Switched to v2 endpoints</li> </ul>"},{"location":"releases/Version%202.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%202.0.1/","title":"v2.0.1","text":"<p>Download here: </p>"},{"location":"releases/Version%202.0.1/#tonnage-list-api","title":"Tonnage List API","text":"<ul> <li>Add <code>open_port_id</code> property in the Vessel Class</li> <li>Add <code>commercial_operator_id</code> property in the Vessel Class</li> <li>Add <code>fixture_type</code> property in the Vessel Class</li> <li>Add <code>current_vessel_sub_type_id</code> property in the Vessel Class</li> <li>Add <code>current_vessel_sub_type</code> property in the Vessel Class</li> <li>Add <code>willing_to_switch_current_vessel_sub_type</code> property in the Vessel Class</li> <li>Add <code>id</code> property in the Area Class</li> <li>Add <code>taxonomy_id</code> property in the Area Class</li> <li>Updated: <code>geared</code> property type from <code>bool</code> to <code>Optional[bool]</code> in the Vessel Class</li> <li>Removed: <code>cranes_ton_capacity</code> from the Vessel Class</li> <li>Removed: <code>gear_details</code> from the Vessel Class</li> </ul>"},{"location":"releases/Version%202.0.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%202.1.0/","title":"v2.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%202.1.0/#voyages-api","title":"Voyages API","text":"<ul> <li>Update SDK to use new VoyagesData API V3 endpoints</li> </ul>"},{"location":"releases/Version%202.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%202.1.1/","title":"v2.1.1","text":"<p>Download here: </p>"},{"location":"releases/Version%202.1.1/#scraped-data-apis","title":"Scraped Data APIs","text":"<ul> <li>Handle large amount of Entity IDs</li> </ul>"},{"location":"releases/Version%202.1.1/#voyages-market-data-api","title":"Voyages Market Data API","text":"<ul> <li>Added the advanced POST endpoint</li> <li>Updated VoyagesMarketDataAPIExample Notebook</li> </ul>"},{"location":"releases/Version%202.1.1/#signal-ocean-util","title":"Signal Ocean Util","text":"<ul> <li>Updated request_helpers</li> </ul>"},{"location":"releases/Version%202.1.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%203.0.0/","title":"v3.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%203.0.0/#geos-api","title":"Geos API","text":"<p>-Switch to new Geos API v2</p>"},{"location":"releases/Version%203.0.0/#voyagesmarketdata-api","title":"VoyagesMarketData API","text":"<p>-Add pagination to the advanced endpoint</p>"},{"location":"releases/Version%203.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%204.0.0/","title":"v4.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%204.0.0/#freight-rates-api","title":"Freight Rates API","text":"<p>-Switch to freight pricing v3 endpoint</p>"},{"location":"releases/Version%204.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%205.0.0/","title":"v5.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%205.0.0/#port-expenses-api","title":"Port Expenses API","text":"<p>-Removed redundant fields from response model</p>"},{"location":"releases/Version%205.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%205.1.0/","title":"v5.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%205.1.0/#port-congestion-api-integration","title":"Port Congestion API Integration","text":"<ul> <li>Adds a Port Congestion API Wrapper (<code>PortCongestionAPI</code>)</li> <li>Refactors Waiting Time over Time to utilize the Port Congestion API wrapper instead of   calculating it internally.</li> </ul>"},{"location":"releases/Version%205.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%206.0.0/","title":"v6.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%206.0.0/#port-expenses-api","title":"Port Expenses API","text":"<p>-Removed obsolete group_id parameter</p>"},{"location":"releases/Version%206.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%206.1.0/","title":"v6.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%206.1.0/#geos-api","title":"Geos API","text":"<p>-Add extra fields (CountryCode, CountryCodeNumeric, CountryCodeISO3) to Country model</p>"},{"location":"releases/Version%206.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%206.2.0/","title":"v6.2.0","text":"<p>Download here: </p>"},{"location":"releases/Version%206.2.0/#vessels-api","title":"Vessels API","text":"<p>-Add ParallelBodyLength and HeatingCoilsFitted to Vessel model</p>"},{"location":"releases/Version%206.2.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.0.0/","title":"v7.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%207.0.0/#vesselemissions-api","title":"VesselEmissions API","text":"<p>-Added main components for VesselEmissionsAPI</p>"},{"location":"releases/Version%207.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.1.0/","title":"v7.1.0","text":"<p>Download here: </p>"},{"location":"releases/Version%207.1.0/#vessels-api","title":"Vessels API","text":"<p>-Add GrabsFitted, Ballast Water Treatment System (BWTS) and Green House Gas Rating (GHG) on Vessel model</p>"},{"location":"releases/Version%207.1.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.1.1/","title":"v7.1.1","text":"<p>Download here: </p>"},{"location":"releases/Version%207.1.1/#vesselemissions-api","title":"VesselEmissions API","text":"<ul> <li>Updated VesselEmissionsAPI methods and models</li> </ul>"},{"location":"releases/Version%207.1.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.1.2/","title":"v7.1.2","text":"<p>Download here: </p>"},{"location":"releases/Version%207.1.2/#voyagesdata-api","title":"VoyagesData API","text":"<ul> <li>Upgraded SDK to use VoyagesData API version 3.2.</li> <li>Added an example for Floating Storages.</li> </ul>"},{"location":"releases/Version%207.1.2/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.2.0/","title":"v7.2.0","text":"<p>Download here: </p>"},{"location":"releases/Version%207.2.0/#port-congestion-api","title":"Port Congestion API","text":"<ul> <li>Update Port Congestion API response Models. Adds:<ul> <li><code>QueueLoading</code>: The number of vessels in the queue with <code>Purpose = Loading</code>.</li> <li><code>QueueDischarging</code>: The number of vessels in the queue with <code>Purpose = Discharging</code>.</li> <li><code>AvgEventualDaysByDeparture</code>: Average number of total port days of all vessels departing on this date.</li> </ul> </li> </ul>"},{"location":"releases/Version%207.2.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.2.1/","title":"v7.2.1","text":"<p>Download here: </p>"},{"location":"releases/Version%207.2.1/#vessel-emissions-api","title":"Vessel Emissions API","text":"<ul> <li>Added method to_dict to API return model objects.</li> <li>Added example notebooks for API calls and a Use Case.</li> </ul>"},{"location":"releases/Version%207.2.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.3.0/","title":"v7.3.0","text":"<p>Download here: </p>"},{"location":"releases/Version%207.3.0/#vessel-valuations-api","title":"Vessel Valuations API","text":"<ul> <li>Updated Valuations sub-module to point to v2 endpoints.</li> <li>Updated example notebook.</li> </ul>"},{"location":"releases/Version%207.3.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.3.1/","title":"v7.3.1","text":"<p>Download here: </p>"},{"location":"releases/Version%207.3.1/#voyages-api","title":"Voyages API","text":"<ul> <li>Restore outputs in notebook examples.</li> </ul>"},{"location":"releases/Version%207.3.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.4.0/","title":"v7.4.0","text":"<p>Download here: </p>"},{"location":"releases/Version%207.4.0/#scraped-cargoes-api","title":"Scraped Cargoes API","text":"<ul> <li>Upgraded endpoint to v5.0.</li> <li>Added <code>message_ids</code> and <code>external_message_ids</code> parameters in <code>get_cargoes</code> method.</li> <li>Added <code>external_message_id</code> and <code>subject</code> fields in <code>ScrapedCargo</code>.</li> </ul>"},{"location":"releases/Version%207.4.0/#scraped-fixtures-api","title":"Scraped Fixtures API","text":"<ul> <li>Upgraded endpoint to v5.0.</li> <li>Added <code>message_ids</code> and <code>external_message_ids</code> parameters in <code>get_fixtures</code> method.</li> <li>Added <code>external_message_id</code> and <code>subject</code> fields in <code>ScrapedFixture</code>.</li> </ul>"},{"location":"releases/Version%207.4.0/#scraped-lineups-api","title":"Scraped Lineups API","text":"<ul> <li>Upgraded endpoint to v5.0.</li> <li>Added <code>message_ids</code> and <code>external_message_ids</code> parameters in <code>get_lineups</code> method.</li> <li>Added <code>external_message_id</code> field in <code>ScrapedLineup</code>.</li> </ul>"},{"location":"releases/Version%207.4.0/#scraped-positions-api","title":"Scraped Positions API","text":"<ul> <li>Upgraded endpoint to v5.0.</li> <li>Added <code>message_ids</code> and <code>external_message_ids</code> parameters in <code>get_positions</code> method.</li> <li>Added <code>external_message_id</code> and <code>subject</code> fields in <code>ScrapedPosition</code>.</li> </ul>"},{"location":"releases/Version%207.4.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%207.5.0/","title":"v7.5.0","text":"<p>Download here: </p>"},{"location":"releases/Version%207.5.0/#pandas-v2","title":"Pandas v2","text":"<ul> <li>Support Pandas v2.</li> <li>Adjusted APIs and Examples.</li> </ul>"},{"location":"releases/Version%207.5.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%208.0.0/","title":"v8.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%208.0.0/#pandas-v2","title":"Pandas v2","text":"<ul> <li>Support Pandas v2.</li> <li>Adjusted APIs and Examples.</li> </ul>"},{"location":"releases/Version%208.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%209.0.0/","title":"v9.0.0","text":"<p>Download here: </p>"},{"location":"releases/Version%209.0.0/#port-expenses-api","title":"Port Expenses API","text":"<ul> <li>Removed port_agents and port_canal from response model.</li> </ul>"},{"location":"releases/Version%209.0.0/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"},{"location":"releases/Version%209.0.1/","title":"v9.0.1","text":"<p>Download here: </p>"},{"location":"releases/Version%209.0.1/#vesselemissions-api","title":"VesselEmissions API","text":"<ul> <li>Updated VesselEmissionsAPI Use Case notebook</li> </ul>"},{"location":"releases/Version%209.0.1/#installation-and-upgrade-notes","title":"Installation and Upgrade Notes","text":"<p>Update your package with: <code>pip install signal-ocean -U</code></p>"}]}